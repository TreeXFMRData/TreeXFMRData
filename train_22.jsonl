{"repo": "OSMDeepOD-master/src/_version.py", "original_string": "def render_pep440(pieces):\n    \"\"\"Build up version string, with post-release \"local version identifier\".\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += plus_or_dot(pieces)\n            rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0+untagged.%d.g%s\" % (pieces[\"distance\"],\n                                          pieces[\"short\"])\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n", "docstring": "Build up version string, with post-release \"local version identifier\"."}
{"repo": "OSMDeepOD-master/src/_version.py", "original_string": "def render_pep440_post(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]+gHEX] .\n    The \".dev0\" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear \"older\" than the corresponding clean one),\n    but you shouldn't be releasing software with -dirty anyways.\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%d\" % pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"g%s\" % pieces[\"short\"]\n    else:\n        # exception #1\n        rendered = \"0.post%d\" % pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n        rendered += \"+g%s\" % pieces[\"short\"]\n    return rendered\n", "docstring": "TAG[.postDISTANCE[.dev0]+gHEX] ."}
{"repo": "OSMDeepOD-master/src/_version.py", "original_string": "def render_git_describe(pieces):\n    \"\"\"TAG[-DISTANCE-gHEX][-dirty].\n    Like 'git describe --tags --dirty --always'.\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"]:\n            rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n", "docstring": "TAG[-DISTANCE-gHEX][-dirty]."}
{"repo": "OSMDeepOD-master/src/_version.py", "original_string": "def render(pieces, style):\n    \"\"\"Render the given version pieces into the requested style.\"\"\"\n    if pieces[\"error\"]:\n        return {\"version\": \"unknown\",\n                \"full-revisionid\": pieces.get(\"long\"),\n                \"dirty\": None,\n                \"error\": pieces[\"error\"],\n                \"date\": pieces.get(\"date\", \"\")}\n    if not style or style == \"default\":\n        style = \"pep440\"  # the default\n    if style == \"pep440\":\n        rendered = render_pep440(pieces)\n    elif style == \"pep440-pre\":\n        rendered = render_pep440_pre(pieces)\n    elif style == \"pep440-post\":\n        rendered = render_pep440_post(pieces)\n    elif style == \"pep440-old\":\n        rendered = render_pep440_old(pieces)\n    elif style == \"git-describe\":\n        rendered = render_git_describe(pieces)\n    elif style == \"git-describe-long\":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(\"unknown style '%s'\" % style)\n    return {\"version\": rendered, \"full-revisionid\": pieces[\"long\"],\n            \"dirty\": pieces[\"dirty\"], \"error\": None,\n            \"date\": pieces.get(\"date\", \"\")}\n", "docstring": "Render the given version pieces into the requested style.\n"}
{"repo": "rolling_shutter-master/rollingshutter.py", "original_string": "def rolling_shutter(folder, speed=1):\n    # ENTER YOUR DIRECTORIES AND FILE TYPE HERE\n    frame_dir = os.path.join(\"/Users/mattparker/Documents/rollingshuttervideos/\", str(folder))\n    frame_file = \"png\"\n    output_dir = \"/Users/mattparker/Documents/rollingshuttervideos/\"\n    width = 1920\n    height = 1080\n    # Making our blank output frame\n    output_image = Image.new('RGB', (width, height))\n    # let us go through the frames one at a time\n    current_row = 0\n    for filename in glob.glob(os.path.join(frame_dir, \"*.\" + frame_file)):\n        frame = Image.open(filename)\n        new_line = frame.crop((0, current_row, width, current_row + speed))\n        output_image.paste(new_line, (0, current_row))\n        current_row += speed\n    # and export the final frame\n    output_image.save(os.path.join(output_dir, \"output_image.png\"))\n    return \"DONE\"\n", "docstring": "ENTER YOUR DIRECTORIES AND FILE TYPE HERE"}
{"repo": "SpiffWorkflow-master/tests/SpiffWorkflow/run_suite.py", "original_string": "def find(dirname, pattern):\n    output = []\n    for root, dirs, files in os.walk(dirname):\n        for file in files:\n            if fnmatch.fnmatchcase(file, pattern):\n                output.append(os.path.join(root, file))\n    return output\n", "docstring": "output = []"}
{"repo": "SpiffWorkflow-master/tests/SpiffWorkflow/camunda/ResetTokenSubWorkflowTest.py", "original_string": "def suite():\n    return unittest.TestLoader().loadTestsFromTestCase(ResetTokenTestSubProcess)\n", "docstring": "return unittest.TestLoader().loadTestsFromTestCase(ResetTokenTestSubProcess)"}
{"repo": "SpiffWorkflow-master/tests/SpiffWorkflow/specs/DeepMergeTest.py", "original_string": "    def testMixOfArrayTypes(self):\n        a = {\"foods\": [{\"fruit\": {\"apples\": \"tasty\", \"oranges\": \"also tasty\"}},\n                       {\"canned_meats\":[\"spam\", \"more spam\"]}]}\n        b = {\"foods\": [{\"fruit\": {\"apples\": \"tasty\", \"oranges\": \"also tasty\"}},\n                       {\"canned_meats\":[\"wonderful spam\", \"spam\", \"more spam\"]}]}\n        c = DeepMerge.merge(a, b)\n        self.assertEqual({\"foods\": [{\"fruit\": {\"apples\": \"tasty\", \"oranges\": \"also tasty\"}},\n                       {\"canned_meats\":[\"spam\", \"more spam\", \"wonderful spam\"]}]}, c)\n", "docstring": "a = {\"foods\": [{\"fruit\": {\"apples\": \"tasty\", \"oranges\": \"also tasty\"}},"}
{"repo": "SpiffWorkflow-master/tests/SpiffWorkflow/specs/WorkflowSpecTest.py", "original_string": "    def testSerialize(self):\n        # Read a complete workflow spec.\n        xml_file = os.path.join(data_dir, 'spiff', 'workflow1.xml')\n        with open(xml_file) as fp:\n            xml = fp.read()\n        path_file = os.path.splitext(xml_file)[0] + '.path'\n        with open(path_file) as fp:\n            expected_path = fp.read().strip().split('\\n')\n        wf_spec = WorkflowSpec.deserialize(serializer, xml)\n        for i in range(5):\n            workflow = Workflow(wf_spec)\n            self.doPickleSingle(workflow, expected_path)\n", "docstring": "Read a complete workflow spec."}
{"repo": "SpiffWorkflow-master/tests/SpiffWorkflow/specs/SubWorkflowTest.py", "original_string": "    def do_next_unique_task(self, name):\n        # This method asserts that there is only one ready task! The specified\n        # one - and then completes it\n        ready_tasks = self.workflow.get_tasks(Task.READY)\n        self.assertEqual(1, len(ready_tasks))\n        task = ready_tasks[0]\n        self.assertEqual(name, task.task_spec.name)\n        task.complete()\n", "docstring": "This method asserts that there is only one ready task! The specified"}
{"repo": "SpiffWorkflow-master/tests/SpiffWorkflow/bpmn/ClashingName2Test.py", "original_string": "    def testRunThroughHappy(self):\n        # make sure we raise an exception\n        # when validating a workflow with multiple\n        # same IDs in the BPMN workspace\n        self.assertRaises(ValidationException,self.loadWorkflow)\n", "docstring": "make sure we raise an exception"}
{"repo": "SpiffWorkflow-master/tests/SpiffWorkflow/bpmn/BpmnSerializerTest.py", "original_string": "    def testDeserializeCallActivityChildren(self):\n        \"\"\"Tested as a part of deserialize workflow.\"\"\"\n        pass\n", "docstring": "Tested as a part of deserialize workflow.\n"}
{"repo": "SpiffWorkflow-master/tests/SpiffWorkflow/bpmn/CallActivityEscalationTest.py", "original_string": "def on_reached_cb(workflow, task, completed_set):\n    # In workflows that load a subworkflow, the newly loaded children\n    # will not have on_reached_cb() assigned. By using this function, we\n    # re-assign the function in every step, thus making sure that new\n    # children also call on_reached_cb().\n    for child in task.children:\n        track_task(child.task_spec, completed_set)\n    return True\n", "docstring": "In workflows that load a subworkflow, the newly loaded children"}
{"repo": "SpiffWorkflow-master/tests/SpiffWorkflow/bpmn/CancelBoundaryEventTest.py", "original_string": "    def testBoundaryNavigation(self):\n        # get the workflow\n        self.workflow = BpmnWorkflow(self.spec)\n        # do engine steps\n        self.workflow.do_engine_steps()\n        nav = self.workflow.get_flat_nav_list()\n        nav_deep = self.workflow.get_deep_nav_list()\n        self.assertEqual(7, len(nav))\n        self.assertNav(nav_item=nav[4], state=\"MAYBE\", description=\"TokenReset\")\n        ready_tasks = self.workflow.get_tasks(Task.READY)\n        ready_tasks[0].update_data(data={'formdata': 'asdf'})\n        self.workflow.complete_task_from_id(ready_tasks[0].id)\n        self.workflow.do_engine_steps()\n        nav = self.workflow.get_flat_nav_list()\n        print(nav)\n        self.assertEquals(7, len(nav))\n        self.assertNav(nav_item=nav[4], state=\"WAITING\", description=\"TokenReset\")\n", "docstring": "get the workflow"}
{"repo": "SpiffWorkflow-master/tests/SpiffWorkflow/bpmn/CancelBoundaryEventTest.py", "original_string": "    def testNoCancelEvent(self):\n        # get the workflow\n        self.workflow = BpmnWorkflow(self.spec)\n        # do engine steps\n        self.workflow.do_engine_steps()\n        ready_tasks = self.workflow.get_tasks(Task.READY)\n        # task = ready_tasks[0]\n        # task is Activity_GetData which has a form\n        ready_tasks[0].update_data(data={'formdata': 'asdf'})\n        self.workflow.complete_task_from_id(ready_tasks[0].id)\n        # refresh and do engine steps again\n        self.workflow.refresh_waiting_tasks()\n        self.workflow.do_engine_steps()\n        # this time we don't cancel\n        # 'title' should not be in last_task.data\n        self.assertNotIn('title', self.workflow.last_task.data)\n        # and Activity_HowMany should be Completed\n        self.assertEqual(self.workflow.last_task.get_name(), 'Activity_HowMany.BoundaryEventParent')\n        self.assertEqual(self.workflow.last_task.get_state(), 32)\n", "docstring": "get the workflow"}
{"repo": "SpiffWorkflow-master/tests/SpiffWorkflow/bpmn/NavLeadFrogTest.py", "original_string": "    def testRunThroughFlatNav(self):\n        # Complete a little bit, so we can see the states in action.\n        nav_list = self.workflow.get_flat_nav_list()\n        self.assertEqual(21, len(nav_list))\n        self.assertNav(nav_list[0], name=\"StartEvent_1\", indent=0, state=\"COMPLETED\")\n        self.assertNav(nav_list[1], description=\"Get Data\", indent=0, state=\"COMPLETED\")\n        self.assertNav(nav_list[2], description=\"how many cats\", indent=0)\n        self.assertNav(nav_list[3], description=\"many a cat\", indent=1)\n        self.assertNav(nav_list[4], description=\"Tell me bout da cats\", indent=2, state=\"READY\")\n        self.assertNav(nav_list[5], description=\"no cats\", indent=1)\n        self.assertNav(nav_list[6], description=\"Get som dem cats\", indent=2)\n        self.assertNav(nav_list[7], description=\"how many cows\", indent=0)\n        self.assertNav(nav_list[8], description=\"1 or more cows\", indent=1)\n        self.assertNav(nav_list[9], description=\"Tell me bout dem cows\", indent=2)\n        self.assertNav(nav_list[10], description=\"no cows\", indent=1)\n        self.assertNav(nav_list[11], description=\"How many chickens\", indent=0)\n        self.assertNav(nav_list[12], description=\"1 or more chicks\", indent=1)\n        self.assertNav(nav_list[13], description=\"Tell me bout da Chikens\", indent=2)\n        self.assertNav(nav_list[14], description=\"no chickens\", indent=1)\n        self.assertNav(nav_list[15], description=\"How many Pigs?\", indent=0)\n        self.assertNav(nav_list[16], description=\"no pigs\", indent=1)\n        self.assertNav(nav_list[17], description=\"1 or more pigs\", indent=1)\n        self.assertNav(nav_list[18], description=\"Tell me boud dem Pigs\", indent=2)\n        self.assertNav(nav_list[19], spec_type=\"EndEvent\", indent=0)\n", "docstring": "Complete a little bit, so we can see the states in action."}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/workflow.py", "original_string": "    def _get_waiting_tasks(self):\n        waiting = Task.Iterator(self.task_tree, Task.WAITING)\n        return [w for w in waiting]\n", "docstring": "waiting = Task.Iterator(self.task_tree, Task.WAITING)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/workflow.py", "original_string": "    def get_message_name_xlate(self):\n        message_name_xlate = {}\n        alltasks = self.get_tasks()\n        tasks = [x for x in alltasks if (x.state == x.READY or x.state== x.WAITING or x.state==x.COMPLETED)\n                 and hasattr(x.parent,'task_spec')]\n        #tasks = self.get_tasks(state=Task.READY)\n        for task in tasks:\n            parent = task.parent\n            if hasattr(task.task_spec,'event_definition') \\\n                and hasattr(task.task_spec.event_definition,'message'):\n                message_name_xlate[task.task_spec.event_definition.name] = task.task_spec.event_definition.message\n            if isinstance(parent.task_spec,_BoundaryEventParent):\n                for sibling in parent.children:\n                    if hasattr(sibling.task_spec,'event_definition') \\\n                       and sibling.task_spec.event_definition is not None:\n                        message_name_xlate[sibling.task_spec.event_definition.name] = \\\n                            sibling.task_spec.event_definition.message\n                        # doing this for the case that we have triggered the event and it is now completed\n                        # but the task is still active, so we would like to be able to re-trigger the event\n                        if sibling.state == Task.COMPLETED and task.state == Task.READY:\n                            sibling._setstate(Task.WAITING, force=True)\n        return message_name_xlate\n", "docstring": "message_name_xlate = {}"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/workflow.py", "original_string": "    def signal(self, message_name):\n        # breakpoint()\n        message_name_xlate = self.get_message_name_xlate()\n        if message_name in message_name_xlate.keys() or \\\n            message_name in message_name_xlate.values():\n            if message_name in message_name_xlate.keys():\n                message_name = message_name_xlate[message_name]\n            self.task_tree.internal_data['signals'] = self.task_tree.internal_data.get('signals',{}) # ensure\n            self.task_tree.internal_data['signals'][message_name] = True\n        LOG.debug(\"signal Workflow instance: %s\" % self.task_tree.internal_data)\n        self.refresh_waiting_tasks()\n        LOG.debug(\"signal Workflow instance: %s\" % self.task_tree.internal_data)\n        self.do_engine_steps()\n        self.task_tree.internal_data['signals'] = {}\n", "docstring": "breakpoint()"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/workflow.py", "original_string": "    def get_flat_nav_list(self):\n        \"\"\"Returns a navigation list with indentation hints, but the list\n        is completly flat, and a nav item has no children.\"\"\"\n        from . import navigation\n        return navigation.get_flat_nav_list(self)\n", "docstring": "Returns a navigation list with indentation hints, but the list"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/operators.py", "original_string": "    def __init__(self, path):\n        self.path = path\n        self.name = path\n", "docstring": "self.path = path"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/operators.py", "original_string": "    def __init__(self,\n                 left_attribute,\n                 right_attribute=None,\n                 right=None,\n                 **kwargs):\n        \"\"\"\n        Constructor.\n        :type  left_attribute: str\n        :param left_attribute: The name of the attribute to which the value\n                               is assigned.\n        :type  right: object\n        :param right: A static value that, when given, is assigned to\n                      left_attribute.\n        :type  right_attribute: str\n        :param right_attribute: When given, the attribute with the given\n                                name is used as the source (instead of the\n                                static value).\n        :type  kwargs: dict\n        :param kwargs: See :class:`SpiffWorkflow.specs.TaskSpec`.\n        \"\"\"\n        if not right_attribute and not right:\n            raise ValueError('require argument: right_attribute or right')\n        assert left_attribute is not None\n        self.left_attribute = left_attribute\n        self.right_attribute = right_attribute\n        self.right = right\n", "docstring": "left_attribute,"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/operators.py", "original_string": "    def _matches(self, task):\n        raise Exception(\"Abstract class, do not call\")\n", "docstring": "raise Exception(\"Abstract class, do not call\")"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/operators.py", "original_string": "    def _matches(self, task):\n        values = self._get_values(task)\n        last = values[0]\n        for value in values:\n            if value != last:\n                return False\n            last = value\n        return True\n", "docstring": "values = self._get_values(task)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/operators.py", "original_string": "    def serialize(self, serializer):\n        return serializer.serialize_operator_greater_than(self)\n", "docstring": "return serializer.serialize_operator_greater_than(self)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/operators.py", "original_string": "    def serialize(self, serializer):\n        return serializer.serialize_operator_less_than(self)\n", "docstring": "return serializer.serialize_operator_less_than(self)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/operators.py", "original_string": "    def serialize(self, serializer):\n        return serializer.serialize_operator_match(self)\n", "docstring": "return serializer.serialize_operator_match(self)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/navigation.py", "original_string": "    def from_flow(cls, flow: SequenceFlow, lane, backtrack_to, indent):\n        \"\"\"We include flows in the navigation if we hit a conditional gateway,\n        as in do this if x, do this if y....\"\"\"\n        instance = cls(\n            spec_id=flow.id,\n            name=flow.name,\n            description=flow.name,\n            lane=lane,\n            backtrack_to=backtrack_to,\n            indent=indent\n        )\n        instance.set_spec_type(flow)\n        return instance\n", "docstring": "We include flows in the navigation if we hit a conditional gateway,"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/navigation.py", "original_string": "def set_deep_state(nav_items):\n    # recursive, in a deeply nested navigation, use the state of children to\n    # inform the state of the parent, so we have some idea what is going on at\n    # that deeper level.  This may override the state of a gateway, which\n    # may be completed, but contain children that are not.\n    state_precedence = ['READY', 'LIKELY', 'FUTURE', 'MAYBE', 'WAITING',\n                        'COMPLETED', 'CANCELLED']\n    for nav_item in nav_items:\n        if len(nav_item.children) > 0:\n            child_states = []\n            for child in nav_item.children:\n                child_states.append(set_deep_state([child]))\n            for state in state_precedence:\n                if state in child_states:\n                    nav_item.state = state\n                    return state\n    return nav_item.state\n", "docstring": "recursive, in a deeply nested navigation, use the state of children to"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/navigation.py", "original_string": "def conditional_task_add(output, task_spec, indent, backtrack_to=None):\n    #if task_spec.id not in [x.spec_id for x in output]:\n    output.append(NavItem.from_spec(spec=task_spec,\n                                    backtrack_to=backtrack_to,\n                                    indent=indent))\n", "docstring": "if task_spec.id not in [x.spec_id for x in output]:"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/task.py", "original_string": "        def _next(self):\n            # Make sure that the end is not yet reached.\n            if len(self.path) == 0:\n                raise StopIteration()\n            current = self.path[-1]\n            # Assure we don't recurse forever.\n            self.count += 1\n            if self.count > self.MAX_ITERATIONS:\n                raise WorkflowException(current,\n                \"Task Iterator entered infinite recursion loop\" )\n            # If the current task has children, the first child is the next\n            # item. If the current task is LIKELY, and predicted tasks are not\n            # specificly searched, we can ignore the children, because\n            # predicted tasks should only have predicted children.\n            ignore_task = False\n            if self.filter is not None:\n                search_predicted = self.filter & Task.LIKELY != 0\n                is_predicted = current.state & Task.LIKELY != 0\n                ignore_task = is_predicted and not search_predicted\n            if current.children and not ignore_task:\n                self.path.append(current.children[0])\n                if (self.filter is not None and\n                        current.state & self.filter == 0):\n                    return None\n                return current\n            # Ending up here, this task has no children. Crop the path until we\n            # reach a task that has unvisited children, or until we hit the\n            # end.\n            while True:\n                old_child = self.path.pop(-1)\n                if len(self.path) == 0:\n                    break\n                # If this task has a sibling, choose it.\n                parent = self.path[-1]\n                pos = parent.children.index(old_child)\n                if len(parent.children) > pos + 1:\n                    self.path.append(parent.children[pos + 1])\n                    break\n            if self.filter is not None and current.state & self.filter == 0:\n                return None\n            return current\n", "docstring": "Make sure that the end is not yet reached."}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/task.py", "original_string": "    def update_data_var(self, fieldid, value):\n        model = {}\n        updateDotDict(model,fieldid, value)\n        self.update_data(model)\n", "docstring": "model = {}"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/task.py", "original_string": "    def is_looping(self):\n        \"\"\"Returns true if this is a looping task.\"\"\"\n        islooping = getattr(self.task_spec, \"is_loop_task\", None)\n        if callable(islooping):\n            return self.task_spec.is_loop_task()\n        else:\n            return False\n", "docstring": "Returns true if this is a looping task.\n"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/task.py", "original_string": "    def _getstate(self):\n        return self._state\n", "docstring": "return self._state"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/task.py", "original_string": "    def _is_finished(self):\n        return self._has_state(self.FINISHED_MASK)\n", "docstring": "return self._has_state(self.FINISHED_MASK)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/task.py", "original_string": "    def _set_likely_task(self, task_specs):\n        if not isinstance(task_specs, list):\n            task_specs = [task_specs]\n        for task_spec in task_specs:\n            for child in self.children:\n                if child.task_spec != task_spec:\n                    continue\n                if child._is_definite():\n                    continue\n                child._set_state(self.LIKELY)\n                return\n", "docstring": "if not isinstance(task_specs, list):"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/task.py", "original_string": "    def get_description(self):\n        return str(self.task_spec.description)\n", "docstring": "return str(self.task_spec.description)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/ReleaseMutex.py", "original_string": "    def serialize(self, serializer):\n        return serializer.serialize_release_mutex(self)\n", "docstring": "return serializer.serialize_release_mutex(self)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/MultiInstance.py", "original_string": "    def _predict_hook(self, my_task):\n        split_n = int(valueof(my_task, self.times, 1))\n        my_task._set_internal_data(splits=split_n)\n        # Create the outgoing tasks.\n        outputs = []\n        for i in range(split_n):\n            outputs += self.outputs\n        if my_task._is_definite():\n            my_task._sync_children(outputs, Task.FUTURE)\n        else:\n            my_task._sync_children(outputs, Task.LIKELY)\n", "docstring": "split_n = int(valueof(my_task, self.times, 1))"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/Join.py", "original_string": "    def _check_threshold_structured(self, my_task, force=False):\n        # Retrieve a list of all activated tasks from the associated\n        # task that did the conditional parallel split.\n        split_task = my_task._find_ancestor_from_name(self.split_task)\n        if split_task is None:\n            msg = 'Join with %s, which was not reached' % self.split_task\n            raise WorkflowException(self, msg)\n        tasks = split_task.task_spec._get_activated_tasks(split_task, my_task)\n        # The default threshold is the number of branches that were started.\n        threshold = valueof(my_task, self.threshold)\n        if threshold is None:\n            threshold = len(tasks)\n        # Look up which tasks have already completed.\n        waiting_tasks = []\n        completed = 0\n        for task in tasks:\n            # Refresh path prediction.\n            task.task_spec._predict(task)\n            if not self._branch_may_merge_at(task):\n                completed += 1\n            elif self._branch_is_complete(task):\n                completed += 1\n            else:\n                waiting_tasks.append(task)\n        # If the threshold was reached, get ready to fire.\n        return force or completed >= threshold, waiting_tasks\n", "docstring": "Retrieve a list of all activated tasks from the associated"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/Join.py", "original_string": "    def _update_hook(self, my_task):\n        # Check whether enough incoming branches have completed.\n        may_fire, waiting_tasks = self._start(my_task)\n        if not may_fire:\n            my_task._set_state(Task.WAITING)\n            return\n        # If this is a cancelling join, cancel all incoming branches,\n        # except for the one that just completed.\n        if self.cancel_remaining:\n            for task in waiting_tasks:\n                task.cancel()\n        # We do NOT set the task state to COMPLETED, because in\n        # case all other incoming tasks get cancelled (or never reach\n        # the Join for other reasons, such as reaching a stub branch),\n        # we need to revisit it.\n        my_task._ready()\n        # Update the state of our child objects.\n        self._do_join(my_task)\n", "docstring": "Check whether enough incoming branches have completed."}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/Choose.py", "original_string": "    def serialize(self, serializer):\n        return serializer.serialize_choose(self)\n", "docstring": "return serializer.serialize_choose(self)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/WorkflowSpec.py", "original_string": "    def validate(self):\n        \"\"\"Checks integrity of workflow and reports any problems with it.\n        Detects:\n        - loops (tasks that wait on each other in a loop)\n        :returns: empty list if valid, a list of errors if not\n        \"\"\"\n        results = []\n        from ..specs import Join\n        def recursive_find_loop(task, history):\n            current = history[:]\n            current.append(task)\n            if isinstance(task, Join):\n                if task in history:\n                    msg = \"Found loop with '%s': %s then '%s' again\" % (\n                        task.name, '->'.join([p.name for p in history]),\n                        task.name)\n                    raise Exception(msg)\n                for predecessor in task.inputs:\n                    recursive_find_loop(predecessor, current)\n            for parent in task.inputs:\n                recursive_find_loop(parent, current)\n        for task_id, task in list(self.task_specs.items()):\n            # Check for cyclic waits\n            try:\n                recursive_find_loop(task, [])\n            except Exception as exc:\n                results.append(exc.__str__())\n            # Check for disconnected tasks\n            if not task.inputs and task.name not in ['Start', 'Root']:\n                if task.outputs:\n                    results.append(\"Task '%s' is disconnected (no inputs)\" %\n                                   task.name)\n                else:\n                    LOG.debug(\"Task '%s' is not being used\" % task.name)\n        return results\n", "docstring": "Checks integrity of workflow and reports any problems with it."}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/WorkflowSpec.py", "original_string": "        def recursive_dump(task_spec, indent):\n            if task_spec in done:\n                return '[shown earlier] %s (%s:%s)' % (\n                    task_spec.name, task_spec.__class__.__name__,\n                    hex(id(task_spec))) + '\\n'\n            done.add(task_spec)\n            dump = '%s (%s:%s)' % (\n                task_spec.name,\n                task_spec.__class__.__name__, hex(id(task_spec))) + '\\n'\n            if verbose:\n                if task_spec.inputs:\n                    dump += indent + '-  IN: ' + \\\n                        ','.join(['%s (%s)' % (t.name, hex(id(t)))\n                                  for t in task_spec.inputs]) + '\\n'\n                if task_spec.outputs:\n                    dump += indent + '- OUT: ' + \\\n                        ','.join(['%s (%s)' % (t.name, hex(id(t)))\n                                  for t in task_spec.outputs]) + '\\n'\n            sub_specs = ([task_spec.spec.start] if hasattr(\n                task_spec, 'spec') else []) + task_spec.outputs\n            for i, t in enumerate(sub_specs):\n                dump += indent + '   --> ' + \\\n                    recursive_dump(\n                        t, indent + ('   |   ' if i + 1 < len(sub_specs) else\n                                     '       '))\n            return dump\n", "docstring": "if task_spec in done:"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/SubWorkflow.py", "original_string": "    def _on_ready_hook(self, my_task):\n        # Assign variables, if so requested.\n        subworkflow = my_task._get_internal_data('subworkflow')\n        for child in subworkflow.task_tree.children:\n            for assignment in self.in_assign:\n                assignment.assign(my_task, child)\n        self._predict(my_task)\n        for child in subworkflow.task_tree.children:\n            child.task_spec._update(child)\n", "docstring": "Assign variables, if so requested."}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/Merge.py", "original_string": "    def _do_join(self, my_task):\n        # Merge all inputs (in order)\n        for input_spec in self.inputs:\n            tasks = [task for task in my_task.workflow.task_tree\n                     if task.task_spec is input_spec]\n            for task in tasks:\n                LOG.debug(\"Merging %s (%s) into %s\" % (task.get_name(),\n                                                       task.get_state_name(\n                ), self.name),\n                    extra=dict(data=task.data))\n                _log_overwrites(my_task.data, task.data)\n                merge_dictionary(my_task.data, task.data)\n        return super(Merge, self)._do_join(my_task)\n", "docstring": "Merge all inputs (in order)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/base.py", "original_string": "    def ancestors(self):\n        \"\"\"Returns list of ancestor task specs based on inputs\"\"\"\n        results = []\n        def recursive_find_ancestors(task, stack):\n            for input in task.inputs:\n                if input not in stack:\n                    stack.append(input)\n                    recursive_find_ancestors(input, stack)\n        recursive_find_ancestors(self, results)\n        return results\n", "docstring": "Returns list of ancestor task specs based on inputs\n"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/Execute.py", "original_string": "    def _update_hook(self, my_task):\n        if not self._start(my_task):\n            my_task._set_state(Task.WAITING)\n            return\n        super(Execute, self)._update_hook(my_task)\n", "docstring": "if not self._start(my_task):"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/ThreadStart.py", "original_string": "    def serialize(self, serializer):\n        return serializer.serialize_thread_start(self)\n", "docstring": "return serializer.serialize_thread_start(self)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/Gate.py", "original_string": "    def serialize(self, serializer):\n        return serializer.serialize_gate(self)\n", "docstring": "return serializer.serialize_gate(self)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/AcquireMutex.py", "original_string": "    def serialize(self, serializer):\n        return serializer.serialize_acquire_mutex(self)\n", "docstring": "return serializer.serialize_acquire_mutex(self)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/Celery.py", "original_string": "def _eval_args(args, my_task):\n    \"\"\"Parses args and evaluates any Attrib entries\"\"\"\n    results = []\n    for arg in args:\n        if isinstance(arg, Attrib) or isinstance(arg, PathAttrib):\n            results.append(valueof(my_task, arg))\n        else:\n            results.append(arg)\n    return results\n", "docstring": "Parses args and evaluates any Attrib entries\n"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/Celery.py", "original_string": "def Serializable(o):\n    \"\"\"Make sure an object is JSON-serializable\n    Use this to return errors and other info that does not need to be\n    deserialized or does not contain important app data. Best for returning\n    error info and such\"\"\"\n    if isinstance(o, (str, dict, int)):\n        return o\n    else:\n        try:\n            json.dumps(o)\n            return o\n        except Exception:\n            LOG.debug(\"Got a non-serilizeable object: %s\" % o)\n            return o.__repr__()\n", "docstring": "Make sure an object is JSON-serializable"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/Celery.py", "original_string": "    def _restart(self, my_task):\n        \"\"\" Abort celery task and retry it\"\"\"\n        if not my_task._has_state(Task.WAITING):\n            raise WorkflowException(my_task, \"Cannot refire a task that is not\"\n                                    \"in WAITING state\")\n        # Check state of existing call and abort it (save history)\n        if my_task._get_internal_data('task_id') is not None:\n            if not hasattr(my_task, 'async_call'):\n                task_id = my_task._get_internal_data('task_id')\n                my_task.async_call = default_app.AsyncResult(task_id)\n                my_task.deserialized = True\n                my_task.async_call.state  # manually refresh\n            async_call = my_task.async_call\n            if async_call.state == 'FAILED':\n                pass\n            elif async_call.state in ['RETRY', 'PENDING', 'STARTED']:\n                async_call.revoke()\n                LOG.info(\"Celery task '%s' was in %s state and was revoked\" % (\n                    async_call.state, async_call))\n            elif async_call.state == 'SUCCESS':\n                LOG.warning(\"Celery task '%s' succeeded, but a refire was \"\n                            \"requested\" % async_call)\n            self._clear_celery_task_data(my_task)\n        # Retrigger\n        return self._start(my_task)\n", "docstring": "Abort celery task and retry it\n"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/Celery.py", "original_string": "    def _start(self, my_task, force=False):\n        \"\"\"Returns False when successfully fired, True otherwise\"\"\"\n        # Deserialize async call if necessary\n        if not hasattr(my_task, 'async_call') and \\\n                my_task._get_internal_data('task_id') is not None:\n            task_id = my_task._get_internal_data('task_id')\n            my_task.async_call = default_app.AsyncResult(task_id)\n            my_task.deserialized = True\n            LOG.debug(\"Reanimate AsyncCall %s\" % task_id)\n        # Make the call if not already done\n        if not hasattr(my_task, 'async_call'):\n            self._send_call(my_task)\n        # Get call status (and manually refresh if deserialized)\n        if getattr(my_task, \"deserialized\", False):\n            my_task.async_call.state  # must manually refresh if deserialized\n        if my_task.async_call.state == 'FAILURE':\n            LOG.debug(\"Async Call for task '%s' failed: %s\" % (\n                my_task.get_name(), my_task.async_call.info))\n            info = {}\n            info['traceback'] = my_task.async_call.traceback\n            info['info'] = Serializable(my_task.async_call.info)\n            info['state'] = my_task.async_call.state\n            my_task._set_internal_data(task_state=info)\n        elif my_task.async_call.state == 'RETRY':\n            info = {}\n            info['traceback'] = my_task.async_call.traceback\n            info['info'] = Serializable(my_task.async_call.info)\n            info['state'] = my_task.async_call.state\n            my_task._set_internal_data(task_state=info)\n        elif my_task.async_call.ready():\n            result = my_task.async_call.result\n            if isinstance(result, Exception):\n                LOG.warn(\"Celery call %s failed: %s\" % (self.call, result))\n                my_task._set_internal_data(error=Serializable(result))\n                return False\n            LOG.debug(\"Completed celery call %s with result=%s\" % (self.call,\n                                                                   result))\n            # Format result\n            if self.result_key:\n                data = {self.result_key: result}\n            else:\n                if isinstance(result, dict):\n                    data = result\n                else:\n                    data = {'result': result}\n            # Load formatted result into internal_data\n            if self.merge_results:\n                merge_dictionary(my_task.internal_data, data)\n            else:\n                my_task.set_data(**data)\n            return True\n        else:\n            LOG.debug(\"async_call.ready()=%s. TryFire for '%s' \"\n                      \"returning False\" % (my_task.async_call.ready(),\n                                           my_task.get_name()))\n            return False\n", "docstring": "Returns False when successfully fired, True otherwise\n"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/ThreadSplit.py", "original_string": "    def _on_complete_hook(self, my_task):\n        # Split, and remember the number of splits in the context data.\n        split_n = int(valueof(my_task, self.times))\n        # Create the outgoing tasks.\n        outputs = []\n        for i in range(split_n):\n            outputs.append(self.thread_starter)\n        my_task._sync_children(outputs, Task.FUTURE)\n        for child in my_task.children:\n            child.task_spec._update(child)\n", "docstring": "Split, and remember the number of splits in the context data."}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/ExclusiveChoice.py", "original_string": "    def _on_complete_hook(self, my_task):\n        # Find the first matching condition.\n        output = self._wf_spec.get_task_spec_from_name(self.default_task_spec)\n        for condition, spec_name in self.cond_task_specs:\n            if condition is None or condition._matches(my_task):\n                output = self._wf_spec.get_task_spec_from_name(spec_name)\n                break\n        my_task._sync_children([output], Task.FUTURE)\n        for child in my_task.children:\n            child.task_spec._update(child)\n", "docstring": "Find the first matching condition."}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/Transform.py", "original_string": "    def serialize(self, serializer):\n        s_state = serializer.serialize_simple(self)\n        s_state['transforms'] = self.transforms\n        return s_state\n", "docstring": "s_state = serializer.serialize_simple(self)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/specs/Cancel.py", "original_string": "    def _on_complete_hook(self, my_task):\n        my_task.workflow.cancel(self.cancel_successfully)\n        TaskSpec._on_complete_hook(self, my_task)\n", "docstring": "my_task.workflow.cancel(self.cancel_successfully)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/util/weakmethod.py", "original_string": "    def __init__(self, f, callback):\n        name = f.__self__.__class__.__name__ + '.' + f.__func__.__name__\n        WeakMethod.__init__(self, name, callback)\n        self.f = f.__func__\n        self.c = weakref.ref(f.__self__, self._dead)\n", "docstring": "name = f.__self__.__class__.__name__ + '.' + f.__func__.__name__"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/util/event.py", "original_string": "    def _weakly_connected_index(self, callback):\n        if self.weak_subscribers is None:\n            return None\n        weak = [s[0].get_function() for s in self.weak_subscribers]\n        try:\n            return weak.index(callback)\n        except ValueError:\n            return None\n", "docstring": "if self.weak_subscribers is None:"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/serializer/xml.py", "original_string": "    def deserialize_operator(self, elem):\n        cls = _op_map[elem.tag]\n        return cls.deserialize(self, elem)\n", "docstring": "cls = _op_map[elem.tag]"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/dmn/specs/model.py", "original_string": "    def deserialize(self,indict):\n        #for key in indict.keys():\n        #    setattr(self,key,indict[key])\n        self.scriptEngine = DMNPythonScriptEngine() # this is the only one we deal with now,\n                                                    # later we will want to look at the classname\n                                                    # that is in indct['scriptEngine'] and instantiate\n                                                    # the right class\n", "docstring": "for key in indict.keys():"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/dmn/parser/DMNParser.py", "original_string": "    def _parse_decision(self, root):\n        decisionElements = list(root)\n        if len(decisionElements) == 0:\n            raise Exception('No decisions found')\n        if len(decisionElements) > 1:\n            raise Exception('Multiple decisions found')\n        decisionElement = decisionElements[0]\n        assert decisionElement.tag.endswith(\n            'decision'), 'Element %r is not of type \"decision\"' % (\n            decisionElement.tag)\n        decision = Decision(decisionElement.attrib['id'],\n                            decisionElement.attrib.get('name', ''))\n        # Parse decision tables\n        try:\n            self._parseDecisionTables(decision, decisionElement)\n        except Exception as e:\n            raise Exception(\"Error in Decision '%s': %s\" % (decision.name, str(e)))\n        return decision\n", "docstring": "decisionElements = list(root)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/workflow.py", "original_string": "    def _is_busy_with_restore(self):\n        if self.outer_workflow == self:\n            return self._busy_with_restore\n        return self.outer_workflow._is_busy_with_restore()\n", "docstring": "if self.outer_workflow == self:"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/FeelLikeScriptEngine.py", "original_string": "    def __init__(self, begin, end, leftOpen=False, rightOpen=False):\n        # pesky thing with python floats and Decimal comparison\n        if isinstance(begin,float):\n            begin = Decimal(\"%0.5f\"%begin)\n        if isinstance(end, float):\n            end = Decimal(\"%0.5f\" % end)\n        self.startInterval = begin\n        self.endInterval = end\n        self.leftOpen = leftOpen\n        self.rightOpen = rightOpen\n", "docstring": "pesky thing with python floats and Decimal comparison"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/FeelLikeScriptEngine.py", "original_string": "    def __init__(self):\n        super().__init__()\n", "docstring": "super().__init__()"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/PythonScriptEngine.py", "original_string": "    def convertToBoxSub(self,data):\n        if isinstance(data,list):\n            for x in range(len(data)):\n                data[x] = self.convertToBoxSub(data[x])\n            return data\n        if isinstance(data,dict):\n            for x in data.keys():\n                if isinstance(data[x],dict):\n                    data[x] = self.convertToBoxSub(data[x])\n            return Box(data)\n        return data\n", "docstring": "if isinstance(data,list):"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/ExclusiveGateway.py", "original_string": "    def serialize(self, serializer):\n        return serializer.serialize_exclusive_gateway(self)\n", "docstring": "return serializer.serialize_exclusive_gateway(self)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/InclusiveGateway.py", "original_string": "    def _check_threshold_unstructured(self, my_task, force=False):\n        # Look at the tree to find all ready and waiting tasks (excluding ones\n        # that are our completed inputs).\n        tasks = []\n        for task in my_task.workflow.get_tasks(Task.READY | Task.WAITING):\n            if task.thread_id != my_task.thread_id:\n                continue\n            if task.workflow != my_task.workflow:\n                continue\n            if task.task_spec == my_task.task_spec:\n                continue\n            tasks.append(task)\n        inputs_with_tokens, waiting_tasks = self._get_inputs_with_tokens(\n            my_task)\n        inputs_without_tokens = [\n            i for i in self.inputs if i not in inputs_with_tokens]\n        waiting_tasks = []\n        for task in tasks:\n            if (self._has_directed_path_to(\n                    task, self,\n                    without_using_sequence_flow_from=inputs_with_tokens) and\n                not self._has_directed_path_to(\n                    task, self,\n                    without_using_sequence_flow_from=inputs_without_tokens)):\n                waiting_tasks.append(task)\n        return force or len(waiting_tasks) == 0, waiting_tasks\n", "docstring": "Look at the tree to find all ready and waiting tasks (excluding ones"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/BpmnProcessSpec.py", "original_string": "    def _check_threshold_unstructured(self, my_task, force=False):\n        # Look at the tree to find all ready and waiting tasks (excluding\n        # ourself). The EndJoin waits for everyone!\n        waiting_tasks = []\n        for task in my_task.workflow.get_tasks(Task.READY | Task.WAITING):\n            if task.thread_id != my_task.thread_id:\n                continue\n            if task.task_spec == my_task.task_spec:\n                continue\n            is_mine = False\n            w = task.workflow\n            if w == my_task.workflow:\n                is_mine = True\n            while w and w.outer_workflow != w:\n                w = w.outer_workflow\n                if w == my_task.workflow:\n                    is_mine = True\n            if is_mine:\n                waiting_tasks.append(task)\n        if len(waiting_tasks) == 0:\n            LOG.debug(\n                'Endjoin Task ready: %s (ready/waiting tasks: %s)',\n                my_task,\n                list(my_task.workflow.get_tasks(Task.READY | Task.WAITING)))\n        return force or len(waiting_tasks) == 0, waiting_tasks\n", "docstring": "Look at the tree to find all ready and waiting tasks (excluding"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/BpmnProcessSpec.py", "original_string": "        def recursive_find(task_spec):\n            if task_spec in done:\n                return\n            done.add(task_spec)\n            if hasattr(task_spec, 'lane') and task_spec.lane:\n                lanes.add(task_spec.lane)\n            if hasattr(task_spec, 'spec'):\n                recursive_find(task_spec.spec.start)\n            for t in task_spec.outputs:\n                recursive_find(t)\n", "docstring": "if task_spec in done:"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/CallActivity.py", "original_string": "    def _on_ready_hook(self, my_task):\n        # Assign variables, if so requested.\n        for child in self.sub_workflow.task_tree.children:\n            for assignment in self.in_assign:\n                assignment.assign(my_task, child)\n        self._predict(my_task)\n        for child in self.sub_workflow.task_tree.children:\n            child.task_spec._update(child)\n", "docstring": "Assign variables, if so requested."}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/IntermediateThrowEvent.py", "original_string": "    def _on_ready_hook(self, my_task):\n        self._predict(my_task)\n", "docstring": "self._predict(my_task)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/BpmnSpecMixin.py", "original_string": "    def connect_outgoing(self, taskspec, sequence_flow_id, sequence_flow_name,\n                         documentation):\n        \"\"\"\n        Connect this task spec to the indicated child.\n        :param sequence_flow_id: The ID of the connecting sequenceFlow node.\n        :param sequence_flow_name: The name of the connecting sequenceFlow\n        node.\n        \"\"\"\n        self.connect(taskspec)\n        s = SequenceFlow(\n            sequence_flow_id, sequence_flow_name, documentation, taskspec)\n        self.outgoing_sequence_flows[taskspec.name] = s\n        self.outgoing_sequence_flows_by_id[sequence_flow_id] = s\n", "docstring": "documentation):"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/BpmnSpecMixin.py", "original_string": "    def _on_complete_hook(self, my_task):\n        super(BpmnSpecMixin, self)._on_complete_hook(my_task)\n        if isinstance(my_task.parent.task_spec, BpmnSpecMixin):\n            my_task.parent.task_spec._child_complete_hook(my_task)\n        if not my_task.workflow._is_busy_with_restore():\n            self.entering_complete_state(my_task)\n", "docstring": "super(BpmnSpecMixin, self)._on_complete_hook(my_task)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/event_definitions.py", "original_string": "    def _accept_message(self, my_task, message):\n        return False\n", "docstring": "return False"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/event_definitions.py", "original_string": "    def _message_ready(self, my_task):\n        waiting_messages = my_task.workflow.task_tree.internal_data.get('messages',{})\n        if (self.message in waiting_messages.keys()):\n            evaledpayload = waiting_messages[self.message]\n            del(waiting_messages[self.message])\n            return evaledpayload\n        return False\n", "docstring": "waiting_messages = my_task.workflow.task_tree.internal_data.get('messages',{})"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/event_definitions.py", "original_string": "    def _message_ready(self, my_task):\n        waiting_messages = my_task.workflow.task_tree.internal_data.get('signals',{})\n        if (self.message in waiting_messages.keys()) :\n            return (self.message,None)\n        return False\n", "docstring": "waiting_messages = my_task.workflow.task_tree.internal_data.get('signals',{})"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/event_definitions.py", "original_string": "    def _message_ready(self, my_task):\n        waiting_messages = my_task.workflow.task_tree.internal_data.get('cancels',{})\n        if ('TokenReset' in waiting_messages.keys()) :\n            return ('TokenReset', None)\n        return False\n", "docstring": "waiting_messages = my_task.workflow.task_tree.internal_data.get('cancels',{})"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/event_definitions.py", "original_string": "    def deserialize(self, dct):\n        return TimerEventDefinition(dct['label'],dct['dateTime'])\n", "docstring": "return TimerEventDefinition(dct['label'],dct['dateTime'])"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/event_definitions.py", "original_string": "    def _accept_message(self, my_task, message):\n        if sys.version_info[0] == 3:\n            string_types = str,\n        else:\n            string_types = basestring,\n        if isinstance(message, string_types) and message.startswith('x_escalation:'):\n            parts = message.split(':')\n            if len(parts) == 3:\n                _, source_task_name, recv_escalation_code = parts\n                if not self.escalation_code or self.escalation_code == recv_escalation_code:\n                    main_child_task_spec = my_task.parent.task_spec.main_child_task_spec\n                    if source_task_name == main_child_task_spec.name:\n                        self._fire(my_task)\n                        return True\n        return False\n", "docstring": "if sys.version_info[0] == 3:"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/event_definitions.py", "original_string": "    def deserialize(self, dct):\n        return CycleTimerEventDefinition(dct['label'],dct['dateTime'])\n", "docstring": "return CycleTimerEventDefinition(dct['label'],dct['dateTime'])"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/IntermediateCatchEvent.py", "original_string": "    def _on_ready_hook(self, my_task):\n        self._predict(my_task)\n", "docstring": "self._predict(my_task)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/ScriptTask.py", "original_string": "    def serialize(self, serializer):\n        return serializer.serialize_script_task(self)\n", "docstring": "return serializer.serialize_script_task(self)"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/MultiInstanceTask.py", "original_string": "    def _get_loop_completion(self,my_task):\n        if not self.completioncondition == None:\n            terminate = my_task.workflow.script_engine.evaluate(my_task,self.completioncondition)\n            if terminate:\n                my_task.terminate_current_loop = True\n            return terminate\n        return False\n", "docstring": "if not self.completioncondition == None:"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/MultiInstanceTask.py", "original_string": "    def _add_gateway(self, my_task):\n        \"\"\" Generate parallel gateway tasks on either side of the current task.\n            This emulates a standard BPMN pattern of having parallel tasks between\n            two parallel gateways.\n            Once we have set up the gateways, we write a note into our internal data so that\n            we don't do it again.\n        \"\"\"\n        #  Expand this\n        #  A-> ME -> C\n        #  into this\n        # A -> GW_start -> ME -> GW_end -> C\n        # where GW is a parallel gateway\n        # check to see if we have already done this, this code gets called multiple times\n        # as we build the tree\n        if my_task.parent.task_spec.name[:11] == 'Gateway_for':\n            LOG.debug(\"MI Recovering from save/restore\")\n            return\n        LOG.debug(\"MI being augmented\")\n        # build the gateway specs and the tasks.\n        # Spiff wants a distinct spec for each task\n        # that it has in the workflow or it will throw an error\n        start_gw_spec, start_gw = self._make_new_gateway(my_task,'start','Begin Gateway')\n        end_gw_spec, end_gw = self._make_new_gateway(my_task,'end','End Gateway')\n        # Set up the parent task and insert it into the workflow\n        # remove the current task spec from the parent, it will be replaced with the new construct.\n        my_task.parent.task_spec.outputs = [x for x in my_task.parent.task_spec.outputs if x != my_task.task_spec]\n        # in the case that our parent is a gateway with a default route,\n        # we need to ensure that the default route is empty\n        # so that connect can set it up properly\n        if hasattr(my_task.parent.task_spec,'default_task_spec') and \\\n                 my_task.parent.task_spec.default_task_spec == my_task.task_spec.name:\n            my_task.parent.task_spec.default_task_spec = None\n            my_task.parent.task_spec.connect(start_gw_spec)\n        else:\n            my_task.parent.task_spec.outputs.append(start_gw_spec)\n            start_gw_spec.inputs.append(my_task.parent.task_spec)\n        # get a list of all siblings and replace myself with the new gateway task\n        # in the parent task\n        newchildren = []\n        for child in my_task.parent.children:\n            if child == my_task:\n                newchildren.append(start_gw)\n            else:\n                newchildren.append(child)\n        my_task.parent.children = newchildren\n        # update the gatways parent to be my parent\n        start_gw.parent = my_task.parent\n        # update my parent to be the gateway\n        my_task.parent = start_gw\n        start_gw_spec.connect(self)\n        start_gw.children = [my_task]\n        # transfer my outputs to the ending gateway and set up the\n        # child parent links\n        end_gw_spec.outputs = self.outputs.copy()\n        self.connect(end_gw_spec)\n        self.outputs = [end_gw_spec]\n        end_gw.parent = my_task\n        my_task.children = [end_gw]\n", "docstring": "Generate parallel gateway tasks on either side of the current task."}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/MultiInstanceTask.py", "original_string": "    def _make_new_child_task(self,my_task,x):\n        # here we generate a distinct copy of our original task each\n        # parallel instance, and hook them up into the task tree\n        LOG.debug(\"MI creating new child & task spec\")\n        new_child = copy.copy(my_task)\n        new_child.id = uuid4()\n        # I think we will need to update both every variables\n        # internal data and the copy of the public data to get the\n        # variables correct\n        new_child.internal_data = copy.copy(my_task.internal_data)\n        new_child.internal_data[\n            'runtimes'] = x + 2  # working with base 1 and we already have one done\n        new_child.data = copy.copy(my_task.data)\n        new_child.data[self.elementVar] = self._get_current_var(my_task,\n                                                                x + 2)\n        new_child.children = []  # these will be updated later\n        # in the case of parallel, the children list will get updated during the predict loop\n        return new_child\n", "docstring": "here we generate a distinct copy of our original task each"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/MultiInstanceTask.py", "original_string": "    def _expand_parallel(self,my_task,split_n):\n        # add a parallel gateway on either side of this task\n        self._add_gateway(my_task)\n        # we use the child count of the parallel gateway to determine\n        # if we have expanded this or not. Children of the gateway we just created\n        # should match the split level provided by the multiinstance\n        for x in range(split_n - len(my_task.parent.children)):\n            new_child = self._make_new_child_task(my_task,x)\n            new_task_spec = self._make_new_task_spec(my_task.task_spec, my_task, x)\n            new_child.task_spec = new_task_spec\n            # patch up the right hand side gateway\n            self.outputs[0].inputs.append(new_task_spec)\n            # patch up the left hand side gateway task and task_spec\n            my_task.parent.children.append(new_child)\n            my_task.parent.task_spec.outputs.append(new_task_spec)\n", "docstring": "add a parallel gateway on either side of this task"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/MultiInstanceTask.py", "original_string": "    def _predict_hook(self, my_task):\n        LOG.debug(my_task.get_name() + 'pre hook')\n        split_n = self._get_count(my_task)\n        runtimes = int(my_task._get_internal_data('runtimes',\n                                                  1))  # set a default if not already run\n        my_task._set_internal_data(splits=split_n, runtimes=runtimes)\n        if not self.elementVar:\n            self.elementVar = my_task.task_spec.name + \"_CurrentVar\"\n        my_task.data[self.elementVar] = copy.copy(\n            self._get_current_var(my_task, runtimes))\n        # Create the outgoing tasks.\n        outputs = []\n        # In the special case that this is a Parallel multiInstance, we need\n        # to expand the children in the middle. This method gets called\n        # during every pass through the tree, so we need to wait until our\n        # real cardinality gets updated to expand the tree.\n        if (not self.isSequential):\n            self._expand_parallel(my_task,split_n)\n        elif not self.loopTask:\n            self._expand_sequential(my_task,split_n)\n        outputs += self.outputs\n        if isinstance(my_task.task_spec,CallActivity):\n            super(CallActivity,self)._predict_hook(my_task)\n        else:\n            if my_task._is_definite():\n                my_task._sync_children(outputs, Task.FUTURE)\n            else:\n                my_task._sync_children(outputs, Task.LIKELY)\n", "docstring": "LOG.debug(my_task.get_name() + 'pre hook')"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/MultiInstanceTask.py", "original_string": "    def _merge_element_variable(self,my_task,collect,runtimes,colvarname):\n        # if we are updating the same collection as was our loopcardinality\n        # then all the keys should be there and we can use the sorted keylist\n        # if not, we use an integer - we should be guaranteed that the\n        # collection is a dictionary\n        if self.collection is not None and \\\n           self.times.name == self.collection.name:\n            keys = list(collect.keys())\n            if len(keys) < runtimes:\n                msg = f\"There is a mismatch between runtimes and the number \" \\\n                      f\"items in the collection, please check for empty \" \\\n                      f\"collection {self.collection.name}.\"\n                raise WorkflowTaskExecException(my_task, msg)\n            runtimesvar = keys[runtimes - 1]\n        else:\n            runtimesvar = runtimes\n        if self.elementVar in my_task.data and isinstance(my_task.data[self.elementVar], dict):\n            collect[runtimesvar] = DeepMerge.merge(collect.get(runtimesvar, {}),\n                                                   copy.copy(my_task.data[self.elementVar]))\n        LOG.debug(my_task.task_spec.name + 'complete hook')\n        my_task.data = DeepMerge.merge(my_task.data,\n                                       gendict(colvarname.split('/'), collect))\n", "docstring": "if we are updating the same collection as was our loopcardinality"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/MultiInstanceTask.py", "original_string": "    def _on_complete_hook(self, my_task):\n        # do special stuff for non-user tasks\n        self._handle_special_cases(my_task)\n        # this is all about updating the collection for a MI\n        self._check_inputs(my_task)\n        # initialize\n        runcount = self._get_count(my_task)\n        runtimes = int(my_task._get_internal_data('runtimes', 1))\n        if self.collection is not None:\n            colvarname = self.collection.name\n        else:\n            colvarname = my_task.task_spec.name\n        collect = valueof(my_task, self.collection, {})\n        self._merge_element_variable(my_task,collect,runtimes,colvarname)\n        element_var_data = self._update_sibling_data(my_task,runtimes,runcount,colvarname,collect)\n        # please see MultiInstance code for previous version\n        outputs = []\n        outputs += self.outputs\n        if not isinstance(my_task.task_spec,CallActivity):\n            my_task._sync_children(outputs, Task.FUTURE)\n            for child in my_task.children:\n                child.task_spec._update(child)\n        # If removed, add the element_var_data back onto this task.\n        if(element_var_data):\n            my_task.data[self.elementVar] = element_var_data\n", "docstring": "do special stuff for non-user tasks"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/specs/BoundaryEvent.py", "original_string": "    def _predict_hook(self, my_task):\n        # We default to MAYBE\n        # for all it's outputs except the main child, which is\n        # FUTURE, if my task is definite, otherwise, my own state.\n        my_task._sync_children(self.outputs, state=Task.MAYBE)\n        if my_task._is_definite():\n            state = Task.FUTURE\n        else:\n            state = my_task.state\n        for child in my_task.children:\n            if child.task_spec == self.main_child_task_spec:\n                child._set_state(state)\n", "docstring": "We default to MAYBE"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/serializer/Packager.py", "original_string": "    def _check_for_disconnected_boundary_events_signavio(self, bpmn, filename):\n        # signavio sometimes disconnects a BoundaryEvent from it's owning task\n        # They then show up as intermediateCatchEvents without any incoming\n        # sequence flows\n        xpath = xpath_eval(bpmn)\n        for catch_event in xpath('.//bpmn:intermediateCatchEvent'):\n            incoming = xpath(\n                './/bpmn:sequenceFlow[@targetRef=\"%s\"]' %\n                catch_event.get('id'))\n            if not incoming:\n                raise ValidationException(\n                    'Intermediate Catch Event has no incoming sequences. '\n                    'This might be a Boundary Event that has been '\n                    'disconnected.',\n                    node=catch_event, filename=filename)\n", "docstring": "signavio sometimes disconnects a BoundaryEvent from it's owning task"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/serializer/Packager.py", "original_string": "    def _call_editor_hook(self, hook, *args, **kwargs):\n        if self.editor:\n            hook_func = getattr(self, \"%s_%s\" % (hook, self.editor), None)\n            if hook_func:\n                return hook_func(*args, **kwargs)\n        return None\n", "docstring": "if self.editor:"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/serializer/Packager.py", "original_string": "    def main(cls, argv=None, package_file=None):\n        parser = cls.create_option_parser()\n        cls.add_main_options(parser)\n        cls.add_additional_options(parser)\n        (options, args) = parser.parse_args(args=argv)\n        config = configparser.ConfigParser()\n        if options.config_file:\n            config.read(options.config_file)\n        if not config.has_section(CONFIG_SECTION_NAME):\n            config.add_section(CONFIG_SECTION_NAME)\n        cls.merge_options_and_config(config, options, args)\n        if options.init_config_file:\n            if not options.config_file:\n                parser.error(\n                    \"no config file specified - cannot initialise config file\")\n            f = open(options.config_file, \"w\")\n            with f:\n                config.write(f)\n                return\n        cls.check_args(config, options, args, parser, package_file)\n        meta_data = cls.create_meta_data(options, args, parser)\n        packager = cls(package_file=package_file or options.package_file,\n                       entry_point_process=options.entry_point_process,\n                       meta_data=meta_data, editor=options.editor)\n        for a in args:\n            packager.add_bpmn_files_by_glob(a)\n        packager.create_package()\n        return packager\n", "docstring": "parser = cls.create_option_parser()"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/serializer/CompactWorkflowSerializer.py", "original_string": "    def _go_in_to_subworkflow(self, my_task, target_children_specs):\n        # This method simulates the entering of a subworkflow, but without\n        # hooks being called, and targeting a specific subset of the entry\n        # tasks in the subworkflow. It creates the new workflow instance and\n        # merges it in to the tree This is based on\n        # SubWorkflow._on_ready_before_hook(..)\n        if my_task._is_finished():\n            return\n        subworkflow = my_task.task_spec._create_subworkflow(my_task)\n        subworkflow.completed_event.connect(\n            my_task.task_spec._on_subworkflow_completed, my_task)\n        # Create the children (these are the tasks that follow the subworkflow,\n        # on completion:\n        my_task.children = []\n        my_task._sync_children(my_task.task_spec.outputs, Task.FUTURE)\n        for t in my_task.children:\n            t.task_spec._predict(t)\n        # Integrate the tree of the subworkflow into the tree of this workflow.\n        for child in subworkflow.task_tree.children:\n            if child.task_spec in target_children_specs:\n                my_task.children.insert(0, child)\n                child.parent = my_task\n        my_task._set_internal_data(subworkflow=subworkflow)\n        my_task._set_state(Task.COMPLETED)\n", "docstring": "This method simulates the entering of a subworkflow, but without"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/serializer/CompactWorkflowSerializer.py", "original_string": "    def _restore_workflow_state(self, workflow, state):\n        state_list = json.loads('[' + state + ']')\n        self._check_spec_version(state_list[-1])\n        s = _BpmnProcessSpecState(workflow.spec)\n        routes = []\n        for state in state_list[:-1]:\n            if isinstance(state, str) or type(state).__name__ == 'str':\n                state = [str(state)]\n            transition = state[0]\n            workflow_parents = state[1] if len(state) > 1 else []\n            state = (Task.WAITING if len(state) >\n                     2 and state[2] == 'W' else Task.READY)\n            route, route_to_parent_complete = s.get_path_to_transition(\n                transition, state, workflow_parents)\n            routes.append(\n                (route, route_to_parent_complete, transition, state,\n                 workflow_parents))\n        retry = True\n        retry_count = 0\n        while (retry):\n            if retry_count > 100:\n                raise ValueError(\n                    'Maximum retry limit exceeded searching for unique paths')\n            retry = False\n            for i in range(len(routes)):\n                (route, route_to_parent_complete, transition, state,\n                 workflow_parents) = routes[i]\n                for j in range(len(routes)):\n                    if i == j:\n                        continue\n                    other_route = routes[j][0]\n                    route_to_parent_complete = routes[j][1]\n                    if route.contains(other_route) or (\n                            route_to_parent_complete and route.contains(\n                                route_to_parent_complete)):\n                        taken_routes = [r for r in routes if r[0] != route]\n                        taken_routes = [r for r in [r[0] for r\n                                                    in taken_routes] +\n                                        [r[1] for r in taken_routes] if r]\n                        (route,\n                         route_to_parent_complete) = s.get_path_to_transition(\n                            transition, state, workflow_parents,\n                            taken_routes=taken_routes)\n                        for r in taken_routes:\n                            assert not route.contains(r)\n                        routes[\n                            i] = (route, route_to_parent_complete, transition,\n                                  state, workflow_parents)\n                        retry = True\n                        retry_count += 1\n                        break\n                if retry:\n                    break\n        for r in routes:\n            s.add_route(r[0])\n        workflow._busy_with_restore = True\n        try:\n            if len(state_list) <= 1:\n                workflow.cancel(success=True)\n                return\n            s.go(workflow)\n        finally:\n            workflow._busy_with_restore = False\n", "docstring": "state_list = json.loads('[' + state + ']')"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/serializer/BpmnSerializer.py", "original_string": "    def deserialize_workflow(self, s_state,  workflow_spec=None,\n                             read_only=False, **kwargs):\n        return super().deserialize_workflow(s_state,\n                                            wf_class=BpmnWorkflow,\n                                            wf_spec=workflow_spec,\n                                            read_only=read_only,\n                                            **kwargs)\n", "docstring": "read_only=False, **kwargs):"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/parser/ProcessParser.py", "original_string": "    def _init_coord_lookup(self):\n        \"\"\"Creates a lookup table with the x/y coordinates of each shape.\n        Only tested with the output from the Camunda modeler, which provides\n        these details in the bpmndi / and dc namespaces.\"\"\"\n        self.id_to_coords_lookup = {}\n        for position in self.doc_xpath('.//bpmndi:BPMNShape'):\n            bounds = xpath_eval(position)(\"dc:Bounds\")\n            if len(bounds) > 0 and 'bpmnElement' in position.attrib:\n                bound = bounds[0]\n                self.id_to_coords_lookup[position.attrib['bpmnElement']] = \\\n                    {'x': float(bound.attrib['x']), 'y': float(bound.attrib['y'])}\n", "docstring": "Creates a lookup table with the x/y coordinates of each shape."}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/parser/BpmnParser.py", "original_string": "    def parse_condition(self, condition_expression, outgoing_task,\n                        outgoing_task_node, sequence_flow_node,\n                        condition_expression_node, task_parser):\n        \"\"\"\n        Pre-parse the given condition expression, and return the parsed\n        version. The returned version will be passed to the Script Engine for\n        evaluation.\n        \"\"\"\n        return condition_expression\n", "docstring": "outgoing_task_node, sequence_flow_node,"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/parser/task_parsers.py", "original_string": "    def create_task(self):\n        wf_spec = self.get_subprocess_parser().get_spec()\n        return self.spec_class(\n            self.spec, self.get_task_spec_name(), bpmn_wf_spec=wf_spec,\n            bpmn_wf_class=self.parser.WORKFLOW_CLASS,\n            position=self.process_parser.get_coord(self.get_id()),\n            description=self.node.get('name', None))\n", "docstring": "wf_spec = self.get_subprocess_parser().get_spec()"}
{"repo": "SpiffWorkflow-master/SpiffWorkflow/bpmn/parser/task_parsers.py", "original_string": "    def create_task(self):\n        event_definition = self.get_event_definition()\n        return self.spec_class(\n            self.spec, self.get_task_spec_name(), event_definition,\n            lane=self.get_lane(),\n            description=self.node.get('name', None))\n", "docstring": "event_definition = self.get_event_definition()"}
{"repo": "SpoofMAC-master/spoofmac/interface.py", "original_string": "    def get_interface_mac(self, device):\n        result = subprocess.check_output([\"ifconfig\", device], stderr=subprocess.STDOUT, universal_newlines=True)\n        m = re.search(\"(?<=HWaddr\\\\s)(.*)\", result)\n        if not hasattr(m, \"group\") or m.group(0) == None:\n            return None\n        return m.group(0).strip()\n", "docstring": "result = subprocess.check_output([\"ifconfig\", device], stderr=subprocess.STDOUT, universal_newlines=True)"}
{"repo": "SpoofMAC-master/spoofmac/interface.py", "original_string": "    def get_interface_mac(self, device):\n        output = self.get_ipconfig_all()\n        device = device.lower().strip()\n        # search for specific adapter gobble through mac address\n        m = re.search(\"adapter \"+device+\":[\\\\n\\\\r]+(.*?)\\\\s*Physical Address[^\\\\d]+(\\\\s\\\\S+)\", output, re.I | re.DOTALL)\n        if not hasattr(m, \"group\") or m.group(0) == None:\n            return None\n        adapt_mac = m.group(0)\n        # extract physical address then mac\n        m = re.search(\"Physical Address[^\\\\d]+(\\\\s\\\\S+)\", adapt_mac)\n        phy_addr = m.group(0)\n        m = re.search(\"(?<=:\\\\s)(.*)\", phy_addr)\n        if not hasattr(m, \"group\") or m.group(0) == None:\n            return None\n        mac = m.group(0)\n        return mac\n", "docstring": "output = self.get_ipconfig_all()"}
{"repo": "ultimate-python-master/runner.py", "original_string": "def success_text(text):\n    \"\"\"Get success text.\"\"\"\n    return f\"{_STYLE_SUCCESS}{bold_text(text)}{_STYLE_END}\"\n", "docstring": "Get success text.\n"}
{"repo": "ultimate-python-master/ultimatepython/classes/exception_class.py", "original_string": "def divide_positive_numbers(dividend, divisor):\n    \"\"\"Divide a positive number by another positive number.\n    Writing a program in this style is considered defensive programming.\n    For more on this programming style, check the Wikipedia link below:\n    https://en.wikipedia.org/wiki/Defensive_programming\n    \"\"\"\n    if dividend <= 0:\n        raise DivisionError(f\"Non-positive dividend: {dividend}\")\n    elif divisor <= 0:\n        raise DivisionError(f\"Non-positive divisor: {divisor}\")\n    return dividend // divisor\n", "docstring": "Divide a positive number by another positive number."}
{"repo": "ultimate-python-master/ultimatepython/classes/basic_class.py", "original_string": "    def __init__(self, make, model, year, miles):\n        \"\"\"Constructor logic.\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n        self.miles = miles\n", "docstring": "Constructor logic.\n"}
{"repo": "ultimate-python-master/ultimatepython/classes/basic_class.py", "original_string": "    def __str__(self):\n        \"\"\"Informal representation for users.\"\"\"\n        return f\"{self.make} {self.model} ({self.year})\"\n", "docstring": "Informal representation for users.\n"}
{"repo": "ultimate-python-master/ultimatepython/classes/basic_class.py", "original_string": "def main():\n    # Create a car with the provided class constructor\n    car = Car(\"Bumble\", \"Bee\", 2000, 200000.0)\n    # Formal representation is good for debugging issues\n    assert repr(car) == \"<Car make=Bumble model=Bee year=2000>\"\n    # Informal representation is good for user output\n    assert str(car) == \"Bumble Bee (2000)\"\n    # Call a method on the class constructor\n    assert car.drive(75) == \"Bumble Bee (2000) is driving at 75 MPH\"\n    # As a reminder: everything in Python is an object! And that applies\n    # to classes in the most interesting way - because they're not only\n    # subclasses of object - they are also instances of object. This\n    # means that we can modify the `Car` class at runtime, just like any\n    # other piece of data we define in Python\n    assert issubclass(Car, object) and isinstance(Car, object)\n    # To emphasize the idea that everything is an object, let's look at\n    # the `drive` method in more detail\n    driving = getattr(car, \"drive\")\n    # The variable method is the same as the instance method\n    assert driving == car.drive\n    # The variable method is bound to the instance\n    assert driving.__self__ == car\n    # That is why `driving` is considered a method and not a function\n    assert ismethod(driving) and not isfunction(driving)\n    # And there is only one parameter for `driving` because `__self__`\n    # binding is implicit\n    driving_params = signature(driving).parameters\n    assert len(driving_params) == 1\n    assert \"rate_in_mph\" in driving_params\n", "docstring": "Create a car with the provided class constructor"}
{"repo": "ultimate-python-master/ultimatepython/classes/iterator_class.py", "original_string": "    def __init__(self, employee):\n        \"\"\"Constructor logic.\"\"\"\n        self.employees_to_visit = [employee]\n        self.employees_visited = set()\n", "docstring": "Constructor logic.\n"}
{"repo": "ultimate-python-master/ultimatepython/classes/iterator_class.py", "original_string": "    def __next__(self):\n        \"\"\"Return the next employee available.\n        The logic may seem complex, but it's actually a common algorithm\n        used in traversing a relationship graph. It is called depth-first\n        search and it can be found on Wikipedia:\n        https://en.wikipedia.org/wiki/Depth-first_search\n        \"\"\"\n        if not self.employees_to_visit:\n            raise StopIteration\n        employee = self.employees_to_visit.pop()\n        if employee.name in self.employees_visited:\n            raise IterationError(_ITERATION_MESSAGE)\n        self.employees_visited.add(employee.name)\n        for report in employee.direct_reports:\n            self.employees_to_visit.append(report)\n        return employee\n", "docstring": "Return the next employee available."}
{"repo": "ultimate-python-master/ultimatepython/classes/iterator_class.py", "original_string": "def main():\n    # Manager with two direct reports\n    manager = Employee(\"Max Doe\", \"Engineering Manager\", [\n        Employee(\"John Doe\", \"Software Engineer\", []),\n        Employee(\"Jane Doe\", \"Software Engineer\", [])\n    ])\n    # We should provide the same three employees in the same order regardless\n    # of whether we use the iterator class or the generator function\n    employees = [emp for emp in EmployeeIterator(manager)]\n    assert employees == [emp for emp in employee_generator(manager)]\n    assert len(employees) == 3\n    # Make sure that the employees are who we expect them to be\n    assert all(isinstance(emp, Employee) for emp in employees)\n    # This is not a good day for this company\n    hacker = Employee(\"Unknown\", \"Hacker\", [])\n    hacker.direct_reports.append(hacker)\n    for iter_obj in (EmployeeIterator, employee_generator):\n        call_failed = False\n        try:\n            list(iter_obj(hacker))\n        except IterationError as e:\n            call_failed = True\n            assert str(e) == _ITERATION_MESSAGE\n        assert call_failed is True\n", "docstring": "Manager with two direct reports"}
{"repo": "ultimate-python-master/ultimatepython/classes/abstract_class.py", "original_string": "    def do_work(self):\n        \"\"\"Do something for work.\"\"\"\n        raise NotImplementedError\n", "docstring": "Do something for work.\n"}
{"repo": "ultimate-python-master/ultimatepython/classes/abstract_class.py", "original_string": "    def do_relax(self):\n        \"\"\"Do something to relax.\"\"\"\n        raise NotImplementedError\n", "docstring": "Do something to relax.\n"}
{"repo": "ultimate-python-master/ultimatepython/classes/abstract_class.py", "original_string": "def main():\n    # Declare two engineers\n    engineer_john = Engineer(\"John Doe\", \"Software Engineer\", \"Android\")\n    engineer_jane = Engineer(\"Jane Doe\", \"Software Engineer\", \"iOS\")\n    engineers = [engineer_john, engineer_jane]\n    # These engineers are employees but not managers\n    assert all(isinstance(engineer, Employee) for engineer in engineers)\n    assert all(not isinstance(engineer, Manager) for engineer in engineers)\n    # Engineers can work, relax and refactor\n    assert engineer_john.do_work() == \"John Doe is coding in Android\"\n    assert engineer_john.do_relax() == \"John Doe is watching YouTube\"\n    assert engineer_john.do_refactor() == \"John Doe is refactoring code\"\n    # Declare manager with engineers as direct reports\n    manager_max = Manager(\"Max Doe\", \"Engineering Manager\", engineers)\n    # Managers are employees but not engineers\n    assert isinstance(manager_max, Employee)\n    assert not isinstance(manager_max, Engineer)\n    # Managers can work, relax and hire\n    assert manager_max.do_work() == \"Max Doe is meeting up with 2 reports\"\n    assert manager_max.do_relax() == \"Max Doe is taking a trip to the Bahamas\"\n    assert manager_max.do_hire() == \"Max Doe is hiring employees\"\n", "docstring": "Declare two engineers"}
{"repo": "ultimate-python-master/ultimatepython/data_structures/dict.py", "original_string": "def main():\n    # Let's create a dictionary with student keys and GPA values\n    student_gpa = {\"john\": 3.5,\n                   \"jane\": _GPA_MAX,\n                   \"bob\": 2.8,\n                   \"mary\": 3.2}\n    # There are four student records in this dictionary\n    assert len(student_gpa) == 4\n    # Each student has a name key and a GPA value\n    assert len(student_gpa.keys()) == len(student_gpa.values())\n    # We can get the names in isolation. Note that in Python 3.7 and\n    # above, dictionary entries are sorted in the order that they were\n    # defined or inserted\n    student_names = []\n    for student in student_gpa.keys():\n        student_names.append(student)\n    assert student_names == [\"john\", \"jane\", \"bob\", \"mary\"]\n    # We can check that `student_gpa` has the names that were stored\n    # in `student_names` from the loop above\n    for student in student_names:\n        assert student in student_gpa\n    # We can get the GPAs in isolation\n    gpa_values = []\n    for gpa in student_gpa.values():\n        gpa_values.append(gpa)\n    assert gpa_values == [3.5, _GPA_MAX, 2.8, 3.2]\n    # We can get the GPA for a specific student\n    assert student_gpa[\"john\"] == 3.5\n    # We can update the GPA for a specific student\n    student_gpa[\"john\"] = _GPA_MAX\n    # Or update the GPA for multiple students\n    student_gpa.update(bob=_GPA_MIN, mary=_GPA_MIN)\n    # We can access the student and GPA simultaneously\n    gpa_binary = []\n    for student, gpa in student_gpa.items():\n        assert student_gpa[student] == gpa\n        gpa_binary.append(gpa)\n    assert gpa_binary == [_GPA_MAX, _GPA_MAX, _GPA_MIN, _GPA_MIN]\n    # Let's remove all the students\n    for student in student_names:\n        student_gpa.pop(student)\n    assert len(student_gpa) == 0\n    # Let's add all the students back in\n    for student, gpa in zip(student_names, gpa_binary):\n        student_gpa[student] = gpa\n    assert len(student_gpa) == len(student_names)\n", "docstring": "Let's create a dictionary with student keys and GPA values"}
{"repo": "ultimate-python-master/ultimatepython/data_structures/tuple.py", "original_string": "def main():\n    # This is a tuple of integers\n    immutable = (1, 2, 3, 4)\n    # It can be indexed like a list\n    assert immutable[0] == 1\n    assert immutable[-1] == 4\n    # It can be sliced like a list\n    assert immutable[1:3] == (2, 3)\n    assert immutable[3:4] == (4,)\n    assert immutable[1::2] == (2, 4)\n    assert immutable[::-1] == (4, 3, 2, 1)\n    # It can be iterated over like a list\n    for ix, number in enumerate(immutable):\n        assert immutable[ix] == number\n    # But its contents cannot be changed. As an alternative, we can\n    # create new tuples from existing tuples\n    bigger_immutable = immutable + (5, 6)\n    assert bigger_immutable == (1, 2, 3, 4, 5, 6)\n    smaller_immutable = immutable[0:2]\n    assert smaller_immutable == (1, 2)\n    # We use tuples when the number of items is consistent. An example\n    # where this can help is a 2D game with X and Y coordinates. Using a\n    # tuple with two numbers can ensure that the number of coordinates\n    # doesn't change to one, three, four, etc.\n    moved_count = 0\n    pos_x, pos_y = (0, 0)\n    for i in range(1, 5, 2):\n        moved_count += 1\n        pos_x, pos_y = (pos_x + 10 * i, pos_y + 15 * i)\n    assert moved_count == 2\n    assert pos_x == 40 and pos_y == 60\n", "docstring": "This is a tuple of integers"}
{"repo": "ultimate-python-master/ultimatepython/data_structures/deque.py", "original_string": "def main():\n    # A list is identical to a vector where a new array is created when\n    # there are too many elements in the old array, and the old array\n    # elements are moved over to the new array one-by-one. The time\n    # involved with growing its size increases linearly. A deque is\n    # identical to a doubly linked list whose nodes have a left pointer\n    # and a right pointer. In order to grow the linked list, a new node\n    # is created and added to the left, or the right, of the linked list.\n    # The time complexity involved with growing its size is constant.\n    # Check out the source code for a list and a deque here:\n    # https://github.com/python/cpython/blob/3.8/Objects/listobject.c\n    # https://github.com/python/cpython/blob/3.8/Modules/_collectionsmodule.c\n    dq = deque()\n    for i in range(1, 5):\n        # Similar to adding a new node to the right of the linked list\n        dq.append(i)\n        # Similar to adding a new node to the left of the linked list\n        dq.appendleft(i * 2)\n    # A deque can be iterated over to build any data structure\n    assert [el for el in dq] == [8, 6, 4, 2, 1, 2, 3, 4]\n    assert tuple(el for el in dq) == (8, 6, 4, 2, 1, 2, 3, 4)\n    assert {el for el in dq} == {8, 6, 4, 2, 1, 3}\n    # A deque can be used as a stack\n    # https://en.wikipedia.org/wiki/Stack_(abstract_data_type)\n    assert dq.pop() == 4\n    assert dq.pop() == 3\n    # A deque can be used as a queue\n    # https://en.wikipedia.org/wiki/Queue_(abstract_data_type)\n    assert dq.popleft() == 8\n    assert dq.popleft() == 6\n", "docstring": "A list is identical to a vector where a new array is created when"}
{"repo": "ultimate-python-master/ultimatepython/data_structures/comprehension.py", "original_string": "def main():\n    # One interesting fact about data structures is that we can build\n    # them with comprehensions. Let's explain how the first one works:\n    # we just want to create zeros so our expression is set to `0`\n    # since no computing is required; because `0` is a constant value,\n    # we can set the item that we compute with to `_`; and we want to\n    # create five zeros so we set the iterator as `range(5)`\n    assert [0 for _ in range(5)] == [0] * 5 == [0, 0, 0, 0, 0]\n    # For the next comprehension operations, let's see what we can do\n    # with a list of 3-5 letter words\n    words = [\"cat\", \"mice\", \"horse\", \"bat\"]\n    # Tuple comprehension can find the length for each word\n    tuple_comp = tuple(len(word) for word in words)\n    assert tuple_comp == (3, 4, 5, 3)\n    # Set comprehension can find the unique word lengths\n    set_comp = {len(word) for word in words}\n    assert len(set_comp) < len(words)\n    assert set_comp == {3, 4, 5}\n    # Dictionary comprehension can map each word to its length\n    dict_comp = {word: len(word) for word in words}\n    assert len(dict_comp) == len(words)\n    assert dict_comp == {\"cat\": 3,\n                         \"mice\": 4,\n                         \"horse\": 5,\n                         \"bat\": 3}\n", "docstring": "One interesting fact about data structures is that we can build"}
{"repo": "ultimate-python-master/ultimatepython/data_structures/string.py", "original_string": "def main():\n    # Strings are some of the most robust data structures around\n    content = \"Ultimate Python study guide\"\n    # We can compute the length of a string just like all other data structures\n    assert len(content) > 0\n    # We can use range slices to get substrings from a string\n    assert content[:8] == \"Ultimate\"\n    assert content[9:15] == \"Python\"\n    assert content[::-1] == \"ediug yduts nohtyP etamitlU\"\n    # Like tuples, we cannot change the data in a string. However, we can\n    # create a new string from existing strings\n    new_content = f\"{content.upper()}{_DELIMITER}{content.lower()}\"\n    assert _DELIMITER in new_content\n    # We can split one string into a list of strings\n    split_content = new_content.split(_DELIMITER)\n    assert isinstance(split_content, list)\n    assert len(split_content) == 2\n    assert all(isinstance(item, str) for item in split_content)\n    # A two-element list can be decomposed as two variables\n    upper_content, lower_content = split_content\n    assert upper_content.isupper() and lower_content.islower()\n    # Notice that the data in `upper_content` and `lower_content` exists\n    # in the `new_content` variable as expected\n    assert upper_content in new_content\n    assert new_content.startswith(upper_content)\n    assert lower_content in new_content\n    assert new_content.endswith(lower_content)\n    # Notice that `upper_content` and `lower_content` are smaller in length\n    # than `new_content` and have the same length as the original `content`\n    # they were derived from\n    assert len(upper_content) < len(new_content)\n    assert len(lower_content) < len(new_content)\n    assert len(upper_content) == len(lower_content) == len(content)\n    # We can also join `upper_content` and `lower_content` back into one\n    # string with the same contents as `new_content`. The `join` method is\n    # useful for joining an arbitrary amount of text items together\n    joined_content = _DELIMITER.join(split_content)\n    assert isinstance(joined_content, str)\n    assert new_content == joined_content\n", "docstring": "Strings are some of the most robust data structures around"}
{"repo": "ultimate-python-master/ultimatepython/data_structures/set.py", "original_string": "def main():\n    # Let's define one `set` for starters\n    simple_set = {0, 1, 2}\n    # A set is dynamic like a `list` and `tuple`\n    simple_set.add(3)\n    simple_set.remove(0)\n    assert simple_set == {1, 2, 3}\n    # Unlike a `list and `tuple`, it is not an ordered sequence as it\n    # does not allow duplicates to be added\n    for _ in range(5):\n        simple_set.add(0)\n        simple_set.add(4)\n    assert simple_set == {0, 1, 2, 3, 4}\n    # Now let's define two new `set` collections\n    multiples_two = set()\n    multiples_four = set()\n    # Fill sensible values into the set using `add`\n    for i in range(10):\n        multiples_two.add(i * 2)\n        multiples_four.add(i * 4)\n    # As we can see, both sets have similarities and differences\n    assert multiples_two == {0, 2, 4, 6, 8, 10, 12, 14, 16, 18}\n    assert multiples_four == {0, 4, 8, 12, 16, 20, 24, 28, 32, 36}\n    # We cannot decide in which order the numbers come out - so let's\n    # look for fundamental truths instead, such as divisibility against\n    # 2 and 4. We do this by checking whether the modulus of 2 and 4\n    # yields 0 (i.e. no remainder from performing a division)\n    multiples_common = multiples_two.intersection(multiples_four)\n    for number in multiples_common:\n        assert number % 2 == 0 and number % 4 == 0\n    # We can compute exclusive multiples\n    multiples_two_exclusive = multiples_two.difference(multiples_four)\n    multiples_four_exclusive = multiples_four.difference(multiples_two)\n    assert len(multiples_two_exclusive) > 0\n    assert len(multiples_four_exclusive) > 0\n    # Numbers in this bracket are greater than 2 * 9 and less than 4 * 10\n    for number in multiples_four_exclusive:\n        assert 18 < number < 40\n    # By computing a set union against the two sets, we have all integers\n    # in this program\n    multiples_all = multiples_two.union(multiples_four)\n    # Check if set A is a subset of set B\n    assert multiples_four_exclusive.issubset(multiples_four)\n    assert multiples_four.issubset(multiples_all)\n    # Check if set A is a subset and superset of itself\n    assert multiples_all.issubset(multiples_all)\n    assert multiples_all.issuperset(multiples_all)\n    # Check if set A is a superset of set B\n    assert multiples_all.issuperset(multiples_two)\n    assert multiples_two.issuperset(multiples_two_exclusive)\n", "docstring": "Let's define one `set` for starters"}
{"repo": "ultimate-python-master/ultimatepython/advanced/context_manager.py", "original_string": "def file(filename):\n    \"\"\"File context manager.\n    This is the function variant of the context manager. Context managers\n    are useful for resources that need to be opened and closed such as\n    files, database connections and sockets.\n    \"\"\"\n    io_buffer = StringIO(_FILESYSTEM[filename])\n    try:\n        # Pass the buffer to the context block\n        yield io_buffer\n    finally:\n        # Close the buffer unconditionally\n        io_buffer.close()\n", "docstring": "File context manager."}
{"repo": "ultimate-python-master/ultimatepython/advanced/context_manager.py", "original_string": "    def __exit__(self, *args):\n        \"\"\"Close the buffer unconditionally.\"\"\"\n        self.io_buffer.close()\n", "docstring": "Close the buffer unconditionally.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/thread.py", "original_string": "def multiply_by_two(item):\n    \"\"\"This multiplication has a small delay.\"\"\"\n    time.sleep(_MULTIPLY_DELAY)\n    return item * 2\n", "docstring": "This multiplication has a small delay.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/weak_ref.py", "original_string": "    def create(cls, role, provider=_CLOUD_PROVIDER):\n        \"\"\"Create server with autogenerated SSID.\"\"\"\n        return cls(uuid4().hex, role, provider)\n", "docstring": "Create server with autogenerated SSID.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/weak_ref.py", "original_string": "    def servers(self):\n        \"\"\"Get set of added servers.\"\"\"\n        return {s for s in self._servers}\n", "docstring": "Get set of added servers.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/weak_ref.py", "original_string": "    def server_count(self):\n        \"\"\"Get count of added servers.\"\"\"\n        return len(self.servers)\n", "docstring": "Get count of added servers.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/weak_ref.py", "original_string": "def setup_and_teardown_servers(registry):\n    \"\"\"Explicitly setup and implicitly teardown servers.\"\"\"\n    app_servers = {}\n    # Let's create all of the servers and store them properly\n    for app in _CLOUD_APPS:\n        app_servers[app] = set()\n        for component in _CLOUD_APP_COMPONENTS:\n            server = Server.create(f\"{app}_{component}\")\n            registry.add(server)\n            app_servers[app].add(server)\n    # All of these counts are equivalent. This is no surprise since our\n    # for loop unconditionally creates a server for every permutation of\n    # apps and components. The loop also adds each server to the registry\n    # and dictionary unconditionally\n    assert (\n        registry.server_count\n        == len(_CLOUD_APPS) * len(_CLOUD_APP_COMPONENTS)\n        == len([(app, server)\n                for app, servers in app_servers.items()\n                for server in servers])\n    )\n    # What's really interesting is that servers go away when we leave the\n    # scope of this function. In this function, each server is created and\n    # strongly referenced by the `app_servers` variable. When we leave this\n    # function, the `app_servers` variable no longer exists which brings\n    # the reference count for each server from 1 to 0. A reference count of\n    # 0 for each server triggers the garbage collector to run the cleanup\n    # process for all of the servers in this function scope\n", "docstring": "Explicitly setup and implicitly teardown servers.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/regex.py", "original_string": "def main():\n    # Running `search` with \"Hello\" has a match for first Hello\n    assert re.search(r\"Hello\", _TEXT_HELLO).start() == 6\n    # Running `search` with \"Hello$\" has a match for last Hello\n    assert re.search(r\"Hello$\", _TEXT_HELLO).start() == 12\n    # Running `search` with \"(Hello) (Hello)\" has matches for Hello\n    assert re.search(r\"(Hello) (Hello)\", _TEXT_HELLO).groups() == (\"Hello\", \"Hello\")\n    # Running `findall` with \"Hi \\w+\" has a list of strings\n    assert re.findall(r\"\\w+\", _TEXT_NAMES) == [\"John\", \"Jane\"]\n    # Running `match` with \"[123]+\" has nothing\n    assert re.match(r\"[123]+\", _TEXT_ABC123) is None\n    # Running `match` with \"[abc]+\" has a match for abc\n    assert re.match(r\"[abc]+\", _TEXT_ABC123).group(0) == \"abc\"\n    # Running `fullmatch` with \"[\\w]+\" has nothing\n    assert re.fullmatch(r\"[\\w]+\", _TEXT_BYE) is None\n    # Running `fullmatch` with \"[\\w ]+\" has a full match\n    assert re.fullmatch(r\"[\\w ]+\", _TEXT_BYE).group(0) == _TEXT_BYE\n    # To learn more about regular expressions:\n    # https://en.wikipedia.org/wiki/Regular_expression\n    # https://github.com/ziishaned/learn-regex\n    # To play around with regular expressions in the browser:\n    # https://regex101.com\n", "docstring": "Running `search` with \"Hello\" has a match for first Hello"}
{"repo": "ultimate-python-master/ultimatepython/advanced/decorator.py", "original_string": "def run_with_stringy(fn):\n    \"\"\"Run a string function with a string or a collection of strings.\n    We define a custom decorator that allows us to convert a function whose\n    input is a single string into a function whose input can be a string\n    or a collection of strings.\n    A function decorator consists of the following:\n    - An input function to run with\n    - A wrapper function that uses the input function\n    The `wrapper` does not need to accept the input function as a parameter\n    because it can get that from its parent `run_with_any`. Also, the\n    parameters that `wrapper` receives do NOT have to be the same as the\n    ones that the input function `fn` needs to receive. However, it is highly\n    recommended to have the parameter lists for `wrapper` and `fn` line up so\n    that developers are less likely to get confused.\n    The formal specification for function decorators is here:\n    https://www.python.org/dev/peps/pep-0318/\n    The formal specification for class decorators is here:\n    https://www.python.org/dev/peps/pep-3129/\n    \"\"\"\n    @wraps(fn)\n    def wrapper(obj):\n        \"\"\"Apply wrapped function to a string or a collection.\n        This looks like a policy-based engine which runs a `return` statement\n        if a particular set of rules is true. Otherwise it aborts. This is\n        an example of the Strategy design pattern.\n        https://en.wikipedia.org/wiki/Strategy_pattern\n        But instead of writing the logic using classes, we write the logic\n        using a single function that encapsulates all possible rules.\n        \"\"\"\n        if isinstance(obj, str):\n            return fn(obj)\n        elif isinstance(obj, dict):\n            return {key: wrapper(value) for key, value in obj.items()}\n        elif isinstance(obj, (list, set, tuple)):\n            sequence_kls = type(obj)\n            return sequence_kls(wrapper(value) for value in obj)\n        raise ValueError(f\"Found an invalid item: {obj}\")\n    return wrapper\n", "docstring": "Run a string function with a string or a collection of strings."}
{"repo": "ultimate-python-master/ultimatepython/advanced/decorator.py", "original_string": "def hide_content(content):\n    \"\"\"Hide half of the string content.\"\"\"\n    start_point = len(content) // 2\n    num_of_asterisks = len(content) // 2 + len(content) % 2\n    return content[:start_point] + _MASKING * num_of_asterisks\n", "docstring": "Hide half of the string content.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/decorator.py", "original_string": "def main():\n    # There is so much plain-text data out in the open\n    insecure_data = [\n        {\"username\": \"johndoe\", \"country\": \"USA\"},  # User information\n        [\"123-456-7890\", \"123-456-7891\"],  # Social security numbers\n        [(\"johndoe\", \"janedoe\"), (\"bobdoe\", \"marydoe\")],  # Couple names\n        \"secretLaunchCode123\",  # Secret launch code\n    ]\n    # Time to encrypt it all so that it can't be snatched away. This kind\n    # of work is the stuff that might be done by a company for GDPR. For more\n    # on that policy, check out the following Wikipedia page:\n    # https://en.wikipedia.org/wiki/General_Data_Protection_Regulation\n    secure_data = hide_content(insecure_data)\n    # See what changed between the insecure data and the secure data\n    for insecure_item, secure_item in zip(insecure_data, secure_data):\n        assert insecure_item != secure_item\n        assert not _is_hidden(insecure_item)\n        assert _is_hidden(secure_item)\n    # Throw an error on a collection with non-string objects\n    input_failed = False\n    try:\n        hide_content([1])\n    except ValueError:\n        input_failed = True\n    assert input_failed is True\n", "docstring": "There is so much plain-text data out in the open"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mixin.py", "original_string": "    def handle(self, request):\n        \"\"\"Handle incoming request.\"\"\"\n        raise NotImplementedError\n", "docstring": "Handle incoming request.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mixin.py", "original_string": "    def get_template_name(self, request_url):\n        \"\"\"Get template name.\"\"\"\n        raise NotImplementedError\n", "docstring": "Get template name.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mixin.py", "original_string": "    def handle_invalid_template(request):\n        \"\"\"Handle request for invalid template.\"\"\"\n        return f\"<p>Invalid entry for {request.url}</p>\"\n", "docstring": "Handle request for invalid template.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mixin.py", "original_string": "    def render_template(self, template_name):\n        \"\"\"Render contents of specified template name.\"\"\"\n        raise NotImplementedError\n", "docstring": "Render contents of specified template name.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mixin.py", "original_string": "    def is_valid_user(self, request_user):\n        \"\"\"Check if user is valid.\"\"\"\n        raise NotImplementedError\n", "docstring": "Check if user is valid.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mixin.py", "original_string": "    def handle_invalid_user(request):\n        \"\"\"Handle request for invalid user.\"\"\"\n        return f\"<p>Access denied for {request.url}</p>\"\n", "docstring": "Handle request for invalid user.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mixin.py", "original_string": "def main():\n    # Handle requests with simple template handler\n    simple_dir = {\"welcome.template\": \"<p>Hello world</p>\",\n                  \"about.template\": \"<p>About me</p>\"}\n    simple_handler = TemplateFolderHandler(simple_dir)\n    welcome_from_nobody = Request(\"/welcome.template\", \"nobody\")\n    about_from_nobody = Request(\"/about.template\", \"nobody\")\n    foo_from_nobody = Request(\"/foo.bar\", \"nobody\")\n    assert simple_handler.handle(welcome_from_nobody) == \"<p>Hello world</p>\"\n    assert simple_handler.handle(about_from_nobody) == \"<p>About me</p>\"\n    assert simple_handler.handle(foo_from_nobody) == \"<p>Invalid entry for /foo.bar</p>\"\n    # Handle requests with admin template handler\n    admin_users = {\"john\", \"jane\"}\n    admin_dir = {\"fqdn.template\": \"<p>server.example.com</p>\",\n                 \"salary.template\": \"<p>123456789.00</p>\"}\n    admin_handler = AdminTemplateHandler(admin_users, admin_dir)\n    fqdn_from_john = Request(\"/fqdn.template\", \"john\")\n    salary_from_jane = Request(\"/salary.template\", \"jane\")\n    salary_from_nobody = Request(\"/salary.template\", \"nobody\")\n    foo_from_john = Request(\"/foo.bar\", \"john\")\n    assert admin_handler.handle(fqdn_from_john) == \"<p>server.example.com</p>\"\n    assert admin_handler.handle(salary_from_jane) == \"<p>123456789.00</p>\"\n    assert admin_handler.handle(salary_from_nobody) == \"<p>Access denied for /salary.template</p>\"\n    assert admin_handler.handle(foo_from_john) == \"<p>Invalid entry for /foo.bar</p>\"\n", "docstring": "Handle requests with simple template handler"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mro.py", "original_string": "    def ping(self):\n        \"\"\"Override `ping` method.\"\"\"\n        return \"pINg\"\n", "docstring": "Override `ping` method.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mro.py", "original_string": "    def pong(self):\n        \"\"\"Override `pong` method.\"\"\"\n        return \"pONg\"\n", "docstring": "Override `pong` method.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mro.py", "original_string": "def main():\n    # `ConfusedPlayer` methods are resolved from child to parent like this\n    assert ConfusedPlayer.mro() == [\n        ConfusedPlayer, PongPlayer, NeutralPlayer, BasePlayer, object]\n    # `IndecisivePlayer` methods are resolved from child to parent like this\n    assert IndecisivePlayer.mro() == [\n        IndecisivePlayer, NeutralPlayer, PongPlayer, BasePlayer, object]\n    # Show `ConfusedPlayer` method resolution in action\n    assert ConfusedPlayer().ping_pong() == [\"pINg\", \"ping\", \"PONG\", \"PONG\"]\n    # Show `IndecisivePlayer` method resolution in action\n    assert IndecisivePlayer().ping_pong() == [\"ping\", \"ping\", \"pONg\", \"pong\"]\n    class_creation_failed = False\n    try:\n        # Creating a new class `ConfusedPlayer` and `IndecisivePlayer`\n        # results in a `TypeError` because both classes do not have\n        # matching MRO outputs. This means that they cannot be reconciled\n        # as one class. Hence `MissingPlayer` will not be created\n        type(\"MissingPlayer\", (ConfusedPlayer, IndecisivePlayer), {})\n    except TypeError:\n        class_creation_failed = True\n    assert class_creation_failed is True\n", "docstring": "`ConfusedPlayer` methods are resolved from child to parent like this"}
{"repo": "ultimate-python-master/ultimatepython/advanced/meta_class.py", "original_string": "    def __new__(mcs, name, bases, attrs):\n        \"\"\"Factory for modifying the defined class at runtime.\"\"\"\n        kls = super().__new__(mcs, name, bases, attrs)\n        # Abstract model does not have a `model_name` but a real model does.\n        # We will leverage this fact later on this routine\n        if attrs.get(\"__abstract__\") is True:\n            kls.model_name = None\n        else:\n            custom_name = attrs.get(\"__table_name__\")\n            default_name = kls.__name__.replace(\"Model\", \"\").lower()\n            kls.model_name = custom_name if custom_name else default_name\n        # Ensure abstract and real models have fields so that\n        # they can be inherited\n        kls.model_fields = {}\n        # Fill model fields from the parent classes (left-to-right)\n        for base in bases:\n            kls.model_fields.update(base.model_fields)\n        # Fill model fields from itself\n        kls.model_fields.update({\n            field_name: field_obj\n            for field_name, field_obj in attrs.items()\n            if isinstance(field_obj, BaseField)\n        })\n        # Register a real table (a table with valid `model_name`) to\n        # the metaclass `table` registry. After all the tables are\n        # registered, the registry can be sent to a database adapter\n        # which uses each table to create a properly defined schema\n        # for the database of choice (i.e. PostgreSQL, MySQL)\n        if kls.model_name:\n            kls.model_table = ModelTable(kls.model_name, kls.model_fields)\n            ModelMeta.tables[kls.model_name] = kls.model_table\n        else:\n            kls.model_table = None\n        # Return newly modified class\n        return kls\n", "docstring": "Factory for modifying the defined class at runtime.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/meta_class.py", "original_string": "    def is_registered(cls):\n        \"\"\"Check if the model's name is valid and exists in the registry.\"\"\"\n        return cls.model_name and cls.model_name in cls.tables\n", "docstring": "Check if the model's name is valid and exists in the registry.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/meta_class.py", "original_string": "def main():\n    # Real models are given a name at runtime with `ModelMeta`\n    assert UserModel.model_name == \"user_rocks\"\n    assert AddressModel.model_name == \"address\"\n    # Real models are given fields at runtime with `ModelMeta`\n    assert \"row_id\" in UserModel.model_fields\n    assert \"row_id\" in AddressModel.model_fields\n    assert \"username\" in UserModel.model_fields\n    assert \"address\" in AddressModel.model_fields\n    # Real models are registered at runtime with `ModelMeta`\n    assert UserModel.is_registered\n    assert AddressModel.is_registered\n    # Real models have a `ModelTable` that can be used for DB setup\n    assert isinstance(ModelMeta.tables[UserModel.model_name], ModelTable)\n    assert isinstance(ModelMeta.tables[AddressModel.model_name], ModelTable)\n    # Base model is given special treatment at runtime\n    assert not BaseModel.is_registered\n    assert BaseModel.model_name is None\n    assert BaseModel.model_table is None\n    # Every model is created by `ModelMeta`\n    assert isinstance(BaseModel, ModelMeta)\n    assert all(isinstance(model, ModelMeta)\n               for model in BaseModel.__subclasses__())\n    # And `ModelMeta` is created by `type`\n    assert isinstance(ModelMeta, type)\n    # And `type` is created by `type` itself\n    assert isinstance(type, type)\n    # And everything in Python is an object!\n    assert isinstance(BaseModel, object)\n    assert isinstance(ModelMeta, object)\n    assert isinstance(type, object)\n    assert isinstance(object, object)\n", "docstring": "Real models are given a name at runtime with `ModelMeta`"}
{"repo": "ultimate-python-master/ultimatepython/advanced/benchmark.py", "original_string": "def finish_slower():\n    \"\"\"Finish slower by sleeping more.\"\"\"\n    for _ in range(20):\n        time.sleep(_SLEEP_DURATION)\n", "docstring": "Finish slower by sleeping more.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/benchmark.py", "original_string": "def main():\n    # Create a profile instance\n    profile = cProfile.Profile()\n    profile.enable()\n    for _ in range(2):\n        finish_slower()\n        finish_faster()\n    profile.disable()\n    # Sort statistics by cumulative time spent for each function call.\n    # There are other ways to sort the stats by, but this is the most\n    # common way of doing so. For more info, please consult Python docs:\n    # https://docs.python.org/3/library/profile.html\n    buffer = io.StringIO()\n    ps = pstats.Stats(profile, stream=buffer).sort_stats(\"cumulative\")\n    # Notice how many times each function was called. In this case, the main\n    # bottleneck for `finish_slower` and `finish_faster` is `time.sleep`\n    # which occurred 60 times. By reading the code and the statistics, we\n    # can infer that 40 occurrences came from `finish_slower` and 20 came\n    # from `finish_faster`. It is clear why the latter function runs faster\n    # in this case, but identifying insights like this are not simple in\n    # large projects. Consider profiling in isolation when analyzing complex\n    # classes and functions\n    ps.print_stats()\n    time_sleep_called = any(\"60\" in line and \"time.sleep\" in line\n                            for line in buffer.getvalue().split(\"\\n\"))\n    assert time_sleep_called is True\n", "docstring": "Create a profile instance"}
{"repo": "ultimate-python-master/ultimatepython/advanced/async.py", "original_string": "def _is_valid_record(record):\n    \"\"\"Check whether job record is valid or not.\"\"\"\n    return record.queued_at < record.started_at\n", "docstring": "Check whether job record is valid or not.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/data_format.py", "original_string": "    def from_data(cls, data):\n        \"\"\"Create note from dictionary data.\"\"\"\n        return cls(**data)\n", "docstring": "Create note from dictionary data.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/data_format.py", "original_string": "    def fields(cls):\n        \"\"\"Get field names to simplify parsing logic.\"\"\"\n        return tuple(field.name for field in fields(cls))\n", "docstring": "Get field names to simplify parsing logic.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/date_time.py", "original_string": "def convert_dt_to_utc_epoch(dt):\n    \"\"\"Convert datetime to UTC epoch seconds.\n    Note that the timestamp method assumes that an offset-naive\n    datetime instance is in the local timezone and converts its\n    offset to UTC before making it a floating point number.\n    \"\"\"\n    return dt.timestamp()\n", "docstring": "Convert datetime to UTC epoch seconds."}
{"repo": "ultimate-python-master/ultimatepython/advanced/date_time.py", "original_string": "def convert_dt_timezone(dt, tz):\n    \"\"\"Convert datetime timezone.\"\"\"\n    return dt.astimezone(tz=tz)\n", "docstring": "Convert datetime timezone.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/date_time.py", "original_string": "def get_utc_now_as_epoch():\n    \"\"\"Get current UTC time as epoch seconds.\"\"\"\n    return convert_dt_to_utc_epoch(get_utc_now_as_dt())\n", "docstring": "Get current UTC time as epoch seconds.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mocking.py", "original_string": "    def endpoint(self):\n        \"\"\"Get application server endpoint URL.\"\"\"\n        return f\"{self._proto}://{self._host}:{self._port}\"\n", "docstring": "Get application server endpoint URL.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mocking.py", "original_string": "    def pid(self):\n        \"\"\"Get application server process ID.\"\"\"\n        return self._pid\n", "docstring": "Get application server process ID.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mocking.py", "original_string": "    def started(self):\n        \"\"\"Check if application server is started.\"\"\"\n        return self.pid > 0\n", "docstring": "Check if application server is started.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mocking.py", "original_string": "    def endpoint(self):\n        \"\"\"Mock output of endpoint URL.\"\"\"\n        return _FAKE_BASE_URL\n", "docstring": "Mock output of endpoint URL.\n"}
{"repo": "ultimate-python-master/ultimatepython/advanced/mocking.py", "original_string": "    def pid(self):\n        \"\"\"Mock output of process ID.\"\"\"\n        return _FAKE_PID\n", "docstring": "Mock output of process ID.\n"}
{"repo": "ultimate-python-master/ultimatepython/syntax/expression.py", "original_string": "def main():\n    # This is a simple integer\n    x = 1\n    # Its value can be used as part of expressions\n    assert x + 1 == 2\n    # An expression can be chained indefinitely. This concept of chaining\n    # expressions is powerful because it allows us to compose simple pieces\n    # of code into larger pieces of code over time\n    assert x * 2 * 2 * 2 == 8\n    # Division is tricky because Python 3.x returns 0.5 of type `float`\n    # whereas Python 2.x returns 0 of type `int`. If this line fails, it\n    # is a sign that the wrong version of Python was used\n    assert x / 2 == 0.5\n    # If an integer division is desired, then an extra slash must be\n    # added to the expression. In Python 2.x and Python 3.x, the behavior\n    # is exactly the same\n    assert x // 2 == 0\n    # Powers of an integer can be leveraged too. If more features are\n    # needed, then leverage the builtin `math` library or a third-party\n    # library. Otherwise, we have to build our own math library\n    assert x * 2 ** 3 == 8\n", "docstring": "This is a simple integer"}
{"repo": "ultimate-python-master/ultimatepython/syntax/loop.py", "original_string": "def main():\n    # This is a `for` loop that iterates on values 0..4 and adds each\n    # value to `total`. It leverages the `range` iterator. Providing\n    # a single integer implies that the start point is 0, the end point\n    # is 5 and the increment step is 1 (going forward one step)\n    total = 0\n    for i in range(5):\n        total += i\n    # The answer is...10!\n    assert total == 10\n    # This is a `for` loop that iterates on values 5..1 and multiplies each\n    # value to `fib`. The `range` iterator is used here more precisely by\n    # setting the start point at 5, the end point at 0 and the increment\n    # step at -1 (going backward one step)\n    fib = 1\n    for i in range(5, 0, -1):\n        fib *= i\n    # The answer is...120!\n    assert fib == 120\n    # This is a simple `while` loop, similar to a `for` loop except that the\n    # counter is declared outside of the loop and its state is explicitly\n    # managed inside of the loop. The loop will continue until the counter\n    # exceeds 8\n    i = 0\n    while i < 8:\n        i += 2\n    # The `while` loop terminated at this value\n    assert i == 8\n    # This is a `while` loop that stops with `break` and its counter is\n    # multiplied in the loop, showing that we can do anything to the\n    # counter. Like the previous `while` loop, this one continues until\n    # the counter exceeds 8\n    i = 1\n    break_hit = False\n    continue_hit = False\n    other_hit = False\n    while True:\n        i *= 2\n        if i >= 8:\n            # The `break` statement stops the current `while` loop.\n            # If this `while` loop was nested in another loop,\n            # this statement would not stop the parent loop\n            break_hit = True\n            break\n        if i == 2:\n            # The `continue` statement returns to the start of the\n            # current `while` loop\n            continue_hit = True\n            continue\n        # This statement runs when the counter equals 4\n        other_hit = True\n    # The `while` loop terminated at this value\n    assert i == 8\n    # The `while` loop hit the `break` and `continue` blocks\n    assert break_hit is True\n    assert continue_hit is True\n    assert other_hit is True\n", "docstring": "This is a `for` loop that iterates on values 0..4 and adds each"}
{"repo": "ultimate-python-master/ultimatepython/syntax/variable.py", "original_string": "def main():\n    # Here are the main literal types to be aware of\n    a = 1\n    b = 2.0\n    c = True\n    d = \"hello\"\n    # Notice that each type is a class. Each of the variables above refers\n    # to an instance of the class it belongs to\n    a_type = type(a)\n    b_type = type(b)\n    c_type = type(c)\n    d_type = type(d)\n    # Also, say hello to the `assert` keyword! This is a debugging aid that\n    # we will use to validate the code as we progress through each `main`\n    # function. These statements are used to validate the correctness of\n    # the data and to reduce the amount of output sent to the screen\n    assert a_type is int\n    assert b_type is float\n    assert c_type is bool\n    assert d_type is str\n    # Everything is an object in Python. That means instances are objects\n    # and classes are objects as well\n    assert isinstance(a, object) and isinstance(a_type, object)\n    assert isinstance(b, object) and isinstance(b_type, object)\n    assert isinstance(c, object) and isinstance(c_type, object)\n    assert isinstance(d, object) and isinstance(d_type, object)\n    # We can represent integer literals in Python using 4 bases: decimal,\n    # hexadecimal, octal, and binary. Decimal literals do not require any\n    # prefix while other bases require prefixes:\n    # - `0x` for hexadecimal\n    # - `0o` for octal\n    # - `0b` for binary\n    assert 100 == 0x64 == 0o144 == 0b1100100\n    # We can use underscores (literal `_`) to separate digit groups in\n    # integer literals\n    assert 10_000 == 10000\n    assert 0x01_0f_2c == 69_420\n    assert 3.456_290e-1 == 0.3_456_290\n", "docstring": "Here are the main literal types to be aware of"}
{"repo": "ultimate-python-master/ultimatepython/syntax/function.py", "original_string": "def add(x, y):\n    \"\"\"Add two objects together to produce a new object.\n    Two differences between `add` and `main` are that:\n    - It accepts input parameters\n    - It returns a value\n    \"\"\"\n    return x + y\n", "docstring": "Add two objects together to produce a new object."}
{"repo": "ultimate-python-master/ultimatepython/syntax/function.py", "original_string": "def main():\n    # The `add` function can be used for numbers as expected\n    add_result_int = add(1, 2)\n    assert add_result_int == 3\n    # The `add` function can be used for strings as well\n    add_result_string = add(\"hello\", \" world\")\n    assert add_result_string == \"hello world\"\n    # Run the input function multiple times. Notice that we make use of\n    # `lambda` to create an anonymous function (i.e. a function without\n    # a name) that accepts one input and does something with it. Anonymous\n    # functions are powerful because they allow one to write functions\n    # inline, unlike `add` and `sum_until`\n    run_results = sum_until(lambda i: i * 100, 5)\n    assert run_results == 1000, run_results\n    # We can see the `sum_until` docstring by accessing the `__doc__` magic\n    # attribute! Remember this - everything in Python is an object\n    assert \"includes this docstring!\" in sum_until.__doc__\n", "docstring": "The `add` function can be used for numbers as expected"}
{"repo": "open_dnsdb-master/dnsdb/config.py", "original_string": "    def __init__(self, app_env, app_kind, conf_dir):\n        # print 'conf_dir: ', conf_dir\n        if \"--\" in sys.argv:\n            args = sys.argv[sys.argv.index(\"--\") + 1:]\n        else:\n            args = []\n        common_config_file = os.path.join(conf_dir, \"etc/{}/common.conf\".format(app_env))\n        default_config_files = [common_config_file]\n        app_config_file = os.path.join(conf_dir, \"etc/{}/{}.conf\".format(app_env, app_kind))\n        default_config_files.append(app_config_file)\n        CONF(default_config_files=default_config_files, args=args)\n        self.SECRET_KEY = os.environ.get('SECRET_KEY') or CONF.etc.secret_key\n        self.SQLALCHEMY_DATABASE_URI = CONF.DB.connection\n        self.SQLALCHEMY_TRACK_MODIFICATIONS = False\n        self.PERMANENT_SESSION_LIFETIME = timedelta(days=1)\n", "docstring": "print 'conf_dir: ', conf_dir"}
{"repo": "open_dnsdb-master/dnsdb_common/library/log.py", "original_string": "def mask_password(message, secret=\"***\"):\n    \"\"\"Replace password with 'secret' in message.\n    :param message: The string which includes security information.\n    :param secret: value with which to replace passwords, defaults to \"***\".\n    :returns: The unicode value of message with the password fields masked.\n    For example:\n    >>> mask_password(\"'adminPass' : 'aaaaa'\")\n    \"'adminPass' : '***'\"\n    >>> mask_password(\"'admin_pass' : 'aaaaa'\")\n    \"'admin_pass' : '***'\"\n    >>> mask_password('\"password\" : \"aaaaa\"')\n    '\"password\" : \"***\"'\n    >>> mask_password(\"'original_password' : 'aaaaa'\")\n    \"'original_password' : '***'\"\n    >>> mask_password(\"u'original_password' :   u'aaaaa'\")\n    \"u'original_password' :   u'***'\"\n    \"\"\"\n    message = six.text_type(message)\n    # NOTE(ldbragst): Check to see if anything in message contains any key\n    # specified in _SANITIZE_KEYS, if not then just return the message since\n    # we don't have to mask any passwords.\n    if not any(key in message for key in _SANITIZE_KEYS):\n        return message\n    secret = r'\\g<1>' + secret + r'\\g<2>'\n    for pattern in _SANITIZE_PATTERNS:\n        message = re.sub(pattern, secret, message)\n    return message\n", "docstring": "Replace password with 'secret' in message."}
{"repo": "open_dnsdb-master/dnsdb_common/library/log.py", "original_string": "    def process(self, msg, kwargs):\n        # NOTE(mrodden): catch any Message/other object and\n        #                coerce to unicode before they can get\n        #                to the python logging and possibly\n        #                cause string encoding trouble\n        if not isinstance(msg, six.string_types):\n            msg = six.text_type(msg)\n        if 'extra' not in kwargs:\n            kwargs['extra'] = {}\n        extra = kwargs['extra']\n        context = kwargs.pop('context', None)\n        if not context:\n            context = getattr(local.store, 'context', None)\n        if context:\n            extra.update(_dictify_context(context))\n        instance = kwargs.pop('instance', None)\n        instance_uuid = (extra.get('instance_uuid', None) or\n                         kwargs.pop('instance_uuid', None))\n        instance_extra = ''\n        if instance:\n            instance_extra = CONF.instance_format % instance\n        elif instance_uuid:\n            instance_extra = (CONF.instance_uuid_format\n                              % {'uuid': instance_uuid})\n        extra.update({'instance': instance_extra})\n        extra.update({\"project\": self.project})\n        extra.update({\"version\": self.version})\n        extra['extra'] = extra.copy()\n        return msg, kwargs\n", "docstring": "NOTE(mrodden): catch any Message/other object and"}
{"repo": "open_dnsdb-master/dnsdb_common/library/log.py", "original_string": "    def __init__(self, fmt=None, datefmt=None):\n        # NOTE(jkoelker) we ignore the fmt argument, but its still there\n        #                since logging.config.fileConfig passes it.\n        self.datefmt = datefmt\n", "docstring": "NOTE(jkoelker) we ignore the fmt argument, but its still there"}
{"repo": "open_dnsdb-master/dnsdb_common/library/log.py", "original_string": "    def format(self, record):\n        \"\"\"Uses contextstring if request_id is set, otherwise default.\"\"\"\n        # NOTE(sdague): default the fancier formating params\n        # to an empty string so we don't throw an exception if\n        # they get used\n        for key in ('instance', 'color'):\n            if key not in record.__dict__:\n                record.__dict__[key] = ''\n        if record.__dict__.get('request_id', None):\n            self._fmt = CONF.logging_context_format_string\n        else:\n            self._fmt = CONF.logging_default_format_string\n        if (record.levelno == logging.DEBUG and\n                CONF.logging_debug_format_suffix):\n            self._fmt += \" \" + CONF.logging_debug_format_suffix\n        # Cache this on the record, Logger will respect our formated copy\n        if record.exc_info:\n            record.exc_text = self.formatException(record.exc_info, record)\n        return logging.Formatter.format(self, record)\n", "docstring": "Uses contextstring if request_id is set, otherwise default.\n"}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def version(self):\n        \"\"\"Return the IP version of this Object.\n        >>> IP('10.0.0.0/8').version()\n        4\n        >>> IP('::1').version()\n        6\n        \"\"\"\n        return self._ipversion\n", "docstring": "Return the IP version of this Object."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def _printPrefix(self, want):\n        \"\"\"Prints Prefixlen/Netmask.\n        Not really. In fact it is our universal Netmask/Prefixlen printer.\n        This is considered an internal function.\n        want == 0 / None        don't return anything    1.2.3.0\n        want == 1               /prefix                  1.2.3.0/24\n        want == 2               /netmask                 1.2.3.0/255.255.255.0\n        want == 3               -lastip                  1.2.3.0-1.2.3.255\n        \"\"\"\n        if (self._ipversion == 4 and self._prefixlen == 32) or \\\n                (self._ipversion == 6 and self._prefixlen == 128):\n            if self.NoPrefixForSingleIp:\n                want = 0\n        if want == None:\n            want = self.WantPrefixLen\n            if want == None:\n                want = 1\n        if want:\n            if want == 2:\n                # this should work with IP and IPint\n                netmask = self.netmask()\n                if not isinstance(netmask, INT_TYPES):\n                    netmask = netmask.int()\n                return \"/%s\" % (intToIp(netmask, self._ipversion))\n            elif want == 3:\n                return \"-%s\" % (intToIp(self.ip + self.len() - 1, self._ipversion))\n            else:\n                # default\n                return \"/%d\" % (self._prefixlen)\n        else:\n            return ''\n            # We have different flavours to convert to:\n            # strFullsize   127.0.0.1    2001:0658:022a:cafe:0200:c0ff:fe8d:08fa\n            # strNormal     127.0.0.1    2001:658:22a:cafe:200:c0ff:fe8d:08fa\n            # strCompressed 127.0.0.1    2001:658:22a:cafe::1\n            # strHex        0x7F000001   0x20010658022ACAFE0200C0FFFE8D08FA\n            # strDec        2130706433   42540616829182469433547974687817795834\n", "docstring": "Prints Prefixlen/Netmask."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def strCompressed(self, wantprefixlen=None):\n        \"\"\"Return a string representation in compressed format using '::' Notation.\n        >>> IP('127.0.0.1').strCompressed()\n        '127.0.0.1'\n        >>> IP('2001:0658:022a:cafe:0200::1').strCompressed()\n        '2001:658:22a:cafe:200::1'\n        >>> IP('ffff:ffff:ffff:ffff:ffff:f:f:fffc/127').strCompressed()\n        'ffff:ffff:ffff:ffff:ffff:f:f:fffc/127'\n        \"\"\"\n        if self.WantPrefixLen == None and wantprefixlen == None:\n            wantprefixlen = 1\n        if self._ipversion == 4:\n            return self.strFullsize(wantprefixlen)\n        else:\n            if self.ip >> 32 == 0xffff:\n                ipv4 = intToIp(self.ip & MAX_IPV4_ADDRESS, 4)\n                text = \"::ffff:\" + ipv4 + self._printPrefix(wantprefixlen)\n                return text\n            # find the longest sequence of '0'\n            hextets = [int(x, 16) for x in self.strFullsize(0).split(':')]\n            # every element of followingzeros will contain the number of zeros\n            # following the corresponding element of hextets\n            followingzeros = [0] * 8\n            for i in xrange(len(hextets)):\n                followingzeros[i] = _countFollowingZeros(hextets[i:])\n            # compressionpos is the position where we can start removing zeros\n            compressionpos = followingzeros.index(max(followingzeros))\n            if max(followingzeros) > 1:\n                # genererate string with the longest number of zeros cut out\n                # now we need hextets as strings\n                hextets = [x for x in self.strNormal(0).split(':')]\n                while compressionpos < len(hextets) and hextets[compressionpos] == '0':\n                    del (hextets[compressionpos])\n                hextets.insert(compressionpos, '')\n                if compressionpos + 1 >= len(hextets):\n                    hextets.append('')\n                if compressionpos == 0:\n                    hextets = [''] + hextets\n                return ':'.join(hextets) + self._printPrefix(wantprefixlen)\n            else:\n                return self.strNormal(0) + self._printPrefix(wantprefixlen)\n", "docstring": "Return a string representation in compressed format using '::' Notation."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def strFullsize(self, wantprefixlen=None):\n        \"\"\"Return a string representation in the non-mangled format.\n        >>> print(IP('127.0.0.1').strFullsize())\n        127.0.0.1\n        >>> print(IP('2001:0658:022a:cafe:0200::1').strFullsize())\n        2001:0658:022a:cafe:0200:0000:0000:0001\n        \"\"\"\n        if self.WantPrefixLen == None and wantprefixlen == None:\n            wantprefixlen = 1\n        return intToIp(self.ip, self._ipversion) + self._printPrefix(wantprefixlen)\n", "docstring": "Return a string representation in the non-mangled format."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def strDec(self, wantprefixlen=None):\n        \"\"\"Return a string representation in decimal format.\n        >>> print(IP('127.0.0.1').strDec())\n        2130706433\n        >>> print(IP('2001:0658:022a:cafe:0200::1').strDec())\n        42540616829182469433547762482097946625\n        \"\"\"\n        if self.WantPrefixLen == None and wantprefixlen == None:\n            wantprefixlen = 0\n        x = '%d' % self.ip\n        return x + self._printPrefix(wantprefixlen)\n", "docstring": "Return a string representation in decimal format."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def netmask(self):\n        \"\"\"Return netmask as an integer.\n        >>> \"%X\" % IP('195.185.0.0/16').netmask().int()\n        'FFFF0000'\n        \"\"\"\n        # TODO: unify with prefixlenToNetmask?\n        bits = _ipVersionToLen(self._ipversion)\n        locallen = bits - self._prefixlen\n        return ((2 ** self._prefixlen) - 1) << locallen\n", "docstring": "Return netmask as an integer."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def len(self):\n        \"\"\"Return the length of a subnet.\n        >>> print(IP('195.185.1.0/28').len())\n        16\n        >>> print(IP('195.185.1.0/24').len())\n        256\n        \"\"\"\n        bits = _ipVersionToLen(self._ipversion)\n        locallen = bits - self._prefixlen\n        return 2 ** locallen\n", "docstring": "Return the length of a subnet."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def __bool__(self):\n        return self.__nonzero__()\n", "docstring": "return self.__nonzero__()"}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def __add__(self, other):\n        \"\"\"Emulate numeric objects through network aggregation\"\"\"\n        if self._ipversion != other._ipversion:\n            raise ValueError(\"Only networks with the same IP version can be added.\")\n        if self._prefixlen != other._prefixlen:\n            raise ValueError(\"Only networks with the same prefixlen can be added.\")\n        if self._prefixlen < 1:\n            raise ValueError(\"Networks with a prefixlen longer than /1 can't be added.\")\n        if self > other:\n            # fixed by Skinny Puppy <skin_pup-IPy@happypoo.com>\n            return other.__add__(self)\n        if other.int() - self[-1].int() != 1:\n            raise ValueError(\"Only adjacent networks can be added together.\")\n        ret = IP(self.int(), ipversion=self._ipversion)\n        ret._prefixlen = self.prefixlen() - 1\n        if not _checkNetaddrWorksWithPrefixlen(ret.ip, ret._prefixlen,\n                                               ret._ipversion):\n            raise ValueError(\"The resulting %s has invalid prefix length (%s)\"\n                             % (repr(ret), ret._prefixlen))\n        return ret\n", "docstring": "Emulate numeric objects through network aggregation\n"}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def __getitem__(self, key):\n        \"\"\"Called to implement evaluation of self[key].\n        >>> ip=IP('127.0.0.0/30')\n        >>> for x in ip:\n        ...  print(repr(x))\n        ...\n        IP('127.0.0.0')\n        IP('127.0.0.1')\n        IP('127.0.0.2')\n        IP('127.0.0.3')\n        >>> ip[2]\n        IP('127.0.0.2')\n        >>> ip[-1]\n        IP('127.0.0.3')\n        \"\"\"\n        if isinstance(key, slice):\n            return [self.ip + int(x) for x in xrange(*key.indices(len(self)))]\n        if not isinstance(key, INT_TYPES):\n            raise TypeError\n        if key < 0:\n            if abs(key) <= self.len():\n                key = self.len() - abs(key)\n            else:\n                raise IndexError\n        else:\n            if key >= self.len():\n                raise IndexError\n        return self.ip + int(key)\n", "docstring": "Called to implement evaluation of self[key]."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def overlaps(self, item):\n        \"\"\"Check if two IP address ranges overlap.\n        Returns 0 if the two ranges don't overlap, 1 if the given\n        range overlaps at the end and -1 if it does at the beginning.\n        >>> IP('192.168.0.0/23').overlaps('192.168.1.0/24')\n        1\n        >>> IP('192.168.0.0/23').overlaps('192.168.1.255')\n        1\n        >>> IP('192.168.0.0/23').overlaps('192.168.2.0')\n        0\n        >>> IP('192.168.1.0/24').overlaps('192.168.0.0/23')\n        -1\n        \"\"\"\n        if not isinstance(item, IP):\n            item = IP(item)\n        if item.ip >= self.ip and item.ip < self.ip + self.len():\n            return 1\n        elif self.ip >= item.ip and self.ip < item.ip + item.len():\n            return -1\n        else:\n            return 0\n", "docstring": "Check if two IP address ranges overlap."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def __repr__(self):\n        \"\"\"Print a representation of the Object.\n        Used to implement repr(IP). Returns a string which evaluates\n        to an identical Object (without the wantprefixlen stuff - see\n        module docstring.\n        >>> print(repr(IP('10.0.0.0/24')))\n        IP('10.0.0.0/24')\n        \"\"\"\n        return (\"IPint('%s')\" % (self.strCompressed(1)))\n", "docstring": "Print a representation of the Object."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def __hash__(self):\n        \"\"\"Called for the key object for dictionary operations, and by\n        the built-in function hash(). Should return a 32-bit integer\n        usable as a hash value for dictionary operations. The only\n        required property is that objects which compare equal have the\n        same hash value\n        >>> IP('10.0.0.0/24').__hash__()\n        -167772185\n        \"\"\"\n        thehash = int(-1)\n        ip = self.ip\n        while ip > 0:\n            thehash = thehash ^ (ip & 0x7fffffff)\n            ip = ip >> 32\n        thehash = thehash ^ self._prefixlen\n        return int(thehash)\n", "docstring": "Called for the key object for dictionary operations, and by"}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def net(self):\n        \"\"\"Return the base (first) address of a network as an IP object.\n        The same as IP[0].\n        >>> IP('10.0.0.0/8').net()\n        IP('10.0.0.0')\n        \"\"\"\n        return IP(IPint.net(self), ipversion=self._ipversion)\n", "docstring": "Return the base (first) address of a network as an IP object."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def netmask(self):\n        \"\"\"Return netmask as an IP object.\n        >>> IP('10.0.0.0/8').netmask()\n        IP('255.0.0.0')\n         \"\"\"\n        return IP(IPint.netmask(self), ipversion=self._ipversion)\n", "docstring": "Return netmask as an IP object."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def reverseNames(self):\n        \"\"\"Return a list with values forming the reverse lookup.\n        >>> IP('213.221.113.87/32').reverseNames()\n        ['87.113.221.213.in-addr.arpa.']\n        >>> IP('213.221.112.224/30').reverseNames()\n        ['224.112.221.213.in-addr.arpa.', '225.112.221.213.in-addr.arpa.', '226.112.221.213.in-addr.arpa.', '227.112.221.213.in-addr.arpa.']\n        >>> IP('127.0.0.0/24').reverseNames()\n        ['0.0.127.in-addr.arpa.']\n        >>> IP('127.0.0.0/23').reverseNames()\n        ['0.0.127.in-addr.arpa.', '1.0.127.in-addr.arpa.']\n        >>> IP('127.0.0.0/16').reverseNames()\n        ['0.127.in-addr.arpa.']\n        >>> IP('127.0.0.0/15').reverseNames()\n        ['0.127.in-addr.arpa.', '1.127.in-addr.arpa.']\n        >>> IP('128.0.0.0/8').reverseNames()\n        ['128.in-addr.arpa.']\n        >>> IP('128.0.0.0/7').reverseNames()\n        ['128.in-addr.arpa.', '129.in-addr.arpa.']\n        >>> IP('::1:2').reverseNames()\n        ['2.0.0.0.1.ip6.arpa.']\n        \"\"\"\n        if self._ipversion == 4:\n            ret = []\n            # TODO: Refactor. Add support for IPint objects\n            if self.len() < 2 ** 8:\n                for x in self:\n                    ret.append(x.reverseName())\n            elif self.len() < 2 ** 16:\n                for i in xrange(0, self.len(), 2 ** 8):\n                    ret.append(self[i].reverseName()[2:])\n            elif self.len() < 2 ** 24:\n                for i in xrange(0, self.len(), 2 ** 16):\n                    ret.append(self[i].reverseName()[4:])\n            else:\n                for i in xrange(0, self.len(), 2 ** 24):\n                    ret.append(self[i].reverseName()[6:])\n            return ret\n        elif self._ipversion == 6:\n            ipv4 = self._getIPv4Map()\n            if ipv4 is not None:\n                return ipv4.reverseNames()\n            s = \"%x\" % self.ip\n            if self._prefixlen % 4 != 0:\n                raise NotImplementedError(\"can't create IPv6 reverse names at sub nibble level\")\n            s = list(s)\n            s.reverse()\n            s = '.'.join(s)\n            first_nibble_index = int(32 - (self._prefixlen // 4)) * 2\n            return [\"%s.ip6.arpa.\" % s[first_nibble_index:]]\n        else:\n            raise ValueError(\"only IPv4 and IPv6 supported\")\n", "docstring": "Return a list with values forming the reverse lookup."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def make_net(self, netmask):\n        \"\"\"Transform a single IP address into a network specification by\n        applying the given netmask.\n        Returns a new IP instance.\n        >>> print(IP('127.0.0.1').make_net('255.0.0.0'))\n        127.0.0.0/8\n        \"\"\"\n        if '/' in str(netmask):\n            raise ValueError(\"invalid netmask (%s)\" % netmask)\n        return IP('%s/%s' % (self, netmask), make_net=True)\n", "docstring": "Transform a single IP address into a network specification by"}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def __repr__(self):\n        \"\"\"Print a representation of the Object.\n        >>> IP('10.0.0.0/8')\n        IP('10.0.0.0/8')\n        \"\"\"\n        return (\"IP('%s')\" % (self.strCompressed(1)))\n", "docstring": "Print a representation of the Object."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def __init__(self, iterable=[]):\n        # Make sure it's iterable, otherwise wrap\n        if not isinstance(iterable, collections.Iterable):\n            raise TypeError(\"'%s' object is not iterable\" % type(iterable).__name__)\n        # Make sure we only accept IP objects\n        for prefix in iterable:\n            if not isinstance(prefix, IP):\n                raise ValueError('Only IP objects can be added to an IPSet')\n        # Store and optimize\n        self.prefixes = iterable[:]\n        self.optimize()\n", "docstring": "Make sure it's iterable, otherwise wrap"}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def __iter__(self):\n        for prefix in self.prefixes:\n            yield prefix\n", "docstring": "for prefix in self.prefixes:"}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def discard(self, value):\n        # Make sure it's iterable, otherwise wrap\n        if not isinstance(value, collections.Iterable):\n            value = [value]\n        # This is much faster than iterating over the addresses\n        if isinstance(value, IPSet):\n            value = value.prefixes\n        # Remove\n        for del_prefix in value:\n            if not isinstance(del_prefix, IP):\n                raise ValueError('Only IP objects can be removed from an IPSet')\n            # First check if this prefix contains anything in our list\n            found = False\n            d = 0\n            for i in range(len(self.prefixes)):\n                if self.prefixes[i - d] in del_prefix:\n                    self.prefixes.pop(i - d)\n                    d = d + 1\n                    found = True\n            if found:\n                # If the prefix was bigger than an existing prefix, then it's\n                # certainly not a subset of one, so skip the rest\n                continue\n            # Maybe one of our prefixes contains this prefix\n            found = False\n            for i in range(len(self.prefixes)):\n                if del_prefix in self.prefixes[i]:\n                    self.prefixes[i:i + 1] = self.prefixes[i] - del_prefix\n                    break\n        self.optimize()\n", "docstring": "Make sure it's iterable, otherwise wrap"}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "    def optimize(self):\n        # The algorithm below *depends* on the sort order\n        self.prefixes.sort()\n        # First eliminate all values that are a subset of other values\n        addrlen = len(self.prefixes)\n        i = 0\n        while i < addrlen:\n            # Everything that might be inside this prefix follows\n            # directly behind it\n            j = i + 1\n            while j < addrlen and self.prefixes[j] in self.prefixes[i]:\n                # Mark for deletion by overwriting with None\n                self.prefixes[j] = None\n                j += 1\n            # Continue where we left off\n            i = j\n        # Try to merge as many prefixes as possible\n        run_again = True\n        while run_again:\n            # Filter None values. This happens when a subset is eliminated\n            # above, or when two prefixes are merged below\n            self.prefixes = [a for a in self.prefixes if a is not None]\n            # We'll set run_again to True when we make changes that require\n            # re-evaluation of the whole list\n            run_again = False\n            # We can merge two prefixes that have the same version, same\n            # prefix length and differ only on the last bit of the prefix\n            addrlen = len(self.prefixes)\n            i = 0\n            while i < addrlen - 1:\n                j = i + 1\n                try:\n                    # The next line will throw an exception when merging\n                    # is not possible\n                    self.prefixes[i] += self.prefixes[j]\n                    self.prefixes[j] = None\n                    i = j + 1\n                    run_again = True\n                except ValueError:\n                    # Can't be merged, see if position j can be merged\n                    i = j\n        # O(n) insertion now by prefix means faster searching on __contains__\n        # when lots of ranges with the same length exist\n        self.prefixtable = {}\n        for address in self.prefixes:\n            try:\n                self.prefixtable[address._prefixlen].append(address)\n            except KeyError:\n                self.prefixtable[address._prefixlen] = [address]\n", "docstring": "The algorithm below *depends* on the sort order"}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "def _ipVersionToLen(version):\n    \"\"\"Return number of bits in address for a certain IP version.\n    >>> _ipVersionToLen(4)\n    32\n    >>> _ipVersionToLen(6)\n    128\n    >>> _ipVersionToLen(5)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in ?\n      File \"IPy.py\", line 1076, in _ipVersionToLen\n        raise ValueError(\"only IPv4 and IPv6 supported\")\n    ValueError: only IPv4 and IPv6 supported\n    \"\"\"\n    if version == 4:\n        return 32\n    elif version == 6:\n        return 128\n    else:\n        raise ValueError(\"only IPv4 and IPv6 supported\")\n", "docstring": "Return number of bits in address for a certain IP version."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "def _intToBin(val):\n    \"\"\"Return the binary representation of an integer as string.\"\"\"\n    if val < 0:\n        raise ValueError(\"Only positive values allowed\")\n    s = \"%x\" % val\n    ret = ''\n    for x in s:\n        ret += _BitTable[x]\n    # remove leading zeros\n    while ret[0] == '0' and len(ret) > 1:\n        ret = ret[1:]\n    return ret\n", "docstring": "Return the binary representation of an integer as string.\n"}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "def _count0Bits(num):\n    \"\"\"Find the highest bit set to 0 in an integer.\"\"\"\n    # this could be so easy if _count1Bits(~int(num)) would work as excepted\n    num = int(num)\n    if num < 0:\n        raise ValueError(\"Only positive Numbers please: %s\" % (num))\n    ret = 0\n    while num > 0:\n        if num & 1 == 1:\n            break\n        num = num >> 1\n        ret += 1\n    return ret\n", "docstring": "Find the highest bit set to 0 in an integer.\n"}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "def _checkNetmask(netmask, masklen):\n    \"\"\"Checks if a netmask is expressable as a prefixlen.\"\"\"\n    num = int(netmask)\n    bits = masklen\n    # remove zero bits at the end\n    while (num & 1) == 0 and bits != 0:\n        num = num >> 1\n        bits -= 1\n        if bits == 0:\n            break\n    # now check if the rest consists only of ones\n    while bits > 0:\n        if (num & 1) == 0:\n            raise ValueError(\"Netmask 0x%x can't be expressed as an prefix.\" % netmask)\n        num = num >> 1\n        bits -= 1\n", "docstring": "Checks if a netmask is expressable as a prefixlen.\n"}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "def _netmaskToPrefixlen(netmask):\n    \"\"\"Convert an Integer representing a netmask to a prefixlen.\n    E.g. 0xffffff00 (255.255.255.0) returns 24\n    \"\"\"\n    netlen = _count0Bits(netmask)\n    masklen = _count1Bits(netmask)\n    _checkNetmask(netmask, masklen)\n    return masklen - netlen\n", "docstring": "Convert an Integer representing a netmask to a prefixlen."}
{"repo": "open_dnsdb-master/dnsdb_common/library/IPy.py", "original_string": "def _remove_subprefix(prefix, subprefix):\n    if prefix in subprefix:\n        # Nothing left\n        return IPSet()\n    if subprefix not in prefix:\n        # That prefix isn't even in here\n        return IPSet([IP(prefix)])\n    # Start cutting in half, recursively\n    prefixes = [\n        IP('%s/%d' % (prefix[0], prefix._prefixlen + 1)),\n        IP('%s/%d' % (prefix[int(prefix.len() / 2)], prefix._prefixlen + 1)),\n    ]\n    if subprefix in prefixes[0]:\n        return _remove_subprefix(prefixes[0], subprefix) + IPSet([prefixes[1]])\n    else:\n        return IPSet([prefixes[0]]) + _remove_subprefix(prefixes[1], subprefix)\n", "docstring": "Nothing left"}
{"repo": "open_dnsdb-master/dnsdb_common/library/gunicorn_app.py", "original_string": "    def access(self, resp, req, environ, request_time):\n        # ignore healthcheck\n        if environ.get('RAW_URI') == '/healthcheck.html':\n            return\n        super(GunicornLogger, self).access(resp, req, environ, request_time)\n", "docstring": "ignore healthcheck"}
{"repo": "docker-django-webpack-skeleton-master/fabfile.py", "original_string": "def _production_env():\n    # Speedup connection setup to server.\n    env.disable_known_hosts = True\n    env.key_filename = [os.path.join(os.environ['HOME'], '.ssh', 'id_rsa')]\n    env.project_root = '~/app/'\n", "docstring": "Speedup connection setup to server."}
{"repo": "darts-master/examples/M4_competition/evaluate_groe_R.py", "original_string": "    def __init__(self, rmodel, m, **info):\n        super().__init__()\n        self.rmodel = rmodel\n        self.m = m\n        self.info = info\n        self.values = None\n", "docstring": "super().__init__()"}
{"repo": "darts-master/examples/M4_competition/evaluate_theta_methods.py", "original_string": "def train_theta(ts, seasonality, n):\n    # should be the same as fitting with mode='multiplicative' and no prior deseasonalization.\n    # done to change easily the deseasonalization method\n    theta = Theta(theta=0, season_mode=SeasonalityMode.NONE)\n    theta.fit(ts)\n    forecast = theta.predict(n) * seasonality\n    return forecast\n", "docstring": "should be the same as fitting with mode='multiplicative' and no prior deseasonalization."}
{"repo": "darts-master/darts/logging.py", "original_string": "    def __init__(self):\n        # Open a pair of null files\n        self.null_fds = [os.open(os.devnull, os.O_RDWR) for x in range(2)]\n        # Save the actual stdout (1) and stderr (2) file descriptors.\n        self.save_fds = [os.dup(1), os.dup(2)]\n", "docstring": "Open a pair of null files"}
{"repo": "darts-master/darts/logging.py", "original_string": "    def __exit__(self, *_):\n        # Re-assign the real stdout/stderr back to (1) and (2)\n        os.dup2(self.save_fds[0], 1)\n        os.dup2(self.save_fds[1], 2)\n        # Close all file descriptors\n        for fd in self.null_fds + self.save_fds:\n            os.close(fd)\n", "docstring": "Re-assign the real stdout/stderr back to (1) and (2)"}
{"repo": "darts-master/darts/datasets/dataset_loaders.py", "original_string": "    def _is_already_downloaded(self) -> bool:\n        return os.path.isfile(self._get_path_dataset())\n", "docstring": "return os.path.isfile(self._get_path_dataset())"}
{"repo": "darts-master/darts/models/forecasting_model.py", "original_string": "    def __init__(self):\n        # The series used for training the model through the `fit()` function.\n        # This is only used if the model has been fit on one time series.\n        self.training_series: Optional[TimeSeries] = None\n        # state; whether the model has been fit (on a single time series)\n        self._fit_called = False\n", "docstring": "The series used for training the model through the `fit()` function."}
{"repo": "darts-master/darts/models/forecasting_model.py", "original_string": "    def fit(self, series: TimeSeries) -> None:\n        \"\"\" Trains the model on the provided univariate series.\n        Parameters\n        ----------\n        series\n            A target time series. The model will be trained to forecast this time series.\n        \"\"\"\n        if not isinstance(self, ExtendedForecastingModel):\n            series._assert_univariate()\n        raise_if_not(len(series) >= self.min_train_series_length,\n                     \"Train series only contains {} elements but {} model requires at least {} entries\"\n                     .format(len(series), str(self), self.min_train_series_length))\n        self.training_series = series\n        self._fit_called = True\n        if series.has_range_index:\n            self._supports_range_index()\n", "docstring": "Trains the model on the provided univariate series."}
{"repo": "darts-master/darts/models/forecasting_model.py", "original_string": "    def predict(self,\n                n: int,\n                num_samples: int = 1) -> TimeSeries:\n        \"\"\" Forecasts values for `n` time steps after the end of the series.\n        Parameters\n        ----------\n        n\n            Forecast horizon - the number of time steps after the end of the series for which to produce predictions.\n        num_samples\n            Number of times a prediction is sampled from a probabilistic model. Should be left set to 1\n            for deterministic models.\n        Returns\n        -------\n        TimeSeries\n            A time series containing the `n` next points after then end of the training series.\n        \"\"\"\n        if not self._fit_called:\n            raise_log(ValueError('The model must be fit before calling `predict()`.'\n                                 'For global models, if `predict()` is called without specifying a series,'\n                                 'the model must have been fit on a single training series.'), logger)\n        if not self._is_probabilistic() and num_samples > 1:\n            raise_log(ValueError('`num_samples > 1` is only supported for probabilistic models.'), logger)\n", "docstring": "n: int,"}
{"repo": "darts-master/darts/models/forecasting_model.py", "original_string": "    def _build_forecast_series(self,\n                               points_preds: Union[np.ndarray, Sequence[np.ndarray]],\n                               input_series: Optional[TimeSeries] = None) -> TimeSeries:\n        \"\"\"\n        Builds a forecast time series starting after the end of the training time series, with the\n        correct time index (or after the end of the input series, if specified).\n        \"\"\"\n        input_series = input_series if input_series is not None else self.training_series\n        time_index_length = len(points_preds) if isinstance(points_preds, np.ndarray) else len(points_preds[0])\n        time_index = self._generate_new_dates(time_index_length, input_series=input_series)\n        if isinstance(points_preds, np.ndarray):\n            return TimeSeries.from_times_and_values(time_index, points_preds, freq=input_series.freq_str)\n        return TimeSeries.from_times_and_values(time_index, np.stack(points_preds, axis=2),\n                                                freq=input_series.freq_str)\n", "docstring": "points_preds: Union[np.ndarray, Sequence[np.ndarray]],"}
{"repo": "darts-master/darts/models/regression_model.py", "original_string": "    def _create_training_data(self, series: TimeSeries, exog: TimeSeries = None):\n        \"\"\" Create dataframe of exogenous and endogenous variables containing lagged values.\n        Parameters\n        ----------\n        series : TimeSeries\n            Target series.\n        exog : TimeSeries, optional\n            Exogenous variables.\n        Returns\n        -------\n        TimeSeries\n            TimeSeries with lagged values of target and exogenous variables.\n        \"\"\"\n        raise_if(series.width > 1,\n            \"Series must not be multivariate. Pass exogenous variables to 'exog' parameter.\",\n            logger\n        )\n        training_data_list = []\n        if self.lags is not None:\n            lagged_data = self._create_lagged_data(series=series, lags=self.lags)\n            training_data_list.append(lagged_data)\n        if self.lags_exog is not None:\n            for i, col in enumerate(exog.columns):\n                lagged_data = self._create_lagged_data(\n                    series=exog[col], lags=self.lags_exog\n                )\n                training_data_list.append(lagged_data)\n        training_data = pd.concat(training_data_list, axis=1)[self.max_lag:]\n        return TimeSeries.from_dataframe(training_data, fill_missing_dates=False, freq=series.freq)\n", "docstring": "Create dataframe of exogenous and endogenous variables containing lagged values."}
{"repo": "darts-master/darts/models/baselines.py", "original_string": "    def __init__(self):\n        \"\"\" Naive Mean Model\n            This model has no parameter, and always predicts the\n            mean value of the training series.\n        \"\"\"\n        super().__init__()\n        self.mean_val = None\n", "docstring": "Naive Mean Model"}
{"repo": "darts-master/darts/models/baselines.py", "original_string": "    def __init__(self, K: int = 1):\n        \"\"\" Naive Seasonal Model\n        This model always predicts the value of `K` time steps ago.\n        When :math:`K=1`, this model predicts the last value of the training set.\n        When :math:`K>1`, it repeats the last :math:`K` values of the training set.\n        Parameters\n        ----------\n        K\n            the number of last time steps of the training set to repeat\n        \"\"\"\n        super().__init__()\n        self.last_k_vals = None\n        self.K = K\n", "docstring": "Naive Seasonal Model"}
{"repo": "darts-master/darts/models/baselines.py", "original_string": "    def __init__(self):\n        \"\"\" Naive Drift Model\n            This model fits a line between the first and last point of the training series,\n            and extends it in the future. For a training series of length :math:`T`, we have:\n            .. math:: \\\\hat{y}_{T+h} = y_T + h\\\\left( \\\\frac{y_T - y_1}{T - 1} \\\\right)\n        \"\"\"\n        super().__init__()\n", "docstring": "Naive Drift Model"}
{"repo": "darts-master/darts/models/baselines.py", "original_string": "    def __init__(self, models: List[ForecastingModel]):\n        \"\"\" Naive combination model\n        Naive implementation of `EnsembleModel`\n        Returns the average of all predictions of the constituent models\n        \"\"\"\n        super().__init__(models)\n", "docstring": "Naive combination model"}
{"repo": "darts-master/darts/models/auto_arima.py", "original_string": "    def __init__(self, *autoarima_args, **autoarima_kwargs):\n        \"\"\" Auto-ARIMA\n        This implementation is a thin wrapper around `pmdarima.txt AutoARIMA model\n        <https://alkaline-ml.com/pmdarima/modules/generated/pmdarima.arima.AutoARIMA.html>`_,\n        which provides functionality similar to R's `auto.arima\n        <https://www.rdocumentation.org/packages/forecast/versions/7.3/topics/auto.arima>`_.\n        This model supports the same parameters as the pmdarima.txt AutoARIMA model.\n        See `pmdarima.txt documentation\n        <https://alkaline-ml.com/pmdarima/modules/generated/pmdarima.arima.AutoARIMA.html>`_\n        for an extensive documentation and a list of supported parameters.\n        Parameters\n        ----------\n        autoarima_args\n            Positional arguments for the pmdarima.txt AutoARIMA model\n        autoarima_kwargs\n            Keyword arguments for the pmdarima.txt AutoARIMA model\n        \"\"\"\n        super().__init__()\n        self.model = PmdAutoARIMA(*autoarima_args, **autoarima_kwargs)\n        self.trend = self.model.trend\n", "docstring": "Auto-ARIMA"}
{"repo": "darts-master/darts/models/fft.py", "original_string": "def _compare_timestamps_on_attributes(ts_1: pd.Timestamp, ts_2: pd.Timestamp, required_matches: set) -> bool:\n    \"\"\" Compares pd.Timestamp instances on attributes.\n    Compares two timestamps according two a given set of attributes (such as minute, hour, day, etc.).\n    It returns True if and only if the two timestamps are matching in all given attributes.\n    Parameters\n    ----------\n    ts_1\n        First timestamp that will be compared.\n    ts_2\n        Second timestamp that will be compared.\n    required_matches\n        A set of pd.Timestamp attributes which ts_1 and ts_2 will be checked on.\n    Returns\n    -------\n    bool\n        True if and only if `ts_1` and `ts_2` match in all attributes given in `required_matches`.\n    \"\"\"\n    return all(map(lambda attr: getattr(ts_1, attr) == getattr(ts_2, attr), required_matches))\n", "docstring": "Compares pd.Timestamp instances on attributes."}
{"repo": "darts-master/darts/models/filtering_model.py", "original_string": "    def filter(self,  series: TimeSeries) -> TimeSeries:\n        \"\"\" Filters a given series\n        Parameters\n        ----------\n        series\n            The series to filter.\n        Returns\n        -------\n        TimeSeries\n            A time series containing the filtered values.\n        \"\"\"\n        pass\n", "docstring": "Filters a given series"}
{"repo": "darts-master/darts/models/filtering_model.py", "original_string": "    def __init__(self,\n                 window: int,\n                 centered: bool = True):\n        \"\"\"\n        Parameters\n        ----------\n        window\n            The length of the window over which to average values\n        centered\n            Set the labels at the center of the window. If not set, the averaged values are lagging after the\n            the original values.\n        \"\"\"\n        super().__init__()\n        self.window = window\n        self.centered = centered\n", "docstring": "window: int,"}
{"repo": "darts-master/darts/models/torch_forecasting_model.py", "original_string": "    def _cat_with_optional(tsr1: torch.Tensor, tsr2: Optional[torch.Tensor]):\n        if tsr2 is None:\n            return tsr1\n        else:\n            return torch.cat([tsr1, tsr2], dim=1)\n", "docstring": "if tsr2 is None:"}
{"repo": "darts-master/darts/models/torch_forecasting_model.py", "original_string": "    def _produce_train_output(self, data):\n        return self.model(data)\n", "docstring": "return self.model(data)"}
{"repo": "darts-master/darts/models/torch_forecasting_model.py", "original_string": "    def __init__(self, likelihood: Optional[LikelihoodModel] = None, **kwargs):\n        \"\"\" Pytorch Parametric Probabilistic Forecasting Model.\n        This is a base class for pytroch parametric probabilistic models. \"Parametric\" \n        means that these models are based on some predefined parametric distribution, say Gaussian. \n        Make sure that subclasses contain the *likelihood* parameter in __init__ method \n        and it is passed to the superclass via calling super().__init__. If the likelihood is not\n        provided, the model is considered as deterministic.\n        Parameters\n        ----------\n        likelihood\n            The likelihood model to be used for probabilistic forecasts.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.likelihood = likelihood\n", "docstring": "Pytorch Parametric Probabilistic Forecasting Model."}
{"repo": "darts-master/darts/utils/likelihood_models.py", "original_string": "    def __init__(self):\n        self.loss = nn.GaussianNLLLoss(reduction='mean')\n        self.softplus = nn.Softplus()\n        super().__init__()\n", "docstring": "self.loss = nn.GaussianNLLLoss(reduction='mean')"}
{"repo": "darts-master/darts/utils/torch.py", "original_string": "def _is_method(func: Callable[..., Any]) -> bool:\n    \"\"\" Check if the specified function is a method.\n    Parameters\n    ----------\n    func\n        the function to inspect.\n    Returns\n    -------\n    bool\n        true if `func` is a method, false otherwise.\n    \"\"\"\n    spec = signature(func)\n    if len(spec.parameters) > 0:\n        if list(spec.parameters.keys())[0] == 'self':\n            return True\n    return False\n", "docstring": "Check if the specified function is a method."}
{"repo": "darts-master/darts/dataprocessing/pipeline.py", "original_string": "    def inverse_transform(self,\n                          data: Union[TimeSeries, Sequence[TimeSeries]],\n                          partial: bool = False) -> Union[TimeSeries, Sequence[TimeSeries]]:\n        \"\"\"\n        For each data transformer in the pipeline, inverse-transform data. Then inverse transformed data is passed to\n        the next transformer. Transformers are traversed in reverse order. Raises value error if not all of the\n        transformers are invertible and ``partial`` is set to False. Set ``partial`` to True for inverting only the\n        InvertibleDataTransformer in the pipeline.\n        Parameters\n        ----------\n        data\n            (Sequence of) TimeSeries to be inverse transformed.\n        partial\n            If set to `True`, the inverse transformation is applied even if the pipeline is not fully invertible,\n            calling `inverse_transform()` only on the `InvertibleDataTransformer`s\n        Returns\n        -------\n        Union[TimeSeries, Sequence[TimeSeries]]\n            Inverse transformed data.\n        \"\"\"\n        if not partial:\n            raise_if_not(self._invertible, \"Not all transformers in the pipeline can perform inverse_transform\", logger)\n            for transformer in reversed(self._transformers):\n                data = transformer.inverse_transform(data)\n            return data\n        else:\n            for transformer in reversed(self._transformers):\n                if isinstance(transformer, InvertibleDataTransformer):\n                    data = transformer.inverse_transform(data)\n            return data\n", "docstring": "data: Union[TimeSeries, Sequence[TimeSeries]],"}
{"repo": "darts-master/darts/dataprocessing/pipeline.py", "original_string": "    def __len__(self):\n        return len(self._transformers)\n", "docstring": "return len(self._transformers)"}
{"repo": "darts-master/darts/dataprocessing/transformers/scaler.py", "original_string": "    def ts_fit(series: TimeSeries, transformer, *args, **kwargs) -> Any:\n        # fit_parameter will receive the transformer object instance\n        scaler = transformer.fit(series.values().reshape((-1, series.width)))\n        return scaler\n", "docstring": "fit_parameter will receive the transformer object instance"}
{"repo": "darts-master/darts/dataprocessing/transformers/scaler.py", "original_string": "    def _transform_iterator(self, series: Sequence[TimeSeries]) -> Iterator[Tuple[TimeSeries, Any]]:\n        # since '_ts_fit()' returns the scaler objects, the 'fit()' call will save transformers instance into\n        # self._fitted_params\n        return zip(series, self._fitted_params)\n", "docstring": "since '_ts_fit()' returns the scaler objects, the 'fit()' call will save transformers instance into"}
{"repo": "darts-master/darts/dataprocessing/transformers/fittable_data_transformer.py", "original_string": "            def __init__(self):\n                super().__init__()\n", "docstring": "super().__init__()"}
{"repo": "darts-master/darts/dataprocessing/transformers/fittable_data_transformer.py", "original_string": "            def _fit_iterator(self, series: Sequence[TimeSeries]) -> Iterator[Tuple[TimeSeries, int]]:\n                # the second generator is setting the m parameter of ts_fit() to 0 for each TimeSeries\n                return zip(series, (0 for i in range(len(series))))\n", "docstring": "the second generator is setting the m parameter of ts_fit() to 0 for each TimeSeries"}
{"repo": "darts-master/darts/dataprocessing/transformers/invertible_data_transformer.py", "original_string": "            def __init__(self):\n                super().__init__(ts_transform=my_ts_transform,\n                                 ts_inverse_transform=my_ts_inverse_transform)\n", "docstring": "super().__init__(ts_transform=my_ts_transform,"}
{"repo": "darts-master/darts/tests/test_dataset_loaders.py", "original_string": "    def tearDown(self):\n        # we need to remove the cached datasets between each test\n        default_directory = DatasetLoader._DEFAULT_DIRECTORY\n        for f in os.listdir(default_directory):\n            os.remove(os.path.join(default_directory, f))\n        os.rmdir(DatasetLoader._DEFAULT_DIRECTORY)\n", "docstring": "we need to remove the cached datasets between each test"}
{"repo": "darts-master/darts/tests/test_filters.py", "original_string": "    def test_kalman(self):\n        \"\"\" KalmanFilter test.\n        Creates an increasing sequence of numbers, adds noise and \n        assumes the kalman filter predicts values closer to real values\n        \"\"\"\n        testing_signal = np.arange(1, 5, 0.1)\n        noise = np.random.normal(0, 0.7, testing_signal.shape)\n        testing_signal_with_noise = testing_signal + noise\n        df = pd.DataFrame(data=testing_signal_with_noise, columns=['signal'])\n        testing_signal_with_noise_ts = TimeSeries.from_dataframe(df, value_cols=['signal'])\n        kf = KalmanFilter(dim_x=1)\n        filtered_ts = kf.filter(testing_signal_with_noise_ts, num_samples=1).univariate_values()\n        \n        noise_distance = testing_signal_with_noise - testing_signal\n        prediction_distance = filtered_ts - testing_signal\n        \n        self.assertGreater(noise_distance.std(), prediction_distance.std())\n", "docstring": "KalmanFilter test."}
{"repo": "darts-master/darts/tests/test_filters.py", "original_string": "    def test_gaussian_process(self):\n        \"\"\" GaussianProcessFilter test.\n        Creates a sine wave, adds noise and assumes the GP filter\n        predicts values closer to real values\n        \"\"\"\n        theta = np.radians(np.linspace(0, 360*5, 200))\n        testing_signal = TimeSeries.from_values(np.cos(theta))\n        noise = TimeSeries.from_values(np.random.normal(0, 0.4, len(testing_signal)))\n        testing_signal_with_noise = testing_signal + noise\n        kernel = ExpSineSquared()\n        gpf = GaussianProcessFilter(kernel=kernel, alpha=0.2, n_restarts_optimizer=100, random_state=42)\n        filtered_ts = gpf.filter(testing_signal_with_noise, num_samples=1)\n        \n        noise_diff = testing_signal_with_noise - testing_signal\n        prediction_diff = filtered_ts - testing_signal\n        self.assertGreater(noise_diff.values().std(), prediction_diff.values().std())\n        filtered_ts_median = gpf.filter(testing_signal_with_noise, num_samples=100).quantile_timeseries()\n        median_prediction_diff = filtered_ts_median - testing_signal\n        self.assertGreater(noise_diff.values().std(), median_prediction_diff.values().std())\n", "docstring": "GaussianProcessFilter test."}
{"repo": "darts-master/darts/tests/test_NBEATS.py", "original_string": "        def test_multivariate(self):\n            # testing a 2-variate linear ts, first one from 0 to 1, second one from 0 to 0.5, length 100\n            series_multivariate = tg.linear_timeseries(length=100).stack(tg.linear_timeseries(length=100, start_value = 0, end_value=0.5))\n            model = NBEATSModel(input_chunk_length=3, output_chunk_length=1, n_epochs=20)\n            model.fit(series_multivariate)\n            res = model.predict(n=2).values()\n            # the theoretical result should be [[1.01, 1.02], [0.505, 0.51]].\n            # We just test if the given result is not too far in average.\n            self.assertTrue(abs(np.average(res-np.array([[1.01, 1.02], [0.505, 0.51]])) < 0.03))\n            # Test Covariates\n            series_covariates = tg.linear_timeseries(length=100).stack(tg.linear_timeseries(length=100, start_value = 0, end_value=0.1))\n            model = NBEATSModel(input_chunk_length=3, output_chunk_length=4, n_epochs=5)\n            model.fit(series_multivariate, covariates=series_covariates)\n            res = model.predict(n=3, series=series_multivariate, covariates=series_covariates).values()\n            self.assertEqual(len(res), 3)\n            self.assertTrue(abs(np.average(res)) < 5)\n", "docstring": "testing a 2-variate linear ts, first one from 0 to 1, second one from 0 to 0.5, length 100"}
{"repo": "darts-master/darts/tests/test_datasets.py", "original_string": "    def test_sequential_dataset(self):\n        # one target series\n        ds = SequentialDataset(target_series=self.target1, input_chunk_length=10, output_chunk_length=10)\n        self.assertEqual(len(ds), 81)\n        self._assert_eq(ds[5], (self.target1[75:85], self.target1[85:95], None))\n        # two target series\n        ds = SequentialDataset(target_series=[self.target1, self.target2], input_chunk_length=10, output_chunk_length=10)\n        self.assertEqual(len(ds), 262)\n        self._assert_eq(ds[5], (self.target1[75:85], self.target1[85:95], None))\n        self._assert_eq(ds[136], (self.target2[125:135], self.target2[135:145], None))\n        # two target series with custom max_nr_samples\n        ds = SequentialDataset(target_series=[self.target1, self.target2],\n                               input_chunk_length=10, output_chunk_length=10, max_samples_per_ts=50)\n        self.assertEqual(len(ds), 100)\n        self._assert_eq(ds[5], (self.target1[75:85], self.target1[85:95], None))\n        self._assert_eq(ds[55], (self.target2[125:135], self.target2[135:145], None))\n        # two targets and one covariate\n        with self.assertRaises(ValueError):\n            ds = SequentialDataset(target_series=[self.target1, self.target2], covariates=[self.cov1])\n        # two targets and two covariates\n        ds = SequentialDataset(target_series=[self.target1, self.target2],\n                               covariates=[self.cov1, self.cov2],\n                               input_chunk_length=10, output_chunk_length=10)\n        self._assert_eq(ds[5], (self.target1[75:85], self.target1[85:95], self.cov1[75:85]))\n        self._assert_eq(ds[136], (self.target2[125:135], self.target2[135:145], self.cov2[125:135]))\n", "docstring": "one target series"}
{"repo": "darts-master/darts/tests/test_regression_models.py", "original_string": "    def test_model_construction(self):\n        for model in self.models:\n            model_instance = model(lags=5)\n            self.assertEqual(model_instance.lags, [1, 2, 3, 4, 5])\n            model_instance = model(lags=None, lags_exog=3)\n            self.assertEqual(model_instance.lags_exog, [1, 2, 3])\n            model_instance = model(lags=5, lags_exog=[3, 6, 9, 12])\n            self.assertEqual(model_instance.lags_exog, [3, 6, 9, 12])\n            model_instance = model(lags=None, lags_exog=0)\n            self.assertEqual(model_instance.lags_exog, [0])\n            with self.assertRaises(ValueError):\n                model()\n            with self.assertRaises(ValueError):\n                model(lags=0)\n            with self.assertRaises(ValueError):\n                model(lags=[3, 4, 5, 0])\n            with self.assertRaises(ValueError):\n                model(lags=[3, 4.0, 5, 0])\n            with self.assertRaises(ValueError):\n                model(lags=-5)\n            with self.assertRaises(ValueError):\n                model(lags=3.6)\n            with self.assertRaises(ValueError):\n                model(lags=None, lags_exog=False)\n            with self.assertRaises(ValueError):\n                model(lags=0)\n            with self.assertRaises(ValueError):\n                model(lags=5, lags_exog=True)\n", "docstring": "for model in self.models:"}
{"repo": "darts-master/darts/tests/test_regression_models.py", "original_string": "    def helper_test_models_accuracy(self, series, exog, min_rmse):\n        # for every model, test whether it predicts the target with a minimum r2 score of `min_rmse`\n        train_f, train_t, test_f, test_t = train_test_split(exog, series, pd.Timestamp('20010101'))\n        for model in self.models:\n            model_instance = model(lags=12, lags_exog=2)\n            model_instance.fit(series=train_t, exog=train_f)\n            prediction = model_instance.predict(n=len(test_f), exog=test_f)\n            current_rmse = rmse(prediction, test_t)\n            self.assertTrue(current_rmse <= min_rmse, (\n                \"{} model was not able to denoise data. A rmse score of {} was recorded.\"\n                .format(str(model_instance), current_rmse)\n                )\n            )\n", "docstring": "for every model, test whether it predicts the target with a minimum r2 score of `min_rmse`"}
{"repo": "darts-master/darts/tests/test_regression_models.py", "original_string": "    def test_models_denoising_multi_input(self):\n        # for every model, test whether it correctly denoises ts_sum_2 using ts_random_multi and ts_sum_2 as inputs\n        self.helper_test_models_accuracy(self.ts_sum2, self.ts_exog2, 19)\n", "docstring": "for every model, test whether it correctly denoises ts_sum_2 using ts_random_multi and ts_sum_2 as inputs"}
{"repo": "darts-master/darts/tests/test_global_forecasting_models.py", "original_string": "        def test_batch_predictions(self):\n            # predicting multiple time series at once needs to work for arbitrary batch sizes\n            # univariate case\n            targets_univar = [self.target_past, self.target_past[:60], self.target_past[:80]]\n            self._batch_prediction_test_helper_function(targets_univar)\n            # multivariate case\n            targets_multivar = [tgt.stack(tgt) for tgt in targets_univar]\n            self._batch_prediction_test_helper_function(targets_multivar)\n", "docstring": "predicting multiple time series at once needs to work for arbitrary batch sizes"}
{"repo": "darts-master/darts/tests/test_global_forecasting_models.py", "original_string": "        def test_predict_from_dataset_unsupported_input(self):\n            # an exception should be thrown if an unsupported type is passed\n            unsupported_type = 'unsupported_type'\n            # just need to test this with one model\n            model_cls, kwargs, err = models_cls_kwargs_errs[0]\n            model = model_cls(input_chunk_length=IN_LEN, output_chunk_length=OUT_LEN, **kwargs)\n            model.fit([self.ts_pass_train, self.ts_pass_train_1])\n            with self.assertRaises(ValueError):\n                model.predict_from_dataset(n=1, input_series_dataset=unsupported_type)\n", "docstring": "an exception should be thrown if an unsupported type is passed"}
{"repo": "darts-master/darts/tests/test_local_forecasting_models.py", "original_string": "    def test_multivariate_models_performance(self):\n        # for every model, check whether its errors do not exceed the given bounds\n        for model, max_mape in multivariate_models:\n            np.random.seed(1)\n            model.fit(self.ts_ice_heater_train)\n            prediction = model.predict(len(self.ts_ice_heater_val))\n            current_mape = mape(prediction, self.ts_ice_heater_val)\n            self.assertTrue(current_mape < max_mape, \"{} model exceeded the maximum MAPE of {}. \"\n                            \"with a MAPE of {}\".format(str(model), max_mape, current_mape))\n", "docstring": "for every model, check whether its errors do not exceed the given bounds"}
{"repo": "darts-master/darts/tests/test_timeseries_generation.py", "original_string": "    def test_constant_timeseries(self):\n        # testing parameters\n        value = 5\n        def test_routine(length):\n            # testing for constant value\n            constant_ts = constant_timeseries(value=value, length=length)\n            value_set = set(constant_ts.values().flatten())\n            self.assertTrue(len(value_set) == 1)\n        for length in [1, 2, 5, 10, 100]:\n            test_routine(length)\n", "docstring": "testing parameters"}
{"repo": "darts-master/darts/tests/test_timeseries_generation.py", "original_string": "        def test_routine(length):\n            # testing for start value, end value and delta between two adjacent entries\n            linear_ts = linear_timeseries(start_value=start_value, end_value=end_value, length=length)\n            self.assertEqual(linear_ts.values()[0][0], start_value)\n            self.assertEqual(linear_ts.values()[-1][0], end_value)\n            self.assertAlmostEqual(linear_ts.values()[-1][0] - linear_ts.values()[-2][0],\n                                   (end_value - start_value) / (length - 1))\n", "docstring": "testing for start value, end value and delta between two adjacent entries"}
{"repo": "darts-master/darts/tests/test_timeseries_generation.py", "original_string": "    def test_sine_timeseries(self):\n        # testing parameters\n        value_amplitude = 5\n        value_y_offset = -3\n        def test_routine(length):\n            # testing for correct value range\n            sine_ts = sine_timeseries(length=length, value_amplitude=value_amplitude, value_y_offset=value_y_offset)\n            self.assertTrue((sine_ts <= value_y_offset + value_amplitude).all().all())\n            self.assertTrue((sine_ts >= value_y_offset - value_amplitude).all().all())\n        for length in [1, 2, 5, 10, 100]:\n            test_routine(length)\n", "docstring": "testing parameters"}
{"repo": "darts-master/darts/tests/test_timeseries_generation.py", "original_string": "    def test_random_walk_timeseries(self):\n        # testing for correct length\n        def test_routine(length):\n            random_walk_ts = random_walk_timeseries(length=length)\n            self.assertEqual(len(random_walk_ts), length)\n        for length in [1, 2, 5, 10, 100]:\n            test_routine(length)\n", "docstring": "testing for correct length"}
{"repo": "darts-master/darts/tests/test_fft.py", "original_string": "    def helper_relevant_attributes(self, freq, length, period_attributes_tuples):\n        # test random walk\n        random_walk_ts = tg.random_walk_timeseries(freq=freq, length=length)\n        self.assertEqual(_find_relevant_timestamp_attributes(random_walk_ts), set())\n        for period, relevant_attributes in period_attributes_tuples:\n            # test seasonal period with no noise\n            seasonal_ts = tg.sine_timeseries(freq=freq, value_frequency=1 / period, length=length)\n            self.assertEqual(_find_relevant_timestamp_attributes(seasonal_ts), relevant_attributes,\n                             'failed to recognize season in non-noisy timeseries')\n            # test seasonal period with no noise\n            seasonal_noisy_ts = seasonal_ts + tg.gaussian_timeseries(freq=freq, length=length)\n            self.assertEqual(_find_relevant_timestamp_attributes(seasonal_noisy_ts), relevant_attributes,\n                             'failed to recognize season in noisy timeseries')\n", "docstring": "test random walk"}
{"repo": "darts-master/darts/tests/test_utils_torch.py", "original_string": "        def helper_test_successive_call_are_different(self, model):\n            # different between init and fit\n            model.fit()\n            self.assertFalse(torch.equal(model.model, model.fit_value))\n            # different between 2 fit\n            old_fit_value = model.fit_value.clone()\n            model.fit()\n            self.assertFalse(torch.equal(model.fit_value, old_fit_value))\n", "docstring": "different between init and fit"}
{"repo": "darts-master/darts/tests/test_logging.py", "original_string": "    def test_timeseries_split_error_log(self):\n        # test raised error log that occurs when trying to split TimeSeries at a point outside of the time index range\n        times = pd.date_range(start='2000-01-01', periods=3, freq='D')\n        values = np.array(range(3))\n        ts = TimeSeries.from_times_and_values(times, values)\n        with LogCapture() as lc:\n            get_logger('darts.timeseries').handlers = []\n            try:\n                ts.split_after(pd.Timestamp('2020-02-01'))\n            except Exception:\n                pass\n        lc.check(\n            ('darts.timeseries', 'ERROR',\n             'ValueError: Timestamp must be between 2000-01-01 00:00:00 and 2000-01-03 00:00:00')\n        )\n", "docstring": "test raised error log that occurs when trying to split TimeSeries at a point outside of the time index range"}
{"repo": "darts-master/darts/tests/test_logging.py", "original_string": "        def _my_timed_fn():\n            # do something for some time\n            for _ in range(2):\n                pass\n", "docstring": "do something for some time"}
{"repo": "darts-master/darts/tests/test_transformer_model.py", "original_string": "        def test_fit(self):\n            # Test fit-save-load cycle\n            model2 = TransformerModel(input_chunk_length=1, output_chunk_length=1,\n                                      n_epochs=2, model_name='unittest-model-transformer')\n            model2.fit(self.series)\n            model_loaded = model2.load_from_checkpoint(model_name='unittest-model-transformer', best=False)\n            pred1 = model2.predict(n=6)\n            pred2 = model_loaded.predict(n=6)\n            # Two models with the same parameters should deterministically yield the same output\n            self.assertEqual(sum(pred1.values() - pred2.values()), 0.)\n            # Another random model should not\n            model3 = TransformerModel(input_chunk_length=1, output_chunk_length=1, n_epochs=1)\n            model3.fit(self.series)\n            pred3 = model3.predict(n=6)\n            self.assertNotEqual(sum(pred1.values() - pred3.values()), 0.)\n            # test short predict\n            pred4 = model3.predict(n=1)\n            self.assertEqual(len(pred4), 1)\n            # test validation series input\n            model3.fit(self.series[:60], val_series=self.series[60:])\n            pred4 = model3.predict(n=6)\n            self.assertEqual(len(pred4), 6)\n", "docstring": "Test fit-save-load cycle"}
{"repo": "darts-master/darts/tests/test_timeseries.py", "original_string": "    def test_column_names(self):\n        # test the column names resolution\n        columns_before = [\n            ['0', '1', '2'],\n            ['v', 'v', 'x'],\n            ['v', 'v', 'x', 'v'],\n            ['0', '0_1', '0'],\n            ['0', '0_1', '0', '0_1_1']\n        ]\n        columns_after = [\n            ['0', '1', '2'],\n            ['v', 'v_1', 'x'],\n            ['v', 'v_1', 'x', 'v_2'],\n            ['0', '0_1', '0_1_1'],\n            ['0', '0_1', '0_1_1', '0_1_1_1']\n        ]\n        for cs_before, cs_after in zip(columns_before, columns_after):\n            ar = xr.DataArray(np.random.randn(10, len(cs_before), 2),\n                              dims=('time', 'component', 'sample'),\n                              coords={'time': self.times, 'component': cs_before})\n            ts = TimeSeries.from_xarray(ar)\n            self.assertEqual(ts.columns.tolist(), cs_after)\n", "docstring": "test the column names resolution"}
{"repo": "darts-master/darts/tests/test_timeseries.py", "original_string": "    def helper_test_slice(test_case, test_series: TimeSeries):\n        # base case\n        seriesA = test_series.slice(pd.Timestamp('20130104'), pd.Timestamp('20130107'))\n        test_case.assertEqual(seriesA.start_time(), pd.Timestamp('20130104'))\n        test_case.assertEqual(seriesA.end_time(), pd.Timestamp('20130107'))\n        # time stamp not in series\n        seriesB = test_series.slice(pd.Timestamp('20130104 12:00:00'), pd.Timestamp('20130107'))\n        test_case.assertEqual(seriesB.start_time(), pd.Timestamp('20130105'))\n        test_case.assertEqual(seriesB.end_time(), pd.Timestamp('20130107'))\n        # end timestamp after series\n        seriesC = test_series.slice(pd.Timestamp('20130108'), pd.Timestamp('20130201'))\n        test_case.assertEqual(seriesC.start_time(), pd.Timestamp('20130108'))\n        test_case.assertEqual(seriesC.end_time(), pd.Timestamp('20130110'))\n        # n points, base case\n        seriesD = test_series.slice_n_points_after(pd.Timestamp('20130102'), n=3)\n        test_case.assertEqual(seriesD.start_time(), pd.Timestamp('20130102'))\n        test_case.assertTrue(len(seriesD.values()) == 3)\n        test_case.assertEqual(seriesD.end_time(), pd.Timestamp('20130104'))\n        seriesE = test_series.slice_n_points_after(pd.Timestamp('20130107 12:00:10'), n=10)\n        test_case.assertEqual(seriesE.start_time(), pd.Timestamp('20130108'))\n        test_case.assertEqual(seriesE.end_time(), pd.Timestamp('20130110'))\n        seriesF = test_series.slice_n_points_before(pd.Timestamp('20130105'), n=3)\n        test_case.assertEqual(seriesF.end_time(), pd.Timestamp('20130105'))\n        test_case.assertTrue(len(seriesF.values()) == 3)\n        test_case.assertEqual(seriesF.start_time(), pd.Timestamp('20130103'))\n        seriesG = test_series.slice_n_points_before(pd.Timestamp('20130107 12:00:10'), n=10)\n        test_case.assertEqual(seriesG.start_time(), pd.Timestamp('20130101'))\n        test_case.assertEqual(seriesG.end_time(), pd.Timestamp('20130107'))\n", "docstring": "base case"}
{"repo": "darts-master/darts/tests/test_timeseries.py", "original_string": "    def helper_test_append(test_case, test_series: TimeSeries):\n        # reconstruct series\n        seriesA, seriesB = test_series.split_after(pd.Timestamp('20130106'))\n        test_case.assertEqual(seriesA.append(seriesB), test_series)\n        test_case.assertEqual(seriesA.append(seriesB).freq, test_series.freq)\n        # Creating a gap is not allowed\n        seriesC = test_series.drop_before(pd.Timestamp('20130108'))\n        with test_case.assertRaises(ValueError):\n            seriesA.append(seriesC)\n        # Changing frequence is not allowed\n        seriesM = TimeSeries.from_times_and_values(pd.date_range('20130107', '20130507', freq='30D'), range(5))\n        with test_case.assertRaises(ValueError):\n            seriesA.append(seriesM)\n", "docstring": "reconstruct series"}
{"repo": "darts-master/darts/tests/test_timeseries.py", "original_string": "    def test_short_series_creation(self):\n        # test missing freq argument error when filling missing dates on short time series\n        with self.assertRaises(ValueError):\n            TimeSeries.from_times_and_values(pd.date_range('20130101', '20130102'), range(2),\n                                             fill_missing_dates=True)\n        # test empty pandas series error\n        with self.assertRaises(ValueError):\n            TimeSeries.from_series(pd.Series(), freq='D')\n        # frequency should be ignored when fill_missing_dates is False\n        seriesA = TimeSeries.from_times_and_values(pd.date_range('20130101', '20130105'),\n                                                   range(5),\n                                                   fill_missing_dates=False,\n                                                   freq='M')\n        self.assertEqual(seriesA.freq, 'D')\n        # test successful instantiation of TimeSeries with length 2\n        TimeSeries.from_times_and_values(pd.date_range('20130101', '20130102'), range(2), freq='D')\n", "docstring": "test missing freq argument error when filling missing dates on short time series"}
{"repo": "darts-master/darts/tests/test_TCN.py", "original_string": "        def test_performance(self):\n            # test TCN performance on dummy time series\n            ts = tg.sine_timeseries(length=100) + tg.linear_timeseries(length=100, end_value=2)\n            train, test = ts[:90], ts[90:]\n            model = TCNModel(input_chunk_length=12, output_chunk_length=10, n_epochs=300, random_state=0)\n            model.fit(train)\n            pred = model.predict(n=10)\n            self.assertTrue(mae(pred, test) < 0.3)\n", "docstring": "test TCN performance on dummy time series"}
{"repo": "darts-master/darts/tests/test_backtesting.py", "original_string": "def compare_best_against_random(model_class, params, series):\n    # instantiate best model in expanding window mode\n    np.random.seed(1)\n    best_model_1, _ = model_class.gridsearch(params,\n                                             series,\n                                             forecast_horizon=10,\n                                             metric=mape,\n                                             start=series.time_index[-21])\n    # instantiate best model in split mode\n    train, val = series.split_before(series.time_index[-10])\n    best_model_2, _ = model_class.gridsearch(params, train, val_series=val, metric=mape)\n    # intantiate model with random parameters from 'params'\n    random.seed(1)\n    random_param_choice = {}\n    for key in params.keys():\n        random_param_choice[key] = random.choice(params[key])\n    random_model = model_class(**random_param_choice)\n    # perform backtest forecasting on both models\n    best_score_1 = best_model_1.backtest(series, start=series.time_index[-21], forecast_horizon=10)\n    random_score_1 = random_model.backtest(series, start=series.time_index[-21], forecast_horizon=10)\n    # perform train/val evaluation on both models\n    best_model_2.fit(train)\n    best_score_2 = mape(best_model_2.predict(len(val)), series)\n    random_model = model_class(**random_param_choice)\n    random_model.fit(train)\n    random_score_2 = mape(random_model.predict(len(val)), series)\n    # check whether best models are at least as good as random models\n    expanding_window_ok = best_score_1 <= random_score_1\n    split_ok = best_score_2 <= random_score_2\n    return expanding_window_ok and split_ok\n", "docstring": "instantiate best model in expanding window mode"}
{"repo": "darts-master/darts/tests/test_backtesting.py", "original_string": "    def test_gridsearch_multi(self):\n        dummy_series = st(length=40, value_y_offset=10).stack(lt(length=40, end_value=20))\n        tcn_params = {\n            'input_chunk_length': [12],\n            'output_chunk_length': [3],\n            'n_epochs': [1],\n            'batch_size': [1],\n            'kernel_size': [2, 3, 4]\n        }\n        TCNModel.gridsearch(tcn_params,\n                            dummy_series,\n                            forecast_horizon=3,\n                            metric=mape)\n", "docstring": "dummy_series = st(length=40, value_y_offset=10).stack(lt(length=40, end_value=20))"}
{"repo": "QuantEcon.py-master/quantecon/robustlq.py", "original_string": "    def __init__(self, Q, R, A, B, C, beta, theta):\n        # == Make sure all matrices can be treated as 2D arrays == #\n        A, B, C, Q, R = list(map(np.atleast_2d, (A, B, C, Q, R)))\n        self.A, self.B, self.C, self.Q, self.R = A, B, C, Q, R\n        # == Record dimensions == #\n        self.k = self.Q.shape[0]\n        self.n = self.R.shape[0]\n        self.j = self.C.shape[1]\n        # == Remaining parameters == #\n        self.beta, self.theta = beta, theta\n        # == Check for case of no control (pure forecasting problem) == #\n        self.pure_forecasting = True if not Q.any() and not B.any() else False\n", "docstring": "== Make sure all matrices can be treated as 2D arrays == #"}
{"repo": "QuantEcon.py-master/quantecon/ivp.py", "original_string": "    def _integrate_variable_trajectory(self, h, g, tol, step, relax):\n        \"\"\"Generates a solution trajectory of variable length.\"\"\"\n        # initialize the solution using initial condition\n        solution = np.hstack((self.t, self.y))\n        while self.successful():\n            self.integrate(self.t + h, step, relax)\n            current_step = np.hstack((self.t, self.y))\n            solution = np.vstack((solution, current_step))\n            if g(self.t, self.y, *self.f_params) < tol:\n                break\n            else:\n                continue\n        return solution\n", "docstring": "Generates a solution trajectory of variable length.\n"}
{"repo": "QuantEcon.py-master/quantecon/compute_fp.py", "original_string": "def _square_sum(a):\n    if isinstance(a, types.Number):\n        return lambda a: a**2\n    elif isinstance(a, types.Array):\n        return _square_sum_array\n", "docstring": "if isinstance(a, types.Number):"}
{"repo": "QuantEcon.py-master/quantecon/graph_tools.py", "original_string": "    def sink_scc_labels(self):\n        if self._sink_scc_labels is None:\n            self._find_sink_scc()\n        return self._sink_scc_labels\n", "docstring": "if self._sink_scc_labels is None:"}
{"repo": "QuantEcon.py-master/quantecon/random/tests/test_utilities.py", "original_string": "def test_sample_without_replacement_value_error():\n    # n <= 0\n    assert_raises(ValueError, sample_without_replacement, 0, 2)\n    assert_raises(ValueError, sample_without_replacement, -1, -1)\n    # k > n\n    assert_raises(ValueError, sample_without_replacement, 2, 3)\n", "docstring": "n <= 0"}
{"repo": "QuantEcon.py-master/quantecon/optimize/pivoting.py", "original_string": "def _min_ratio_test_no_tie_breaking(tableau, pivot, test_col,\n                                    argmins, num_candidates,\n                                    tol_piv, tol_ratio_diff):\n    \"\"\"\n    Perform the minimum ratio test, without tie breaking, for the\n    candidate rows in `argmins[:num_candidates]`. Return the number\n    `num_argmins` of the rows minimizing the ratio and store thier\n    indices in `argmins[:num_argmins]`.\n    Parameters\n    ----------\n    tableau : ndarray(float, ndim=2)\n        Array containing the tableau.\n    pivot : scalar(int)\n        Pivot.\n    test_col : scalar(int)\n        Index of the column used in the test.\n    argmins : ndarray(int, ndim=1)\n        Array containing the indices of the candidate rows. Modified in\n        place to store the indices of minimizing rows.\n    num_candidates : scalar(int)\n        Number of candidate rows in `argmins`.\n    tol_piv : scalar(float)\n        Pivot tolerance below which a number is considered to be\n        nonpositive.\n    tol_ratio_diff : scalar(float)\n        Tolerance to determine a tie between ratio values.\n    Returns\n    -------\n    num_argmins : scalar(int)\n        Number of minimizing rows.\n    \"\"\"\n    ratio_min = np.inf\n    num_argmins = 0\n    for k in range(num_candidates):\n        i = argmins[k]\n        if tableau[i, pivot] <= tol_piv:  # Treated as nonpositive\n            continue\n        ratio = tableau[i, test_col] / tableau[i, pivot]\n        if ratio > ratio_min + tol_ratio_diff:  # Ratio large for i\n            continue\n        elif ratio < ratio_min - tol_ratio_diff:  # Ratio smaller for i\n            ratio_min = ratio\n            num_argmins = 1\n        else:  # Ratio equal\n            num_argmins += 1\n        argmins[num_argmins-1] = i\n    return num_argmins\n", "docstring": "argmins, num_candidates,"}
{"repo": "QuantEcon.py-master/quantecon/optimize/root_finding.py", "original_string": "def _bisect_interval(a, b, fa, fb):\n    \"\"\"Conditional checks for intervals in methods involving bisection\"\"\"\n    if fa*fb > 0:\n        raise ValueError(\"f(a) and f(b) must have different signs\")\n    root = 0.0\n    status = _ECONVERR\n    # Root found at either end of [a,b]\n    if fa == 0:\n        root = a\n        status = _ECONVERGED\n    if fb == 0:\n        root = b\n        status = _ECONVERGED\n    return root, status\n", "docstring": "Conditional checks for intervals in methods involving bisection\n"}
{"repo": "QuantEcon.py-master/quantecon/optimize/tests/test_linprog_simplex.py", "original_string": "def _assert_infeasible(res):\n    # res: linprog result object\n    assert_(not res.success, \"incorrectly reported success\")\n    assert_equal(res.status, 2, \"failed to report infeasible status\")\n", "docstring": "res: linprog result object"}
{"repo": "QuantEcon.py-master/quantecon/optimize/tests/test_linprog_simplex.py", "original_string": "    def test_infeasible(self):\n        # Test linprog response to an infeasible problem\n        c = np.array([-1, -1]) * (-1)\n        A_ub = [[1, 0],\n                [0, 1],\n                [-1, -1]]\n        b_ub = [2, 2, -5]\n        c, A_ub, b_ub = map(np.asarray, [c, A_ub, b_ub])\n        res = linprog_simplex(c, A_ub=A_ub, b_ub=b_ub)\n        _assert_infeasible(res)\n", "docstring": "Test linprog response to an infeasible problem"}
{"repo": "QuantEcon.py-master/quantecon/optimize/tests/test_linprog_simplex.py", "original_string": "    def test_nontrivial_problem(self):\n        # Test linprog for a problem involving all constraint types,\n        # negative resource limits, and rounding issues.\n        c = np.array([-1, 8, 4, -6]) * (-1)\n        A_ub = [[-7, -7, 6, 9],\n                [1, -1, -3, 0],\n                [10, -10, -7, 7],\n                [6, -1, 3, 4]]\n        b_ub = [-3, 6, -6, 6]\n        A_eq = [[-10, 1, 1, -8]]\n        b_eq = [-4]\n        c, A_ub, b_ub, A_eq, b_eq = \\\n            map(np.asarray, [c, A_ub, b_ub, A_eq, b_eq])\n        desired_fun = 7083 / 1391 * (-1)\n        desired_x = [101 / 1391, 1462 / 1391, 0, 752 / 1391]\n        res = linprog_simplex(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq)\n        _assert_success(res, c, b_ub=b_ub, b_eq=b_eq, desired_fun=desired_fun,\n                        desired_x=desired_x)\n", "docstring": "Test linprog for a problem involving all constraint types,"}
{"repo": "QuantEcon.py-master/quantecon/optimize/tests/test_linprog_simplex.py", "original_string": "    def test_basic_artificial_vars(self):\n        # Test if linprog succeeds when at the end of Phase 1 some artificial\n        # variables remain basic, and the row in T corresponding to the\n        # artificial variables is not all zero.\n        c = np.array([-0.1, -0.07, 0.004, 0.004, 0.004, 0.004]) * (-1)\n        A_ub = np.array([[1.0, 0, 0, 0, 0, 0], [-1.0, 0, 0, 0, 0, 0],\n                         [0, -1.0, 0, 0, 0, 0], [0, 1.0, 0, 0, 0, 0],\n                         [1.0, 1.0, 0, 0, 0, 0]])\n        b_ub = np.array([3.0, 3.0, 3.0, 3.0, 20.0])\n        A_eq = np.array([[1.0, 0, -1, 1, -1, 1], [0, -1.0, -1, 1, -1, 1]])\n        b_eq = np.array([0, 0])\n        res = linprog_simplex(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq)\n        _assert_success(res, c, b_ub=b_ub, b_eq=b_eq, desired_fun=0,\n                        desired_x=np.zeros_like(c))\n", "docstring": "Test if linprog succeeds when at the end of Phase 1 some artificial"}
{"repo": "QuantEcon.py-master/quantecon/optimize/tests/test_linprog_simplex.py", "original_string": "    def test_issue_8174_stackoverflow(self):\n        # Test supplementary example from issue 8174.\n        # https://github.com/scipy/scipy/issues/8174\n        # https://stackoverflow.com/questions/47717012/\n        c = np.array([1, 0, 0, 0, 0, 0, 0]) * (-1)\n        A_ub = -np.identity(7)\n        b_ub = np.full(7, -2)\n        A_eq = np.array([\n            [1, 1, 1, 1, 1, 1, 0],\n            [0.3, 1.3, 0.9, 0, 0, 0, -1],\n            [0.3, 0, 0, 0, 0, 0, -2/3],\n            [0, 0.65, 0, 0, 0, 0, -1/15],\n            [0, 0, 0.3, 0, 0, 0, -1/15]\n        ])\n        b_eq = np.array([100, 0, 0, 0, 0])\n        res = linprog_simplex(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq)\n        _assert_success(res, c, b_ub=b_ub, b_eq=b_eq)\n", "docstring": "Test supplementary example from issue 8174."}
{"repo": "QuantEcon.py-master/quantecon/optimize/tests/test_linprog_simplex.py", "original_string": "    def test_linprog_cyclic_bland(self):\n        # Test the effect of Bland's rule on a cycling problem\n        c = np.array([-10, 57, 9, 24.]) * (-1)\n        A_ub = np.array([[0.5, -5.5, -2.5, 9],\n                         [0.5, -1.5, -0.5, 1],\n                         [1, 0, 0, 0]])\n        b_ub = np.array([0, 0, 1])\n        desired_x = [1, 0, 1, 0]\n        res = linprog_simplex(c, A_ub=A_ub, b_ub=b_ub)\n        _assert_success(res, c, b_ub=b_ub, desired_x=desired_x)\n", "docstring": "Test the effect of Bland's rule on a cycling problem"}
{"repo": "QuantEcon.py-master/quantecon/optimize/tests/test_linprog_simplex.py", "original_string": "    def test_bug_8662(self):\n        # linprog simplex used to report inncorrect optimal results\n        # https://github.com/scipy/scipy/issues/8662\n        c = np.array([-10, 10, 6, 3]) * (-1)\n        A_ub = [[8, -8, -4, 6],\n                [-8, 8, 4, -6],\n                [-4, 4, 8, -4],\n                [3, -3, -3, -10]]\n        b_ub = [9, -9, -9, -4]\n        c, A_ub, b_ub = map(np.asarray, [c, A_ub, b_ub])\n        desired_fun = -36.0000000000\n        res = linprog_simplex(c, A_ub=A_ub, b_ub=b_ub)\n        _assert_success(res, c, b_ub=b_ub, desired_fun=desired_fun)\n", "docstring": "linprog simplex used to report inncorrect optimal results"}
{"repo": "QuantEcon.py-master/quantecon/optimize/tests/test_scalar_max.py", "original_string": "def test_invalid_a_brent_max():\n    brent_max(f, -np.inf, 2)\n", "docstring": "brent_max(f, -np.inf, 2)"}
{"repo": "QuantEcon.py-master/quantecon/optimize/tests/test_root_finding.py", "original_string": "def run_check(method, name):\n    a = -1\n    b = np.sqrt(3)\n    true_fval = 0.408\n    r = method(func_two, a, b)\n    assert_allclose(true_fval, r.root, atol=0.01, rtol=1e-5,\n                    err_msg='method %s' % name)\n", "docstring": "a = -1"}
{"repo": "QuantEcon.py-master/quantecon/util/timing.py", "original_string": "def tic():\n    return __timer__.tic()\n", "docstring": "return __timer__.tic()"}
{"repo": "QuantEcon.py-master/quantecon/markov/core.py", "original_string": "    def digraph(self):\n        if self._digraph is None:\n            self._digraph = DiGraph(self.P, node_labels=self.state_values)\n        return self._digraph\n", "docstring": "if self._digraph is None:"}
{"repo": "QuantEcon.py-master/quantecon/markov/core.py", "original_string": "def _generate_sample_paths_sparse(P_cdfs1d, indices, indptr, init_states,\n                                  random_values, out):\n    \"\"\"\n    For sparse matrix.\n    Generate num_reps sample paths of length ts_length, where num_reps =\n    out.shape[0] and ts_length = out.shape[1].\n    Parameters\n    ----------\n    P_cdfs1d : ndarray(float, ndim=1)\n        1D array containing the CDFs of the state transition.\n    indices : ndarray(int, ndim=1)\n        CSR format index array.\n    indptr : ndarray(int, ndim=1)\n        CSR format index pointer array.\n    init_states : array_like(int, ndim=1)\n        Array containing the initial states. Its length must be equal to\n        num_reps.\n    random_values : ndarray(float, ndim=2)\n        Array containing random values from [0, 1). Its shape must be\n        equal to (num_reps, ts_length-1)\n    out : ndarray(int, ndim=2)\n        Array to store the sample paths.\n    Notes\n    -----\n    This routine is jit-complied by Numba.\n    \"\"\"\n    num_reps, ts_length = out.shape\n    for i in range(num_reps):\n        out[i, 0] = init_states[i]\n        for t in range(ts_length-1):\n            k = searchsorted(P_cdfs1d[indptr[out[i, t]]:indptr[out[i, t]+1]],\n                             random_values[i, t])\n            out[i, t+1] = indices[indptr[out[i, t]]+k]\n", "docstring": "random_values, out):"}
{"repo": "QuantEcon.py-master/quantecon/markov/utilities.py", "original_string": "def _fill_dense_Q(s_indices, a_indices, Q_in, Q_out):\n    L = Q_in.shape[0]\n    for i in range(L):\n        Q_out[s_indices[i], a_indices[i], :] = Q_in[i, :]\n    return Q_out\n", "docstring": "L = Q_in.shape[0]"}
{"repo": "QuantEcon.py-master/quantecon/markov/random.py", "original_string": "def _random_stochastic_matrix(m, n, k=None, sparse=False, format='csr',\n                              random_state=None):\n    \"\"\"\n    Generate a \"non-square stochastic matrix\" of shape (m, n), which\n    contains as rows m probability vectors of length n with k nonzero\n    entries.\n    For other parameters, see `random_stochastic_matrix`.\n    \"\"\"\n    if k is None:\n        k = n\n    # m prob vectors of dimension k, shape (m, k)\n    probvecs = probvec(m, k, random_state=random_state)\n    if k == n:\n        P = probvecs\n        if sparse:\n            return scipy.sparse.coo_matrix(P).asformat(format)\n        else:\n            return P\n    # if k < n:\n    rows = np.repeat(np.arange(m), k)\n    cols = \\\n        sample_without_replacement(\n            n, k, num_trials=m, random_state=random_state\n        ).ravel()\n    data = probvecs.ravel()\n    if sparse:\n        P = scipy.sparse.coo_matrix((data, (rows, cols)), shape=(m, n))\n        return P.asformat(format)\n    else:\n        P = np.zeros((m, n))\n        P[rows, cols] = data\n        return P\n", "docstring": "random_state=None):"}
{"repo": "QuantEcon.py-master/quantecon/markov/ddp.py", "original_string": "    def solve(self, method='policy_iteration',\n              v_init=None, epsilon=None, max_iter=None, k=20):\n        \"\"\"\n        Solve the dynamic programming problem.\n        Parameters\n        ----------\n        method : str, optinal(default='policy_iteration')\n            Solution method, str in {'value_iteration', 'vi',\n            'policy_iteration', 'pi', 'modified_policy_iteration',\n            'mpi', 'linear_programming', 'lp'}.\n        v_init : array_like(float, ndim=1), optional(default=None)\n            Initial value function, of length n. If None, `v_init` is\n            set such that v_init(s) = max_a r(s, a) for value iteration,\n            policy iteration, and linear programming; for modified\n            policy iteration, v_init(s) = min_(s_next, a)\n            r(s_next, a)/(1 - beta) to guarantee convergence.\n        epsilon : scalar(float), optional(default=None)\n            Value for epsilon-optimality. If None, the value stored in\n            the attribute `epsilon` is used.\n        max_iter : scalar(int), optional(default=None)\n            Maximum number of iterations. If None, the value stored in\n            the attribute `max_iter` is used.\n        k : scalar(int), optional(default=20)\n            Number of iterations for partial policy evaluation in\n            modified policy iteration (irrelevant for other methods).\n        Returns\n        -------\n        res : DPSolveResult\n            Optimization result represetned as a DPSolveResult. See\n            `DPSolveResult` for details.\n        \"\"\"\n        if method in ['value_iteration', 'vi']:\n            res = self.value_iteration(v_init=v_init,\n                                       epsilon=epsilon,\n                                       max_iter=max_iter)\n        elif method in ['policy_iteration', 'pi']:\n            res = self.policy_iteration(v_init=v_init,\n                                        max_iter=max_iter)\n        elif method in ['modified_policy_iteration', 'mpi']:\n            res = self.modified_policy_iteration(v_init=v_init,\n                                                 epsilon=epsilon,\n                                                 max_iter=max_iter,\n                                                 k=k)\n        elif method in ['linear_programming', 'lp']:\n            res = self.linprog_simplex(v_init=v_init,\n                                       max_iter=max_iter)\n        else:\n            raise ValueError('invalid method')\n        return res\n", "docstring": "v_init=None, epsilon=None, max_iter=None, k=20):"}
{"repo": "QuantEcon.py-master/quantecon/markov/ddp.py", "original_string": "        def span(z):\n            return z.max() - z.min()\n", "docstring": "return z.max() - z.min()"}
{"repo": "QuantEcon.py-master/quantecon/markov/tests/test_core.py", "original_string": "    def setUp(self):\n        \"\"\" Setup a KMRMarkovMatrix and Compute Stationary Values \"\"\"\n        self.P = KMR_Markov_matrix_sequential(self.N, self.p, self.epsilon)\n        self.mc = MarkovChain(self.P)\n        self.stationary = self.mc.stationary_distributions\n        stat_shape = self.stationary.shape\n        if len(stat_shape) == 1:\n            self.n_stat_dists = 1\n        else:\n            self.n_stat_dists = stat_shape[0]\n", "docstring": "Setup a KMRMarkovMatrix and Compute Stationary Values \n"}
{"repo": "QuantEcon.py-master/quantecon/markov/tests/test_core.py", "original_string": "    def test_sum_one(self):\n        \"Check that each stationary distribution sums to 1\"\n        stationary_distributions = self.stationary\n        assert_allclose(np.sum(stationary_distributions, axis=1),\n                        np.ones(self.n_stat_dists))\n", "docstring": "\"Check that each stationary distribution sums to 1\""}
{"repo": "QuantEcon.py-master/quantecon/markov/tests/test_core.py", "original_string": "def test_mc_sample_path_lln():\n    P = [[0.4, 0.6], [0.2, 0.8]]\n    stationary_dist = [0.25, 0.75]\n    init = 0\n    seed = 4433\n    sample_size = 10**4\n    tol = 0.02\n    frequency_1 = mc_sample_path(P, init=init, sample_size=sample_size,\n                                 random_state=seed).mean()\n    ok_(np.abs(frequency_1 - stationary_dist[1]) < tol)\n", "docstring": "P = [[0.4, 0.6], [0.2, 0.8]]"}
{"repo": "QuantEcon.py-master/quantecon/markov/tests/test_core.py", "original_string": "def test_raises_value_error_non_2dim():\n    \"\"\"Test with non 2dim input\"\"\"\n    MarkovChain(np.array([0.4, 0.6]))\n", "docstring": "Test with non 2dim input\n"}
{"repo": "QuantEcon.py-master/quantecon/markov/tests/test_core.py", "original_string": "def test_raises_value_error_non_nonnegative():\n    \"\"\"Test with non nonnegative input\"\"\"\n    P = np.array([[0.4, 0.6], [-0.2, 1.2]])\n    assert_raises(ValueError, MarkovChain, P)\n    assert_raises(ValueError, MarkovChain, sparse.csr_matrix(P))\n", "docstring": "Test with non nonnegative input\n"}
{"repo": "QuantEcon.py-master/quantecon/markov/tests/test_gth_solve.py", "original_string": "    def __init__(self):\n        self.stoch_matrix_dicts = []\n        self.kmr_matrix_dicts = []\n        self.gen_matrix_dicts = []\n        matrix_dict = {\n            'A': np.array([[0.4, 0.6], [0.2, 0.8]]),\n            'stationary_dist': np.array([0.25, 0.75]),\n        }\n        self.stoch_matrix_dicts.append(matrix_dict)\n        matrix_dict = {\n            # Reducible matrix\n            'A': np.array([[1, 0], [0, 1]]),\n            # Stationary dist whose support contains index 0\n            'stationary_dist': np.array([1, 0]),\n        }\n        self.stoch_matrix_dicts.append(matrix_dict)\n        matrix_dict = {\n            'A': KMR_Markov_matrix_sequential(N=27, p=1./3, epsilon=1e-2),\n        }\n        self.kmr_matrix_dicts.append(matrix_dict)\n        matrix_dict = {\n            'A': KMR_Markov_matrix_sequential(N=3, p=1./3, epsilon=1e-14),\n        }\n        self.kmr_matrix_dicts.append(matrix_dict)\n        matrix_dict = {\n            'A': np.array([[-3, 3], [4, -4]]),\n            'stationary_dist': np.array([4/7, 3/7]),\n        }\n        self.gen_matrix_dicts.append(matrix_dict)\n", "docstring": "self.stoch_matrix_dicts = []"}
{"repo": "QuantEcon.py-master/quantecon/markov/tests/test_gth_solve.py", "original_string": "def test_kmr_matrix():\n    \"\"\"Test with KMR matrices\"\"\"\n    print(__name__ + '.' + test_kmr_matrix.__name__)\n    matrices = Matrices()\n    for matrix_dict in matrices.kmr_matrix_dicts:\n        x = gth_solve(matrix_dict['A'])\n        yield StationaryDistSumOne(), x\n        yield StationaryDistNonnegative(), x\n        yield StationaryDistLeftEigenVec(), matrix_dict['A'], x\n", "docstring": "Test with KMR matrices\n"}
{"repo": "QuantEcon.py-master/quantecon/markov/tests/test_gth_solve.py", "original_string": "def test_raises_value_error_non_2dim():\n    \"\"\"Test with non 2dim input\"\"\"\n    gth_solve(np.array([0.4, 0.6]))\n", "docstring": "Test with non 2dim input\n"}
{"repo": "QuantEcon.py-master/quantecon/markov/tests/test_gth_solve.py", "original_string": "def test_raises_value_error_non_square():\n    \"\"\"Test with non square input\"\"\"\n    gth_solve(np.array([[0.4, 0.6]]))\n", "docstring": "Test with non square input\n"}
{"repo": "QuantEcon.py-master/quantecon/markov/tests/test_random.py", "original_string": "def test_random_markov_chain_value_error():\n    # n <= 0\n    assert_raises(ValueError, random_markov_chain, 0)\n    # k = 0\n    assert_raises(ValueError, random_markov_chain, 2, 0)\n    # k > n\n    assert_raises(ValueError, random_markov_chain, 2, 3)\n", "docstring": "n <= 0"}
{"repo": "QuantEcon.py-master/quantecon/markov/tests/test_ddp.py", "original_string": "    def setUp(self):\n        # From Puterman 2005, Section 3.1\n        beta = 0.95\n        # Formulation with R: n x m, Q: n x m x n\n        n, m = 2, 2  # number of states, number of actions\n        R = [[5, 10], [-1, -np.inf]]\n        Q = np.empty((n, m, n))\n        Q[0, 0, :] = 0.5, 0.5\n        Q[0, 1, :] = 0, 1\n        Q[1, :, :] = 0, 1\n        ddp0 = DiscreteDP(R, Q, beta)\n        # Formulation with state-action pairs\n        L = 3  # number of state-action pairs\n        s_indices = [0, 0, 1]\n        a_indices = [0, 1, 0]\n        R_sa = [R[0][0], R[0][1], R[1][0]]\n        Q_sa = sparse.lil_matrix((L, n))\n        Q_sa[0, :] = Q[0, 0, :]\n        Q_sa[1, :] = Q[0, 1, :]\n        Q_sa[2, :] = Q[1, 0, :]\n        ddp_sa_sparse = DiscreteDP(R_sa, Q_sa, beta, s_indices, a_indices)\n        ddp_sa_dense = \\\n            DiscreteDP(R_sa, Q_sa.toarray(), beta, s_indices, a_indices)\n        self.ddps = [ddp0, ddp_sa_sparse, ddp_sa_dense]\n        for ddp in self.ddps:\n            ddp.max_iter = 200\n        self.epsilon = 1e-2\n        # Analytical solution for beta > 10/11, Example 6.2.1\n        self.v_star = [(5-5.5*beta)/((1-0.5*beta)*(1-beta)), -1/(1-beta)]\n        self.sigma_star = [0, 0]\n", "docstring": "From Puterman 2005, Section 3.1"}
{"repo": "QuantEcon.py-master/quantecon/markov/tests/test_ddp.py", "original_string": "    def setUp(self):\n        # From Puterman 2005, Section 3.2, Section 4.6.1\n        # \"single-product stochastic inventory control\"\n        s_indices = [0, 0, 0, 0, 1, 1, 1, 2, 2, 3]\n        a_indices = [0, 1, 2, 3, 0, 1, 2, 0, 1, 0]\n        R = [ 0., -1., -2., -5.,  5.,  0., -3.,  6., -1.,  5.]\n        Q = [[ 1.  ,  0.  ,  0.  ,  0.  ],\n             [ 0.75,  0.25,  0.  ,  0.  ],\n             [ 0.25,  0.5 ,  0.25,  0.  ],\n             [ 0.  ,  0.25,  0.5 ,  0.25],\n             [ 0.75,  0.25,  0.  ,  0.  ],\n             [ 0.25,  0.5 ,  0.25,  0.  ],\n             [ 0.  ,  0.25,  0.5 ,  0.25],\n             [ 0.25,  0.5 ,  0.25,  0.  ],\n             [ 0.  ,  0.25,  0.5 ,  0.25],\n             [ 0.  ,  0.25,  0.5 ,  0.25]]\n        beta = 1\n        self.ddp = DiscreteDP(R, Q, beta, s_indices, a_indices)\n", "docstring": "From Puterman 2005, Section 3.2, Section 4.6.1"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/normal_form_game.py", "original_string": "    def payoff_profile_array(self):\n        N = self.N\n        dtype = self.dtype\n        payoff_profile_array = \\\n            np.empty(self.players[0].payoff_array.shape + (N,), dtype=dtype)\n        for i, player in enumerate(self.players):\n            payoff_profile_array[..., i] = \\\n                player.payoff_array.transpose(list(range(N-i, N)) +\n                                              list(range(N-i)))\n        return payoff_profile_array\n", "docstring": "N = self.N"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/normal_form_game.py", "original_string": "def _payoff_profile_array2string(payoff_profile_array, class_name=None):\n    s = np.array2string(payoff_profile_array, separator=', ')\n    # Remove one linebreak\n    s = re.sub(r'(\\n+)', lambda x: x.group(0)[0:-1], s)\n    if class_name is not None:\n        prefix = class_name + '('\n        next_line_prefix = ' ' * len(prefix)\n        suffix = ')'\n        l = s.splitlines()\n        l[0] = prefix + l[0]\n        for i in range(1, len(l)):\n            if l[i]:\n                l[i] = next_line_prefix + l[i]\n        l[-1] += suffix\n        s = '\\n'.join(l)\n    return s\n", "docstring": "Remove one linebreak"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/game_generators/tests/test_bimatrix_generators.py", "original_string": "    def test_payoff_values(self):\n        # Player 0\n        ok_((np.sum(self.g.players[0].payoff_array, axis=0) == 1).all())\n", "docstring": "Player 0"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_support_enumeration.py", "original_string": "    def setUp(self):\n        self.game_dicts = []\n        # From von Stengel 2007 in Algorithmic Game Theory\n        bimatrix = [[(3, 3), (3, 2)],\n                    [(2, 2), (5, 6)],\n                    [(0, 3), (6, 1)]]\n        d = {'g': NormalFormGame(bimatrix),\n             'NEs': [([1, 0, 0], [1, 0]),\n                     ([4/5, 1/5, 0], [2/3, 1/3]),\n                     ([0, 1/3, 2/3], [1/3, 2/3])]}\n        self.game_dicts.append(d)\n        # Degenerate game\n        # NEs ([0, p, 1-p], [1/2, 1/2]), 0 <= p <= 1, are not detected.\n        bimatrix = [[(1, 1), (-1, 0)],\n                    [(-1, 0), (1, 0)],\n                    [(0, 0), (0, 0)]]\n        d = {'g': NormalFormGame(bimatrix),\n             'NEs': [([1, 0, 0], [1, 0]),\n                     ([0, 1, 0], [0, 1])]}\n        self.game_dicts.append(d)\n", "docstring": "From von Stengel 2007 in Algorithmic Game Theory"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_support_enumeration.py", "original_string": "    def test_no_error_skew_sym(self):\n        # Test no LinAlgError is raised.\n        n, m = 3, 2\n        seed = 7028\n        g = random_skew_sym(n, m, random_state=seed)\n        support_enumeration(g)\n", "docstring": "Test no LinAlgError is raised."}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_pure_nash.py", "original_string": "    def test_tol(self):\n        # Prisoners' Dilemma game with one NE and one epsilon NE\n        epsilon = 1e-08\n        PD_bimatrix = [[(1, 1), (-2, 1 + epsilon)],\n                       [(1 + epsilon, -2), (0, 0)]]\n        NEs = [(1, 1)]\n        epsilon_NEs = [(1, 1), (0, 0)]\n        g = NormalFormGame(PD_bimatrix)\n        for tol, answer in zip([0, epsilon], [NEs, epsilon_NEs]):\n            eq_(sorted(pure_nash_brute(g, tol=tol)), sorted(answer))\n", "docstring": "Prisoners' Dilemma game with one NE and one epsilon NE"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_vertex_enumeration.py", "original_string": "def test_vertex_enumeration_qhull_options():\n    # Degenerate game, player 0's actions reordered\n    bimatrix = [[(0, 3), (6, 1)],\n                [(2, 2), (5, 6)],\n                [(3, 3), (3, 3)]]\n    g = NormalFormGame(bimatrix)\n    NEs_expected = [([0, 0, 1], [1, 0]),\n                    ([0, 0, 1], [2/3, 1/3]),\n                    ([2/3, 1/3, 0], [1/3, 2/3])]\n    qhull_options = 'QJ'\n    NEs_computed = vertex_enumeration(g, qhull_options=qhull_options)\n    eq_(len(NEs_computed), len(NEs_expected))\n    for NEs in (NEs_computed, NEs_expected):\n        NEs.sort(key=lambda x: (list(x[1]), list(x[0])))\n    for actions_computed, actions in zip(NEs_computed, NEs_expected):\n        for action_computed, action in zip(actions_computed, actions):\n            assert_allclose(action_computed, action, atol=1e-10)\n", "docstring": "Degenerate game, player 0's actions reordered"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_vertex_enumeration.py", "original_string": "    def setUp(self):\n        # From von Stengel 2007 in Algorithmic Game Theory\n        bimatrix = [[(3, 3), (3, 2)],\n                    [(2, 2), (5, 6)],\n                    [(0, 3), (6, 1)]]\n        g = NormalFormGame(bimatrix)\n        # Original best response polytope for player 0\n        vertices_P = np.array([\n            [0, 0, 0],       # 0\n            [1/3, 0, 0],     # a\n            [2/7, 1/14, 0],  # b\n            [0, 1/6, 0],     # c\n            [0, 1/8, 1/4],   # d\n            [0, 0, 1/3]      # e\n        ])\n        labelings_P = np.array([\n            [0, 1, 2],  # 0\n            [1, 2, 3],  # a\n            [2, 3, 4],  # b\n            [0, 2, 4],  # c\n            [0, 3, 4],  # d\n            [0, 1, 3]   # e\n        ])\n        # Sort rows lexicographically\n        K = labelings_P.shape[1]\n        ind = np.lexsort([labelings_P[:, K-k-1] for k in range(K)])\n        self.labelings_P = labelings_P[ind]\n        self.vertices_P = vertices_P[ind]\n        # Translated best response polytope for player 0\n        self.brp0 = _BestResponsePolytope(g.players[1], idx=0)\n", "docstring": "From von Stengel 2007 in Algorithmic Game Theory"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def setUp(self):\n        \"\"\"Setup a Player instance\"\"\"\n        coordination_game_matrix = [[4, 0], [3, 2]]\n        self.player = Player(coordination_game_matrix)\n", "docstring": "Setup a Player instance\n"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def test_best_response_list_when_tie(self):\n        \"\"\"best_response with tie_breaking=False\"\"\"\n        assert_array_equal(\n            sorted(self.player.best_response([2/3, 1/3], tie_breaking=False)),\n            sorted([0, 1])\n        )\n", "docstring": "best_response with tie_breaking=False\n"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def test_best_response_with_smallest_tie_breaking(self):\n        \"\"\"best_response with tie_breaking='smallest' (default)\"\"\"\n        eq_(self.player.best_response([2/3, 1/3]), 0)\n", "docstring": "best_response with tie_breaking='smallest' (default)\n"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def setUp(self):\n        \"\"\"Setup a Player instance\"\"\"\n        payoffs_2opponents = [[[3, 6],\n                               [4, 2]],\n                              [[1, 0],\n                               [5, 7]]]\n        self.player = Player(payoffs_2opponents)\n", "docstring": "Setup a Player instance\n"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def setUp(self):\n        \"\"\"Setup a NormalFormGame instance\"\"\"\n        coordination_game_matrix = [[4, 0], [3, 2]]\n        self.g = NormalFormGame(coordination_game_matrix)\n", "docstring": "Setup a NormalFormGame instance\n"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def setUp(self):\n        \"\"\"Setup a NormalFormGame instance\"\"\"\n        self.BoS_bimatrix = np.array([[(3, 2), (1, 1)],\n                                      [(0, 0), (2, 3)]])\n        self.g = NormalFormGame(self.BoS_bimatrix)\n", "docstring": "Setup a NormalFormGame instance\n"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def setUp(self):\n        \"\"\"Setup a NormalFormGame instance\"\"\"\n        payoffs_2opponents = [[[3, 6],\n                               [4, 2]],\n                              [[1, 0],\n                               [5, 7]]]\n        player = Player(payoffs_2opponents)\n        self.g = NormalFormGame([player for i in range(3)])\n", "docstring": "Setup a NormalFormGame instance\n"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def setUp(self):\n        \"\"\"Setup a Player instance\"\"\"\n        self.payoffs = [0, 1, -1]\n        self.player = Player(self.payoffs)\n        self.best_response_action = 1\n        self.dominated_actions = [0, 2]\n", "docstring": "Setup a Player instance\n"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def test_payoff_vector(self):\n        \"\"\"Trivial player: payoff_vector\"\"\"\n        assert_array_equal(self.player.payoff_vector(None), self.payoffs)\n", "docstring": "Trivial player: payoff_vector\n"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def test_best_response(self):\n        \"\"\"Trivial player: best_response\"\"\"\n        eq_(self.player.best_response(None), self.best_response_action)\n", "docstring": "Trivial player: best_response\n"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def test_dominated_actions(self):\n        \"\"\"Trivial player: dominated_actions\"\"\"\n        eq_(self.player.dominated_actions(), self.dominated_actions)\n", "docstring": "Trivial player: dominated_actions\n"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def setUp(self):\n        \"\"\"Setup a NormalFormGame instance\"\"\"\n        data = [[0], [1], [1]]\n        self.g = NormalFormGame(data)\n", "docstring": "Setup a NormalFormGame instance\n"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def test_getitem(self):\n        \"\"\"Trivial game: __getitem__\"\"\"\n        eq_(self.g[0], 0)\n", "docstring": "Trivial game: __getitem__\n"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def test_is_nash_pure(self):\n        \"\"\"Trivial game: is_nash with pure action\"\"\"\n        ok_(self.g.is_nash((1,)))\n        ok_(not self.g.is_nash((0,)))\n", "docstring": "Trivial game: is_nash with pure action\n"}
{"repo": "QuantEcon.py-master/quantecon/game_theory/tests/test_normal_form_game.py", "original_string": "    def setUp(self):\n        \"\"\"Setup a Player instance\"\"\"\n        self.payoffs = [[0, 1]]\n        self.player = Player(self.payoffs)\n", "docstring": "Setup a Player instance\n"}
{"repo": "QuantEcon.py-master/quantecon/tests/test_graph_tools.py", "original_string": "    def setUp(self):\n        \"\"\"Setup Digraph instances\"\"\"\n        self.graphs = Graphs()\n        for graph_dict in self.graphs.graph_dicts:\n            try:\n                weighted = graph_dict['weighted']\n            except:\n                weighted = False\n            graph_dict['g'] = DiGraph(graph_dict['A'], weighted=weighted)\n", "docstring": "Setup Digraph instances\n"}
{"repo": "QuantEcon.py-master/quantecon/tests/test_graph_tools.py", "original_string": "def test_raises_value_error_non_sym():\n    \"\"\"Test with non symmetric input\"\"\"\n    DiGraph(np.array([[0.4, 0.6]]))\n", "docstring": "Test with non symmetric input\n"}
{"repo": "QuantEcon.py-master/quantecon/tests/test_graph_tools.py", "original_string": "    def test_off_diagonal(self):\n        # Test for each pair of distinct nodes to have exactly one edge\n        ok_((self.adj_matrix ^ self.adj_matrix.T)[~self.eye_bool].all())\n", "docstring": "Test for each pair of distinct nodes to have exactly one edge"}
{"repo": "QuantEcon.py-master/quantecon/tests/test_dle.py", "original_string": "    def test_transformation_Q(self):\n        Q_solution = np.array([[5.e-09]])\n        assert_allclose(Q_solution, self.dle.Q)\n", "docstring": "Q_solution = np.array([[5.e-09]])"}
{"repo": "QuantEcon.py-master/quantecon/tests/test_filter.py", "original_string": "def test_hamilton_filter():\n    # read data\n    data_dir = get_data_dir()\n    data = pd.read_csv(os.path.join(data_dir, \"employment.csv\"),\n                       names = ['year', 'employment', 'matlab_cyc', 'matlab_cyc_rw'])\n    data['hamilton_cyc'], data['hamilton_trend'] =  hamilton_filter(\n        100*np.log(data['employment']), 8, 4)\n    data['hamilton_cyc_rw'], data['hamilton_trend_rw'] = hamilton_filter(\n        100*np.log(data['employment']), 8)\n    assert_allclose(data['matlab_cyc'], data['hamilton_cyc'],\n                    rtol = 1e-07, atol = 1e-07)\n    assert_allclose(data['matlab_cyc_rw'], data['hamilton_cyc_rw'])\n", "docstring": "read data"}
{"repo": "QuantEcon.py-master/quantecon/tests/test_kalman.py", "original_string": "    def setUp(self):\n        # Initial Values\n        self.A = np.array([[.95, 0], [0., .95]])\n        self.C = np.eye(2) * np.sqrt(0.5)\n        self.G = np.eye(2) * .5\n        self.H = np.eye(2) * np.sqrt(0.2)\n        self.Q = np.dot(self.C, self.C.T)\n        self.R = np.dot(self.H, self.H.T)\n        ss = LinearStateSpace(self.A, self.C, self.G, self.H)\n        self.kf = Kalman(ss)\n        self.methods = ['doubling', 'qz']\n", "docstring": "Initial Values"}
{"repo": "QuantEcon.py-master/quantecon/tests/test_arma.py", "original_string": "    def setUp(self):\n        # Initial Values\n        phi = np.array([.95, -.4, -.4])\n        theta = np.zeros(3)\n        sigma = .15\n        self.lp = ARMA(phi, theta, sigma)\n", "docstring": "Initial Values"}
{"repo": "QuantEcon.py-master/quantecon/tests/test_robustlq.py", "original_string": "    def setUp(self):\n        # Initial Values\n        a_0     = 100\n        a_1     = 0.5\n        rho     = 0.9\n        sigma_d = 0.05\n        beta    = 0.95\n        c       = 2\n        gamma   = 50.0\n        theta = 0.002\n        ac    = (a_0 - c) / 2.0\n        R = np.array([[0,  ac,    0],\n                      [ac, -a_1, 0.5],\n                      [0., 0.5,  0]])\n        R = -R\n        Q = gamma / 2\n        Q_pf = 0.\n        A = np.array([[1., 0., 0.],\n                      [0., 1., 0.],\n                      [0., 0., rho]])\n        B = np.array([[0.],\n                      [1.],\n                      [0.]])\n        B_pf = np.zeros((3, 1))\n        C = np.array([[0.],\n                      [0.],\n                      [sigma_d]])\n        # the *_pf endings refer to an example with pure forecasting\n        # (see p171 in Robustness)\n        self.rblq_test = RBLQ(Q, R, A, B, C, beta, theta)\n        self.rblq_test_pf = RBLQ(Q_pf, R, A, B_pf, C, beta, theta)\n        self.lq_test = LQ(Q, R, A, B, C, beta=beta)\n        self.methods = ['doubling', 'qz']\n", "docstring": "Initial Values"}
{"repo": "QuantEcon.py-master/quantecon/tests/test_ivp.py", "original_string": "def _compute_fixed_length_solns(model, t0, k0):\n    \"\"\"Returns a dictionary of fixed length solution trajectories.\"\"\"\n    # storage containter for integration results\n    results = {}\n    for integrator in ['dopri5', 'dop853', 'vode', 'lsoda']:\n        # tighten tolerances so tests don't fail due to numerical issues\n        discrete_soln = model.solve(t0, k0, h=1e0, T=1e3,\n                                    integrator=integrator,\n                                    atol=1e-14, rtol=1e-11)\n        # store the result\n        results[integrator] = discrete_soln\n    return results\n", "docstring": "Returns a dictionary of fixed length solution trajectories.\n"}
{"repo": "QuantEcon.py-master/quantecon/tests/test_ivp.py", "original_string": "def _compute_variable_length_solns(model, t0, k0, g, tol):\n    \"\"\"Returns a dictionary of variable length solution trajectories.\"\"\"\n    # storage containter for integration results\n    results = {}\n    for integrator in ['dopri5', 'dop853', 'vode', 'lsoda']:\n        # tighten tolerances so tests don't fail due to numerical issues\n        discrete_soln = model.solve(t0, k0, h=1e0, g=g, tol=tol,\n                                    integrator=integrator,\n                                    atol=1e-14, rtol=1e-11)\n        # store the result\n        results[integrator] = discrete_soln\n    return results\n", "docstring": "Returns a dictionary of variable length solution trajectories.\n"}
{"repo": "QuantEcon.py-master/quantecon/tests/test_ivp.py", "original_string": "def test_solve_args():\n    \"\"\"Testing arguments passed to the IVP.solve method.\"\"\"\n    # g and tol must be passed together!\n    with nose.tools.assert_raises(ValueError):\n        t0, k0 = 0, np.array([5.0])\n        model.solve(t0, k0, g=_termination_condition)\n", "docstring": "Testing arguments passed to the IVP.solve method.\n"}
{"repo": "QuantEcon.py-master/quantecon/tests/test_ivp.py", "original_string": "def test_solve_variable_trajectory():\n    \"\"\"Testing computation of variable length solution trajectory.\"\"\"\n    # compute some variable length trajectories\n    t0, k0, tol = 0, np.array([5.0]), 1e-3\n    results = _compute_variable_length_solns(model, t0, k0,\n                                             g=_termination_condition, tol=tol)\n    # conduct the tests\n    for integrator, numeric_solution in results.items():\n        ti = numeric_solution[:, 0]\n        analytic_solution = solow_analytic_solution(ti, k0, *valid_params)\n        # test accuracy of solution\n        np.testing.assert_allclose(numeric_solution, analytic_solution)\n        # test termination condition\n        diff = numeric_solution[-1, 1] - solow_steady_state(*valid_params)\n        nose.tools.assert_less_equal(diff, tol)\n", "docstring": "Testing computation of variable length solution trajectory.\n"}
{"repo": "QuantEcon.py-master/docs/qe_apidoc.py", "original_string": "def all_auto():\n    # Get list of module names\n    mod_names = glob(\"../quantecon/[a-z0-9]*.py\")\n    mod_names = list(map(lambda x: x.split('/')[-1], mod_names))\n    # Ensure source/modules directory exists\n    if not os.path.exists(source_join(\"modules\")):\n        os.makedirs(source_join(\"modules\"))\n    # Write file for each module\n    for mod in mod_names:\n        name = mod.split(\".\")[0]  # drop .py ending\n        new_path = os.path.join(\"source\", \"modules\", name + \".rst\")\n        with open(new_path, \"w\") as f:\n            gen_module(name, f)\n    # write index.rst file to include these autogenerated files\n    with open(source_join(\"index.rst\"), \"w\") as index:\n        generated = \"\\n   \".join(list(map(lambda x: \"modules/\" + x.split(\".\")[0],\n                                     mod_names)))\n        temp = all_index_template.format(generated=generated)\n        index.write(temp)\n", "docstring": "Get list of module names"}
{"repo": "cookiecutter-aws-sam-python-master/{{ cookiecutter.project_name }}/hello_world/app.py", "original_string": "def hello_you(name):\n    # query_strings_as_dict = app.current_event.query_string_parameters\n    # json_payload = app.current_event.json_body\n    return {\"message\": f\"hello {name}\"}\n", "docstring": "query_strings_as_dict = app.current_event.query_string_parameters"}
{"repo": "cricket-master/cricket/dialogs.py", "original_string": "    def __init__(self, parent, title, label, trace, critical=False):\n        '''Show a dialog with a scrollable stack trace.\n        Arguments:\n            parent -- a parent window (the application window)\n            title -- the title for the stack trace window\n            label -- the label describing the stack trace\n            trace -- the stack trace content to display.\n            critical -- indicates if the stack trace dialog will be critical\n        '''\n        self.parent = parent\n        self.status = None\n        self.button_result = self.parent.main_window.stack_trace_dialog(\n            title, label, trace, retry=critical\n        )\n        if self.button_result:\n            self.status = self.OK\n        elif critical:\n            self.status = self.CANCEL\n", "docstring": "Show a dialog with a scrollable stack trace."}
{"repo": "cricket-master/cricket/dialogs.py", "original_string": "    def __init__(self, parent, trace):\n        '''Report an error when running a test suite.\n        Arguments:\n            parent -- a parent window (the application window)\n            trace -- the stack trace content to display.\n        '''\n        StackTraceDialog.__init__(\n            self,\n            parent,\n            'Error running test suite',\n            'The following stack trace was generated when attempting to run the test suite:',\n            trace,\n        )\n", "docstring": "Report an error when running a test suite."}
{"repo": "cricket-master/cricket/dialogs.py", "original_string": "    def __init__(self, parent, trace):\n        '''Show a dialog with a scrollable list of errors.\n        Arguments:\n            parent -- a parent window (the application window)\n            error -- the error content to display.\n        '''\n        StackTraceDialog.__init__(\n            self,\n            parent,\n            'Errors during test suite',\n            ('The following errors were generated while running the test suite:'),\n            trace,\n        )\n", "docstring": "Show a dialog with a scrollable list of errors."}
{"repo": "cricket-master/cricket/dialogs.py", "original_string": "    def __init__(self, parent, trace):\n        '''Show a dialog with a scrollable stack trace.\n        Arguments:\n            parent -- a parent window (the application window)\n            trace -- the stack trace content to display.\n        '''\n        StackTraceDialog.__init__(\n            self,\n            parent,\n            'Error discovering test suite',\n            ('The following stack trace was generated when attempting to '\n             'discover the test suite:'),\n            trace,\n            True,\n        )\n", "docstring": "Show a dialog with a scrollable stack trace."}
{"repo": "cricket-master/cricket/model.py", "original_string": "    def __setitem__(self, label, child):\n        # Insert the item, sort the list,\n        # and find out where the item was inserted.\n        self._child_labels.append(label)\n        self._child_labels.sort()\n        index = self._child_labels.index(label)\n        self._child_nodes[label] = child\n        self._source._notify('insert', parent=self, index=index, item=child)\n", "docstring": "Insert the item, sort the list,"}
{"repo": "cricket-master/cricket/model.py", "original_string": "    def set_active(self, is_active, cascade=True):\n        \"\"\"Explicitly set the active state of the test method\n        If cascade is True, the parent testCase will be prompted\n        to check it's current active status.\n        \"\"\"\n        if self._active:\n            if not is_active:\n                self._active = False\n                if cascade:\n                    self.parent._update_active()\n        else:\n            if is_active:\n                self._active = True\n                if cascade:\n                    self.parent._update_active()\n", "docstring": "Explicitly set the active state of the test method"}
{"repo": "cricket-master/cricket/model.py", "original_string": "    def refresh(self, test_list=None, errors=None):\n        \"\"\"Rediscover the tests in the test suite.\n        \"\"\"\n        if test_list is None:\n            runner = subprocess.Popen(\n                self.discover_commandline(),\n                stdin=None,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                shell=False,\n            )\n            test_list = []\n            for line in runner.stdout:\n                test_list.append(line.strip().decode('utf-8'))\n            errors = []\n            for line in runner.stderr:\n                errors.append(line.strip().decode('utf-8'))\n            if errors and not test_list:\n                raise ModelLoadError('\\n'.join(errors))\n        timestamp = datetime.now()\n        # Make sure there is a data representation for every test in the list.\n        for test_id in test_list:\n            self.put_test(test_id)\n        self.errors = errors if errors is not None else []\n", "docstring": "Rediscover the tests in the test suite."}
{"repo": "cricket-master/cricket/executor.py", "original_string": "def enqueue_output(out, queue):\n    \"\"\"A utility method for consuming piped output from a subprocess.\n    Reads content from `out` one line at a time, and puts it onto\n    queue for consumption in a separate thread.\n    \"\"\"\n    for line in iter(out.readline, b''):\n        queue.put(line.strip().decode('utf-8'))\n    out.close()\n", "docstring": "A utility method for consuming piped output from a subprocess."}
{"repo": "cricket-master/cricket/view.py", "original_string": "    def test_load_error(self):\n        return self._test_load_error\n", "docstring": "return self._test_load_error"}
{"repo": "cricket-master/cricket/view.py", "original_string": "    def _setup_commands(self):\n        # Custom command groups\n        self.control_tests_group = toga.Group('Test')\n        self.instruments_group = toga.Group('Instruments')\n        self.show_coverage_command = toga.Command(\n            self.cmd_show_coverage,\n            'Show coverage...',\n            group=self.instruments_group\n        )\n        self.show_coverage_command.enabled = False if duvet is None else True\n        # Button to stop run the tests\n        self.stop_command = toga.Command(\n            self.cmd_stop, 'Stop',\n            tooltip='Stop running the tests.',\n            icon=toga.Icon('resources/stop.png'),\n            shortcut='s',\n            group=self.control_tests_group\n        )\n        self.stop_command.enabled = False\n        # Button to run all the tests\n        self.run_all_command = toga.Command(\n            self.cmd_run_all, 'Run all',\n            tooltip='Run all the tests.',\n            icon=toga.Icon('resources/play.png'),\n            shortcut='r',\n            group=self.control_tests_group\n        )\n        # Button to run only the tests selected by the user\n        self.run_selected_command = toga.Command(\n            self.cmd_run_selected, 'Run selected',\n            tooltip='Run the tests selected.',\n            icon=toga.Icon('resources/run_select.png'),\n            shortcut='e',\n            group=self.control_tests_group\n        )\n        self.run_selected_command.enabled = False\n        # Re-run all the tests\n        self.rerun_command = toga.Command(\n            self.cmd_rerun, 'Re-run',\n            tooltip='Re-run the tests.',\n            icon=toga.Icon('resources/re_run.png'),\n            shortcut='a',\n            group=self.control_tests_group\n        )\n        self.rerun_command.enabled = False\n        # Cricket's menu items\n        self.commands.add(\n            # Instrument items\n            self.show_coverage_command,\n        )\n        self.main_window.toolbar.add(\n            self.stop_command,\n            self.run_all_command,\n            self.run_selected_command,\n            self.rerun_command\n        )\n", "docstring": "Custom command groups"}
{"repo": "cricket-master/cricket/view.py", "original_string": "    def _setup_status_bar(self):\n        '''The bottom frame to inform the user about the status of the tests\n        that are running.\n        '''\n        self.run_status = toga.Label('Not running', style=Pack(padding_left=10))\n        self.run_summary = toga.Label(\n            'T:0 P:0 F:0 E:0 X:0 U:0 S:0',\n            style=Pack(flex=1, text_align=RIGHT)\n        )\n        # Test progress\n        self.progress = toga.ProgressBar(\n            max=100, value=0, style=Pack(padding_left=10, padding_right=10, width=200)\n        )\n        self.statusbar = toga.Box(\n            style=Pack(direction=ROW)\n        )\n        self.statusbar.add(self.run_status)\n        self.statusbar.add(self.run_summary)\n        self.statusbar.add(self.progress)\n", "docstring": "The bottom frame to inform the user about the status of the tests"}
{"repo": "cricket-master/cricket/view.py", "original_string": "    def test_suite(self):\n        return self._test_suite\n", "docstring": "return self._test_suite"}
{"repo": "cricket-master/cricket/pipes.py", "original_string": "def trim_docstring(docstring):\n    \"\"\"Trim leading spaces in docstring indentation.\n    Algorithm taken from PEP 257:\n        http://www.python.org/dev/peps/pep-0257/#id20\n    \"\"\"\n    # Convert tabs to spaces (following the normal Python rules)\n    # and split into a list of lines:\n    lines = docstring.expandtabs().splitlines()\n    # Determine minimum indentation (first line doesn't count):\n    indent = sys.maxsize\n    for line in lines[1:]:\n        stripped = line.lstrip()\n        if stripped:\n            indent = min(indent, len(line) - len(stripped))\n    # Remove indentation (first line is special):\n    trimmed = [lines[0].strip()]\n    if indent < sys.maxsize:\n        for line in lines[1:]:\n            trimmed.append(line[indent:].rstrip())\n    # Strip off trailing and leading blank lines:\n    while trimmed and not trimmed[-1]:\n        trimmed.pop()\n    while trimmed and not trimmed[0]:\n        trimmed.pop(0)\n    # Return a single string:\n    return '\\n'.join(trimmed)\n", "docstring": "Trim leading spaces in docstring indentation."}
{"repo": "cricket-master/cricket/pipes.py", "original_string": "    def addError(self, test, err):\n        # If there's no current test, the error occurred during test\n        # setup. Output a test start line so the protocol isn't confused.\n        if self._current_test is None:\n            self.startTest(test)\n        super(PipedTestResult, self).addError(test, err)\n        body = {\n            'status': 'E',\n            'end_time': time.time(),\n            'description': self.description(test),\n            'error': '\\n'.join(traceback.format_exception(*err)),\n            'output': self._stdout.getvalue(),\n        }\n        self.stream.write('%s\\n' % json.dumps(body))\n        self.stream.flush()\n        self._current_test = None\n", "docstring": "If there's no current test, the error occurred during test"}
{"repo": "cricket-master/cricket/django/model.py", "original_string": "    def add_arguments(cls, parser):\n        \"\"\"Add Django-specific settings to the argument parser.\n        \"\"\"\n        settings_help = (\"The Python path to a settings module, e.g. \"\n                         \"\\\"myproject.settings.main\\\". If this isn't provided, the \"\n                         \"DJANGO_SETTINGS_MODULE environment variable will be \"\n                         \"used.\")\n        parser.add_argument('--settings', help=settings_help)\n", "docstring": "Add Django-specific settings to the argument parser."}
{"repo": "cricket-master/cricket/unittest/executor.py", "original_string": "def unroll_test_suite(suite):\n    \"\"\"Convert a (possibly heirarchical) test suite into a flat set of tests.\n    This is used to ensure that the suite only executes any\n    individual test once.\n    \"\"\"\n    flat = set()\n    for test in suite:\n        if isinstance(test, unittest.TestSuite):\n            flat.update(unroll_test_suite(test))\n        else:\n            flat.add(test)\n    return flat\n", "docstring": "Convert a (possibly heirarchical) test suite into a flat set of tests."}
{"repo": "cricket-master/cricket/unittest/executor.py", "original_string": "    def __init__(self):\n        # Allows the executor to run a specified list of tests\n        self.specified_list = None\n", "docstring": "Allows the executor to run a specified list of tests"}
{"repo": "uniswap-python-master/uniswap/uniswap.py", "original_string": "    def _get_eth_token_input_price(self, token: AddressLike, qty: Wei, fee: int) -> Wei:\n        \"\"\"Public price for ETH to Token trades with an exact input.\"\"\"\n        if self.version == 1:\n            ex = self._exchange_contract(token)\n            price: Wei = ex.functions.getEthToTokenInputPrice(qty).call()\n        elif self.version == 2:\n            price = self.router.functions.getAmountsOut(\n                qty, [self.get_weth_address(), token]\n            ).call()[-1]\n        elif self.version == 3:\n            price = self._get_token_token_input_price(\n                self.get_weth_address(), token, qty, fee=fee\n            )  # type: ignore\n        return price\n", "docstring": "Public price for ETH to Token trades with an exact input.\n"}
{"repo": "uniswap-python-master/uniswap/uniswap.py", "original_string": "    def get_eth_balance(self) -> Wei:\n        \"\"\"Get the balance of ETH for your address.\"\"\"\n        return self.w3.eth.get_balance(self.address)\n", "docstring": "Get the balance of ETH for your address.\n"}
{"repo": "uniswap-python-master/uniswap/uniswap.py", "original_string": "    def get_ex_eth_balance(self, token: AddressLike) -> int:\n        \"\"\"Get the balance of ETH in an exchange contract.\"\"\"\n        ex_addr: AddressLike = self._exchange_address_from_token(token)\n        return self.w3.eth.get_balance(ex_addr)\n", "docstring": "Get the balance of ETH in an exchange contract.\n"}
{"repo": "uniswap-python-master/uniswap/uniswap.py", "original_string": "    def get_ex_token_balance(self, token: AddressLike) -> int:\n        \"\"\"Get the balance of a token in an exchange contract.\"\"\"\n        erc20 = _load_contract_erc20(self.w3, token)\n        balance: int = erc20.functions.balanceOf(\n            self._exchange_address_from_token(token)\n        ).call()\n        return balance\n", "docstring": "Get the balance of a token in an exchange contract.\n"}
{"repo": "uniswap-python-master/uniswap/uniswap.py", "original_string": "    def get_exchange_rate(self, token: AddressLike) -> float:\n        \"\"\"Get the current ETH/token exchange rate of the token.\"\"\"\n        eth_reserve = self.get_ex_eth_balance(token)\n        token_reserve = self.get_ex_token_balance(token)\n        return float(token_reserve / eth_reserve)\n", "docstring": "Get the current ETH/token exchange rate of the token.\n"}
{"repo": "uniswap-python-master/uniswap/uniswap.py", "original_string": "    def remove_liquidity(self, token: str, max_token: int) -> HexBytes:\n        \"\"\"Remove liquidity from the pool.\"\"\"\n        func_params = [int(max_token), 1, 1, self._deadline()]\n        function = self._exchange_contract(token).functions.removeLiquidity(\n            *func_params\n        )\n        return self._build_and_send_tx(function)\n", "docstring": "Remove liquidity from the pool.\n"}
{"repo": "uniswap-python-master/uniswap/uniswap.py", "original_string": "    def approve(self, token: AddressLike, max_approval: Optional[int] = None) -> None:\n        \"\"\"Give an exchange/router max approval of a token.\"\"\"\n        max_approval = self.max_approval_int if not max_approval else max_approval\n        contract_addr = (\n            self._exchange_address_from_token(token)\n            if self.version == 1\n            else self.router_address\n        )\n        function = _load_contract_erc20(self.w3, token).functions.approve(\n            contract_addr, max_approval\n        )\n        logger.warning(f\"Approving {_addr_to_str(token)}...\")\n        tx = self._build_and_send_tx(function)\n        self.w3.eth.waitForTransactionReceipt(tx, timeout=6000)\n        # Add extra sleep to let tx propogate correctly\n        time.sleep(1)\n", "docstring": "Give an exchange/router max approval of a token.\n"}
{"repo": "uniswap-python-master/uniswap/uniswap.py", "original_string": "    def _deadline(self) -> int:\n        \"\"\"Get a predefined deadline. 10min by default (same as the Uniswap SDK).\"\"\"\n        return int(time.time()) + 10 * 60\n", "docstring": "Get a predefined deadline. 10min by default (same as the Uniswap SDK).\n"}
{"repo": "uniswap-python-master/uniswap/uniswap.py", "original_string": "    def _get_tx_params(self, value: Wei = Wei(0), gas: Wei = Wei(250000)) -> TxParams:\n        \"\"\"Get generic transaction parameters.\"\"\"\n        return {\n            \"from\": _addr_to_str(self.address),\n            \"value\": value,\n            \"gas\": gas,\n            \"nonce\": max(\n                self.last_nonce, self.w3.eth.getTransactionCount(self.address)\n            ),\n        }\n", "docstring": "Get generic transaction parameters.\n"}
{"repo": "uniswap-python-master/uniswap/uniswap.py", "original_string": "    def get_weth_address(self) -> ChecksumAddress:\n        \"\"\"Retrieves the WETH address from the contracts (which may vary between chains).\"\"\"\n        if self.version == 2:\n            # Contract calls should always return checksummed addresses\n            address: ChecksumAddress = self.router.functions.WETH().call()\n        elif self.version == 3:\n            address = self.router.functions.WETH9().call()\n        return address\n", "docstring": "Retrieves the WETH address from the contracts (which may vary between chains).\n"}
{"repo": "uniswap-python-master/uniswap/uniswap.py", "original_string": "    def get_fee_maker(self) -> float:\n        \"\"\"Get the maker fee.\"\"\"\n        return 0\n", "docstring": "Get the maker fee.\n"}
{"repo": "uniswap-python-master/uniswap/uniswap.py", "original_string": "    def get_fee_taker(self) -> float:\n        \"\"\"Get the taker fee.\"\"\"\n        return 0.003\n", "docstring": "Get the taker fee.\n"}
{"repo": "uniswap-python-master/uniswap/uniswap.py", "original_string": "    def _exchange_address_from_token(self, token_addr: AddressLike) -> AddressLike:\n        ex_addr: AddressLike = self.factory_contract.functions.getExchange(\n            token_addr\n        ).call()\n        # TODO: What happens if the token doesn't have an exchange/doesn't exist?\n        #       Should probably raise an Exception (and test it)\n        return ex_addr\n", "docstring": "ex_addr: AddressLike = self.factory_contract.functions.getExchange("}
{"repo": "uniswap-python-master/uniswap/cli.py", "original_string": "def token(ctx: click.Context, token: AddressLike) -> None:\n    \"\"\"Show metadata for token\"\"\"\n    uni: Uniswap = ctx.obj[\"UNISWAP\"]\n    t1 = uni.get_token(token)\n    print(t1)\n", "docstring": "Show metadata for token\n"}
{"repo": "uniswap-python-master/uniswap/decorators.py", "original_string": "def check_approval(method: Callable) -> Callable:\n    \"\"\"Decorator to check if user is approved for a token. It approves them if they\n    need to be approved.\"\"\"\n    @functools.wraps(method)\n    def approved(self: Any, *args: Any, **kwargs: Any) -> Any:\n        # Check to see if the first token is actually ETH\n        token = args[0] if args[0] != ETH_ADDRESS else None\n        token_two = None\n        # Check second token, if needed\n        if method.__name__ == \"make_trade\" or method.__name__ == \"make_trade_output\":\n            token_two = args[1] if args[1] != ETH_ADDRESS else None\n        # Approve both tokens, if needed\n        if token:\n            is_approved = self._is_approved(token)\n            # logger.warning(f\"Approved? {token}: {is_approved}\")\n            if not is_approved:\n                self.approve(token)\n        return method(self, *args, **kwargs)\n    return approved\n", "docstring": "Decorator to check if user is approved for a token. It approves them if they"}
{"repo": "uniswap-python-master/uniswap/util.py", "original_string": "def _str_to_addr(s: Union[AddressLike, str]) -> Address:\n    \"\"\"Idempotent\"\"\"\n    if isinstance(s, str):\n        if s.startswith(\"0x\"):\n            return Address(bytes.fromhex(s[2:]))\n        else:\n            raise Exception(f\"Couldn't convert string '{s}' to AddressLike\")\n    else:\n        return s\n", "docstring": "Idempotent\n"}
{"repo": "uniswap-python-master/tests/test_uniswap.py", "original_string": "def web3(ganache: GanacheInstance):\n    w3 = Web3(Web3.HTTPProvider(ganache.provider, request_kwargs={\"timeout\": 60}))\n    if 1 != int(w3.net.version):\n        raise Exception(\"PROVIDER was not a mainnet provider, which the tests require\")\n    return w3\n", "docstring": "w3 = Web3(Web3.HTTPProvider(ganache.provider, request_kwargs={\"timeout\": 60}))"}
{"repo": "uniswap-python-master/tests/test_uniswap.py", "original_string": "def ganache() -> Generator[GanacheInstance, None, None]:\n    \"\"\"Fixture that runs ganache-cli which has forked off mainnet\"\"\"\n    if not shutil.which(\"ganache-cli\"):\n        raise Exception(\n            \"ganache-cli was not found in PATH, you can install it with `npm install -g ganache-cli`\"\n        )\n    if \"PROVIDER\" not in os.environ:\n        raise Exception(\n            \"PROVIDER was not set, you need to set it to a mainnet provider (such as Infura) so that we can fork off our testnet\"\n        )\n    port = 10999\n    p = subprocess.Popen(\n        f\"ganache-cli --port {port} -s test --networkId 1 --fork {os.environ['PROVIDER']}\",\n        shell=True,\n    )\n    # Address #1 when ganache is run with `-s test`, it starts with 100 ETH\n    eth_address = \"0x94e3361495bD110114ac0b6e35Ed75E77E6a6cFA\"\n    eth_privkey = \"0x6f1313062db38875fb01ee52682cbf6a8420e92bfbc578c5d4fdc0a32c50266f\"\n    sleep(3)\n    yield GanacheInstance(f\"http://127.0.0.1:{port}\", eth_address, eth_privkey)\n    p.kill()\n    p.wait()\n", "docstring": "Fixture that runs ganache-cli which has forked off mainnet\n"}
{"repo": "uniswap-python-master/tests/test_cli.py", "original_string": "def test_get_price_stables():\n    \"\"\"Tests that decimals are handled correctly.\"\"\"\n    if os.getenv(\"UNISWAP_VERSION\") == \"1\":\n        pytest.skip(\"Not supported in v1\")\n    runner = CliRunner(mix_stderr=False)\n    result = runner.invoke(main, [\"price\", \"dai\", \"usdc\"])\n    print_result(result)\n    assert result.exit_code == 0\n    # Will break if peg is lost\n    assert 0.9 < float(result.stdout) < 1.1\n", "docstring": "Tests that decimals are handled correctly.\n"}
{"repo": "autojump-master/install.py", "original_string": "def modify_autojump_lua(clink_dir, bin_dir, dryrun=False):\n    \"\"\"Prepend custom AUTOJUMP_BIN_DIR definition to autojump.lua\"\"\"\n    custom_install = \"local AUTOJUMP_BIN_DIR = \\\"%s\\\"\\n\" % bin_dir.replace(\n        '\\\\',\n        '\\\\\\\\',\n    )\n    clink_file = os.path.join(clink_dir, 'autojump.lua')\n    with open(clink_file, 'r') as f:\n        original = f.read()\n    with open(clink_file, 'w') as f:\n        f.write(custom_install + original)\n", "docstring": "Prepend custom AUTOJUMP_BIN_DIR definition to autojump.lua\n"}
{"repo": "autojump-master/uninstall.py", "original_string": "def remove_custom_installation(args, dryrun=False):\n    if not args.destdir:\n        return\n    bin_dir = os.path.join(args.destdir, args.prefix, 'bin')\n    doc_dir = os.path.join(args.destdir, args.prefix, 'share', 'man', 'man1')\n    etc_dir = os.path.join(args.destdir, 'etc', 'profile.d')\n    share_dir = os.path.join(args.destdir, args.prefix, 'share', 'autojump')\n    zshshare_dir = os.path.join(args.destdir, args.zshshare)\n    if not os.path.exists(share_dir):\n        return\n    print('\\nFound custom installation...')\n    rm(os.path.join(bin_dir, 'autojump'), dryrun)\n    rm(os.path.join(bin_dir, 'autojump_data.py'), dryrun)\n    rm(os.path.join(bin_dir, 'autojump_utils.py'), dryrun)\n    rm(os.path.join(bin_dir, 'autojump_argparse.py'), dryrun)\n    if platform.system() == 'Windows':\n        if os.path.exists(args.clinkdir):\n            rm(os.path.join(args.clinkdir, 'autojump.lua'), dryrun)\n        rm(os.path.join(bin_dir, 'autojump.bat'), dryrun)\n        rm(os.path.join(bin_dir, 'j.bat'), dryrun)\n        rm(os.path.join(bin_dir, 'jc.bat'), dryrun)\n        rm(os.path.join(bin_dir, 'jco.bat'), dryrun)\n        rm(os.path.join(bin_dir, 'jo.bat'), dryrun)\n    else:\n        rm(os.path.join(etc_dir, 'autojump.sh'), dryrun)\n        rm(os.path.join(share_dir, 'autojump.bash'), dryrun)\n        rm(os.path.join(share_dir, 'autojump.fish'), dryrun)\n        rm(os.path.join(share_dir, 'autojump.tcsh'), dryrun)\n        rm(os.path.join(share_dir, 'autojump.zsh'), dryrun)\n        rm(os.path.join(zshshare_dir, '_j'), dryrun)\n    rmdir(share_dir, dryrun)\n    rm(os.path.join(doc_dir, 'autojump.1'), dryrun)\n    if is_empty_dir(args.destdir):\n        rmdir(args.destdir, dryrun)\n", "docstring": "if not args.destdir:"}
{"repo": "autojump-master/bin/autojump_data.py", "original_string": "def load(config):\n    \"\"\"Returns a dictonary (key=path, value=weight) loaded from data file.\"\"\"\n    xdg_aj_home = os.path.join(\n        os.path.expanduser('~'),\n        '.local',\n        'share',\n        'autojump',\n    )\n    if is_osx() and os.path.exists(xdg_aj_home):\n        migrate_osx_xdg_data(config)\n    if not os.path.exists(config['data_path']):\n        return {}\n    # example: u'10.0\\t/home/user\\n' -> ['10.0', u'/home/user']\n    parse = lambda line: line.strip().split('\\t')\n    correct_length = lambda x: len(x) == 2\n    # example: ['10.0', u'/home/user'] -> (u'/home/user', 10.0)\n    tupleize = lambda x: (x[1], float(x[0]))\n    try:\n        with open(\n                config['data_path'],\n                'r', encoding='utf-8',\n                errors='replace',\n        ) as f:\n            return dict(\n                imap(\n                    tupleize,\n                    ifilter(correct_length, imap(parse, f)),\n                ),\n            )\n    except (IOError, EOFError):\n        return load_backup(config)\n", "docstring": "Returns a dictonary (key=path, value=weight) loaded from data file.\n"}
{"repo": "autojump-master/bin/autojump_utils.py", "original_string": "def create_dir(path):\n    \"\"\"Creates a directory atomically.\"\"\"\n    try:\n        os.makedirs(path)\n    except OSError as exception:\n        if exception.errno != errno.EEXIST:\n            raise\n", "docstring": "Creates a directory atomically.\n"}
{"repo": "autojump-master/bin/autojump_utils.py", "original_string": "def print_local(string):\n    print(encode_local(string))\n", "docstring": "print(encode_local(string))"}
{"repo": "autojump-master/bin/autojump_utils.py", "original_string": "def sanitize(directories):\n    # edge case to allow '/' as a valid path\n    clean = lambda x: unico(x) if x == os.sep else unico(x).rstrip(os.sep)\n    return list(imap(clean, directories))\n", "docstring": "edge case to allow '/' as a valid path"}
{"repo": "autojump-master/bin/autojump_argparse.py", "original_string": "    def add_parser(self, name, **kwargs):\n        # set prog from the existing prefix\n        if kwargs.get('prog') is None:\n            kwargs['prog'] = '%s %s' % (self._prog_prefix, name)\n        # create a pseudo-action to hold the choice help\n        if 'help' in kwargs:\n            help = kwargs.pop('help')\n            choice_action = self._ChoicesPseudoAction(name, help)\n            self._choices_actions.append(choice_action)\n        # create the parser and add it to the map\n        parser = self._parser_class(**kwargs)\n        self._name_parser_map[name] = parser\n        return parser\n", "docstring": "set prog from the existing prefix"}
{"repo": "autojump-master/bin/autojump_argparse.py", "original_string": "    def add_mutually_exclusive_group(self, **kwargs):\n        group = _MutuallyExclusiveGroup(self, **kwargs)\n        self._mutually_exclusive_groups.append(group)\n        return group\n", "docstring": "group = _MutuallyExclusiveGroup(self, **kwargs)"}
{"repo": "autojump-master/bin/autojump_argparse.py", "original_string": "    def _get_positional_kwargs(self, dest, **kwargs):\n        # make sure required is not specified\n        if 'required' in kwargs:\n            msg = _(\"'required' is an invalid argument for positionals\")\n            raise TypeError(msg)\n        # mark positional arguments as required if at least one is\n        # always required\n        if kwargs.get('nargs') not in [OPTIONAL, ZERO_OR_MORE]:\n            kwargs['required'] = True\n        if kwargs.get('nargs') == ZERO_OR_MORE and 'default' not in kwargs:\n            kwargs['required'] = True\n        # return the keyword arguments with no option strings\n        return dict(kwargs, dest=dest, option_strings=[])\n", "docstring": "make sure required is not specified"}
{"repo": "autojump-master/bin/autojump_argparse.py", "original_string": "    def _check_conflict(self, action):\n        # find all options that conflict with this option\n        confl_optionals = []\n        for option_string in action.option_strings:\n            if option_string in self._option_string_actions:\n                confl_optional = self._option_string_actions[option_string]\n                confl_optionals.append((option_string, confl_optional))\n        # resolve any conflicts\n        if confl_optionals:\n            conflict_handler = self._get_handler()\n            conflict_handler(action, confl_optionals)\n", "docstring": "find all options that conflict with this option"}
{"repo": "autojump-master/bin/autojump_argparse.py", "original_string": "    def _handle_conflict_resolve(self, action, conflicting_actions):\n        # remove all conflicting options\n        for option_string, action in conflicting_actions:\n            # remove the conflicting option\n            action.option_strings.remove(option_string)\n            self._option_string_actions.pop(option_string, None)\n            # if the option now has no option string, remove it from the\n            # container holding it\n            if not action.option_strings:\n                action.container._remove_action(action)\n", "docstring": "remove all conflicting options"}
{"repo": "autojump-master/bin/autojump_argparse.py", "original_string": "    def __init__(self, container, title=None, description=None, **kwargs):\n        # add any missing keyword arguments by checking the container\n        update = kwargs.setdefault\n        update('conflict_handler', container.conflict_handler)\n        update('prefix_chars', container.prefix_chars)\n        update('argument_default', container.argument_default)\n        super_init = super(_ArgumentGroup, self).__init__\n        super_init(description=description, **kwargs)\n        # group attributes\n        self.title = title\n        self._group_actions = []\n        # share most attributes with the container\n        self._registries = container._registries\n        self._actions = container._actions\n        self._option_string_actions = container._option_string_actions\n        self._defaults = container._defaults\n        self._has_negative_number_optionals = \\\n            container._has_negative_number_optionals\n", "docstring": "add any missing keyword arguments by checking the container"}
{"repo": "autojump-master/bin/autojump_argparse.py", "original_string": "    def _match_arguments_partial(self, actions, arg_strings_pattern):\n        # progressively shorten the actions list by slicing off the\n        # final actions until we find a match\n        result = []\n        for i in range(len(actions), 0, -1):\n            actions_slice = actions[:i]\n            pattern = ''.join([\n                self._get_nargs_pattern(action)\n                for action in actions_slice\n            ])\n            match = _re.match(pattern, arg_strings_pattern)\n            if match is not None:\n                result.extend([len(string) for string in match.groups()])\n                break\n        # return the list of arg string counts\n        return result\n", "docstring": "progressively shorten the actions list by slicing off the"}
{"repo": "autojump-master/bin/autojump_argparse.py", "original_string": "    def _get_values(self, action, arg_strings):\n        # for everything but PARSER args, strip out '--'\n        if action.nargs not in [PARSER, REMAINDER]:\n            arg_strings = [s for s in arg_strings if s != '--']\n        # optional argument produces a default when not present\n        if not arg_strings and action.nargs == OPTIONAL:\n            if action.option_strings:\n                value = action.const\n            else:\n                value = action.default\n            if isinstance(value, basestring):\n                value = self._get_value(action, value)\n                self._check_value(action, value)\n        # when nargs='*' on a positional, if there were no command-line\n        # args, use the default if it is anything other than None\n        elif (\n            not arg_strings and action.nargs == ZERO_OR_MORE and\n            not action.option_strings\n        ):\n            if action.default is not None:\n                value = action.default\n            else:\n                value = arg_strings\n            self._check_value(action, value)\n        # single argument or optional argument produces a single value\n        elif len(arg_strings) == 1 and action.nargs in [None, OPTIONAL]:\n            arg_string, = arg_strings\n            value = self._get_value(action, arg_string)\n            self._check_value(action, value)\n        # REMAINDER arguments convert all values, checking none\n        elif action.nargs == REMAINDER:\n            value = [self._get_value(action, v) for v in arg_strings]\n        # PARSER arguments convert all values, but check only the first\n        elif action.nargs == PARSER:\n            value = [self._get_value(action, v) for v in arg_strings]\n            self._check_value(action, value[0])\n        # all other types of nargs produce a list\n        else:\n            value = [self._get_value(action, v) for v in arg_strings]\n            for v in value:\n                self._check_value(action, v)\n        # return the converted value\n        return value\n", "docstring": "for everything but PARSER args, strip out '--'"}
{"repo": "autojump-master/bin/autojump_argparse.py", "original_string": "    def _check_value(self, action, value):\n        # converted value must be one of the choices (if specified)\n        if action.choices is not None and value not in action.choices:\n            tup = value, ', '.join(map(repr, action.choices))\n            msg = _('invalid choice: %r (choose from %s)') % tup\n            raise ArgumentError(action, msg)\n", "docstring": "converted value must be one of the choices (if specified)"}
{"repo": "POMDPy-master/pomdpy/agent.py", "original_string": "    def multi_epoch_tf(self):\n        import tensorflow as tf\n        tf.set_random_seed(int(self.model.seed) + 1)\n        with tf.Session() as sess:\n            solver = self.solver_factory(self, sess)\n            for epoch in range(self.model.n_epochs + 1):\n                self.model.reset_for_epoch()\n                if epoch % self.model.test == 0:\n                    epoch_start = time.time()\n                    print('evaluating agent at epoch {}...'.format(epoch))\n                    # evaluate agent\n                    reward = 0.\n                    discounted_reward = 0.\n                    discount = 1.0\n                    belief = self.model.get_initial_belief_state()\n                    step = 0\n                    while step < self.model.max_steps:\n                        action, v_b = solver.greedy_predict(belief)\n                        step_result = self.model.generate_step(action)\n                        if not step_result.is_terminal:\n                            belief = self.model.belief_update(belief, action, step_result.observation)\n                        reward += step_result.reward\n                        discounted_reward += discount * step_result.reward\n                        discount *= self.model.discount\n                        # show the step result\n                        self.display_step_result(epoch, step_result)\n                        step += 1\n                        if step_result.is_terminal:\n                            break\n                    self.experiment_results.time.add(time.time() - epoch_start)\n                    self.experiment_results.undiscounted_return.count += 1\n                    self.experiment_results.undiscounted_return.add(reward)\n                    self.experiment_results.discounted_return.count += 1\n                    self.experiment_results.discounted_return.add(discounted_reward)\n                    summary = sess.run([solver.experiment_summary], feed_dict={\n                        solver.avg_undiscounted_return: self.experiment_results.undiscounted_return.mean,\n                        solver.avg_undiscounted_return_std_dev: self.experiment_results.undiscounted_return.std_dev(),\n                        solver.avg_discounted_return: self.experiment_results.discounted_return.mean,\n                        solver.avg_discounted_return_std_dev: self.experiment_results.discounted_return.std_dev()\n                    })\n                    for summary_str in summary:\n                        solver.summary_ops['writer'].add_summary(summary_str, epoch)\n                    # TODO: save model at checkpoints\n                else:\n                    # train for 1 epoch\n                    solver.train(epoch)\n            if self.model.save:\n                solver.save_alpha_vectors()\n                print('saved alpha vectors!')\n", "docstring": "import tensorflow as tf"}
{"repo": "POMDPy-master/pomdpy/agent.py", "original_string": "    def __init__(self):\n        self.time = Statistic('Time')\n        self.discounted_return = Statistic('discounted return')\n        self.undiscounted_return = Statistic('undiscounted return')\n", "docstring": "self.time = Statistic('Time')"}
{"repo": "POMDPy-master/pomdpy/discrete_pomdp/discrete_action_pool.py", "original_string": "    def sample_an_action(self, bin_number):\n        return self.all_actions[bin_number]\n", "docstring": "return self.all_actions[bin_number]"}
{"repo": "POMDPy-master/pomdpy/solvers/value_iteration.py", "original_string": "    def reset(agent):\n        return ValueIteration(agent)\n", "docstring": "return ValueIteration(agent)"}
{"repo": "POMDPy-master/pomdpy/solvers/base_tf_solver.py", "original_string": "    def load_model(self):\n        print(\" [*] Loading checkpoints...\")\n        ckpt = tf.train.get_checkpoint_state(self.model.ckpt_dir)\n        if ckpt and ckpt.model_checkpoint_path:\n            ckpt_name = os.path.basename(ckpt.model_checkpoint_path)\n            fname = os.path.join(self.model.ckpt_dir, ckpt_name)\n            self.saver.restore(self.sess, fname)\n            print(\" [*] Load SUCCESS: {}\".format(fname))\n            return True\n        else:\n            print(\" [!] Load FAILED: {}\".format(self.model.ckpt_dir))\n            return False\n", "docstring": "print(\" [*] Loading checkpoints...\")"}
{"repo": "POMDPy-master/pomdpy/solvers/linear_alpha_net.py", "original_string": "    def e_greedy_predict(self, belief, epsilon_step):\n        # try hard-coding input of linear net to be rewards (can try random as well)\n        action, v_b, epsilon = self.sess.run([self.ops['a'], self.ops['v_b'], self.ops['epsilon_op']],\n            feed_dict={\n                self.ops['l0_in']: np.reshape(self.model.get_reward_matrix().flatten(), [1, 6]),\n                self.ops['belief']: belief,\n                self.ops['epsilon_step']: epsilon_step})\n        # e-greedy action selection\n        if np.random.uniform(0, 1) < epsilon:\n            action = np.random.randint(self.model.num_actions)\n        return action, v_b\n", "docstring": "try hard-coding input of linear net to be rewards (can try random as well)"}
{"repo": "POMDPy-master/pomdpy/pomdp/action_node.py", "original_string": "    def __init__(self, parent_entry=None):\n        # parent_entry is type ActionMappingEntry\n        if parent_entry is not None:\n            self.parent_entry = parent_entry\n        else:\n            self.parent_entry = None\n        self.observation_map = None\n", "docstring": "parent_entry is type ActionMappingEntry"}
{"repo": "POMDPy-master/pomdpy/pomdp/model.py", "original_string": "    def __init__(self):\n        self.action = None\n        self.observation = None\n        self.reward = 0\n        self.next_state = None\n        self.is_terminal = 0\n", "docstring": "self.action = None"}
{"repo": "POMDPy-master/experiments/scripts/plot_alpha_vectors.py", "original_string": "    def map_index_to_rgb_color(index):\n        return scalar_map.to_rgba(index)\n", "docstring": "return scalar_map.to_rgba(index)"}
{"repo": "POMDPy-master/examples/tiger/tiger_model.py", "original_string": "    def get_legal_actions(self, _):\n        return self.get_all_actions()\n", "docstring": "return self.get_all_actions()"}
{"repo": "POMDPy-master/examples/tiger/tiger_model.py", "original_string": "    def get_initial_belief_state():\n        return np.array([0.5, 0.5])\n", "docstring": "return np.array([0.5, 0.5])"}
{"repo": "POMDPy-master/examples/rock_sample/rock_model.py", "original_string": "    def create_root_historical_data(self, solver):\n        self.create_new_rock_data()\n        return PositionAndRockData(self, self.start_position.copy(), self.all_rock_data, solver)\n", "docstring": "self.create_new_rock_data()"}
{"repo": "POMDPy-master/examples/rock_sample/rock_position_history.py", "original_string": "    def __init__(self):\n        # The number of times this rock has been checked.\n        self.check_count = 0\n        # The \"goodness number\"; +1 for each good observation of this rock, and -1 for each bad\n        # observation of this rock.\n        self.goodness_number = 0\n        # The calculated probability that this rock is good.\n        self.chance_good = 0.5\n", "docstring": "The number of times this rock has been checked."}
{"repo": "POMDPy-master/examples/rock_sample/rock_position_history.py", "original_string": "    def update(self, other_belief):\n        self.all_rock_data = other_belief.data.all_rock_data\n", "docstring": "self.all_rock_data = other_belief.data.all_rock_data"}
{"repo": "theano_lstm-master/theano_lstm/shared_memory.py", "original_string": "        def spawn_model(path, wrapped_params):\n            # prevent recompilation and arbitrary locks\n            theano.config.reoptimize_unpickled_function = False\n            theano.gof.compilelock.set_lock_status(False)\n            # load your model from its pickled instance (from path)\n            mymodel = MyModel.load(path)\n            \n            # for each parameter in your model\n            # apply the borrow memory strategy to replace\n            # the internal parameter's memory with the\n            # across-process memory\n            for param, memory in zip(mymodel.params, wrapped_params):\n                borrow_memory(param, memory)\n            \n            # acquire your dataset (either through some smart shared memory\n            # or by reloading it for each process)\n            dataset, dataset_labels = acquire_dataset()\n            \n            # then run your model forward in this process\n            epochs = 20\n            for epoch in range(epochs):\n                model.update_fun(dataset, dataset_labels)\n", "docstring": "prevent recompilation and arbitrary locks"}
{"repo": "theano_lstm-master/theano_lstm/__init__.py", "original_string": "    def __init__(self, input_size, hidden_size, activation, clip_gradients=False):\n        self.input_size  = input_size\n        self.hidden_size = hidden_size\n        self.activation  = activation\n        self.clip_gradients = clip_gradients\n        self.is_recursive = False\n        self.create_variables()\n", "docstring": "self.input_size  = input_size"}
{"repo": "theano_lstm-master/theano_lstm/__init__.py", "original_string": "    def params(self):\n        return [self.linear_matrix, self.bias_matrix]\n", "docstring": "return [self.linear_matrix, self.bias_matrix]"}
{"repo": "theano_lstm-master/theano_lstm/__init__.py", "original_string": "    def params(self):\n        return [self.embedding_matrix]\n", "docstring": "return [self.embedding_matrix]"}
{"repo": "theano_lstm-master/theano_lstm/__init__.py", "original_string": "    def params(self):\n        return [self.linear_matrix, self.bias_matrix]\n", "docstring": "return [self.linear_matrix, self.bias_matrix]"}
{"repo": "theano_lstm-master/theano_lstm/__init__.py", "original_string": "    def params(self, param_list):\n        start = 0\n        for layer in self.internal_layers:\n            end = start + len(layer.params)\n            layer.params = param_list[start:end]\n            start = end\n", "docstring": "start = 0"}
{"repo": "theano_lstm-master/theano_lstm/__init__.py", "original_string": "    def create_variables(self):\n        # input gate for cells\n        self.in_gate     = Layer(self.input_size + self.hidden_size, 1, T.nnet.sigmoid, self.clip_gradients)\n        self.internal_layers = [self.in_gate]\n", "docstring": "input gate for cells"}
{"repo": "theano_lstm-master/theano_lstm/__init__.py", "original_string": "    def params(self, param_list):\n        start = 0\n        for layer in self.internal_layers:\n            end = start + len(layer.params)\n            layer.params = param_list[start:end]\n            start = end\n", "docstring": "start = 0"}
{"repo": "Handright-master/handright/_util.py", "original_string": "    def __init__(self, typecode: str, privileged=None) -> None:\n        \"\"\"More info about typecode: https://docs.python.org/3/library/array.html#module-array\n        The value of privileged must be within the typecode's range. The\n        privileged can be successfully added more than one time to this data\n        structure and appear more than one time in the ordered sequence.\"\"\"\n        self._typecode = typecode\n        self._privileged = privileged\n        self._array = array.array(typecode)\n        self._set = set()\n", "docstring": "More info about typecode: https://docs.python.org/3/library/array.html#module-array"}
{"repo": "Handright-master/handright/_util.py", "original_string": "    def add_privileged(self) -> None:\n        \"\"\"Equivalent to add(privileged)\"\"\"\n        self._set.add(self._privileged)\n        self._array.append(self._privileged)\n", "docstring": "Equivalent to add(privileged)\n"}
{"repo": "Handright-master/handright/_util.py", "original_string": "    def __len__(self) -> int:\n        \"\"\"The length of ordered sequence\"\"\"\n        return len(self._array)\n", "docstring": "The length of ordered sequence\n"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def cmd(self, *args, **kwargs):\n        '''adb command, add -s serial by default. return the subprocess.Popen object.'''\n        serial = self.device_serial()\n        if serial:\n            if \" \" in serial:  # TODO how to include special chars on command line\n                serial = \"'%s'\" % serial\n            return self.raw_cmd(*[\"-s\", serial] + list(args))\n        else:\n            return self.raw_cmd(*args)\n", "docstring": "adb command, add -s serial by default. return the subprocess.Popen object.'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def forward(self, local_port, device_port):\n        '''adb port forward. return 0 if success, else non-zero.'''\n        return self.cmd(\"forward\", \"tcp:%d\" % local_port, \"tcp:%d\" % device_port).wait()\n", "docstring": "adb port forward. return 0 if success, else non-zero.'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def version(self):\n        '''adb version'''\n        match = re.search(r\"(\\d+)\\.(\\d+)\\.(\\d+)\", self.raw_cmd(\"version\").communicate()[0].decode(\"utf-8\"))\n        return [match.group(i) for i in range(4)]\n", "docstring": "adb version'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def alive(self):\n        '''Check if the rpc server is alive.'''\n        return self.ping() == \"pong\"\n", "docstring": "Check if the rpc server is alive.'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def __getattr__(self, attr):\n        '''alias of fields in info property.'''\n        info = self.info\n        if attr in info:\n            return info[attr]\n        elif attr in self.__alias:\n            return info[self.__alias[attr]]\n        else:\n            raise AttributeError(\"%s attribute not found!\" % attr)\n", "docstring": "alias of fields in info property.'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def info(self):\n        '''Get the device info.'''\n        return self.server.jsonrpc.deviceInfo()\n", "docstring": "Get the device info.'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def long_click(self, x, y):\n        '''long click at arbitrary coordinates.'''\n        return self.swipe(x, y, x + 1, y + 1)\n", "docstring": "long click at arbitrary coordinates.'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def dump(self, filename=None, compressed=True, pretty=True):\n        '''dump device window and pull to local file.'''\n        content = self.server.jsonrpc.dumpWindowHierarchy(compressed, None)\n        if filename:\n            with open(filename, \"wb\") as f:\n                f.write(content.encode(\"utf-8\"))\n        if pretty and \"\\n \" not in content:\n            xml_text = xml.dom.minidom.parseString(content.encode(\"utf-8\"))\n            content = U(xml_text.toprettyxml(indent='  '))\n        return content\n", "docstring": "dump device window and pull to local file.'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def freeze_rotation(self, freeze=True):\n        '''freeze or unfreeze the device rotation in current status.'''\n        self.server.jsonrpc.freezeRotation(freeze)\n", "docstring": "freeze or unfreeze the device rotation in current status.'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def orientation(self, value):\n        '''setter of orientation property.'''\n        for values in self.__orientation:\n            if value in values:\n                # can not set upside-down until api level 18.\n                self.server.jsonrpc.setOrientation(values[1])\n                break\n        else:\n            raise ValueError(\"Invalid orientation.\")\n", "docstring": "setter of orientation property.'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def last_traversed_text(self):\n        '''get last traversed text. used in webview for highlighted text.'''\n        return self.server.jsonrpc.getLastTraversedText()\n", "docstring": "get last traversed text. used in webview for highlighted text.'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def handlers(self):\n        obj = self\n        class Handlers(object):\n            def on(self, fn):\n                if fn not in obj.server.handlers['handlers']:\n                    obj.server.handlers['handlers'].append(fn)\n                obj.server.handlers['device'] = obj\n                return fn\n            def off(self, fn):\n                if fn in obj.server.handlers['handlers']:\n                    obj.server.handlers['handlers'].remove(fn)\n        return Handlers()\n", "docstring": "obj = self"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def sleep(self):\n        '''turn off screen in case of screen on.'''\n        self.server.jsonrpc.sleep()\n", "docstring": "turn off screen in case of screen on.'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def __init__(self, device, selector):\n        self.device = device\n        self.jsonrpc = device.server.jsonrpc\n        self.selector = selector\n", "docstring": "self.device = device"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def exists(self):\n        '''check if the object exists in current window.'''\n        return self.jsonrpc.exist(self.selector)\n", "docstring": "check if the object exists in current window.'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def info(self):\n        '''ui object info.'''\n        return self.jsonrpc.objInfo(self.selector)\n", "docstring": "ui object info.'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def clear_text(self):\n        '''clear text. alias for set_text(None).'''\n        self.set_text(None)\n", "docstring": "clear text. alias for set_text(None).'''"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "        def to(obj_self, end1, end2, steps=100):\n            ctp = lambda pt: point(*pt) if type(pt) == tuple else pt  # convert tuple to point\n            s1, s2, e1, e2 = ctp(start1), ctp(start2), ctp(end1), ctp(end2)\n            return self.jsonrpc.gesture(self.selector, s1, s2, e1, e2, steps)\n", "docstring": "ctp = lambda pt: point(*pt) if type(pt) == tuple else pt  # convert tuple to point"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def __init__(self, device, name):\n        super(AutomatorDeviceNamedUiObject, self).__init__(device, name)\n", "docstring": "super(AutomatorDeviceNamedUiObject, self).__init__(device, name)"}
{"repo": "uiautomator-master/uiautomator/__init__.py", "original_string": "    def sibling(self, **kwargs):\n        '''set fromParent selector.'''\n        return AutomatorDeviceObject(\n            self.device,\n            self.selector.clone().sibling(**kwargs)\n        )\n", "docstring": "set fromParent selector.'''"}
{"repo": "metaflow-master/test/core/tests/s3_failure.py", "original_string": "    def step_start(self):\n        # we need a unique artifact for every run which we can reconstruct\n        # independently in the start and end tasks\n        from metaflow import current\n        self.x = '%s/%s' % (current.flow_name, current.run_id)\n", "docstring": "we need a unique artifact for every run which we can reconstruct"}
{"repo": "metaflow-master/test/core/tests/basic_foreach.py", "original_string": "    def inner(self):\n        # index must stay constant over multiple steps inside foreach\n        if self.my_index is None:\n            self.my_index = self.index\n        assert_equals(self.my_index, self.index)\n        assert_equals(self.input, self.arr[self.index])\n        self.my_input = self.input\n", "docstring": "index must stay constant over multiple steps inside foreach"}
{"repo": "metaflow-master/test/core/tests/merge_artifacts.py", "original_string": "    def modify_things(self):\n        # Set to different things\n        from metaflow.current import current\n        self.manual_merge_required = current.task_id\n        self.ignore_me = current.task_id\n        self.modified_to_same_value = 'e'\n        assert_equals(self.non_modified_passdown, 'a')\n", "docstring": "Set to different things"}
{"repo": "metaflow-master/test/core/tests/lineage.py", "original_string": "    def step_join(self):\n        # we can't easily account for the number of foreach splits,\n        # so we only care about unique lineages (hence set())\n        self.lineage = (tuple(sorted({x.lineage for x in inputs})),\n                        self._current_step)\n", "docstring": "we can't easily account for the number of foreach splits,"}
{"repo": "metaflow-master/test/core/tests/merge_artifacts_include.py", "original_string": "    def modify_things(self):\n        # Set to different things\n        from metaflow.current import current\n        self.manual_merge_required = current.task_id\n        self.ignore_me = current.task_id\n        self.modified_to_same_value = 'e'\n        assert_equals(self.non_modified_passdown, 'a')\n", "docstring": "Set to different things"}
{"repo": "metaflow-master/test/core/tests/merge_artifacts_include.py", "original_string": "    def end(self):\n        # Check that all values made it through\n        assert_equals(self.non_modified_passdown, 'a')\n        assert(hasattr(self, 'manual_merge_required'))\n", "docstring": "Check that all values made it through"}
{"repo": "metaflow-master/test/core/tests/basic_unbounded_foreach.py", "original_string": "    def inner(self):\n        # index must stay constant over multiple steps inside foreach\n        if self.my_index is None:\n            self.my_index = self.index\n        assert_equals(self.my_index, self.index)\n        assert_equals(self.input, self.arr[self.index])\n        self.my_input = self.input\n", "docstring": "index must stay constant over multiple steps inside foreach"}
{"repo": "metaflow-master/test/core/tests/detect_segfault.py", "original_string": "    def step_end(self):\n        # cause a segfault\n        import ctypes\n        print(\"Crash and burn!\")\n        ctypes.string_at(0)\n", "docstring": "cause a segfault"}
{"repo": "metaflow-master/test/core/tests/merge_artifacts_propagation.py", "original_string": "    def modify_things(self):\n        # Set different names to different things\n        val = self.index\n        setattr(self, 'var%d' % (val), val)\n", "docstring": "Set different names to different things"}
{"repo": "metaflow-master/test/env_escape/example.py", "original_string": "def run_test(through_escape=False):\n    # NOTE: This will be the same for both escaped path and non-escaped path\n    # if the library test_lib is installed. For the unescaped path, we pretend\n    # we installed the library by modifying the path\n    if not through_escape:\n        # HACK to pretend that we installed test_lib\n        sys.path.append(os.path.realpath(\n            os.path.join(os.path.dirname(__file__), '..', '..', 'metaflow', 'plugins',\n                         'env_escape', 'configurations', 'test_lib_impl')))\n        print(\"Path is %s\" % str(sys.path))\n    import test_lib as test\n    if through_escape:\n        # This tests package aliasing\n        from test_lib.package import TestClass3\n    else:\n        from test_lib import TestClass3\n    o1 = test.TestClass1(123)\n    print(\"-- Test print_value --\")\n    if through_escape:\n        # The server_mapping should add 5 here\n        assert o1.print_value() == 128\n    else:\n        assert o1.print_value() == 123\n    print(\"-- Test property --\")\n    assert o1.value == 123\n    print(\"-- Test value override (get) --\")\n    assert o1.override_value == 123\n    print(\"-- Test value override (set) --\")\n    o1.override_value = 456\n    assert o1.override_value == 456\n    print(\"-- Test static method --\")\n    assert test.TestClass1.somethingstatic(5) == 47\n    assert o1.somethingstatic(5) == 47\n    print(\"-- Test class method --\")\n    assert test.TestClass1.somethingclass() == 25\n    assert o1.somethingclass() == 25\n    print(\"-- Test set and get --\")\n    o1.value = 2\n    if through_escape:\n        # The server_mapping should add 5 here\n        assert o1.print_value() == 7\n    else:\n        assert o1.print_value() == 2\n    print(\"-- Test function --\")\n    assert test.test_func() == \"In test func\"\n    print(\"-- Test value --\")\n    assert test.test_value == 1\n    test.test_value = 2\n    assert test.test_value == 2\n    print(\"-- Test chaining of exported classes --\")\n    o2 = o1.to_class2(5)\n    assert o2.something(\"foo\") == \"In Test2 with foo\"\n    print(\"-- Test Iterating --\")\n    for i in o2:\n        print(\"Got %d\" % i)\n    print(\"-- Test exception --\")\n    o3 = TestClass3()\n    try:\n        o3.raiseSomething()\n    except test.SomeException as e:\n        print(\"Caught the local exception: %s\" % str(e))\n    print(\"-- Test returning proxied object --\")\n    o3.weird_indirection(\"foo\")(10)\n    assert o3.foo == 10\n", "docstring": "NOTE: This will be the same for both escaped path and non-escaped path"}
{"repo": "metaflow-master/test/data/s3/test_s3.py", "original_string": "def test_put_one_benchmark(benchmark, tempdir, s3root, blobs, expected):\n    # We generate the files here to avoid having them saved in the benchmark\n    # result file which then prevents comparisons\n    def _generate_files(blobs):\n        for blob in blobs:\n            prefix, fname, size = blob\n            data = s3_data.RandomFile(prefix, fname, size)\n            key = str(uuid4())\n            path = os.path.join(tempdir, key)\n            with open(path, 'wb') as f:\n                f.write(data.data)\n            yield key, path\n    # Generate all files before the test so we don't time this\n    all_files = list(_generate_files(blobs))\n    def _do():\n        with S3(s3root=s3root) as s3:\n            res = []\n            for key, obj in all_files:\n                key = str(uuid4()) # New \"name\" every time\n                res.append(s3.put(key, obj, overwrite=False))\n            return res\n    res = benchmark(_do)\n", "docstring": "We generate the files here to avoid having them saved in the benchmark"}
{"repo": "metaflow-master/test/data/s3/test_s3.py", "original_string": "def test_get_exceptions(s3root, prefixes, expected):\n    # get_many() goes via s3op, get() is a method - test both the code paths\n    with S3() as s3:\n        with pytest.raises(MetaflowS3AccessDenied):\n            s3.get_many(['s3://foobar/foo'])\n        with pytest.raises(MetaflowS3AccessDenied):\n            s3.get('s3://foobar/foo')\n    with S3(s3root=s3root) as s3:\n        with pytest.raises(MetaflowS3NotFound):\n            s3.get_many(['this_file_does_not_exist'])\n        with pytest.raises(MetaflowS3NotFound):\n            s3.get('this_file_does_not_exist')\n", "docstring": "get_many() goes via s3op, get() is a method - test both the code paths"}
{"repo": "metaflow-master/test/data/s3/s3_data.py", "original_string": "def ensure_test_data():\n    # update S3ROOT in __init__.py to get a fresh set of data\n    print('Ensuring that test data exists at %s' % S3ROOT)\n    mark = urlparse(os.path.join(S3ROOT, 'ALL_OK'))\n    try:\n        # Check if the data exists and has been modified in the last\n        # 29 days (this should be lower than the TTL for your bucket to ensure\n        # the data is available for the test)\n        import datetime\n        today = datetime.date.today()\n        delta = datetime.timedelta(days=29)\n        s3client.head_object(Bucket=mark.netloc, Key=mark.path.lstrip('/'),\n                             IfModifiedSince=str(today - delta))\n        print('All data ok.')\n    except:\n        print('Uploading test data')\n        def _do_upload(prefix, filespecs, meta=None):\n            for fname, size in filespecs.items():\n                if size is not None:\n                    f = RandomFile(prefix, fname, size)\n                    url = urlparse(f.url)\n                    # For metadata, we don't actually touch RandomFile\n                    # (since it is the same) but we modify the path to post-pend\n                    # the name\n                    print('Case %s: %s started' % (prefix, f.url))\n                    s3client.upload_fileobj(f.fileobj(),\n                                            url.netloc,\n                                            url.path.lstrip('/'))\n                    print('Case %s: %s added' % (prefix, f.url))\n                    if meta is not None:\n                        for metaname, metainfo in meta.items():\n                            new_url = \"%s_%s\" % (f.url, metaname)\n                            url = urlparse(new_url)\n                            print('Case %s: %s started' % (prefix, new_url))\n                            extra = {}\n                            content_type, user_meta = metainfo\n                            if content_type:\n                                extra['ContentType'] = content_type\n                            if user_meta:\n                                new_meta = {\n                                    'metaflow-user-attributes': json.dumps(user_meta)}\n                                extra['Metadata'] = new_meta\n                            s3client.upload_fileobj(f.fileobj(),\n                                                    url.netloc,\n                                                    url.path.lstrip('/'),\n                                                    ExtraArgs=extra)\n                            print('Case %s: %s added' % (prefix, new_url))\n        for prefix, filespecs in BIG_DATA + FAKE_RUN_DATA:\n            _do_upload(prefix, filespecs)\n        for prefix, filespecs in BASIC_DATA:\n            _do_upload(prefix, filespecs, meta=BASIC_METADATA)\n        s3client.upload_fileobj(to_fileobj('ok'),\n                                Bucket=mark.netloc,\n                                Key=mark.path.lstrip('/'))\n        print('Test data uploaded ok')\n", "docstring": "update S3ROOT in __init__.py to get a fresh set of data"}
{"repo": "metaflow-master/metaflow/metaflow_config.py", "original_string": "def init_config():\n    # Read configuration from $METAFLOW_HOME/config_<profile>.json.\n    home = os.environ.get('METAFLOW_HOME', '~/.metaflowconfig')\n    profile = os.environ.get('METAFLOW_PROFILE')\n    path_to_config = os.path.join(home, 'config.json')\n    if profile:\n        path_to_config = os.path.join(home, 'config_%s.json' % profile)\n    path_to_config = os.path.expanduser(path_to_config)\n    config = {}\n    if os.path.exists(path_to_config):\n        with open(path_to_config) as f:\n            return json.load(f)\n    elif profile:\n        raise MetaflowException('Unable to locate METAFLOW_PROFILE \\'%s\\' in \\'%s\\')' %\n                                (profile, home))\n    return config\n", "docstring": "Read configuration from $METAFLOW_HOME/config_<profile>.json."}
{"repo": "metaflow-master/metaflow/metaflow_environment.py", "original_string": "    def get_environment_info(self):\n        global version_cache\n        if version_cache is None:\n            version_cache = metaflow_version.get_version()\n        # note that this dict goes into the code package\n        # so variables here should be relatively stable (no\n        # timestamps) so the hash won't change all the time\n        env = {'platform': platform.system(),\n               'username': get_username(),\n               'production_token': os.environ.get('METAFLOW_PRODUCTION_TOKEN'),\n               'runtime': os.environ.get('METAFLOW_RUNTIME_NAME', 'dev'),\n               'app': os.environ.get('APP'),\n               'environment_type': self.TYPE,\n               'use_r': R.use_r(),\n               'python_version': sys.version,\n               'python_version_code': '%d.%d.%d' % sys.version_info[:3],\n               'metaflow_version': version_cache,\n               'script': os.path.basename(os.path.abspath(sys.argv[0]))}\n        if R.use_r():\n            env['metaflow_r_version'] = R.metaflow_r_version()\n            env['r_version'] = R.r_version()\n            env['r_version_code'] = R.r_version_code()\n        return env\n", "docstring": "global version_cache"}
{"repo": "metaflow-master/metaflow/monitor.py", "original_string": "    def __init__(self, monitor_type, env, flow_name):\n        # type: (str) -> None\n        self.sidecar_process = None\n        self.monitor_type = monitor_type\n        self.env_info = env.get_environment_info()\n        self.env_info[\"flow_name\"] = flow_name\n", "docstring": "type: (str) -> None"}
{"repo": "metaflow-master/metaflow/flowspec.py", "original_string": "    def __init__(self, msg):\n        # NOTE this assume that InvalidNextException is only raised\n        # at the top level of next()\n        _, line_no, _, _ = traceback.extract_stack()[-3]\n        super(InvalidNextException, self).__init__(msg, line_no)\n", "docstring": "NOTE this assume that InvalidNextException is only raised"}
{"repo": "metaflow-master/metaflow/flowspec.py", "original_string": "    def _set_datastore(self, datastore):\n        self._datastore = datastore\n", "docstring": "self._datastore = datastore"}
{"repo": "metaflow-master/metaflow/flowspec.py", "original_string": "        def root(self):\n            self.split_1 = ['a', 'b', 'c']\n            self.next(self.nest_1, foreach='split_1')\n", "docstring": "self.split_1 = ['a', 'b', 'c']"}
{"repo": "metaflow-master/metaflow/runtime.py", "original_string": "    def _queue_tasks(self, finished_tasks):\n        # finished tasks include only successful tasks\n        for task in finished_tasks:\n            self._finished[task.finished_id] = task.path\n            self._is_cloned[task.path] = task.is_cloned\n            # CHECK: ensure that runtime transitions match with\n            # statically inferred transitions. Make an exception for control\n            # tasks, where we just rely on static analysis since we don't\n            # execute user code.\n            trans = task.results.get('_transition')\n            if trans:\n                next_steps = trans[0]\n                foreach = trans[1]\n            else:\n                next_steps = []\n                foreach = None\n            expected = self._graph[task.step].out_funcs\n            if next_steps != expected:\n                msg = 'Based on static analysis of the code, step *{step}* '\\\n                      'was expected to transition to step(s) *{expected}*. '\\\n                      'However, when the code was executed, self.next() was '\\\n                      'called with *{actual}*. Make sure there is only one '\\\n                      'unconditional self.next() call in the end of your '\\\n                      'step. '\n                raise MetaflowInternalError(msg.format(step=task.step,\n                                                       expected=', '.join(\n                                                           expected),\n                                                       actual=', '.join(next_steps)))\n            # Different transition types require different treatment\n            if any(self._graph[f].type == 'join' for f in next_steps):\n                # Next step is a join\n                self._queue_task_join(task, next_steps)\n            elif foreach:\n                # Next step is a foreach child\n                self._queue_task_foreach(task, next_steps)\n            else:\n                # Next steps are normal linear steps\n                for step in next_steps:\n                    self._queue_push(step, {'input_paths': [task.path]})\n", "docstring": "finished tasks include only successful tasks"}
{"repo": "metaflow-master/metaflow/runtime.py", "original_string": "    def finished_id(self):\n        # note: id is not available before the task has finished\n        return (self.step, tuple(self.results['_foreach_stack']))\n", "docstring": "note: id is not available before the task has finished"}
{"repo": "metaflow-master/metaflow/cli.py", "original_string": "def init(obj, run_id=None, task_id=None, tags=None, **kwargs):\n    # init is a separate command instead of an option in 'step'\n    # since we need to capture user-specified parameters with\n    # @add_custom_parameters. Adding custom parameters to 'step'\n    # is not desirable due to the possibility of name clashes between\n    # user-specified parameters and our internal options. Note that\n    # user-specified parameters are often defined as environment\n    # variables.\n    if obj.datastore.datastore_root is None:\n        obj.datastore.datastore_root = \\\n            obj.datastore.get_datastore_root_from_config(obj.echo)\n    obj.metadata.add_sticky_tags(tags=tags)\n    runtime = NativeRuntime(obj.flow,\n                            obj.graph,\n                            obj.datastore,\n                            obj.metadata,\n                            obj.environment,\n                            obj.package,\n                            obj.logger,\n                            obj.entrypoint,\n                            obj.event_logger,\n                            obj.monitor,\n                            run_id=run_id)\n    parameters.set_parameters(obj.flow, kwargs)\n    runtime.persist_parameters(task_id=task_id)\n", "docstring": "init is a separate command instead of an option in 'step'"}
{"repo": "metaflow-master/metaflow/cli.py", "original_string": "def before_run(obj, tags, decospecs):\n    # There's a --with option both at the top-level and for the run\n    # subcommand. Why?\n    #\n    # \"run --with shoes\" looks so much better than \"--with shoes run\".\n    # This is a very common use case of --with.\n    #\n    # A downside is that we need to have the following decorators handling\n    # in two places in this module and we need to make sure that\n    # _init_step_decorators doesn't get called twice.\n    if decospecs:\n        decorators._attach_decorators(obj.flow, decospecs)\n        obj.graph = FlowGraph(obj.flow.__class__)\n    obj.check(obj.graph, obj.flow, obj.environment, pylint=obj.pylint)\n    #obj.environment.init_environment(obj.logger)\n    if obj.datastore.datastore_root is None:\n        obj.datastore.datastore_root = \\\n            obj.datastore.get_datastore_root_from_config(obj.echo)\n    decorators._init_step_decorators(\n        obj.flow, obj.graph, obj.environment, obj.datastore, obj.logger)\n    obj.metadata.add_sticky_tags(tags=tags)\n    # Package working directory only once per run.\n    # We explicitly avoid doing this in `start` since it is invoked for every\n    # step in the run.\n    obj.package = MetaflowPackage(obj.flow,\n                                  obj.environment,\n                                  obj.echo,\n                                  obj.package_suffixes)\n", "docstring": "There's a --with option both at the top-level and for the run"}
{"repo": "metaflow-master/metaflow/package.py", "original_string": "    def _make(self):\n        def no_mtime(tarinfo):\n            # a modification time change should not change the hash of\n            # the package. Only content modifications will.\n            tarinfo.mtime = 0\n            return tarinfo\n        buf = BytesIO()\n        with tarfile.TarFile(fileobj=buf, mode='w') as tar:\n            self._add_info(tar)\n            for path, arcname in self.path_tuples():\n                tar.add(path, arcname=arcname,\n                        recursive=False, filter=no_mtime)\n        blob = buf.getvalue()\n        return blob, sha1(blob).hexdigest()\n", "docstring": "a modification time change should not change the hash of"}
{"repo": "metaflow-master/metaflow/sidecar.py", "original_string": "    def __init__(self, worker_type):\n        # type: (str) -> None\n        self.__worker_type = worker_type\n        self.__process = None\n        self.__poller = None\n        self.start()\n", "docstring": "type: (str) -> None"}
{"repo": "metaflow-master/metaflow/includefile.py", "original_string": "    def __init__(self, url, path):\n        # all fields of S3Object should return a unicode object\n        def ensure_unicode(x):\n            return None if x is None else to_unicode(x)\n        path = ensure_unicode(path)\n        self._path = path\n        self._url = url\n        if self._path:\n            try:\n                os.stat(self._path)\n            except FileNotFoundError:\n                self._path = None\n", "docstring": "all fields of S3Object should return a unicode object"}
{"repo": "metaflow-master/metaflow/includefile.py", "original_string": "    def is_file_handled(cls, path):\n        # This returns a tuple:\n        #  - True/False indicating whether the file is handled\n        #  - None if we need to create a handler for the file, a LocalFile if\n        #    we already know what to do with the file or a Uploader if the file\n        #    is already present remotely (either starting with s3:// or local://)\n        #  - An error message if file is not handled\n        if path:\n            if isinstance(path, IncludedFile):\n                path = path.descriptor\n            decoded_value = Uploader.decode_value(to_unicode(path))\n            if decoded_value['type'] == 'self':\n                return True, LocalFile(\n                    decoded_value['is_text'], decoded_value['encoding'],\n                    decoded_value['url']), None\n            path = decoded_value['url']\n        for prefix, handler in DATACLIENTS.items():\n            if path.startswith(u\"%s://\" % prefix):\n                return True, Uploader(handler), None\n        try:\n            with open(path, mode='r') as _:\n                pass\n        except OSError:\n            return False, None, \"IncludeFile: could not open file '%s'\" % path\n        return True, None, None\n", "docstring": "This returns a tuple:"}
{"repo": "metaflow-master/metaflow/includefile.py", "original_string": "    def encode_url(url_type, url, **kwargs):\n        # Avoid encoding twice (default -> URL -> _convert method of FilePath for example)\n        if isinstance(url, IncludedFile):\n            return url\n        return_value = {'type': url_type, 'url': url}\n        return_value.update(kwargs)\n        return IncludedFile(return_value)\n", "docstring": "Avoid encoding twice (default -> URL -> _convert method of FilePath for example)"}
{"repo": "metaflow-master/metaflow/decorators.py", "original_string": "    def __init__(self, *args, **kwargs):\n        # Note that this assumes we are executing one flow per process so we have a global list of\n        # _flow_decorators. A similar setup is used in parameters.\n        self._flow_decorators.append(self)\n        super(FlowDecorator, self).__init__(*args, **kwargs)\n", "docstring": "Note that this assumes we are executing one flow per process so we have a global list of"}
{"repo": "metaflow-master/metaflow/decorators.py", "original_string": "def add_decorator_options(cmd):\n    seen = {}\n    for deco in flow_decorators():\n        for option, kwargs in deco.options.items():\n            if option in seen:\n                msg = \"Flow decorator '%s' uses an option '%s' which is also \"\\\n                      \"used by the decorator '%s'. This is a bug in Metaflow. \"\\\n                      \"Please file a ticket on GitHub.\"\\\n                      % (deco.name, option, seen[option])\n                raise MetaflowInternalError(msg)\n            else:\n                seen[option] = deco.name\n                cmd.params.insert(0, click.Option(('--' + option,), **kwargs))\n    return cmd\n", "docstring": "seen = {}"}
{"repo": "metaflow-master/metaflow/decorators.py", "original_string": "    def runtime_task_created(self,\n                             datastore,\n                             task_id,\n                             split_index,\n                             input_paths,\n                             is_cloned,\n                             ubf_context):\n        \"\"\"\n        Called when the runtime has created a task related to this step.\n        \"\"\"\n        pass\n", "docstring": "datastore,"}
{"repo": "metaflow-master/metaflow/decorators.py", "original_string": "        def wrap(f):\n            return _base_step_decorator(decotype, f, **kwargs)\n", "docstring": "return _base_step_decorator(decotype, f, **kwargs)"}
{"repo": "metaflow-master/metaflow/decorators.py", "original_string": "def _init_flow_decorators(flow, graph, environment, datastore, logger, echo, deco_options):\n    for deco in flow._flow_decorators.values():\n        opts = {option: deco_options[option] for option in deco.options}\n        deco.flow_init(flow, graph, environment, datastore, logger, echo, opts)\n", "docstring": "for deco in flow._flow_decorators.values():"}
{"repo": "metaflow-master/metaflow/main_cli.py", "original_string": "def makedirs(path):\n    # This is for python2 compatibility.\n    # Python3 has os.makedirs(exist_ok=True).\n    try:\n        os.makedirs(path)\n    except OSError as x:\n        if x.errno == 17:\n            return\n        else:\n            raise\n", "docstring": "This is for python2 compatibility."}
{"repo": "metaflow-master/metaflow/util.py", "original_string": "def get_latest_run_id(echo, flow_name):\n    from metaflow.datastore.local import LocalDataStore\n    local_root = LocalDataStore.datastore_root\n    if local_root is None:\n        v = LocalDataStore.get_datastore_root_from_config(echo, create_on_absent=False)\n        LocalDataStore.datastore_root = local_root = v\n    if local_root:\n        path = os.path.join(local_root, flow_name, 'latest_run')\n        if os.path.exists(path):\n            with open(path) as f:\n                return f.read()\n    return None\n", "docstring": "from metaflow.datastore.local import LocalDataStore"}
{"repo": "metaflow-master/metaflow/util.py", "original_string": "def decompress_list(lststr, separator=',', rangedelim=':', zlibmarker='!'):\n    # Three input modes:\n    if lststr[0] == zlibmarker:\n        # 3. zlib-compressed, base64-encoded\n        lstbytes = base64.b64decode(lststr[1:])\n        decoded = zlib.decompress(zlib.decompress(lstbytes)).decode('utf-8')\n    else:\n        decoded = lststr\n    if rangedelim in decoded:\n        prefix, suffixes = decoded.split(rangedelim)\n        # 2. Prefix and a comma-separated list of suffixes\n        return [prefix + suffix for suffix in suffixes.split(separator)]\n    else:\n        # 1. Just a comma-separated list\n        return decoded.split(separator)\n", "docstring": "Three input modes:"}
{"repo": "metaflow-master/metaflow/util.py", "original_string": "def get_metaflow_root():\n    return os.path.dirname(os.path.dirname(__file__))\n", "docstring": "return os.path.dirname(os.path.dirname(__file__))"}
{"repo": "metaflow-master/metaflow/util.py", "original_string": "def which(cmd, mode=os.F_OK | os.X_OK, path=None):\n    \"\"\"Given a command, mode, and a PATH string, return the path which\n    conforms to the given mode on the PATH, or None if there is no such\n    file.\n    `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result\n    of os.environ.get(\"PATH\"), or can be overridden with a custom search\n    path.\n    Note: This function was backported from the Python 3 source code.\n    \"\"\"\n    # Check that a given file can be accessed with the correct mode.\n    # Additionally check that `file` is not a directory, as on Windows\n    # directories pass the os.access check.\n    try:  # Forced testing\n        from shutil import which as w\n        return w(cmd, mode, path)\n    except ImportError: \n        def _access_check(fn, mode):\n            return os.path.exists(fn) and os.access(fn, mode) and not os.path.isdir(fn)\n        # If we're given a path with a directory part, look it up directly\n        # rather than referring to PATH directories. This includes checking\n        # relative to the current directory, e.g. ./script\n        if os.path.dirname(cmd):\n            if _access_check(cmd, mode):\n                return cmd\n            return None\n        if path is None:\n            path = os.environ.get(\"PATH\", os.defpath)\n        if not path:\n            return None\n        path = path.split(os.pathsep)\n        files = [cmd]\n        seen = set()\n        for dir in path:\n            normdir = os.path.normcase(dir)\n            if normdir not in seen:\n                seen.add(normdir)\n                for thefile in files:\n                    name = os.path.join(dir, thefile)\n                    if _access_check(name, mode):\n                        return name\n        return None\n", "docstring": "Given a command, mode, and a PATH string, return the path which"}
{"repo": "metaflow-master/metaflow/parameters.py", "original_string": "    def _check_type(self, val):\n        # it is easy to introduce a deploy-time function that that accidentally\n        # returns a value whose type is not compatible with what is defined\n        # in Parameter. Let's catch those mistakes early here, instead of\n        # showing a cryptic stack trace later.\n        # note: this doesn't work with long in Python2 or types defined as\n        # click types, e.g. click.INT\n        TYPES = {bool: 'bool',\n                 int: 'int',\n                 float: 'float',\n                 list: 'list'}\n        msg = \"The value returned by the deploy-time function for \"\\\n              \"the parameter *%s* field *%s* has a wrong type. \" %\\\n              (self.parameter_name, self.field)\n        if self.parameter_type in TYPES:\n            if type(val) != self.parameter_type:\n                msg += 'Expected a %s.' % TYPES[self.parameter_type]\n                raise ParameterFieldTypeMismatch(msg)\n            return str(val) if self.return_str else val\n        else:\n            if not is_stringish(val):\n                msg += 'Expected a string.'\n                raise ParameterFieldTypeMismatch(msg)\n            return val\n", "docstring": "it is easy to introduce a deploy-time function that that accidentally"}
{"repo": "metaflow-master/metaflow/parameters.py", "original_string": "    def wrapper(cmd):\n        # Iterate over parameters in reverse order so cmd.params lists options\n        # in the order they are defined in the FlowSpec subclass\n        for arg in parameters[::-1]:\n            kwargs = arg.option_kwargs(deploy_mode)\n            cmd.params.insert(0, click.Option(('--' + arg.name,), **kwargs))\n        return cmd\n", "docstring": "Iterate over parameters in reverse order so cmd.params lists options"}
{"repo": "metaflow-master/metaflow/metaflow_version.py", "original_string": "    def find_git_on_windows():\n        \"\"\"find the path to the git executable on windows\"\"\"\n        # first see if git is in the path\n        try:\n            check_output([\"where\", \"/Q\", \"git\"])\n            # if this command succeeded, git is in the path\n            return \"git\"\n        # catch the exception thrown if git was not found\n        except CalledProcessError:\n            pass\n        # There are several locations git.exe may be hiding\n        possible_locations = []\n        # look in program files for msysgit\n        if \"PROGRAMFILES(X86)\" in environ:\n            possible_locations.append(\"%s/Git/cmd/git.exe\" %\n                                      environ[\"PROGRAMFILES(X86)\"])\n        if \"PROGRAMFILES\" in environ:\n            possible_locations.append(\"%s/Git/cmd/git.exe\" %\n                                      environ[\"PROGRAMFILES\"])\n        # look for the github version of git\n        if \"LOCALAPPDATA\" in environ:\n            github_dir = \"%s/GitHub\" % environ[\"LOCALAPPDATA\"]\n            if path.isdir(github_dir):\n                for subdir in listdir(github_dir):\n                    if not subdir.startswith(\"PortableGit\"):\n                        continue\n                    possible_locations.append(\"%s/%s/bin/git.exe\" %\n                                              (github_dir, subdir))\n        for possible_location in possible_locations:\n            if path.isfile(possible_location):\n                return possible_location\n        # git was not found\n        return \"git\"\n", "docstring": "find the path to the git executable on windows\n"}
{"repo": "metaflow-master/metaflow/metaflow_version.py", "original_string": "def call_git_describe(abbrev=7):\n    \"\"\"return the string output of git desribe\"\"\"\n    try:\n        # first, make sure we are actually in a Metaflow repo,\n        # not some other repo\n        with open(devnull, 'w') as fnull:\n            arguments = [GIT_COMMAND, \"rev-parse\", \"--show-toplevel\"]\n            reponame = check_output(arguments, cwd=CURRENT_DIRECTORY,\n                                    stderr=fnull).decode(\"ascii\").strip()\n            if path.basename(reponame) != 'metaflow':\n                return None\n        with open(devnull, \"w\") as fnull:\n            arguments = [GIT_COMMAND, \"describe\", \"--tags\",\n                         \"--abbrev=%d\" % abbrev]\n            return check_output(arguments, cwd=CURRENT_DIRECTORY,\n                                stderr=fnull).decode(\"ascii\").strip()\n    except (OSError, CalledProcessError):\n        return None\n", "docstring": "return the string output of git desribe\n"}
{"repo": "metaflow-master/metaflow/metaflow_version.py", "original_string": "def read_info_version():\n    \"\"\"Read version information from INFO file\"\"\"\n    try:\n        with open(INFO_FILE, \"r\") as contents:\n            return json.load(contents).get('metaflow_version')\n    except IOError:\n        return None\n", "docstring": "Read version information from INFO file\n"}
{"repo": "metaflow-master/metaflow/__init__.py", "original_string": "    def __init__(self, handled):\n        # Modules directly loaded (this is either new modules or overrides of existing ones)\n        self._handled = handled if handled else {}\n        # This is used to revert back to regular loading when trying to load\n        # the over-ridden module\n        self._tempexcluded = set()\n", "docstring": "Modules directly loaded (this is either new modules or overrides of existing ones)"}
{"repo": "metaflow-master/metaflow/event_logger.py", "original_string": "    def __init__(self, logger_type):\n        # type: (str) -> None\n        self.sidecar_process = None\n        self.logger_type = logger_type\n", "docstring": "type: (str) -> None"}
{"repo": "metaflow-master/metaflow/graph.py", "original_string": "    def _postprocess(self):\n        # any node who has a foreach as any of its split parents\n        # has is_inside_foreach=True *unless* all of those foreaches\n        # are joined by the node\n        for node in self.nodes.values():\n            foreaches = [p for p in node.split_parents\n                         if self.nodes[p].type == 'foreach']\n            if [f for f in foreaches\n                if self.nodes[f].matching_join != node.name]:\n                node.is_inside_foreach = True\n", "docstring": "any node who has a foreach as any of its split parents"}
{"repo": "metaflow-master/metaflow/task.py", "original_string": "    def _init_parameters(self, parameter_ds):\n        # overwrite Parameters in the flow object\n        vars = []\n        for var, param in self.flow._get_parameters():\n            # make the parameter a read-only property\n            # note x=x binds the current value of x to the closure\n            def property_setter(\n                    _, cls=self.flow.__class__, param=param, var=var, parameter_ds=parameter_ds):\n                v = param.load_parameter(parameter_ds[var])\n                setattr(cls, var, property(fget=lambda _, val=v: val))\n                return v\n            setattr(self.flow.__class__, var,\n                    property(fget=property_setter))\n            vars.append(var)\n        self.flow._datastore.passdown_partial(parameter_ds, vars)\n        return vars\n", "docstring": "overwrite Parameters in the flow object"}
{"repo": "metaflow-master/metaflow/client/core.py", "original_string": "    def __init__(self):\n        # the default namespace is activated lazily at the first object\n        # invocation or get_namespace(). The other option of activating\n        # the namespace at the import time is problematic, since there\n        # may be other modules that alter environment variables etc.\n        # which may affect the namescape setting.\n        if current_namespace is False:\n            default_namespace()\n        if current_metadata is False:\n            default_metadata()\n        self.metadata = current_metadata\n", "docstring": "the default namespace is activated lazily at the first object"}
{"repo": "metaflow-master/metaflow/client/core.py", "original_string": "    def __str__(self):\n        return 'Metaflow()'\n", "docstring": "return 'Metaflow()'"}
{"repo": "metaflow-master/metaflow/client/core.py", "original_string": "    def _url_token(cls):\n        return '%ss' % cls._NAME\n", "docstring": "return '%ss' % cls._NAME"}
{"repo": "metaflow-master/metaflow/client/core.py", "original_string": "    def __init__(self, artifacts):\n        self._artifacts = dict((art.id, art) for art in artifacts)\n", "docstring": "self._artifacts = dict((art.id, art) for art in artifacts)"}
{"repo": "metaflow-master/metaflow/client/core.py", "original_string": "    def __init__(self, *args, **kwargs):\n        super(Task, self).__init__(*args, **kwargs)\n", "docstring": "super(Task, self).__init__(*args, **kwargs)"}
{"repo": "metaflow-master/metaflow/client/core.py", "original_string": "    def __iter__(self):\n        children = super(Step, self).__iter__()\n        for t in children:\n            if CONTROL_TASK_TAG not in t.tags:\n                yield t\n", "docstring": "children = super(Step, self).__iter__()"}
{"repo": "metaflow-master/metaflow/client/core.py", "original_string": "    def _iter_filter(self, x):\n        # exclude _parameters step\n        return x.id[0] != '_'\n", "docstring": "exclude _parameters step"}
{"repo": "metaflow-master/metaflow/client/core.py", "original_string": "    def __init__(self, *args, **kwargs):\n        super(Flow, self).__init__(*args, **kwargs)\n", "docstring": "super(Flow, self).__init__(*args, **kwargs)"}
{"repo": "metaflow-master/metaflow/client/filecache.py", "original_string": "    def _makedirs(self, path):\n        # this is for python2 compatibility.\n        # Python3 has os.makedirs(exist_ok=True).\n        try:\n            os.makedirs(path)\n        except OSError as x:\n            if x.errno == 17:\n                return\n            else:\n                raise\n", "docstring": "this is for python2 compatibility."}
{"repo": "metaflow-master/metaflow/plugins/retry_decorator.py", "original_string": "    def step_init(self, flow, graph, step, decos, environment, datastore, logger):\n        # The total number of attempts must not exceed MAX_ATTEMPTS.\n        # attempts = normal task (1) + retries (N) + @catch fallback (1)\n        if int(self.attributes['times']) + 2 > MAX_ATTEMPTS:\n            raise MetaflowException('The maximum number of retries is '\n                                    '@retry(times=%d).' % (MAX_ATTEMPTS - 2))\n", "docstring": "The total number of attempts must not exceed MAX_ATTEMPTS."}
{"repo": "metaflow-master/metaflow/plugins/catch_decorator.py", "original_string": "    def step_init(self, flow, graph, step, decos, environment, datastore, logger):\n        # handling _foreach_var and _foreach_num_splits requires some\n        # deeper thinking, so let's not support that use case for now\n        self.logger = logger\n        if graph[step].type == 'foreach':\n            raise MetaflowException('@catch is defined for the step *%s* '\n                                    'but @catch is not supported in foreach '\n                                    'split steps.' % step)\n", "docstring": "handling _foreach_var and _foreach_num_splits requires some"}
{"repo": "metaflow-master/metaflow/plugins/package_cli.py", "original_string": "def package(obj):\n    # Prepare the package before any of the sub-commands are invoked.\n    obj.package = MetaflowPackage(obj.flow,\n                                  obj.environment,\n                                  obj.echo,\n                                  obj.package_suffixes)\n", "docstring": "Prepare the package before any of the sub-commands are invoked."}
{"repo": "metaflow-master/metaflow/plugins/debug_monitor.py", "original_string": "    def measure(self, timer):\n        # type: (Timer) -> None\n        self.logger('elapsed time for {}: {}'.\n                    format(timer.name, str(timer.get_duration())))\n", "docstring": "type: (Timer) -> None"}
{"repo": "metaflow-master/metaflow/plugins/debug_monitor.py", "original_string": "    def process_message(self, msg):\n        # type: (Message) -> None\n        self.logger('processing message %s' % str(msg.msg_type))\n        msg_type = get_monitor_msg_type(msg)\n        if msg_type == MEASURE_TYPE:\n            timer = deserialize_metric(msg.payload.get('timer'))\n            self.measure(timer)\n        else:\n            pass\n", "docstring": "type: (Message) -> None"}
{"repo": "metaflow-master/metaflow/plugins/__init__.py", "original_string": "def get_plugin_cli():\n    # it is important that CLIs are not imported when\n    # __init__ is imported. CLIs may use e.g.\n    # parameters.add_custom_parameters which requires\n    # that the flow is imported first\n    # Add new CLI commands in this list\n    from . import package_cli\n    from .aws.batch import batch_cli\n    from .aws.step_functions import step_functions_cli\n    return _ext_plugins.get_plugin_cli() + [\n        package_cli.cli,\n        batch_cli.cli,\n        step_functions_cli.cli]\n", "docstring": "it is important that CLIs are not imported when"}
{"repo": "metaflow-master/metaflow/plugins/aws/step_functions/step_functions.py", "original_string": "    def schedule(self):\n        # Scheduling is currently enabled via AWS Event Bridge.\n        if EVENTS_SFN_ACCESS_IAM_ROLE is None:\n            raise StepFunctionsSchedulingException(\"No IAM role found for AWS \"\n                                                   \"Events Bridge. You can \"\n                                                   \"create one following the \"\n                                                   \"instructions listed at \"\n                                                   \"*https://admin-docs.metaflo\"\n                                                   \"w.org/metaflow-on-aws/deplo\"\n                                                   \"yment-guide/manual-deployme\"\n                                                   \"nt#scheduling* and \"\n                                                   \"re-configure Metaflow \"\n                                                   \"using *metaflow configure \"\n                                                   \"aws* on your terminal.\")\n        try:\n            self.event_bridge_rule = EventBridgeClient(self.name) \\\n                                        .cron(self._cron) \\\n                                        .role_arn(EVENTS_SFN_ACCESS_IAM_ROLE) \\\n                                        .state_machine_arn(self._state_machine_arn) \\\n                                        .schedule()\n        except Exception as e:\n            raise StepFunctionsSchedulingException(repr(e))\n", "docstring": "Scheduling is currently enabled via AWS Event Bridge."}
{"repo": "metaflow-master/metaflow/plugins/aws/step_functions/event_bridge_client.py", "original_string": "    def _set(self):\n        # Generate a new rule or update existing rule.\n        self._client.put_rule(\n            Name=self.name,\n            ScheduleExpression='cron(%s)' % self.cron,\n            Description='Metaflow generated rule for %s' % self.name,\n            State='ENABLED'\n        )\n        # Assign AWS Step Functions ARN to the rule as a target.\n        self._client.put_targets(\n            Rule=self.name,\n            Targets=[\n                {\n                    'Id':self.name,\n                    'Arn':self.state_machine_arn,\n                    # Set input parameters to empty.\n                    'Input':json.dumps({'Parameters':json.dumps({})}),\n                    'RoleArn':self.role_arn\n                }\n            ]\n        )\n", "docstring": "Generate a new rule or update existing rule."}
{"repo": "metaflow-master/metaflow/plugins/aws/batch/batch.py", "original_string": "        def _print_available(tail, stream, should_persist=False):\n            # print the latest batch of lines from S3Tail\n            try:\n                for line in tail:\n                    if should_persist:\n                        line = set_should_persist(line)\n                    else:\n                        line = refine(line, prefix=prefix)\n                    echo(line.strip().decode('utf-8', errors='replace'), stream)\n            except Exception as ex:\n                echo('[ temporary error in fetching logs: %s ]' % ex,\n                     'stderr',\n                     batch_id=self.job.id)\n", "docstring": "print the latest batch of lines from S3Tail"}
{"repo": "metaflow-master/metaflow/plugins/env_escape/server.py", "original_string": "    def encode(self, obj):\n        # This encodes an object to transfer back out\n        # Basic data types will be sent over directly\n        # and other ones will be saved locally and an ID will be returned\n        return self._datatransferer.dump(obj)\n", "docstring": "This encodes an object to transfer back out"}
{"repo": "metaflow-master/metaflow/plugins/env_escape/server.py", "original_string": "    def decode(self, json_obj):\n        # This decodes an object that was transferred in\n        return self._datatransferer.load(json_obj)\n", "docstring": "This decodes an object that was transferred in"}
{"repo": "metaflow-master/metaflow/plugins/env_escape/server.py", "original_string": "    def pickle_object(self, obj):\n        # This function is called to pickle obj to be transferred to the client\n        # when the data layer can't transfer it by itself. We basically will save\n        # locally and transfer an identifier for it\n        identifier = id(obj)\n        mapped_class_name = self._class_types_to_names.get(type(obj))\n        if mapped_class_name is None:\n            raise ValueError(\"Cannot proxy value of type %s\" % type(obj))\n        self._local_objects[identifier] = obj\n        return ObjReference(VALUE_REMOTE, mapped_class_name, identifier)\n", "docstring": "This function is called to pickle obj to be transferred to the client"}
{"repo": "metaflow-master/metaflow/plugins/env_escape/server.py", "original_string": "    def _flatten_dict(d):\n        # Takes a dictionary of (\"name1\", \"name2\"): {\"sub1\": X, \"sub2\": Y} and\n        # returns one of \"name1.sub1\": X, \"name1.sub2\": Y, etc. as well as a\n        # dictionary of aliases {\"name1\": [\"name2\"]}...\n        result = {}\n        aliases = {}\n        for base, values in d.items():\n            if isinstance(base, tuple):\n                aliases[base[0]] = list(base[1:])\n                base = base[0]\n            for name, value in values.items():\n                result[\"%s.%s\" % (base, name)] = value\n        return result, aliases\n", "docstring": "Takes a dictionary of (\"name1\", \"name2\"): {\"sub1\": X, \"sub2\": Y} and"}
{"repo": "metaflow-master/metaflow/plugins/env_escape/client.py", "original_string": "    def stub_request(self, stub, request_type, *args, **kwargs):\n        # Encode the operation to send over the wire and wait for the response\n        target = self.encode(stub)\n        encoded_args = []\n        for arg in args:\n            encoded_args.append(self.encode(arg))\n        encoded_kwargs = []\n        for k, v in kwargs.items():\n            encoded_kwargs.append((self.encode(k), self.encode(v)))\n        response = self._communicate(\n            {\n                FIELD_MSGTYPE: MSG_OP,\n                FIELD_OPTYPE: request_type,\n                FIELD_TARGET: target,\n                FIELD_ARGS: self.encode(args),\n                FIELD_KWARGS: self.encode([(k, v) for k, v in kwargs.items()]),\n            }\n        )\n        response_type = response[FIELD_MSGTYPE]\n        if response_type == MSG_REPLY:\n            return self.decode(response[FIELD_CONTENT])\n        elif response_type == MSG_EXCEPTION:\n            raise load_exception(self._datatransferer, response[FIELD_CONTENT])\n        elif response_type == MSG_INTERNAL_ERROR:\n            raise RuntimeError(\n                \"Error in the server runtime:\\n\\n===== SERVER TRACEBACK =====\\n%s\"\n                % response[FIELD_CONTENT]\n            )\n", "docstring": "Encode the operation to send over the wire and wait for the response"}
{"repo": "metaflow-master/metaflow/plugins/env_escape/client.py", "original_string": "    def decode(self, json_obj):\n        # This decodes an object that was transferred in. This will call\n        # unpickle_object where needed. Any remote object that is handled by\n        # this connection will be converted to a local stub.\n        return self._datatransferer.load(json_obj)\n", "docstring": "This decodes an object that was transferred in. This will call"}
{"repo": "metaflow-master/metaflow/plugins/env_escape/client.py", "original_string": "    def unpickle_object(self, obj):\n        # This function is called when the server sends a remote reference.\n        # We create a local stub for it locally\n        if (not isinstance(obj, ObjReference)) or obj.value_type != VALUE_REMOTE:\n            raise ValueError(\"Invalid transferred object: %s\" % str(obj))\n        remote_class_name = obj.class_name\n        obj_id = obj.identifier\n        local_instance = self._proxied_objects.get(obj_id)\n        if not local_instance:\n            local_class = self.get_local_class(remote_class_name, obj_id)\n            local_instance = local_class(self, remote_class_name, obj_id)\n        return local_instance\n", "docstring": "This function is called when the server sends a remote reference."}
{"repo": "metaflow-master/metaflow/plugins/env_escape/data_transferer.py", "original_string": "    def _load_str(obj_type, transferer, json_annotation, json_obj):\n        # The object is actually bytes\n        return (_load_simple(bytes, json_annotation, json_obj)).decode(\"utf-8\")\n", "docstring": "The object is actually bytes"}
{"repo": "metaflow-master/metaflow/plugins/env_escape/__init__.py", "original_string": "def generate_trampolines(python_path):\n    # This function will look in the configurations directory and create\n    # files named <module>.py that will properly setup the environment escape when\n    # called\n    # in some cases we may want to disable environment escape\n    # functionality, in that case, set METAFLOW_ENV_ESCAPE_DISABLED\n    if os.environ.get('METAFLOW_ENV_ESCAPE_DISABLED', False) in (True, 'True'):\n        return\n    python_interpreter_path = ENV_ESCAPE_PY\n    max_pickle_version = int(ENV_ESCAPE_PICKLE_VERSION)\n    paths = [os.path.dirname(os.path.abspath(__file__)) + \"/configurations\"]\n    try:\n        import metaflow_custom.plugins.env_escape as custom_escape\n    except ImportError as e:\n        ver = sys.version_info[0] * 10 + sys.version_info[1]\n        if ver >= 36:\n            # e.name is set to the name of the package that fails to load\n            # so don't error ONLY IF the error is importing this module (but do\n            # error if there is a transitive import error)\n            if not (isinstance(e, ModuleNotFoundError) and e.name in [\n                    'metaflow_custom', 'metaflow_custom.plugins',\n                    'metaflow_custom.plugins.env_escape']):\n                print(\n                    \"Cannot load metaflow_custom env escape configurations -- \"\n                    \"if you want to ignore, uninstall metaflow_custom package\")\n                raise\n    else:\n        paths.append(os.path.dirname(os.path.abspath(custom_escape.__file__)) +\n                     \"/configurations\")\n    for rootpath in paths:\n        for path in os.listdir(rootpath):\n            path = os.path.join(rootpath, path)\n            if os.path.isdir(path):\n                dir_name = os.path.basename(path)\n                if dir_name.startswith('emulate_'):\n                    module_names = dir_name[8:].split(\"__\")\n                    for module_name in module_names:\n                        with open(os.path.join(\n                                python_path, module_name + \".py\"), mode='w') as f:\n                            f.write(\"\"\"\n", "docstring": "This function will look in the configurations directory and create"}
{"repo": "metaflow-master/metaflow/plugins/env_escape/__init__.py", "original_string": "def load():\n    # We check if we are not overriding a module that already exists; to do so, we remove\n    # the path we live at from sys.path and check\n    old_paths = sys.path\n    cur_path = os.path.dirname(__file__)\n    sys.path = [p for p in old_paths if p != cur_path]\n    # Handle special case where we launch a shell (including with a command)\n    # and we are in the CWD (searched if '' is the first element of sys.path)\n    if cur_path == os.getcwd() and sys.path[0] == '':\n        sys.path = sys.path[1:]\n    # Remove the module (this file) to reload it properly. Do *NOT* update sys.modules but\n    # modify directly since it may be referenced elsewhere\n    del sys.modules[\"{module_name}\"]\n    for prefix in {prefixes}:\n        try:\n            importlib.import_module(prefix)\n        except ImportError:\n            # Here we actually have two cases: we are being imported from the client (inner env)\n            # in which case we are happy (since no module exists) OR we are being imported by the\n            # server in which case we could not find the underlying module so we re-raise\n            # this error.\n            # We distinguish these cases by checking if the executable is the python_path the\n            # server should be using\n            if sys.executable == \"{python_path}\":\n                raise\n            # print(\"Env escape using executable {python_path}\")\n        else:\n            # Inverse logic as above here.\n            if sys.executable == \"{python_path}\":\n                return\n            raise RuntimeError(\"Trying to override '%s' when module exists in system\" % prefix)\n    sys.path = old_paths\n    m = ModuleImporter(\"{python_path}\", {max_pickle_version}, \"{path}\", {prefixes})\n    sys.meta_path.insert(0, m)\n    # Reload this module using the ModuleImporter\n    importlib.import_module(\"{module_name}\")\n", "docstring": "We check if we are not overriding a module that already exists; to do so, we remove"}
{"repo": "metaflow-master/metaflow/plugins/env_escape/communication/bytestream.py", "original_string": "    def __enter__(self):\n        return self\n", "docstring": "return self"}
{"repo": "metaflow-master/metaflow/plugins/env_escape/communication/channel.py", "original_string": "    def recv(self, timeout=None):\n        # To receive, we first receive the size of the object and then the object itself\n        try:\n            sz_bytes = self._stream.read(self._fmt.size, timeout)\n            msg_sz = self._fmt.unpack(sz_bytes)[0]\n            obj_bytes = self._stream.read(msg_sz, timeout)\n            return json.loads(obj_bytes, encoding=\"utf-8\")\n        except EOFError as e:\n            raise RuntimeError(\"Cannot receive object over streaming interface: %s\" % e)\n        except BaseException as e:\n            raise ValueError(\"Cannot deserialize object: %s\" % traceback.format_exc())\n", "docstring": "To receive, we first receive the size of the object and then the object itself"}
{"repo": "metaflow-master/metaflow/plugins/metadata/service.py", "original_string": "    def _get_object_internal(cls, obj_type, obj_order, sub_type, sub_order, filters=None, *args):\n        # Special handling of self, artifact, and metadata\n        if sub_type == 'self':\n            url = ServiceMetadataProvider._obj_path(*args[:obj_order])\n            try:\n                return MetadataProvider._apply_filter([cls._request(None, url)], filters)[0]\n            except ServiceException as ex:\n                if ex.http_code == 404:\n                    return None\n                raise\n        # For the other types, we locate all the objects we need to find and return them\n        if obj_type != 'root':\n            url = ServiceMetadataProvider._obj_path(*args[:obj_order])\n        else:\n            url = ''\n        if sub_type != 'metadata':\n            url += '/%ss' % sub_type\n        else:\n            url += '/metadata'\n        try:\n            return MetadataProvider._apply_filter(cls._request(None, url), filters)\n        except ServiceException as ex:\n            if ex.http_code == 404:\n                return None\n            raise\n", "docstring": "Special handling of self, artifact, and metadata"}
{"repo": "metaflow-master/metaflow/plugins/metadata/local.py", "original_string": "    def new_run_id(self, tags=[], sys_tags=[]):\n        # We currently just use the timestamp to create an ID. We can be reasonably certain\n        # that it is unique and this makes it possible to do without coordination or\n        # reliance on POSIX locks in the filesystem.\n        run_id = '%d' % (time.time() * 1e6)\n        self._new_run(run_id, tags, sys_tags)\n        return run_id\n", "docstring": "We currently just use the timestamp to create an ID. We can be reasonably certain"}
{"repo": "metaflow-master/metaflow/plugins/metadata/local.py", "original_string": "    def _makedirs(path):\n        # this is for python2 compatibility.\n        # Python3 has os.makedirs(exist_ok=True).\n        try:\n            os.makedirs(path)\n        except OSError as x:\n            if x.errno == 17:\n                # Error raised when directory exists\n                return\n            else:\n                raise\n", "docstring": "this is for python2 compatibility."}
{"repo": "metaflow-master/metaflow/plugins/conda/conda.py", "original_string": "    def python(self, env_id):\n        # Get Python interpreter for the conda environment\n        return os.path.join(self._env_path(env_id), 'bin/python')\n", "docstring": "Get Python interpreter for the conda environment"}
{"repo": "metaflow-master/metaflow/plugins/conda/conda.py", "original_string": "    def config(self):\n        # Show conda installation configuration\n        return json.loads(self._call_conda(['config', '--show']))\n", "docstring": "Show conda installation configuration"}
{"repo": "metaflow-master/metaflow/plugins/conda/conda_environment.py", "original_string": "    def bootstrap_commands(self, step_name):\n        # Bootstrap conda and execution environment for step\n        env_id = self._get_env_id(step_name)\n        if env_id is not None:\n            return [\n                    \"echo \\'Bootstrapping environment...\\'\",\n                    \"python -m metaflow.plugins.conda.batch_bootstrap \\\"%s\\\" %s\" % \\\n                        (self.flow.name, env_id),\n                    \"echo \\'Environment bootstrapped.\\'\",\n                ]\n        return []\n", "docstring": "Bootstrap conda and execution environment for step"}
{"repo": "metaflow-master/metaflow/mflog/mflog.py", "original_string": "def set_should_persist(line):\n    # this marker indicates that the logline should be persisted by\n    # the receiver\n    line = to_bytes(line)\n    if is_structured(line) and not line.startswith(b'[!['):\n        return b'[!' + line\n    else:\n        return line\n", "docstring": "this marker indicates that the logline should be persisted by"}
{"repo": "metaflow-master/metaflow/mflog/mflog.py", "original_string": "    def line_iter(logblob):\n        # all valid timestamps are guaranteed to be smaller than\n        # MISSING_TIMESTAMP, hence this iterator maintains the\n        # ascending order even when corrupt loglines are present\n        missing = []\n        for line in to_fileobj(logblob):\n            res = parse(line)\n            if res:\n                yield res.utc_tstamp_str, res\n            else:\n                missing.append(line)\n        for line in missing:\n            res = MFLogline(False,\n                            None,\n                            MISSING_TIMESTAMP_STR,\n                            None,\n                            None,\n                            line,\n                            MISSING_TIMESTAMP)\n            yield res.utc_tstamp_str, res\n", "docstring": "all valid timestamps are guaranteed to be smaller than"}
{"repo": "metaflow-master/metaflow/mflog/__init__.py", "original_string": "def update_delay(secs_since_start):\n    # this sigmoid function reaches\n    # - 0.1 after 11 minutes\n    # - 0.5 after 15 minutes\n    # - 1.0 after 23 minutes\n    # in other words, the user will see very frequent updates\n    # during the first 10 minutes\n    sigmoid = 1. / (1. + math.exp(-0.01 * secs_since_start + 9.))\n    return MIN_UPDATE_DELAY + sigmoid * MAX_UPDATE_DELAY\n", "docstring": "this sigmoid function reaches"}
{"repo": "metaflow-master/metaflow/datatools/s3.py", "original_string": "    def __repr__(self):\n        return str(self)\n", "docstring": "return str(self)"}
{"repo": "metaflow-master/metaflow/datatools/s3.py", "original_string": "        def _info(s3, tmp):\n            resp = s3.head_object(Bucket=src.netloc, Key=src.path.lstrip('/\"'))\n            with open('%s' % tmp, mode='w') as f:\n                args = {\n                    'content_type': resp['ContentType'],\n                    'metadata': resp['Metadata'],\n                    'size': resp['ContentLength']}\n                json.dump(args, f)\n", "docstring": "resp = s3.head_object(Bucket=src.netloc, Key=src.path.lstrip('/\"'))"}
{"repo": "metaflow-master/metaflow/datatools/s3.py", "original_string": "        def _get():\n            res = self._read_many_files('get',\n                                        map(self._url_and_range, keys),\n                                        recursive=True,\n                                        verify=True,\n                                        verbose=False,\n                                        info=return_info,\n                                        listing=True)\n            for s3prefix, s3url, fname in res:\n                if return_info:\n                    # We have a metadata file to read from\n                    with open(os.path.join(self._tmpdir, '%s_meta' % fname),\n                            'r') as f:\n                        info = json.load(f)\n                    yield self._s3root, s3url, os.path.join(self._tmpdir, fname), \\\n                        None, info['content_type'], info['metadata']\n                else:\n                    yield s3prefix, s3url, os.path.join(self._tmpdir, fname)\n", "docstring": "res = self._read_many_files('get',"}
{"repo": "metaflow-master/metaflow/datatools/s3.py", "original_string": "        def _upload(s3, _):\n            # We make sure we are at the beginning in case we are retrying\n            blob.seek(0)\n            s3.upload_fileobj(\n                blob, src.netloc, src.path.lstrip('/'), ExtraArgs=extra_args)\n", "docstring": "We make sure we are at the beginning in case we are retrying"}
{"repo": "metaflow-master/metaflow/datatools/s3.py", "original_string": "            def _head(s3, _):\n                s3.head_object(Bucket=src.netloc, Key=src.path.lstrip('/'))\n", "docstring": "s3.head_object(Bucket=src.netloc, Key=src.path.lstrip('/'))"}
{"repo": "metaflow-master/metaflow/datatools/s3.py", "original_string": "        def _check():\n            for key_path in key_paths:\n                if isinstance(key_path, tuple):\n                    key = key_path[0]\n                    path = key_path[1]\n                else:\n                    key = key_path.key\n                    path = key_path.path\n                store_info = {\n                    'key': key,\n                    'content_type': getattr(key_path, 'content_type', None),\n                }\n                metadata = getattr(key_path, 'metadata', None)\n                if metadata:\n                    store_info['metadata'] = {\n                        'metaflow-user-attributes': json.dumps(metadata)}\n                if not os.path.exists(path):\n                    raise MetaflowS3NotFound(\"Local file not found: %s\" % path)\n                yield path, self._url(key), store_info\n", "docstring": "for key_path in key_paths:"}
{"repo": "metaflow-master/metaflow/datatools/s3op.py", "original_string": "def parallel_op(op, lst, num_workers):\n    # parallel op divides work equally amongst num_workers\n    # processes. This is a good strategy if the cost is\n    # uniform over the units of work, e.g. op_get_info, which\n    # is a single HEAD request to S3.\n    #\n    # This approach is less optimal with op_list_prefix where\n    # the cost of S3 listing per prefix can vary drastically.\n    # We could optimize this case by using a worker model with\n    # a queue, like for downloads but the difference here is\n    # that we need to return a value, which would require a\n    # bit more work - something to consider if this turns out\n    # to be a bottleneck.\n    if lst:\n        num = min(len(lst), num_workers)\n        batch_size = math.ceil(len(lst) / float(num))\n        batches = []\n        it = iter(lst)\n        while True:\n            batch = list(islice(it, batch_size))\n            if batch:\n                batches.append(batch)\n            else:\n                break\n        it = parallel_map(op, batches, max_parallel=num)\n        for x in chain.from_iterable(it):\n            yield x\n", "docstring": "parallel op divides work equally amongst num_workers"}
{"repo": "metaflow-master/metaflow/metadata/metadata.py", "original_string": "    def get_object(cls, obj_type, sub_type, filters=None, *args):\n        '''Returns the requested object depending on obj_type and sub_type\n        obj_type can be one of 'root', 'flow', 'run', 'step', 'task',\n        or 'artifact'\n        sub_type describes the aggregation required and can be either:\n        'metadata', 'self' or any of obj_type provided that it is slotted below\n        the object itself. For example, if obj_type is 'flow', you can\n        specify 'run' to get all the runs in that flow.\n        A few special rules:\n            - 'metadata' is only allowed for obj_type 'task'\n            - For obj_type 'artifact', only 'self' is allowed\n        A few examples:\n            - To get a list of all flows:\n                - set obj_type to 'root' and sub_type to 'flow'\n            - To get a list of all tasks:\n                - set obj_type to 'root' and sub_type to 'task'\n            - To get a list of all artifacts in a task:\n                - set obj_type to 'task' and sub_type to 'artifact'\n            - To get information about a specific flow:\n                - set obj_type to 'flow' and sub_type to 'self'\n        Parameters\n        ----------\n        obj_type : string\n            One of 'root', 'flow', 'run', 'step', 'task', 'artifact' or 'metadata'\n        sub_type : string\n            Same as obj_type with the addition of 'self'\n        filters : dict\n            Dictionary with keys 'any_tags', 'tags' and 'system_tags'. If specified\n            will return only objects that have the specified tags present. Filters\n            are ANDed together so all tags must be present for the object to be returned.\n        Return\n        ------\n            object or list :\n                Depending on the call, the type of object return varies\n        '''\n        obj_order = {\n            'root': 0,\n            'flow': 1,\n            'run': 2,\n            'step': 3,\n            'task': 4,\n            'artifact': 5,\n            'metadata': 6,\n            'self': 7}\n        type_order = obj_order.get(obj_type)\n        sub_order = obj_order.get(sub_type)\n        if type_order is None:\n            raise MetaflowInternalError(msg='Cannot find type %s' % obj_type)\n        if type_order > 5:\n            raise MetaflowInternalError(msg='Type %s is not allowed' % obj_type)\n        if sub_order is None:\n            raise MetaflowInternalError(msg='Cannot find subtype %s' % sub_type)\n        if type_order >= sub_order:\n            raise MetaflowInternalError(msg='Subtype %s not allowed for %s' % (sub_type, obj_type))\n        # Metadata is always only at the task level\n        if sub_type == 'metadata' and obj_type != 'task':\n            raise MetaflowInternalError(msg='Metadata can only be retrieved at the task level')\n        return cls._get_object_internal(obj_type, type_order, sub_type, sub_order, filters, *args)\n", "docstring": "Returns the requested object depending on obj_type and sub_type"}
{"repo": "metaflow-master/metaflow/metadata/metadata.py", "original_string": "    def _flow_to_json(self):\n        # No need to store tags, sys_tags or username at the flow level\n        # since runs are the top level logical concept, which is where we\n        # store tags, sys_tags and username\n        return {\n            'flow_id': self._flow_name,\n            'ts_epoch': int(round(time.time() * 1000))}\n", "docstring": "No need to store tags, sys_tags or username at the flow level"}
{"repo": "metaflow-master/metaflow/datastore/datastore.py", "original_string": "    def __init__(self, flows):\n        # TODO sort by foreach index\n        self.flows = list(flows)\n        for flow in self.flows:\n            setattr(self, flow._current_step, flow)\n", "docstring": "TODO sort by foreach index"}
{"repo": "metaflow-master/metaflow/datastore/datastore.py", "original_string": "    def get_latest_tasks(cls,\n                         flow_name,\n                         run_id=None,\n                         steps=None,\n                         pathspecs=None):\n        \"\"\"\n        Return a list of (step, task, attempt, metadata_blob) for a subset of\n        the tasks (consider eventual consistency) for which the latest attempt\n        is done for the input `flow_name, run_id`.\n        We filter the list based on `steps` if non-None.\n        Alternatively, `pathspecs` can contain the exact list of pathspec(s)\n        (run_id/step_name/task_id) that should be filtered.\n        Note: When `pathspecs` is specified, we expect strict consistency and\n        not eventual consistency in contrast to other modes.\n        \"\"\"\n        raise NotImplementedError()\n", "docstring": "flow_name,"}
{"repo": "metaflow-master/metaflow/datastore/datastore.py", "original_string": "    def make_path(cls,\n                  flow_name,\n                  run_id=None,\n                  step_name=None,\n                  task_id=None,\n                  pathspec=None):\n        \"\"\"\n        Return the path for a given flow using this datastore.\n        path = cls.datastore_root/flow_name/run_id/step_name/task_id\n        Callers are expected to invoke this function with a sequence of non-None\n        values depending on the nested path they want.\n        For example,\n        If run_id is None, return path = cls.datastore_root/flow_name\n        If step_name is None, return path = cls.datastore_root/flow_name/run_id\n        and so on.\n        If pathspec is non None,\n        return path = cls.datastore_root/flow_name/pathspec\n        \"\"\"\n        sysroot = cls.datastore_root\n        if pathspec:\n            return os.path.join(sysroot, flow_name, pathspec)\n        elif flow_name is None:\n            return sysroot\n        elif run_id is None:\n            return os.path.join(sysroot, flow_name)\n        elif step_name is None:\n            return os.path.join(sysroot, flow_name, run_id)\n        elif task_id is None:\n            return os.path.join(sysroot, flow_name, run_id, step_name)\n        else:\n            return os.path.join(sysroot, flow_name, run_id, step_name, task_id)\n", "docstring": "flow_name,"}
{"repo": "metaflow-master/metaflow/datastore/datastore.py", "original_string": "    def init_task(self):\n        # this method should be called once after datastore has been opened\n        # for task-related write operations\n        self.save_metadata('attempt', {'time': time.time()})\n        self.objects = {}\n        self.info = {}\n", "docstring": "this method should be called once after datastore has been opened"}
{"repo": "metaflow-master/metaflow/datastore/datastore.py", "original_string": "    def pathspec(self):\n        return '%s/%s/%s' % (self.run_id, self.step_name, self.task_id)\n", "docstring": "return '%s/%s/%s' % (self.run_id, self.step_name, self.task_id)"}
{"repo": "metaflow-master/metaflow/datastore/datastore.py", "original_string": "    def passdown_partial(self, origin, vars):\n        # Pass-down from datastore origin all information related to vars to\n        # this datastore. In other words, this adds to the current datastore all\n        # the variables in vars (obviously, it does not download them or anything but\n        # records information about them). This is used to propagate parameters between\n        # datastores without actually loading the parameters\n        for var in vars:\n            sha = origin.objects.get(var)\n            if sha:\n                self.objects[var] = sha\n                self.info[var] = origin.info[var]\n", "docstring": "Pass-down from datastore origin all information related to vars to"}
{"repo": "metaflow-master/metaflow/datastore/datastore.py", "original_string": "    def __getitem__(self, var):\n        # backwards compatibility: we might not have info for all objects\n        if not self.info:\n            return None\n        info = self.info.get(var)\n        if info:\n            encoding = info.get('encoding', 'gzip+pickle-v2')\n        else:\n            encoding = 'gzip+pickle-v2'\n        if encoding in self._encodings:\n            return self._load_object(self.objects[var])\n        raise DataException(\"Artifact *%s* requires a newer version \"\n                            \"of Python. Try with Python 3.4 or newer.\" %\n                            var)\n", "docstring": "backwards compatibility: we might not have info for all objects"}
{"repo": "metaflow-master/metaflow/datastore/s3.py", "original_string": "    def reset_client(cls, hard_reset=False):\n        # the s3 client is shared across all S3DataStores\n        # so we don't open N connections to S3 unnecessarily\n        if cls.s3 is None or hard_reset:\n            cls.s3, cls.ClientError = get_s3_client()\n", "docstring": "the s3 client is shared across all S3DataStores"}
{"repo": "metaflow-master/metaflow/datastore/s3.py", "original_string": "    def load_logs(self, logsources, stream, attempt_override=None):\n        urls = [self.get_log_location(source, stream, attempt_override) \n                    for source in logsources]\n        with self.S3() as s3:\n            results = s3.get_many(urls, return_missing=True)\n            blobs = [log.blob if log.exists else b'' for log in results]\n            return list(zip(logsources, blobs))\n", "docstring": "urls = [self.get_log_location(source, stream, attempt_override)"}
{"repo": "metaflow-master/metaflow/datastore/local.py", "original_string": "    def get_datastore_root_from_config(cls, echo, create_on_absent=True):\n        # Compute path for DATASTORE_SYSROOT_LOCAL\n        result = DATASTORE_SYSROOT_LOCAL\n        if result is None:\n            try:\n                # Python2\n                current_path = os.getcwdu()\n            except: # noqa E722\n                current_path = os.getcwd()\n            check_dir = os.path.join(current_path, DATASTORE_LOCAL_DIR)\n            check_dir = os.path.realpath(check_dir)\n            orig_path = check_dir\n            top_level_reached = False\n            while not os.path.isdir(check_dir):\n                new_path = os.path.dirname(current_path)\n                if new_path == current_path:\n                    top_level_reached = True\n                    break  # We are no longer making upward progress\n                current_path = new_path\n                check_dir = os.path.join(current_path, DATASTORE_LOCAL_DIR)\n            if top_level_reached:\n                if create_on_absent:\n                    # Could not find any directory to use so create a new one\n                    echo('Creating local datastore in current directory (%s)' % orig_path,\n                         fg='magenta', bold=True)\n                    os.mkdir(orig_path)\n                    result = orig_path\n                else:\n                    return None\n            else:\n                result = check_dir\n        else:\n            result = os.path.join(result, DATASTORE_LOCAL_DIR)\n        return result\n", "docstring": "Compute path for DATASTORE_SYSROOT_LOCAL"}
{"repo": "metaflow-master/metaflow/datastore/local.py", "original_string": "    def has_metadata(self, name, with_attempt=True):\n        attempt = self.attempt if with_attempt else None\n        filename = self.filename_with_attempt_prefix('%s.json' % name, attempt)\n        path = os.path.join(self.root, filename)\n        return os.path.exists(path)\n", "docstring": "attempt = self.attempt if with_attempt else None"}
{"repo": "scikit-optimize-master/skopt/benchmarks.py", "original_string": "def bench1(x):\n    \"\"\"A benchmark function for test purposes.\n        f(x) = x ** 2\n    It has a single minima with f(x*) = 0 at x* = 0.\n    \"\"\"\n    return x[0] ** 2\n", "docstring": "A benchmark function for test purposes."}
{"repo": "scikit-optimize-master/skopt/benchmarks.py", "original_string": "def bench2(x):\n    \"\"\"A benchmark function for test purposes.\n        f(x) = x ** 2           if x < 0\n               (x-5) ** 2 - 5   otherwise.\n    It has a global minima with f(x*) = -5 at x* = 5.\n    \"\"\"\n    if x[0] < 0:\n        return x[0] ** 2\n    else:\n        return (x[0] - 5) ** 2 - 5\n", "docstring": "A benchmark function for test purposes."}
{"repo": "scikit-optimize-master/skopt/benchmarks.py", "original_string": "def bench4(x):\n    \"\"\"A benchmark function for test purposes.\n        f(x) = float(x) ** 2\n    where x is a string. It has a single minima with f(x*) = 0 at x* = \"0\".\n    This benchmark is used for checking support of categorical variables.\n    \"\"\"\n    return float(x[0]) ** 2\n", "docstring": "A benchmark function for test purposes."}
{"repo": "scikit-optimize-master/skopt/callbacks.py", "original_string": "    def __init__(self, n_total, n_init=0, n_random=0):\n        self.n_init = n_init\n        self.n_random = n_random\n        self.n_total = n_total\n        self.iter_no = 1\n        self._start_time = time()\n        self._print_info(start=True)\n", "docstring": "self.n_init = n_init"}
{"repo": "scikit-optimize-master/skopt/callbacks.py", "original_string": "    def __init__(self):\n        self._time = time()\n        self.iter_time = []\n", "docstring": "self._time = time()"}
{"repo": "scikit-optimize-master/skopt/callbacks.py", "original_string": "    def __init__(self, delta):\n        super(EarlyStopper, self).__init__()\n        self.delta = delta\n", "docstring": "super(EarlyStopper, self).__init__()"}
{"repo": "scikit-optimize-master/skopt/utils.py", "original_string": "def is_listlike(x):\n    return isinstance(x, (list, tuple))\n", "docstring": "return isinstance(x, (list, tuple))"}
{"repo": "scikit-optimize-master/skopt/utils.py", "original_string": "def dimensions_aslist(search_space):\n    \"\"\"Convert a dict representation of a search space into a list of\n    dimensions, ordered by sorted(search_space.keys()).\n    Parameters\n    ----------\n    search_space : dict\n        Represents search space. The keys are dimension names (strings)\n        and values are instances of classes that inherit from the class\n        :class:`skopt.space.Dimension` (Real, Integer or Categorical)\n    Returns\n    -------\n    params_space_list: list\n        list of skopt.space.Dimension instances.\n    Examples\n    --------\n    >>> from skopt.space.space import Real, Integer\n    >>> from skopt.utils import dimensions_aslist\n    >>> search_space = {'name1': Real(0,1),\n    ...                 'name2': Integer(2,4), 'name3': Real(-1,1)}\n    >>> dimensions_aslist(search_space)[0]\n    Real(low=0, high=1, prior='uniform', transform='identity')\n    >>> dimensions_aslist(search_space)[1]\n    Integer(low=2, high=4, prior='uniform', transform='identity')\n    >>> dimensions_aslist(search_space)[2]\n    Real(low=-1, high=1, prior='uniform', transform='identity')\n    \"\"\"\n    params_space_list = [\n        search_space[k] for k in sorted(search_space.keys())\n    ]\n    return params_space_list\n", "docstring": "Convert a dict representation of a search space into a list of"}
{"repo": "scikit-optimize-master/skopt/utils.py", "original_string": "def point_aslist(search_space, point_as_dict):\n    \"\"\"Convert a dictionary representation of a point from a search space to\n    the list representation. The list of values is created from the values of\n    the dictionary, sorted by the names of dimensions used as keys.\n    .. seealso:: :class:`skopt.utils.point_asdict`\n    Parameters\n    ----------\n    search_space : dict\n        Represents search space. The keys are dimension names (strings)\n        and values are instances of classes that inherit from the class\n        :class:`skopt.space.Dimension` (Real, Integer or Categorical)\n    point_as_dict : dict\n        dict with parameter names as keys to which corresponding\n        parameter values are assigned.\n    Returns\n    -------\n    point_as_list : list\n        list with point values.The order of\n        parameters in the list is given by sorted(params_space.keys()).\n    Examples\n    --------\n    >>> from skopt.space.space import Real, Integer\n    >>> from skopt.utils import point_aslist\n    >>> search_space = {'name1': Real(0,1),\n    ...                 'name2': Integer(2,4), 'name3': Real(-1,1)}\n    >>> point_as_dict = {'name1': 0.66, 'name2': 3, 'name3': -0.15}\n    >>> point_aslist(search_space, point_as_dict)\n    [0.66, 3, -0.15]\n    \"\"\"\n    point_as_list = [\n        point_as_dict[k] for k in sorted(search_space.keys())\n    ]\n    return point_as_list\n", "docstring": "Convert a dictionary representation of a point from a search space to"}
{"repo": "scikit-optimize-master/skopt/searchcv.py", "original_string": "    def _step(self, search_space, optimizer, evaluate_candidates, n_points=1):\n        \"\"\"Generate n_jobs parameters and evaluate them in parallel.\n        \"\"\"\n        # get parameter values to evaluate\n        params = optimizer.ask(n_points=n_points)\n        # convert parameters to python native types\n        params = [[np.array(v).item() for v in p] for p in params]\n        # make lists into dictionaries\n        params_dict = [point_asdict(search_space, p) for p in params]\n        all_results = evaluate_candidates(params_dict)\n        # Feed the point and objective value back into optimizer\n        # Optimizer minimizes objective, hence provide negative score\n        local_results = all_results[\"mean_test_score\"][-len(params):]\n        return optimizer.tell(params, [-score for score in local_results])\n", "docstring": "Generate n_jobs parameters and evaluate them in parallel."}
{"repo": "scikit-optimize-master/skopt/searchcv.py", "original_string": "    def fit(self, X, y=None, *, groups=None, callback=None, **fit_params):\n        \"\"\"Run fit on the estimator with randomly drawn parameters.\n        Parameters\n        ----------\n        X : array-like or sparse matrix, shape = [n_samples, n_features]\n            The training input samples.\n        y : array-like, shape = [n_samples] or [n_samples, n_output]\n            Target relative to X for classification or regression (class\n            labels should be integers or strings).\n        groups : array-like, with shape (n_samples,), optional\n            Group labels for the samples used while splitting the dataset into\n            train/test set.\n        callback: [callable, list of callables, optional]\n            If callable then `callback(res)` is called after each parameter\n            combination tested. If list of callables, then each callable in\n            the list is called.\n        \"\"\"\n        self._callbacks = check_callback(callback)\n        if self.optimizer_kwargs is None:\n            self.optimizer_kwargs_ = {}\n        else:\n            self.optimizer_kwargs_ = dict(self.optimizer_kwargs)\n        super().fit(X=X, y=y, groups=groups, **fit_params)\n        # BaseSearchCV never ranked train scores,\n        # but apparently we used to ship this (back-compat)\n        if self.return_train_score:\n            self.cv_results_[\"rank_train_score\"] = \\\n                rankdata(-np.array(self.cv_results_[\"mean_train_score\"]),\n                         method='min').astype(int)\n        return self\n", "docstring": "Run fit on the estimator with randomly drawn parameters."}
{"repo": "scikit-optimize-master/skopt/optimizer/optimizer.py", "original_string": "    def tell(self, x, y, fit=True):\n        \"\"\"Record an observation (or several) of the objective function.\n        Provide values of the objective function at points suggested by\n        `ask()` or other points. By default a new model will be fit to all\n        observations. The new model is used to suggest the next point at\n        which to evaluate the objective. This point can be retrieved by calling\n        `ask()`.\n        To add observations without fitting a new model set `fit` to False.\n        To add multiple observations in a batch pass a list-of-lists for `x`\n        and a list of scalars for `y`.\n        Parameters\n        ----------\n        x : list or list-of-lists\n            Point at which objective was evaluated.\n        y : scalar or list\n            Value of objective at `x`.\n        fit : bool, default: True\n            Fit a model to observed evaluations of the objective. A model will\n            only be fitted after `n_initial_points` points have been told to\n            the optimizer irrespective of the value of `fit`.\n        \"\"\"\n        check_x_in_space(x, self.space)\n        self._check_y_is_valid(x, y)\n        # take the logarithm of the computation times\n        if \"ps\" in self.acq_func:\n            if is_2Dlistlike(x):\n                y = [[val, log(t)] for (val, t) in y]\n            elif is_listlike(x):\n                y = list(y)\n                y[1] = log(y[1])\n        return self._tell(x, y, fit=fit)\n", "docstring": "Record an observation (or several) of the objective function."}
{"repo": "scikit-optimize-master/skopt/optimizer/optimizer.py", "original_string": "    def _check_y_is_valid(self, x, y):\n        \"\"\"Check if the shape and types of x and y are consistent.\"\"\"\n        if \"ps\" in self.acq_func:\n            if is_2Dlistlike(x):\n                if not (np.ndim(y) == 2 and np.shape(y)[1] == 2):\n                    raise TypeError(\"expected y to be a list of (func_val, t)\")\n            elif is_listlike(x):\n                if not (np.ndim(y) == 1 and len(y) == 2):\n                    raise TypeError(\"expected y to be (func_val, t)\")\n        # if y isn't a scalar it means we have been handed a batch of points\n        elif is_listlike(y) and is_2Dlistlike(x):\n            for y_value in y:\n                if not isinstance(y_value, Number):\n                    raise ValueError(\"expected y to be a list of scalars\")\n        elif is_listlike(x):\n            if not isinstance(y, Number):\n                raise ValueError(\"`func` should return a scalar\")\n        else:\n            raise ValueError(\"Type of arguments `x` (%s) and `y` (%s) \"\n                             \"not compatible.\" % (type(x), type(y)))\n", "docstring": "Check if the shape and types of x and y are consistent.\n"}
{"repo": "scikit-optimize-master/skopt/optimizer/optimizer.py", "original_string": "    def update_next(self):\n        \"\"\"Updates the value returned by opt.ask(). Useful if a parameter\n        was updated after ask was called.\"\"\"\n        self.cache_ = {}\n        # Ask for a new next_x.\n        # We only need to overwrite _next_x if it exists.\n        if hasattr(self, '_next_x'):\n            opt = self.copy(random_state=self.rng)\n            self._next_x = opt._next_x\n", "docstring": "Updates the value returned by opt.ask(). Useful if a parameter"}
{"repo": "scikit-optimize-master/skopt/learning/forest.py", "original_string": "    def __init__(self, n_estimators=10, criterion='mse', max_depth=None,\n                 min_samples_split=2, min_samples_leaf=1,\n                 min_weight_fraction_leaf=0.0, max_features='auto',\n                 max_leaf_nodes=None, min_impurity_decrease=0.,\n                 bootstrap=True, oob_score=False,\n                 n_jobs=1, random_state=None, verbose=0, warm_start=False,\n                 min_variance=0.0):\n        self.min_variance = min_variance\n        super(RandomForestRegressor, self).__init__(\n            n_estimators=n_estimators, criterion=criterion,\n            max_depth=max_depth,\n            min_samples_split=min_samples_split,\n            min_samples_leaf=min_samples_leaf,\n            min_weight_fraction_leaf=min_weight_fraction_leaf,\n            max_features=max_features, max_leaf_nodes=max_leaf_nodes,\n            min_impurity_decrease=min_impurity_decrease,\n            bootstrap=bootstrap, oob_score=oob_score,\n            n_jobs=n_jobs, random_state=random_state,\n            verbose=verbose, warm_start=warm_start)\n", "docstring": "min_samples_split=2, min_samples_leaf=1,"}
{"repo": "scikit-optimize-master/skopt/learning/gaussian_process/gpr.py", "original_string": "            def optimizer(obj_func, initial_theta, bounds):\n                # * 'obj_func' is the objective function to be maximized, which\n                #   takes the hyperparameters theta as parameter and an\n                #   optional flag eval_gradient, which determines if the\n                #   gradient is returned additionally to the function value\n                # * 'initial_theta': the initial value for theta, which can be\n                #   used by local optimizers\n                # * 'bounds': the bounds on the values of theta\n                ....\n                # Returned are the best found hyperparameters theta and\n                # the corresponding value of the target function.\n                return theta_opt, func_min\n", "docstring": "* 'obj_func' is the objective function to be maximized, which"}
{"repo": "scikit-optimize-master/skopt/learning/gaussian_process/gpr.py", "original_string": "    def __init__(self, kernel=None, alpha=1e-10,\n                 optimizer=\"fmin_l_bfgs_b\", n_restarts_optimizer=0,\n                 normalize_y=False, copy_X_train=True, random_state=None,\n                 noise=None):\n        self.noise = noise\n        super(GaussianProcessRegressor, self).__init__(\n            kernel=kernel, alpha=alpha, optimizer=optimizer,\n            n_restarts_optimizer=n_restarts_optimizer,\n            normalize_y=normalize_y, copy_X_train=copy_X_train,\n            random_state=random_state)\n", "docstring": "optimizer=\"fmin_l_bfgs_b\", n_restarts_optimizer=0,"}
{"repo": "scikit-optimize-master/skopt/learning/gaussian_process/kernels.py", "original_string": "    def gradient_x(self, x, X_train):\n        # diff = (x - X) / length_scale\n        # size = (n_train_samples, n_dimensions)\n        x = np.asarray(x)\n        X_train = np.asarray(X_train)\n        length_scale = np.asarray(self.length_scale)\n        diff = x - X_train\n        diff /= length_scale\n        # e = -exp(0.5 * \\sum_{i=1}^d (diff ** 2))\n        # size = (n_train_samples, 1)\n        exp_diff_squared = np.sum(diff**2, axis=1)\n        exp_diff_squared *= -0.5\n        exp_diff_squared = np.exp(exp_diff_squared, exp_diff_squared)\n        exp_diff_squared = np.expand_dims(exp_diff_squared, axis=1)\n        exp_diff_squared *= -1\n        # gradient = (e * diff) / length_scale\n        gradient = exp_diff_squared * diff\n        gradient /= length_scale\n        return gradient\n", "docstring": "diff = (x - X) / length_scale"}
{"repo": "scikit-optimize-master/skopt/learning/gaussian_process/tests/test_gpr.py", "original_string": "def predict_wrapper(X, gpr):\n    \"\"\"Predict that can handle 1-D input\"\"\"\n    X = np.expand_dims(X, axis=0)\n    return gpr.predict(X, return_std=True)\n", "docstring": "Predict that can handle 1-D input\n"}
{"repo": "scikit-optimize-master/skopt/learning/gaussian_process/tests/test_kernels.py", "original_string": "def test_distance_string():\n    # Inspired by test_hamming_string_array in scipy.tests.test_distance\n    a = np.array(['eggs', 'spam', 'spam', 'eggs', 'spam', 'spam', 'spam',\n                  'spam', 'spam', 'spam', 'spam', 'eggs', 'eggs', 'spam',\n                  'eggs', 'eggs', 'eggs', 'eggs', 'eggs', 'spam'],\n                 dtype='|S4')\n    b = np.array(['eggs', 'spam', 'spam', 'eggs', 'eggs', 'spam', 'spam',\n                  'spam', 'spam', 'eggs', 'spam', 'eggs', 'spam', 'eggs',\n                  'spam', 'spam', 'eggs', 'spam', 'spam', 'eggs'],\n                 dtype='|S4')\n    true_values = np.array([[0, 0.45], [0.45, 0]])\n    X = np.vstack((a, b))\n    hm = HammingKernel()\n    assert_array_almost_equal(-np.log(hm(X)) / 20.0, true_values)\n", "docstring": "Inspired by test_hamming_string_array in scipy.tests.test_distance"}
{"repo": "scikit-optimize-master/skopt/learning/gaussian_process/tests/test_kernels.py", "original_string": "def test_isotropic_kernel():\n    rng = np.random.RandomState(0)\n    X = rng.randint(0, 4, (5, 3))\n    hm = HammingKernel()\n    # Scipy calulates the mean. We need exp(-sum)\n    hamming_distance = squareform(pdist(X, metric='hamming'))\n    scipy_dist = np.exp(-hamming_distance * X.shape[1])\n    assert_array_almost_equal(scipy_dist, hm(X))\n", "docstring": "rng = np.random.RandomState(0)"}
{"repo": "scikit-optimize-master/skopt/learning/tests/test_gbrt.py", "original_string": "def test_gbrt_gaussian():\n    # estimate quantiles of the normal distribution\n    rng = np.random.RandomState(1)\n    N = 10000\n    X = np.ones((N, 1))\n    y = rng.normal(size=N)\n    rgr = GradientBoostingQuantileRegressor()\n    rgr.fit(X, y)\n    estimates = rgr.predict(X, return_quantiles=True)\n    assert_almost_equal(stats.norm.ppf(rgr.quantiles),\n                        np.mean(estimates, axis=0),\n                        decimal=2)\n", "docstring": "estimate quantiles of the normal distribution"}
{"repo": "scikit-optimize-master/skopt/learning/tests/test_gbrt.py", "original_string": "def test_gbrt_with_std():\n    # simple test of the interface\n    rng = np.random.RandomState(1)\n    X = rng.uniform(0, 5, 500)[:, np.newaxis]\n    noise_level = 0.5\n    y = truth(X) + rng.normal(0, noise_level, len(X))\n    X_ = np.linspace(0, 5, 1000)[:, np.newaxis]\n    model = GradientBoostingQuantileRegressor()\n    model.fit(X, y)\n    # three quantiles, so three numbers per sample\n    assert_array_equal(model.predict(X_, return_quantiles=True).shape,\n                       (len(X_), 3))\n    # \"traditional\" API which returns one number per sample, in this case\n    # just the median/mean\n    assert_array_equal(model.predict(X_).shape, (len(X_)))\n    l, c, h = model.predict(X_, return_quantiles=True).T\n    assert_equal(l.shape, c.shape)\n    assert_equal(c.shape, h.shape)\n    assert_equal(l.shape[0], X_.shape[0])\n    mean, std = model.predict(X_, return_std=True)\n    assert_array_equal(mean, c)\n    assert_array_equal(std, (h - l) / 2.0)\n", "docstring": "simple test of the interface"}
{"repo": "scikit-optimize-master/skopt/learning/tests/test_forest.py", "original_string": "def test_random_forest():\n    # toy sample\n    X = [[-2, -1], [-1, -1], [-1, -2], [1, 1], [1, 2], [2, 1]]\n    y = [-1, -1, -1, 1, 1, 1]\n    T = [[-1, -1], [2, 2], [3, 2]]\n    true_result = [-1, 1, 1]\n    clf = RandomForestRegressor(n_estimators=10, random_state=1)\n    clf.fit(X, y)\n    assert_array_equal(clf.predict(T), true_result)\n    assert 10 == len(clf)\n    clf = RandomForestRegressor(n_estimators=10, min_impurity_decrease=0.1,\n                                random_state=1)\n    clf.fit(X, y)\n    assert_array_equal(clf.predict(T), true_result)\n    assert 10 == len(clf)\n    clf = RandomForestRegressor(n_estimators=10, criterion=\"mse\",\n                                max_depth=None, min_samples_split=2,\n                                min_samples_leaf=1,\n                                min_weight_fraction_leaf=0.,\n                                max_features=\"auto\", max_leaf_nodes=None,\n                                min_impurity_decrease=0., bootstrap=True,\n                                oob_score=False,\n                                n_jobs=1, random_state=1,\n                                verbose=0, warm_start=False)\n    clf.fit(X, y)\n    assert_array_equal(clf.predict(T), true_result)\n    assert 10 == len(clf)\n    clf = RandomForestRegressor(n_estimators=10, max_features=1,\n                                random_state=1)\n    clf.fit(X, y)\n    assert_array_equal(clf.predict(T), true_result)\n    assert 10 == len(clf)\n    # also test apply\n    leaf_indices = clf.apply(X)\n    assert leaf_indices.shape == (len(X), clf.n_estimators)\n", "docstring": "toy sample"}
{"repo": "scikit-optimize-master/skopt/sampler/halton.py", "original_string": "def _van_der_corput_samples(idx, number_base=2):\n    \"\"\"Create `Van Der Corput` low discrepancy sequence samples.\n    A van der Corput sequence is an example of the simplest one-dimensional\n    low-discrepancy sequence over the unit interval; it was first described in\n    1935 by the Dutch mathematician J. G. van der Corput. It is constructed by\n    reversing the base-n representation of the sequence of natural numbers\n    (1, 2, 3, ...).\n    In practice, use Halton sequence instead of Van Der Corput, as it is the\n    same, but generalized to work in multiple dimensions.\n    Parameters\n    ----------\n    idx (int, numpy.ndarray):\n        The index of the sequence. If array is provided, all values in\n        array is returned.\n    number_base : int\n        The numerical base from where to create the samples from.\n    Returns\n    -------\n    float, numpy.ndarray\n        Van der Corput samples.\n    \"\"\"\n    assert number_base > 1\n    idx = np.asarray(idx).flatten()\n    out = np.zeros(len(idx), dtype=float)\n    base = float(number_base)\n    active = np.ones(len(idx), dtype=bool)\n    while np.any(active):\n        out[active] += (idx[active] % number_base)/base\n        idx //= number_base\n        base *= number_base\n        active = idx > 0\n    return out\n", "docstring": "Create `Van Der Corput` low discrepancy sequence samples."}
{"repo": "scikit-optimize-master/skopt/sampler/sobol.py", "original_string": "    def generate(self, dimensions, n_samples, random_state=None):\n        \"\"\"Creates samples from Sobol' set.\n        Parameters\n        ----------\n        dimensions : list, shape (n_dims,)\n            List of search space dimensions.\n            Each search dimension can be defined either as\n            - a `(lower_bound, upper_bound)` tuple (for `Real` or `Integer`\n              dimensions),\n            - a `(lower_bound, upper_bound, \"prior\")` tuple (for `Real`\n              dimensions),\n            - as a list of categories (for `Categorical` dimensions), or\n            - an instance of a `Dimension` object (`Real`, `Integer` or\n              `Categorical`).\n        n_samples : int\n            The order of the Sobol' sequence. Defines the number of samples.\n        random_state : int, RandomState instance, or None (default)\n            Set random state to something other than None for reproducible\n            results.\n        Returns\n        -------\n        sample : array_like (n_samples, dim)\n            Sobol' set.\n        \"\"\"\n        total_n_samples = self.num_generated + n_samples\n        if not (total_n_samples & (total_n_samples - 1) == 0):\n            warnings.warn(\"The balance properties of Sobol' points require \"\n                          \"n to be a power of 2. {0} points have been \"\n                          \"previously generated, then: n={0}+{1}={2}. \"\n                          .format(self.num_generated, n_samples,\n                                  total_n_samples))\n        if self.skip != 0 and total_n_samples > self.skip:\n            raise ValueError(f\"{self.skip} points have been skipped: \"\n                             f\"generating \"\n                             f\"{n_samples} more points would cause the \"\n                             f\"sequence to repeat.\")\n        rng = check_random_state(random_state)\n        space = Space(dimensions)\n        n_dim = space.n_dims\n        transformer = space.get_transformer()\n        space.set_transformer(\"normalize\")\n        r = np.full((n_samples, n_dim), np.nan)\n        seed = self.skip\n        for j in range(n_samples):\n            r[j, 0:n_dim], seed = self._sobol(n_dim, seed)\n        if self.randomize:\n            r = _random_shift(r, rng)\n        r = space.inverse_transform(r)\n        space.set_transformer(transformer)\n        self.num_generated += n_samples\n        return r\n", "docstring": "Creates samples from Sobol' set."}
{"repo": "scikit-optimize-master/skopt/sampler/sobol.py", "original_string": "def _bit_hi1(n):\n    \"\"\"Returns the position of the high 1 bit base 2 in an integer.\n    Parameters\n    ----------\n    n : int\n        Input, should be positive.\n    \"\"\"\n    bin_repr = np.binary_repr(n)\n    most_left_one = bin_repr.find('1')\n    if most_left_one == -1:\n        return 0\n    else:\n        return len(bin_repr) - most_left_one\n", "docstring": "Returns the position of the high 1 bit base 2 in an integer."}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def rvs(self, n_samples=1, random_state=None):\n        \"\"\"Draw random samples.\n        Parameters\n        ----------\n        n_samples : int or None\n            The number of samples to be drawn.\n        random_state : int, RandomState instance, or None (default)\n            Set random state to something other than None for reproducible\n            results.\n        \"\"\"\n        rng = check_random_state(random_state)\n        samples = self._rvs.rvs(size=n_samples, random_state=rng)\n        return self.inverse_transform(samples)\n", "docstring": "Draw random samples."}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def inverse_transform(self, Xt):\n        \"\"\"Inverse transform samples from the warped space back into the\n           original space.\n        \"\"\"\n        return self.transformer.inverse_transform(Xt)\n", "docstring": "Inverse transform samples from the warped space back into the"}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def inverse_transform(self, Xt):\n        \"\"\"Inverse transform samples from the warped space back into the\n           original space.\n        \"\"\"\n        inv_transform = super(Real, self).inverse_transform(Xt)\n        if isinstance(inv_transform, list):\n            inv_transform = np.array(inv_transform)\n        inv_transform = np.clip(inv_transform,\n                                self.low, self.high).astype(self.dtype)\n        if self.dtype == float or self.dtype == 'float':\n            # necessary, otherwise the type is converted to a numpy type\n            return getattr(inv_transform, \"tolist\", lambda: value)()\n        else:\n            return inv_transform\n", "docstring": "Inverse transform samples from the warped space back into the"}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def inverse_transform(self, Xt):\n        \"\"\"Inverse transform samples from the warped space back into the\n           original space.\n        \"\"\"\n        # The concatenation of all transformed dimensions makes Xt to be\n        # of type float, hence the required cast back to int.\n        inv_transform = super(Integer, self).inverse_transform(Xt)\n        if isinstance(inv_transform, list):\n            inv_transform = np.array(inv_transform)\n        inv_transform = np.clip(inv_transform,\n                                self.low, self.high)\n        if self.dtype == int or self.dtype == 'int':\n            # necessary, otherwise the type is converted to a numpy type\n            return getattr(np.round(inv_transform).astype(self.dtype),\n                           \"tolist\", lambda: value)()\n        else:\n            return np.round(inv_transform).astype(self.dtype)\n", "docstring": "Inverse transform samples from the warped space back into the"}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def inverse_transform(self, Xt):\n        \"\"\"Inverse transform samples from the warped space back into the\n           original space.\n        \"\"\"\n        # The concatenation of all transformed dimensions makes Xt to be\n        # of type float, hence the required cast back to int.\n        inv_transform = super(Categorical, self).inverse_transform(Xt)\n        if isinstance(inv_transform, list):\n            inv_transform = np.array(inv_transform)\n        return inv_transform\n", "docstring": "Inverse transform samples from the warped space back into the"}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def from_yaml(cls, yml_path, namespace=None):\n        \"\"\"Create Space from yaml configuration file\n        Parameters\n        ----------\n        yml_path : str\n            Full path to yaml configuration file, example YaML below:\n            Space:\n            - Integer:\n              low: -5\n              high: 5\n            - Categorical:\n              categories:\n              - a\n              - b\n            - Real:\n              low: 1.0\n              high: 5.0\n              prior: log-uniform\n        namespace : str, default=None\n           Namespace within configuration file to use, will use first\n           namespace if not provided\n        Returns\n        -------\n        space : Space\n           Instantiated Space object\n        \"\"\"\n        with open(yml_path, 'rb') as f:\n            config = yaml.safe_load(f)\n        dimension_classes = {'real': Real,\n                             'integer': Integer,\n                             'categorical': Categorical}\n        # Extract space options for configuration file\n        if isinstance(config, dict):\n            if namespace is None:\n                options = next(iter(config.values()))\n            else:\n                options = config[namespace]\n        elif isinstance(config, list):\n            options = config\n        else:\n            raise TypeError('YaML does not specify a list or dictionary')\n        # Populate list with Dimension objects\n        dimensions = []\n        for option in options:\n            key = next(iter(option.keys()))\n            # Make configuration case insensitive\n            dimension_class = key.lower()\n            values = {k.lower(): v for k, v in option[key].items()}\n            if dimension_class in dimension_classes:\n                # Instantiate Dimension subclass and add it to the list\n                dimension = dimension_classes[dimension_class](**values)\n                dimensions.append(dimension)\n        space = cls(dimensions=dimensions)\n        return space\n", "docstring": "Create Space from yaml configuration file"}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def set_transformer(self, transform):\n        \"\"\"Sets the transformer of all dimension objects to `transform`\n        Parameters\n        ----------\n        transform : str or list of str\n           Sets all transformer,, when `transform`  is a string.\n           Otherwise, transform must be a list with strings with\n           the same length as `dimensions`\n        \"\"\"\n        # Transform\n        for j in range(self.n_dims):\n            if isinstance(transform, list):\n                self.dimensions[j].set_transformer(transform[j])\n            else:\n                self.dimensions[j].set_transformer(transform)\n", "docstring": "Sets the transformer of all dimension objects to `transform`"}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def get_transformer(self):\n        \"\"\"Returns all transformers as list\"\"\"\n        return [self.dimensions[j].transform_ for j in range(self.n_dims)]\n", "docstring": "Returns all transformers as list\n"}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def inverse_transform(self, Xt):\n        \"\"\"Inverse transform samples from the warped space back to the\n           original space.\n        Parameters\n        ----------\n        Xt : array of floats, shape=(n_samples, transformed_n_dims)\n            The samples to inverse transform.\n        Returns\n        -------\n        X : list of lists, shape=(n_samples, n_dims)\n            The original samples.\n        \"\"\"\n        # Inverse transform\n        columns = []\n        start = 0\n        Xt = np.asarray(Xt)\n        for j in range(self.n_dims):\n            dim = self.dimensions[j]\n            offset = dim.transformed_size\n            if offset == 1:\n                columns.append(dim.inverse_transform(Xt[:, start]))\n            else:\n                columns.append(\n                    dim.inverse_transform(Xt[:, start:start + offset]))\n            start += offset\n        # Transpose\n        return _transpose_list_array(columns)\n", "docstring": "Inverse transform samples from the warped space back to the"}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def n_dims(self):\n        \"\"\"The dimensionality of the original space.\"\"\"\n        return len(self.dimensions)\n", "docstring": "The dimensionality of the original space.\n"}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def transformed_n_dims(self):\n        \"\"\"The dimensionality of the warped space.\"\"\"\n        return sum([dim.transformed_size for dim in self.dimensions])\n", "docstring": "The dimensionality of the warped space.\n"}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def bounds(self):\n        \"\"\"The dimension bounds, in the original space.\"\"\"\n        b = []\n        for dim in self.dimensions:\n            if dim.size == 1:\n                b.append(dim.bounds)\n            else:\n                b.extend(dim.bounds)\n        return b\n", "docstring": "The dimension bounds, in the original space.\n"}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def transformed_bounds(self):\n        \"\"\"The dimension bounds, in the warped space.\"\"\"\n        b = []\n        for dim in self.dimensions:\n            if dim.transformed_size == 1:\n                b.append(dim.transformed_bounds)\n            else:\n                b.extend(dim.transformed_bounds)\n        return b\n", "docstring": "The dimension bounds, in the warped space.\n"}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def is_categorical(self):\n        \"\"\"Space contains exclusively categorical dimensions\"\"\"\n        return all([isinstance(dim, Categorical) for dim in self.dimensions])\n", "docstring": "Space contains exclusively categorical dimensions\n"}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def is_partly_categorical(self):\n        \"\"\"Space contains any categorical dimensions\"\"\"\n        return any([isinstance(dim, Categorical) for dim in self.dimensions])\n", "docstring": "Space contains any categorical dimensions\n"}
{"repo": "scikit-optimize-master/skopt/space/space.py", "original_string": "    def n_constant_dimensions(self):\n        \"\"\"Returns the number of constant dimensions which have zero degree of\n        freedom, e.g. an Integer dimensions with (0., 0.) as bounds.\n        \"\"\"\n        n = 0\n        for dim in self.dimensions:\n            if dim.is_constant:\n                n += 1\n        return n\n", "docstring": "Returns the number of constant dimensions which have zero degree of"}
{"repo": "scikit-optimize-master/skopt/space/transformers.py", "original_string": "    def transform(self, X):\n        \"\"\"Transform an array of categories to a string encoded representation.\n        Parameters\n        ----------\n        X : array-like, shape=(n_samples,)\n            List of categories.\n        Returns\n        -------\n        Xt : array-like, shape=(n_samples,)\n            The string encoded categories.\n        \"\"\"\n        return [str(x) for x in X]\n", "docstring": "Transform an array of categories to a string encoded representation."}
{"repo": "scikit-optimize-master/skopt/space/transformers.py", "original_string": "    def __init__(self):\n        \"\"\"Convert labeled categories into one-hot encoded features.\"\"\"\n        self._lb = LabelBinarizer()\n", "docstring": "Convert labeled categories into one-hot encoded features.\n"}
{"repo": "scikit-optimize-master/skopt/space/transformers.py", "original_string": "    def transform(self, X):\n        \"\"\"Transform an array of categories to a one-hot encoded representation.\n        Parameters\n        ----------\n        X : array-like, shape=(n_samples,)\n            List of categories.\n        Returns\n        -------\n        Xt : array-like, shape=(n_samples, n_categories)\n            The one-hot encoded categories.\n        \"\"\"\n        return self._lb.transform([self.mapping_[v] for v in X])\n", "docstring": "Transform an array of categories to a one-hot encoded representation."}
{"repo": "scikit-optimize-master/skopt/space/transformers.py", "original_string": "    def transform(self, X):\n        \"\"\"Transform an array of categories to a one-hot encoded\n        representation.\n        Parameters\n        ----------\n        X : array-like, shape=(n_samples,)\n            List of categories.\n        Returns\n        -------\n        Xt : array-like, shape=(n_samples, n_categories)\n            The integer categories.\n        \"\"\"\n        X = np.asarray(X)\n        return [self.mapping_[v] for v in X]\n", "docstring": "Transform an array of categories to a one-hot encoded"}
{"repo": "scikit-optimize-master/skopt/tests/test_plots.py", "original_string": "def save_axes(ax, filename):\n    \"\"\"Save matplotlib axes `ax` to an image `filename`.\"\"\"\n    fig = plt.gcf()\n    fig.add_axes(ax)\n    fig.savefig(filename)\n", "docstring": "Save matplotlib axes `ax` to an image `filename`.\n"}
{"repo": "scikit-optimize-master/skopt/tests/test_plots.py", "original_string": "def test_plots_work():\n    \"\"\"Basic smoke tests to make sure plotting doesn't crash.\"\"\"\n    SPACE = [\n        Integer(1, 20, name='max_depth'),\n        Integer(2, 100, name='min_samples_split'),\n        Integer(5, 30, name='min_samples_leaf'),\n        Integer(1, 30, name='max_features'),\n        Categorical(['gini', 'entropy'], name='criterion'),\n        Categorical(list('abcdefghij'), name='dummy'),\n    ]\n    def objective(params):\n        clf = DecisionTreeClassifier(random_state=3,\n                                     **{dim.name: val\n                                        for dim, val in zip(SPACE, params)\n                                        if dim.name != 'dummy'})\n        return -np.mean(cross_val_score(clf, *load_breast_cancer(True)))\n    res = gp_minimize(objective, SPACE, n_calls=10, random_state=3)\n    x = [[11, 52, 8, 14, 'entropy', 'f'],\n         [14, 90, 10, 2, 'gini', 'a'],\n         [7, 90, 6, 14, 'entropy', 'f']]\n    samples = res.space.transform(x)\n    xi_ = [1., 10.5, 20.]\n    yi_ = [-0.9240883492576596, -0.9240745890422687, -0.9240586402439884]\n    xi, yi = partial_dependence_1D(res.space, res.models[-1], 0,\n                                   samples, n_points=3)\n    assert_array_almost_equal(xi, xi_)\n    assert_array_almost_equal(yi, yi_, 2)\n    xi_ = [0, 1]\n    yi_ = [-0.9241087603770617, -0.9240188905968352]\n    xi, yi = partial_dependence_1D(res.space, res.models[-1], 4,\n                                   samples, n_points=3)\n    assert_array_almost_equal(xi, xi_)\n    assert_array_almost_equal(yi, yi_, 2)\n    xi_ = [0, 1]\n    yi_ = [1., 10.5, 20.]\n    zi_ = [[-0.92412562, -0.92403575],\n           [-0.92411186, -0.92402199],\n           [-0.92409591, -0.92400604]]\n    xi, yi, zi = partial_dependence_2D(res.space, res.models[-1], 0, 4,\n                                       samples, n_points=3)\n    assert_array_almost_equal(xi, xi_)\n    assert_array_almost_equal(yi, yi_)\n    assert_array_almost_equal(zi, zi_, 2)\n    x_min, f_min = expected_minimum_random_sampling(res, random_state=1)\n    x_min2, f_min2 = expected_minimum(res, random_state=1)\n    assert x_min == x_min2\n    assert f_min == f_min2\n    plots.plot_convergence(res)\n    plots.plot_evaluations(res)\n    plots.plot_objective(res)\n    plots.plot_objective(res, dimensions=[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"])\n    plots.plot_objective(res,\n                         minimum='expected_minimum_random')\n    plots.plot_objective(res,\n                         sample_source='expected_minimum_random',\n                         n_minimum_search=10000)\n    plots.plot_objective(res,\n                         sample_source='result')\n    plots.plot_regret(res)\n    plots.plot_objective_2D(res, 0, 4)\n    plots.plot_histogram(res, 0, 4)\n    # TODO: Compare plots to known good results?\n    # Look into how matplotlib does this.\n", "docstring": "Basic smoke tests to make sure plotting doesn't crash.\n"}
{"repo": "scikit-optimize-master/skopt/tests/test_plots.py", "original_string": "def test_plots_work_without_cat():\n    \"\"\"Basic smoke tests to make sure plotting doesn't crash.\"\"\"\n    SPACE = [\n        Integer(1, 20, name='max_depth'),\n        Integer(2, 100, name='min_samples_split'),\n        Integer(5, 30, name='min_samples_leaf'),\n        Integer(1, 30, name='max_features'),\n    ]\n    def objective(params):\n        clf = DecisionTreeClassifier(random_state=3,\n                                     **{dim.name: val\n                                        for dim, val in zip(SPACE, params)\n                                        if dim.name != 'dummy'})\n        return -np.mean(cross_val_score(clf, *load_breast_cancer(True)))\n    res = gp_minimize(objective, SPACE, n_calls=10, random_state=3)\n    plots.plot_convergence(res)\n    plots.plot_evaluations(res)\n    plots.plot_objective(res)\n    plots.plot_objective(res,\n                         minimum='expected_minimum')\n    plots.plot_objective(res,\n                         sample_source='expected_minimum',\n                         n_minimum_search=10)\n    plots.plot_objective(res, sample_source='result')\n    plots.plot_regret(res)\n    # TODO: Compare plots to known good results?\n    # Look into how matplotlib does this.\n", "docstring": "Basic smoke tests to make sure plotting doesn't crash.\n"}
{"repo": "scikit-optimize-master/skopt/tests/test_gp_opt.py", "original_string": "def test_gp_minimize_bench4(search, acq):\n    # this particular random_state picks \"2\" twice so we can make an extra\n    # call to the objective without repeating options\n    check_minimize(bench4, 0,\n                   [(\"-2\", \"-1\", \"0\", \"1\", \"2\")], search, acq, 1.05, 20)\n", "docstring": "this particular random_state picks \"2\" twice so we can make an extra"}
{"repo": "scikit-optimize-master/skopt/tests/test_gp_opt.py", "original_string": "def test_gpr_default():\n    \"\"\"Smoke test that gp_minimize does not fail for default values.\"\"\"\n    gp_minimize(branin, ((-5.0, 10.0), (0.0, 15.0)), n_initial_points=2,\n                n_calls=2)\n", "docstring": "Smoke test that gp_minimize does not fail for default values.\n"}
{"repo": "scikit-optimize-master/skopt/tests/test_gp_opt.py", "original_string": "def test_use_given_estimator():\n    \"\"\" Test that gp_minimize does not use default estimator if one is passed\n    in explicitly. \"\"\"\n    domain = [(1.0, 2.0), (3.0, 4.0)]\n    noise_correct = 1e+5\n    noise_fake = 1e-10\n    estimator = cook_estimator(\"GP\", domain, noise=noise_correct)\n    res = gp_minimize(branin, domain, n_calls=4, n_initial_points=2,\n                      base_estimator=estimator, noise=noise_fake)\n    assert res['models'][-1].noise == noise_correct\n", "docstring": "Test that gp_minimize does not use default estimator if one is passed"}
{"repo": "scikit-optimize-master/skopt/tests/test_gp_opt.py", "original_string": "def test_use_given_estimator_with_max_model_size():\n    \"\"\" Test that gp_minimize does not use default estimator if one is passed\n    in explicitly. \"\"\"\n    domain = [(1.0, 2.0), (3.0, 4.0)]\n    noise_correct = 1e+5\n    noise_fake = 1e-10\n    estimator = cook_estimator(\"GP\", domain, noise=noise_correct)\n    res = gp_minimize(branin, domain, n_calls=4, n_initial_points=2,\n                      base_estimator=estimator, noise=noise_fake,\n                      model_queue_size=1)\n    assert len(res['models']) == 1\n    assert res['models'][-1].noise == noise_correct\n", "docstring": "Test that gp_minimize does not use default estimator if one is passed"}
{"repo": "scikit-optimize-master/skopt/tests/test_forest_opt.py", "original_string": "def test_forest_minimize_api(base_estimator):\n    # invalid string value\n    with pytest.raises(ValueError):\n        forest_minimize(lambda x: 0., [], base_estimator='abc')\n    # not a string nor a regressor\n    with pytest.raises(ValueError):\n        forest_minimize(lambda x: 0., [], base_estimator=base_estimator)\n", "docstring": "invalid string value"}
{"repo": "scikit-optimize-master/skopt/tests/test_acquisition.py", "original_string": "def test_acquisition_ei_correctness():\n    # check that it works with a vector as well\n    X = 10 * np.ones((4, 2))\n    ei = gaussian_ei(X, ConstSurrogate(), -0.5, xi=0.)\n    assert_array_almost_equal(ei, [0.1977966] * 4)\n", "docstring": "check that it works with a vector as well"}
{"repo": "scikit-optimize-master/skopt/tests/test_acquisition.py", "original_string": "def test_acquisition_pi_correctness():\n    # check that it works with a vector as well\n    X = 10 * np.ones((4, 2))\n    pi = gaussian_pi(X, ConstSurrogate(), -0.5, xi=0.)\n    assert_array_almost_equal(pi, [0.308538] * 4)\n", "docstring": "check that it works with a vector as well"}
{"repo": "scikit-optimize-master/skopt/tests/test_acquisition.py", "original_string": "def test_acquisition_variance_correctness():\n    # check that it works with a vector as well\n    X = 10 * np.ones((4, 2))\n    var = gaussian_lcb(X, ConstSurrogate(), kappa='inf')\n    assert_array_almost_equal(var, [-1.0] * 4)\n", "docstring": "check that it works with a vector as well"}
{"repo": "scikit-optimize-master/skopt/tests/test_acquisition.py", "original_string": "def test_acquisition_lcb_correctness():\n    # check that it works with a vector as well\n    X = 10 * np.ones((4, 2))\n    lcb = gaussian_lcb(X, ConstSurrogate(), kappa=0.3)\n    assert_array_almost_equal(lcb, [-0.3] * 4)\n", "docstring": "check that it works with a vector as well"}
{"repo": "scikit-optimize-master/skopt/tests/test_optimizer.py", "original_string": "def test_multiple_asks():\n    # calling ask() multiple times without a tell() inbetween should\n    # be a \"no op\"\n    base_estimator = ExtraTreesRegressor(random_state=2)\n    opt = Optimizer([(-2.0, 2.0)], base_estimator, n_initial_points=1,\n                    acq_optimizer=\"sampling\")\n    opt.run(bench1, n_iter=3)\n    # tell() computes the next point ready for the next call to ask()\n    # hence there are three after three iterations\n    assert_equal(len(opt.models), 3)\n    assert_equal(len(opt.Xi), 3)\n    opt.ask()\n    assert_equal(len(opt.models), 3)\n    assert_equal(len(opt.Xi), 3)\n    assert_equal(opt.ask(), opt.ask())\n    opt.update_next()\n    assert_equal(opt.ask(), opt.ask())\n", "docstring": "calling ask() multiple times without a tell() inbetween should"}
{"repo": "scikit-optimize-master/skopt/tests/test_optimizer.py", "original_string": "def test_model_queue_size():\n    # Check if model_queue_size limits the model queue size\n    base_estimator = ExtraTreesRegressor(random_state=2)\n    opt = Optimizer([(-2.0, 2.0)], base_estimator, n_initial_points=1,\n                    acq_optimizer=\"sampling\", model_queue_size=2)\n    opt.run(bench1, n_iter=3)\n    # tell() computes the next point ready for the next call to ask()\n    # hence there are three after three iterations\n    assert_equal(len(opt.models), 2)\n    assert_equal(len(opt.Xi), 3)\n    opt.ask()\n    assert_equal(len(opt.models), 2)\n    assert_equal(len(opt.Xi), 3)\n    assert_equal(opt.ask(), opt.ask())\n", "docstring": "Check if model_queue_size limits the model queue size"}
{"repo": "scikit-optimize-master/skopt/tests/test_optimizer.py", "original_string": "def test_optimizer_copy(acq_func):\n    # Checks that the base estimator, the objective and target values\n    # are copied correctly.\n    base_estimator = ExtraTreesRegressor(random_state=2)\n    opt = Optimizer([(-2.0, 2.0)], base_estimator, acq_func=acq_func,\n                    n_initial_points=1, acq_optimizer=\"sampling\")\n    # run three iterations so that we have some points and objective values\n    if \"ps\" in acq_func:\n        opt.run(bench1_with_time, n_iter=3)\n    else:\n        opt.run(bench1, n_iter=3)\n    opt_copy = opt.copy()\n    copied_estimator = opt_copy.base_estimator_\n    if \"ps\" in acq_func:\n        assert isinstance(copied_estimator, MultiOutputRegressor)\n        # check that the base_estimator is not wrapped multiple times\n        is_multi = isinstance(copied_estimator.estimator,\n                              MultiOutputRegressor)\n        assert not is_multi\n    else:\n        assert not isinstance(copied_estimator, MultiOutputRegressor)\n    assert_array_equal(opt_copy.Xi, opt.Xi)\n    assert_array_equal(opt_copy.yi, opt.yi)\n", "docstring": "Checks that the base estimator, the objective and target values"}
{"repo": "scikit-optimize-master/skopt/tests/test_optimizer.py", "original_string": "def test_exhaust_initial_calls(base_estimator):\n    # check a model is fitted and used to make suggestions after we added\n    # at least n_initial_points via tell()\n    opt = Optimizer([(-2.0, 2.0)], base_estimator, n_initial_points=2,\n                    acq_optimizer=\"sampling\", random_state=1)\n    x0 = opt.ask()  # random point\n    x1 = opt.ask()  # random point\n    assert x0 != x1\n    # first call to tell()\n    r1 = opt.tell(x1, 3.)\n    assert len(r1.models) == 0\n    x2 = opt.ask()  # random point\n    assert x1 != x2\n    # second call to tell()\n    r2 = opt.tell(x2, 4.)\n    if base_estimator.lower() == 'dummy':\n        assert len(r2.models) == 0\n    else:\n        assert len(r2.models) == 1\n    # this is the first non-random point\n    x3 = opt.ask()\n    assert x2 != x3\n    x4 = opt.ask()\n    r3 = opt.tell(x3, 1.)\n    # no new information was added so should be the same, unless we are using\n    # the dummy estimator which will forever return random points and never\n    # fits any models\n    if base_estimator.lower() == 'dummy':\n        assert x3 != x4\n        assert len(r3.models) == 0\n    else:\n        assert x3 == x4\n        assert len(r3.models) == 2\n", "docstring": "check a model is fitted and used to make suggestions after we added"}
{"repo": "scikit-optimize-master/skopt/tests/test_common.py", "original_string": "def check_minimizer_api(result, n_calls, n_models=None):\n    # assumes the result was produced on branin\n    assert(isinstance(result.space, Space))\n    if n_models is not None:\n        assert_equal(len(result.models), n_models)\n    assert_equal(len(result.x_iters), n_calls)\n    assert_array_equal(result.func_vals.shape, (n_calls,))\n    assert(isinstance(result.x, list))\n    assert_equal(len(result.x), 2)\n    assert(isinstance(result.x_iters, list))\n    for n in range(n_calls):\n        assert(isinstance(result.x_iters[n], list))\n        assert_equal(len(result.x_iters[n]), 2)\n        assert(isinstance(result.func_vals[n], float))\n        assert_almost_equal(result.func_vals[n], branin(result.x_iters[n]))\n    assert_array_equal(result.x, result.x_iters[np.argmin(result.func_vals)])\n    assert_almost_equal(result.fun, branin(result.x))\n    assert(isinstance(result.specs, dict))\n    assert(\"args\" in result.specs)\n    assert(\"function\" in result.specs)\n", "docstring": "assumes the result was produced on branin"}
{"repo": "scikit-optimize-master/skopt/tests/test_common.py", "original_string": "def test_minimizer_api_dummy_minimize(verbose, call):\n    # dummy_minimize is special as it does not support all parameters\n    # and does not fit any models\n    n_calls = 7\n    result = dummy_minimize(branin, [(-5.0, 10.0), (0.0, 15.0)],\n                            n_calls=n_calls, random_state=1,\n                            verbose=verbose, callback=call)\n    assert result.models == []\n    check_minimizer_api(result, n_calls)\n    check_minimizer_bounds(result, n_calls)\n    with pytest.raises(ValueError):\n        dummy_minimize(lambda x: x, [[-5, 10]])\n", "docstring": "dummy_minimize is special as it does not support all parameters"}
{"repo": "scikit-optimize-master/skopt/tests/test_common.py", "original_string": "def test_minimizer_api(verbose, call, minimizer):\n    n_calls = 7\n    n_initial_points = 3\n    n_models = n_calls - n_initial_points + 1\n    result = minimizer(branin, [(-5.0, 10.0), (0.0, 15.0)],\n                       n_initial_points=n_initial_points,\n                       n_calls=n_calls,\n                       random_state=1,\n                       verbose=verbose, callback=call)\n    check_minimizer_api(result, n_calls, n_models)\n    check_minimizer_bounds(result, n_calls)\n    with pytest.raises(ValueError):\n        minimizer(lambda x: x, [[-5, 10]])\n", "docstring": "n_calls = 7"}
{"repo": "scikit-optimize-master/skopt/tests/test_common.py", "original_string": "def test_minimizer_api_random_only(minimizer):\n    # no models should be fit as we only evaluate at random points\n    n_calls = 5\n    n_initial_points = 5\n    result = minimizer(branin, [(-5.0, 10.0), (0.0, 15.0)],\n                       n_initial_points=n_initial_points,\n                       n_calls=n_calls,\n                       random_state=1)\n    check_minimizer_api(result, n_calls)\n    check_minimizer_bounds(result, n_calls)\n", "docstring": "no models should be fit as we only evaluate at random points"}
{"repo": "scikit-optimize-master/skopt/tests/test_common.py", "original_string": "def test_fixed_random_states(minimizer):\n    # check that two runs produce exactly same results, if not there is a\n    # random state somewhere that is not reproducible\n    n_calls = 4\n    n_initial_points = 2\n    space = [(-5.0, 10.0), (0.0, 15.0)]\n    result1 = minimizer(branin, space, n_calls=n_calls,\n                        n_initial_points=n_initial_points, random_state=1)\n    dimensions = [(-5.0, 10.0), (0.0, 15.0)]\n    result2 = minimizer(branin, dimensions, n_calls=n_calls,\n                        n_initial_points=n_initial_points, random_state=1)\n    assert_array_almost_equal(result1.x_iters, result2.x_iters)\n    assert_array_almost_equal(result1.func_vals, result2.func_vals)\n", "docstring": "check that two runs produce exactly same results, if not there is a"}
{"repo": "scikit-optimize-master/skopt/tests/test_common.py", "original_string": "def test_minimizer_with_space(minimizer):\n    # check we can pass a Space instance as dimensions argument and get same\n    # result\n    n_calls = 4\n    n_initial_points = 2\n    space = Space([(-5.0, 10.0), (0.0, 15.0)])\n    space_result = minimizer(branin, space, n_calls=n_calls,\n                             n_initial_points=n_initial_points, random_state=1)\n    check_minimizer_api(space_result, n_calls)\n    check_minimizer_bounds(space_result, n_calls)\n    dimensions = [(-5.0, 10.0), (0.0, 15.0)]\n    result = minimizer(branin, dimensions, n_calls=n_calls,\n                       n_initial_points=n_initial_points, random_state=1)\n    assert_array_almost_equal(space_result.x_iters, result.x_iters)\n    assert_array_almost_equal(space_result.func_vals, result.func_vals)\n", "docstring": "check we can pass a Space instance as dimensions argument and get same"}
{"repo": "scikit-optimize-master/skopt/tests/test_common.py", "original_string": "def test_init_vals_and_models(n_initial_points, optimizer_func):\n    # test how many models are fitted when using initial points, y0 values\n    # and random starts\n    space = [(-5.0, 10.0), (0.0, 15.0)]\n    x0 = [[1, 2], [3, 4], [5, 6]]\n    y0 = list(map(branin, x0))\n    n_calls = 7\n    optimizer = partial(optimizer_func, n_initial_points=n_initial_points)\n    res = optimizer(branin, space, x0=x0, y0=y0, random_state=0,\n                    n_calls=n_calls)\n    assert_equal(len(res.models), n_calls - n_initial_points + 1)\n", "docstring": "test how many models are fitted when using initial points, y0 values"}
{"repo": "scikit-optimize-master/skopt/tests/test_common.py", "original_string": "def test_init_points_and_models(n_initial_points, optimizer_func):\n    # test how many models are fitted when using initial points and random\n    # starts (no y0 in this case)\n    space = [(-5.0, 10.0), (0.0, 15.0)]\n    x0 = [[1, 2], [3, 4], [5, 6]]\n    n_calls = 7\n    optimizer = partial(optimizer_func, n_initial_points=n_initial_points)\n    res = optimizer(branin, space, x0=x0, random_state=0,\n                    n_calls=n_calls)\n    assert_equal(len(res.models), n_calls - len(x0) - n_initial_points + 1)\n", "docstring": "test how many models are fitted when using initial points and random"}
{"repo": "scikit-optimize-master/skopt/tests/test_common.py", "original_string": "def test_consistent_x_iter_dimensions(minimizer):\n    # check that all entries in x_iters have the same dimensions\n    # two dmensional problem, bench1 is a 1D function but in this\n    # instance we do not really care about the objective, could be\n    # a total dummy\n    res = minimizer(bench1,\n                    dimensions=[(0, 1), (2, 3)],\n                    x0=[[0, 2], [1, 2]], n_calls=3,\n                    n_initial_points=0)\n    assert len(set(len(x) for x in res.x_iters)) == 1\n    assert len(res.x_iters[0]) == 2\n    # one dimensional problem\n    res = minimizer(bench1, dimensions=[(0, 1)], x0=[[0], [1]], n_calls=3,\n                    n_initial_points=0)\n    assert len(set(len(x) for x in res.x_iters)) == 1\n    assert len(res.x_iters[0]) == 1\n    with pytest.raises(RuntimeError):\n        minimizer(bench1, dimensions=[(0, 1)],\n                  x0=[[0, 1]], n_calls=3, n_initial_points=0)\n    with pytest.raises(RuntimeError):\n        minimizer(bench1, dimensions=[(0, 1)],\n                  x0=[0, 1], n_calls=3, n_initial_points=0)\n", "docstring": "check that all entries in x_iters have the same dimensions"}
{"repo": "scikit-optimize-master/skopt/tests/test_common.py", "original_string": "def test_early_stopping_delta_x_empty_result_object(minimizer):\n    # check that the callback handles the case of being passed an empty\n    # results object, e.g. at the start of the optimization loop\n    n_calls = 15\n    res = minimizer(bench1,\n                    callback=DeltaXStopper(0.1),\n                    dimensions=[(-1., 1.)],\n                    n_calls=n_calls,\n                    n_initial_points=2, random_state=1)\n    assert len(res.x_iters) < n_calls\n", "docstring": "check that the callback handles the case of being passed an empty"}
{"repo": "scikit-optimize-master/skopt/tests/test_space.py", "original_string": "def check_limits(value, low, high):\n    # check if low <= value <= high\n    if isinstance(value, list):\n        value = np.array(value)\n    assert np.all(low <= value)\n    assert np.all(high >= value)\n", "docstring": "check if low <= value <= high"}
{"repo": "scikit-optimize-master/skopt/tests/test_space.py", "original_string": "def test_real_bounds():\n    # should give same answer as using check_limits() but this is easier\n    # to read\n    a = Real(1., 2.1)\n    assert 0.99 not in a\n    assert 1. in a\n    assert 2.09 in a\n    assert 2.1 in a\n    assert np.nextafter(2.1, 3.) not in a\n", "docstring": "should give same answer as using check_limits() but this is easier"}
{"repo": "scikit-optimize-master/skopt/tests/test_space.py", "original_string": "def test_space_from_space():\n    # can you pass a Space instance to the Space constructor?\n    space = Space([(0.0, 1.0), (-5, 5),\n                   (\"a\", \"b\", \"c\"), (1.0, 5.0, \"log-uniform\"), (\"e\", \"f\")])\n    space2 = Space(space)\n    assert_equal(space, space2)\n", "docstring": "can you pass a Space instance to the Space constructor?"}
{"repo": "scikit-optimize-master/skopt/tests/test_space.py", "original_string": "def test_set_get_transformer():\n    # can you pass a Space instance to the Space constructor?\n    space = Space([(0.0, 1.0), (-5, 5),\n                   (\"a\", \"b\", \"c\"), (1.0, 5.0, \"log-uniform\"), (\"e\", \"f\")])\n    transformer = space.get_transformer()\n    assert_array_equal([\"identity\", \"identity\", \"onehot\",\n                        \"identity\", \"onehot\"], transformer)\n    space.set_transformer(\"normalize\")\n    transformer = space.get_transformer()\n    assert_array_equal([\"normalize\"] * 5, transformer)\n    space.set_transformer(transformer)\n    assert_array_equal(transformer, space.get_transformer())\n    space.set_transformer_by_type(\"label\", Categorical)\n    assert space.dimensions[2].transform([\"a\"]) == [0]\n", "docstring": "can you pass a Space instance to the Space constructor?"}
{"repo": "scikit-optimize-master/skopt/tests/test_space.py", "original_string": "def test_normalize():\n    # can you pass a Space instance to the Space constructor?\n    space = Space([(0.0, 1.0), (-5, 5),\n                   (\"a\", \"b\", \"c\"), (1.0, 5.0, \"log-uniform\"), (\"e\", \"f\")])\n    space.set_transformer(\"normalize\")\n    X = [[0., -5, 'a', 1., 'e']]\n    Xt = np.zeros((1, 5))\n    assert_array_equal(space.transform(X), Xt)\n    assert_array_equal(space.inverse_transform(Xt), X)\n    assert_array_equal(space.inverse_transform(space.transform(X)), X)\n", "docstring": "can you pass a Space instance to the Space constructor?"}
{"repo": "scikit-optimize-master/skopt/tests/test_space.py", "original_string": "def test_normalize_types():\n    # can you pass a Space instance to the Space constructor?\n    space = Space([(0.0, 1.0), Integer(-5, 5, dtype=int), (True, False)])\n    space.set_transformer(\"normalize\")\n    X = [[0., -5, False]]\n    Xt = np.zeros((1, 3))\n    assert_array_equal(space.transform(X), Xt)\n    assert_array_equal(space.inverse_transform(Xt), X)\n    assert_array_equal(space.inverse_transform(space.transform(X)), X)\n    assert isinstance(space.inverse_transform(Xt)[0][0], float)\n    assert isinstance(space.inverse_transform(Xt)[0][1], int)\n    assert isinstance(space.inverse_transform(Xt)[0][2], (np.bool_, bool))\n", "docstring": "can you pass a Space instance to the Space constructor?"}
{"repo": "scikit-optimize-master/skopt/tests/test_space.py", "original_string": "def test_purely_categorical_space():\n    # Test reproduces the bug in #908, make sure it doesn't come back\n    dims = [Categorical(['a', 'b', 'c']), Categorical(['A', 'B', 'C'])]\n    optimizer = Optimizer(dims, n_initial_points=2, random_state=3)\n    for _ in range(2):\n        x = optimizer.ask()\n        # before the fix this call raised an exception\n        optimizer.tell(x, np.random.uniform())\n", "docstring": "Test reproduces the bug in #908, make sure it doesn't come back"}
{"repo": "scikit-optimize-master/skopt/tests/test_searchcv.py", "original_string": "def test_searchcv_callback():\n    # Test whether callback is used in BayesSearchCV and\n    # whether is can be used to interrupt the search loop\n    X, y = load_iris(True)\n    opt = BayesSearchCV(\n        DecisionTreeClassifier(),\n        {\n            'max_depth': [3],  # additional test for single dimension\n            'min_samples_split': Real(0.1, 0.9),\n        },\n        n_iter=5\n    )\n    total_iterations = [0]\n    def callback(opt_result):\n        # this simply counts iterations\n        total_iterations[0] += 1\n        # break the optimization loop at some point\n        if total_iterations[0] > 2:\n            return True  # True == stop optimization\n        return False\n    opt.fit(X, y, callback=callback)\n    assert total_iterations[0] == 3\n    # test whether final model was fit\n    opt.score(X, y)\n", "docstring": "Test whether callback is used in BayesSearchCV and"}
{"repo": "scikit-optimize-master/skopt/tests/test_utils.py", "original_string": "def check_optimization_results_equality(res_1, res_2):\n    # Check if the results objects have the same keys\n    assert_equal(sorted(res_1.keys()), sorted(res_2.keys()))\n    # Shallow check of the main optimization results\n    assert_array_equal(res_1.x, res_2.x)\n    assert_array_equal(res_1.x_iters, res_2.x_iters)\n    assert_array_equal(res_1.fun, res_2.fun)\n    assert_array_equal(res_1.func_vals, res_2.func_vals)\n", "docstring": "Check if the results objects have the same keys"}
{"repo": "scikit-optimize-master/skopt/tests/test_utils.py", "original_string": "def test_has_gradients(estimator, gradients):\n    space = Space([(-2.0, 2.0)])\n    assert has_gradients(cook_estimator(estimator, space=space)) == gradients\n", "docstring": "space = Space([(-2.0, 2.0)])"}
{"repo": "scikit-optimize-master/skopt/tests/test_utils.py", "original_string": "def test_space_names_in_use_named_args():\n    space = [Integer(250, 2000, name='n_estimators')]\n    @use_named_args(space)\n    def objective(n_estimators):\n        return n_estimators\n    res = gp_minimize(objective, space, n_calls=10, random_state=0)\n    best_params = dict(zip((s.name for s in res.space), res.x))\n    assert 'n_estimators' in best_params\n    assert res.space.dimensions[0].name == 'n_estimators'\n", "docstring": "space = [Integer(250, 2000, name='n_estimators')]"}
{"repo": "scikit-optimize-master/skopt/tests/test_utils.py", "original_string": "def test_check_dimension_names():\n    # Define the search-space dimensions. They must all have names!\n    dim1 = Real(name='foo', low=0.0, high=1.0)\n    dim2 = Real(name='bar', low=0.0, high=1.0)\n    dim3 = Real(name='baz', low=0.0, high=1.0)\n    # Gather the search-space dimensions in a list.\n    dimensions = [dim1, dim2, dim3]\n    check_dimension_names(dimensions)\n    dimensions = [dim1, dim2, dim3, Real(-1, 1)]\n    assert_raises(ValueError, check_dimension_names, dimensions)\n", "docstring": "Define the search-space dimensions. They must all have names!"}
{"repo": "scikit-optimize-master/benchmarks/bench_ml.py", "original_string": "    def __init__(self, model, dataset, random_state):\n        X, Y = load_data_target(dataset)\n        self.X_train, self.y_train, self.X_test, self.y_test = split_normalize(\n            X, Y, random_state)\n        self.random_state = random_state\n        self.model = model\n        self.space = MODELS[model]\n", "docstring": "X, Y = load_data_target(dataset)"}
{"repo": "scikit-optimize-master/benchmarks/bench_ml.py", "original_string": "    def objective(x):\n        # convert list of dimension values to dictionary\n        x = dict(zip(dimensions_names, x))\n        # the result of \"evaluate\" is accuracy / r^2, which is the more the better\n        y = -problem.evaluate(x)\n        return y\n", "docstring": "convert list of dimension values to dictionary"}
{"repo": "scikit-optimize-master/doc/conf.py", "original_string": "def make_carousel_thumbs(app, exception):\n    \"\"\"produces the final resized carousel images\"\"\"\n    if exception is not None:\n        return\n    print('Preparing carousel images')\n    image_dir = os.path.join(app.builder.outdir, '_images')\n    for glr_plot, max_width in carousel_thumbs.items():\n        image = os.path.join(image_dir, glr_plot)\n        if os.path.exists(image):\n            c_thumb = os.path.join(image_dir, glr_plot[:-4] + '_carousel.png')\n            sphinx_gallery.gen_rst.scale_image(image, c_thumb, max_width, 190)\n", "docstring": "produces the final resized carousel images\n"}
{"repo": "scikit-optimize-master/doc/conf.py", "original_string": "def setup(app):\n    # to hide/show the prompt in code examples:\n    app.connect('build-finished', make_carousel_thumbs)\n    app.connect('build-finished', filter_search_index)\n", "docstring": "to hide/show the prompt in code examples:"}
{"repo": "scikit-optimize-master/doc/sphinxext/custom_references_resolver.py", "original_string": "    def resolve_anyref(self, refdoc, node, contnode):\n        \"\"\"Resolve reference generated by the \"any\" role.\"\"\"\n        stddomain = self.env.get_domain('std')\n        target = node['reftarget']\n        # process 'py' domain first for python classes\n        if \"py:class\" in node:\n            with suppress(KeyError):\n                py_domain = self.env.domains['py']\n                py_ref = py_domain.resolve_any_xref(\n                    self.env, refdoc, self.app.builder, target, node, contnode)\n                if py_ref:\n                    return self.create_node(py_ref[0])\n        # resolve :term:\n        term_ref = stddomain.resolve_xref(self.env, refdoc, self.app.builder,\n                                          'term', target, node, contnode)\n        if term_ref:\n            # replace literal nodes with inline nodes\n            if not isinstance(term_ref[0], nodes.inline):\n                inline_node = nodes.inline(rawsource=term_ref[0].rawsource,\n                                           classes=term_ref[0].get('classes'))\n                if term_ref[0]:\n                    inline_node.append(term_ref[0][0])\n                term_ref[0] = inline_node\n            return self.create_node((\"std:term\", term_ref))\n        # next, do the standard domain\n        std_ref = stddomain.resolve_any_xref(\n            self.env, refdoc, self.app.builder, target, node, contnode)\n        if std_ref:\n            return self.create_node(std_ref[0])\n        for domain in self.env.domains.values():\n            try:\n                ref = domain.resolve_any_xref(\n                    self.env, refdoc, self.app.builder, target, node, contnode)\n                if ref:\n                    return self.create_node(ref[0])\n            except NotImplementedError:\n                # the domain doesn't yet support the new interface\n                # we have to manually collect possible references (SLOW)\n                for role in domain.roles:\n                    res = domain.resolve_xref(self.env, refdoc,\n                                              self.app.builder, role, target,\n                                              node, contnode)\n                    if res and isinstance(res[0], nodes.Element):\n                        result = ('%s:%s' % (domain.name, role), res)\n                        return self.create_node(result)\n        # no results considered to be <code>\n        contnode['classes'] = []\n        return contnode\n", "docstring": "Resolve reference generated by the \"any\" role.\n"}
{"repo": "scikit-optimize-master/doc/sphinxext/sphinx_issues.py", "original_string": "def user_role(name, rawtext, text, lineno, inliner, options=None, content=None):\n    \"\"\"Sphinx role for linking to a user profile. Defaults to linking to\n    Github profiles, but the profile URIS can be configured via the\n    ``issues_user_uri`` config value.\n    Examples: ::\n        :user:`sloria`\n    Anchor text also works: ::\n        :user:`Steven Loria <sloria>`\n    \"\"\"\n    options = options or {}\n    content = content or []\n    has_explicit_title, title, target = split_explicit_title(text)\n    target = utils.unescape(target).strip()\n    title = utils.unescape(title).strip()\n    config = inliner.document.settings.env.app.config\n    if config.issues_user_uri:\n        ref = config.issues_user_uri.format(user=target)\n    else:\n        ref = \"https://github.com/{0}\".format(target)\n    if has_explicit_title:\n        text = title\n    else:\n        text = \"@{0}\".format(target)\n    link = nodes.reference(text=text, refuri=ref, **options)\n    return [link], []\n", "docstring": "Sphinx role for linking to a user profile. Defaults to linking to"}
{"repo": "python-o365-master/release.py", "original_string": "def build(force):\n    \"\"\" Builds the distribution files: wheels and source. \"\"\"\n    dist_path = Path(DIST_PATH)\n    if dist_path.exists() and list(dist_path.glob('*')):\n        if force or click.confirm('{} is not empty - delete contents?'.format(dist_path)):\n            dist_path.rename(DIST_PATH_DELETE)\n            shutil.rmtree(Path(DIST_PATH_DELETE))\n            dist_path.mkdir()\n        else:\n            click.echo('Aborting')\n            sys.exit(1)\n    subprocess.check_call(['python', 'setup.py', 'bdist_wheel'])\n    subprocess.check_call(['python', 'setup.py', 'sdist',\n                           '--formats=gztar'])\n", "docstring": "Builds the distribution files: wheels and source. \n"}
{"repo": "python-o365-master/release.py", "original_string": "def upload(ctx, release, rebuild):\n    \"\"\" Uploads distribuition files to pypi or pypitest. \"\"\"\n    dist_path = Path(DIST_PATH)\n    if rebuild is False:\n        if not dist_path.exists() or not list(dist_path.glob('*')):\n            print(\"No distribution files found. Please run 'build' command first\")\n            return\n    else:\n        ctx.invoke(build, force=True)\n    if release:\n        args = ['twine', 'upload', 'dist/*']\n    else:\n        repository = 'https://test.pypi.org/legacy/'\n        args = ['twine', 'upload', '--repository-url', repository, 'dist/*']\n    env = os.environ.copy()\n    p = subprocess.Popen(args, env=env)\n    p.wait()\n", "docstring": "Uploads distribuition files to pypi or pypitest. \n"}
{"repo": "python-o365-master/release.py", "original_string": "def check():\n    \"\"\" Checks the long description. \"\"\"\n    dist_path = Path(DIST_PATH)\n    if not dist_path.exists() or not list(dist_path.glob('*')):\n        print(\"No distribution files found. Please run 'build' command first\")\n        return\n    subprocess.check_call(['twine', 'check', 'dist/*'])\n", "docstring": "Checks the long description. \n"}
{"repo": "python-o365-master/release.py", "original_string": "def test(annotate, coverage, v, vv):\n    \"\"\" Runs tests and optionally creates annotated files of coverage. \"\"\"\n    args = ['python3', '-m', 'pytest', 'tests/']\n    if coverage:\n        args.append('--cov=O365')\n        if annotate:\n            args.append('--cov-report')\n            args.append('annotate')\n        if v:  # Verbose\n            args.append('-v')\n        if vv and not v:  # Very verbose\n            args.append('-vv')\n    env = os.environ.copy()\n    p = subprocess.Popen(args, env=env)\n    p.wait()\n", "docstring": "Runs tests and optionally creates annotated files of coverage. \n"}
{"repo": "python-o365-master/release.py", "original_string": "def list_releases():\n    \"\"\" Lists all releases published on pypi. \"\"\"\n    releases = _get_releases()\n    if releases is None:\n        print('Package \"{}\" not found on Pypi.org'.format(PYPI_PACKAGE_NAME))\n    elif not releases:\n        print('No releases found for {}'.format(PYPI_PACKAGE_NAME))\n    else:\n        for version, published_on_date, release_formats in releases:\n            print('{:<10}{:>15}{:>25}'.format(version, published_on_date, release_formats))\n", "docstring": "Lists all releases published on pypi. \n"}
{"repo": "python-o365-master/release.py", "original_string": "def contribution_breakdown():\n    \"\"\" Displays a table of the contributors and to what extent we have them to thank.\"\"\"\n    args = ['git', 'blame']\n    counts = {}\n    line_format = '{0:30}\\t{1:>10}\\t{2:>10}%'\n    files = subprocess.check_output(['git', 'ls-files']).decode(\"utf-8\").split('\\n')\n    for f in files[:-1]:\n        if 'docs/latest' in f or '_themes' in f:\n            continue  # skip generated stuff\n        lines = subprocess.check_output(args + [f]).decode('utf-8')\n        blames = [get_line_blame(line) for line in lines.split('\\n')]\n        for blame in blames:\n            counts[blame] = counts.get(blame, 0) + 1\n    total = sum([counts[count] for count in counts])\n    contribs = [(user, counts[user]) for user in counts]\n    contribs.sort(key=lambda x: x[1], reverse=True)\n    print(line_format.format('User', 'Lines', 'Line '))\n    for user in contribs:\n        percent = floor(100.0 * user[1] / total)\n        if percent == 0: percent = '>1'\n        print(line_format.format(user[0], user[1], percent))\n    print(line_format.format('Total', total, 100))\n", "docstring": "Displays a table of the contributors and to what extent we have them to thank.\n"}
{"repo": "python-o365-master/examples/token_backends.py", "original_string": "    def _check_refresh_flag(self):\n        \"\"\" Returns the token if the flag is True or None otherwise\"\"\"\n        try:\n            doc = self.doc_ref.get()\n        except Exception as e:\n            log.error('Flag (collection: {}, doc_id: {}) '\n                      'could not be retrieved from the backend: {}'\n                      .format(self.collection, self.doc_id, str(e)))\n            doc = None\n        if doc and doc.exists:\n            if doc.get(self.refresh_flag_field_name):\n                token_str = doc.get(self.field_name)\n                if token_str:\n                    token = self.token_constructor(self.serializer.loads(token_str))\n                    return token\n        return None\n", "docstring": "Returns the token if the flag is True or None otherwise\n"}
{"repo": "python-o365-master/examples/token_backends.py", "original_string": "    def save_token(self):\n        \"\"\"We must overwrite this method to update also the flag to True\"\"\"\n        if self.token is None:\n            raise ValueError('You have to set the \"token\" first.')\n        try:\n            # set token will overwrite previous data\n            self.doc_ref.set({\n                self.field_name: self.serializer.dumps(self.token),\n                self.refresh_flag_field_name: True\n            })\n        except Exception as e:\n            log.error('Token could not be saved: {}'.format(str(e)))\n            return False\n        return True\n", "docstring": "We must overwrite this method to update also the flag to True\n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def __init__(self, *, parent=None, con=None, persist=True, **kwargs):\n        \"\"\" Create a workbook session object.\n        :param parent: parent for this operation\n        :param Connection con: connection to use if no parent specified\n        :param Bool persist: Whether or not to persist the session changes\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        self.persist = persist\n        self.inactivity_limit = dt.timedelta(seconds=PERSISTENT_SESSION_INACTIVITY_MAX_AGE) \\\n            if persist else dt.timedelta(seconds=NON_PERSISTENT_SESSION_INACTIVITY_MAX_AGE)\n        self.session_id = None\n        self.last_activity = dt.datetime.now()\n", "docstring": "Create a workbook session object."}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def create_session(self):\n        \"\"\" Request a new session id \"\"\"\n        url = self.build_url(self._endpoints.get('create_session'))\n        response = self.con.post(url, data={'persistChanges': self.persist})\n        if not response:\n            raise RuntimeError('Could not create session as requested by the user.')\n        data = response.json()\n        self.session_id = data.get('id')\n        return True\n", "docstring": "Request a new session id \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def close_session(self):\n        \"\"\" Close the current session \"\"\"\n        if self.session_id:\n            url = self.build_url(self._endpoints.get('close_session'))\n            response = self.con.post(url, headers={'workbook-session-id': self.session_id})\n            return bool(response)\n        return False\n", "docstring": "Close the current session \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def to_api_data(self, restrict_keys=None):\n        \"\"\" Returns a dict to communicate with the server\n        :param restrict_keys: a set of keys to restrict the returned data to\n        :rtype: dict\n        \"\"\"\n        cc = self.parent._cc  # alias\n        data = {\n            cc('bold'): self._bold,\n            cc('color'): self._color,\n            cc('italic'): self._italic,\n            cc('name'): self._name,\n            cc('size'): self._size,\n            cc('underline'): self._underline\n        }\n        if restrict_keys:\n            for key in list(data.keys()):\n                if key not in restrict_keys:\n                    del data[key]\n        return data\n", "docstring": "Returns a dict to communicate with the server"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def update(self):\n        \"\"\" Updates this range format \"\"\"\n        if self._track_changes:\n            data = self.to_api_data(restrict_keys=self._track_changes)\n            if data:\n                response = self.session.patch(self.build_url(''), data=data)\n                if not response:\n                    return False\n                self._track_changes.clear()\n        if self._font._track_changes:\n            data = self._font.to_api_data(restrict_keys=self._font._track_changes)\n            if data:\n                response = self.session.patch(self.build_url(self._endpoints.get('font')), data=data)\n                if not response:\n                    return False\n                self._font._track_changes.clear()\n        if self._track_background_color:\n            if self._background_color is None:\n                url = self.build_url(self._endpoints.get('clear_fill'))\n                response = self.session.post(url)\n            else:\n                data = {'color': self._background_color}\n                url = self.build_url(self._endpoints.get('fill'))\n                response = self.session.patch(url, data=data)\n            if not response:\n                return False\n            self._track_background_color = False\n        return True\n", "docstring": "Updates this range format \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def auto_fit_columns(self):\n        \"\"\" Changes the width of the columns of the current range\n         to achieve the best fit, based on the current data in the columns\n        \"\"\"\n        url = self.build_url(self._endpoints.get('auto_fit_columns'))\n        return bool(self.session.post(url))\n", "docstring": "Changes the width of the columns of the current range"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def set_borders(self, side_style=''):\n        \"\"\" Sets the border of this range \"\"\"\n        pass\n", "docstring": "Sets the border of this range \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def _get_range(self, endpoint, *args, method='GET', **kwargs):\n        \"\"\" Helper that returns another range\"\"\"\n        if args:\n            url = self.build_url(self._endpoints.get(endpoint).format(*args))\n        else:\n            url = self.build_url(self._endpoints.get(endpoint))\n        if not kwargs:\n            kwargs = None\n        if method == 'GET':\n            response = self.session.get(url, params=kwargs)\n        elif method == 'POST':\n            response = self.session.post(url, data=kwargs)\n        if not response:\n            return None\n        return self.__class__(parent=self, **{self._cloud_data_key: response.json()})\n", "docstring": "Helper that returns another range\n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_entire_column(self):\n        \"\"\" Gets a Range that represents the entire column of the range. \"\"\"\n        return self._get_range('entire_column')\n", "docstring": "Gets a Range that represents the entire column of the range. \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_last_cell(self):\n        \"\"\" Gets the last cell within the range. \"\"\"\n        return self._get_range('last_cell')\n", "docstring": "Gets the last cell within the range. \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_last_row(self):\n        \"\"\" Gets the last row within the range. \"\"\"\n        return self._get_range('last_row')\n", "docstring": "Gets the last row within the range. \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def unmerge(self):\n        \"\"\" Unmerge the range cells into separate cells.\"\"\"\n        url = self.build_url(self._endpoints.get('unmerge_range'))\n        return bool(self.session.post(url))\n", "docstring": "Unmerge the range cells into separate cells.\n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def update(self):\n        \"\"\" Update this range \"\"\"\n        if not self._track_changes:\n            return True  # there's nothing to update\n        data = self.to_api_data(restrict_keys=self._track_changes)\n        response = self.session.patch(self.build_url(''), data=data)\n        if not response:\n            return False\n        data = response.json()\n        for field in self._track_changes:\n            setattr(self, snakecase(field), data.get(field))\n        self._track_changes.clear()\n        return True\n", "docstring": "Update this range \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_format(self):\n        \"\"\" Returns a RangeFormat instance with the format of this range \"\"\"\n        url = self.build_url(self._endpoints.get('get_format'))\n        response = self.session.get(url)\n        if not response:\n            return None\n        return self.range_format_constructor(parent=self, **{self._cloud_data_key: response.json()})\n", "docstring": "Returns a RangeFormat instance with the format of this range \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def __init__(self, parent=None, session=None, **kwargs):\n        if parent and session:\n            raise ValueError('Need a parent or a session but not both')\n        self.session = parent.session if parent else session\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.object_id = cloud_data.get('name', None)\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        main_resource = '{}/names/{}'.format(main_resource, self.object_id)\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        self.name = cloud_data.get('name', None)\n        self.comment = cloud_data.get('comment', '')\n        self.scope = cloud_data.get('scope', '')\n        self.data_type = cloud_data.get('type', '')\n        self.value = cloud_data.get('value', '')\n        self.visible = cloud_data.get('visible', True)\n", "docstring": "if parent and session:"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_range(self):\n        \"\"\" Returns the Range instance this named range refers to \"\"\"\n        url = self.build_url(self._endpoints.get('get_range'))\n        response = self.session.get(url)\n        if not response:\n            return None\n        return self.range_constructor(parent=self, **{self._cloud_data_key: response.json()})\n", "docstring": "Returns the Range instance this named range refers to \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_range(self):\n        \"\"\" Gets the range object associated with the entire row \"\"\"\n        url = self.build_url(self._endpoints.get('get_range'))\n        response = self.session.get(url)\n        if not response:\n            return None\n        return self.range_constructor(parent=self, **{self._cloud_data_key: response.json()})\n", "docstring": "Gets the range object associated with the entire row \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def delete(self):\n        \"\"\" Deletes this row \"\"\"\n        url = self.build_url(self._endpoints.get('delete'))\n        return bool(self.session.post(url))\n", "docstring": "Deletes this row \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def delete(self):\n        \"\"\" Deletes this table Column \"\"\"\n        url = self.build_url(self._endpoints.get('delete'))\n        return bool(self.session.post(url))\n", "docstring": "Deletes this table Column \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def _get_range(self, endpoint_name):\n        \"\"\" Returns a Range based on the endpoint name \"\"\"\n        url = self.build_url(self._endpoints.get(endpoint_name))\n        response = self.session.get(url)\n        if not response:\n            return None\n        return self.range_constructor(parent=self, **{self._cloud_data_key: response.json()})\n", "docstring": "Returns a Range based on the endpoint name \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_header_row_range(self):\n        \"\"\" Gets the range object associated with the header row of the column \"\"\"\n        return self._get_range('header_row_range')\n", "docstring": "Gets the range object associated with the header row of the column \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_range(self):\n        \"\"\" Gets the range object associated with the entire column \"\"\"\n        return self._get_range('entire_range')\n", "docstring": "Gets the range object associated with the entire column \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def __init__(self, parent=None, session=None, **kwargs):\n        if parent and session:\n            raise ValueError('Need a parent or a session but not both')\n        self.parent = parent\n        self.session = parent.session if parent else session\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.object_id = cloud_data.get('id', None)\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        # append the encoded table path\n        main_resource = \"{}/tables('{}')\".format(main_resource, quote(self.object_id))\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        self.name = cloud_data.get('name', None)\n        self.show_headers = cloud_data.get('showHeaders', True)\n        self.show_totals = cloud_data.get('showTotals', True)\n        self.style = cloud_data.get('style', None)\n        self.highlight_first_column = cloud_data.get('highlightFirstColumn', False)\n        self.highlight_last_column = cloud_data.get('highlightLastColumn', False)\n        self.show_banded_columns = cloud_data.get('showBandedColumns', False)\n        self.show_banded_rows = cloud_data.get('showBandedRows', False)\n        self.show_filter_button = cloud_data.get('showFilterButton', False)\n        self.legacy_id = cloud_data.get('legacyId', False)\n", "docstring": "if parent and session:"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_row(self, index):\n        \"\"\" Returns a Row instance at an index \"\"\"\n        url = self.build_url(self._endpoints.get('get_row').format(id=index))\n        response = self.session.get(url)\n        if not response:\n            return None\n        return self.row_constructor(parent=self, **{self._cloud_data_key: response.json()})\n", "docstring": "Returns a Row instance at an index \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def _get_range(self, endpoint_name):\n        \"\"\" Returns a Range based on the endpoint name \"\"\"\n        url = self.build_url(self._endpoints.get(endpoint_name))\n        response = self.session.get(url)\n        if not response:\n            return None\n        data = response.json()\n        return self.range_constructor(parent=self, **{self._cloud_data_key: data})\n", "docstring": "Returns a Range based on the endpoint name \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_header_row_range(self):\n        \"\"\" Gets the range object associated with the header row of the table \"\"\"\n        return self._get_range('header_row_range')\n", "docstring": "Gets the range object associated with the header row of the table \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_range(self):\n        \"\"\" Gets the range object associated with the entire table \"\"\"\n        return self._get_range('entire_range')\n", "docstring": "Gets the range object associated with the entire table \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def clear_filters(self):\n        \"\"\" Clears all the filters currently applied on the table. \"\"\"\n        url = self.build_url(self._endpoints.get('clear_filters'))\n        return bool(self.session.post(url))\n", "docstring": "Clears all the filters currently applied on the table. \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_worksheet(self):\n        \"\"\" Returns this table worksheet \"\"\"\n        url = self.build_url('')\n        q = self.q().select('name').expand('worksheet')\n        response = self.session.get(url, params=q.as_params())\n        if not response:\n            return None\n        data = response.json()\n        ws = data.get('worksheet')\n        if ws is None:\n            return None\n        return WorkSheet(parent=self.parent, **{self._cloud_data_key: ws})\n", "docstring": "Returns this table worksheet \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def __init__(self, parent=None, session=None, **kwargs):\n        if parent and session:\n            raise ValueError('Need a parent or a session but not both')\n        self.workbook = parent\n        self.session = parent.session if parent else session\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.object_id = cloud_data.get('id', None)\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        # append the encoded worksheet path\n        main_resource = \"{}/worksheets('{}')\".format(main_resource, quote(self.object_id))\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        self.name = cloud_data.get('name', None)\n        self.position = cloud_data.get('position', None)\n        self.visibility = cloud_data.get('visibility', None)\n", "docstring": "if parent and session:"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def delete(self):\n        \"\"\" Deletes this worksheet \"\"\"\n        return bool(self.session.delete(self.build_url('')))\n", "docstring": "Deletes this worksheet \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_tables(self):\n        \"\"\" Returns a collection of this worksheet tables\"\"\"\n        url = self.build_url(self._endpoints.get('get_tables'))\n        response = self.session.get(url)\n        if not response:\n            return []\n        data = response.json()\n        return [self.table_constructor(parent=self, **{self._cloud_data_key: table})\n                for table in data.get('value', [])]\n", "docstring": "Returns a collection of this worksheet tables\n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_used_range(self):\n        \"\"\" Returns the smallest range that encompasses any cells that\n         have a value or formatting assigned to them.\n        \"\"\"\n        url = self.build_url(self._endpoints.get('get_used_range'))\n        response = self.session.get(url)\n        if not response:\n            return None\n        return self.range_constructor(parent=self, **{self._cloud_data_key: response.json()})\n", "docstring": "Returns the smallest range that encompasses any cells that"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def remove_sheet_name_from_address(address):\n        \"\"\" Removes the sheet name from a given address \"\"\"\n        compiled = re.compile('([a-zA-Z]+[0-9]+):.*?([a-zA-Z]+[0-9]+)')\n        result = compiled.search(address)\n        if result:\n            return ':'.join(result.groups())\n        else:\n            return address\n", "docstring": "Removes the sheet name from a given address \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def __repr__(self):\n        return 'WorkbookApplication for Workbook: {}'.format(self.workbook_id or 'Not set')\n", "docstring": "return 'WorkbookApplication for Workbook: {}'.format(self.workbook_id or 'Not set')"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_details(self):\n        \"\"\" Gets workbookApplication \"\"\"\n        url = self.build_url(self._endpoints.get('get_details'))\n        response = self.con.get(url)\n        if not response:\n            return None\n        return response.json()\n", "docstring": "Gets workbookApplication \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def __init__(self, file_item, *, use_session=True, persist=True):\n        \"\"\" Create a workbook representation\n        :param File file_item: the Drive File you want to interact with\n        :param Bool use_session: Whether or not to use a session to be more efficient\n        :param Bool persist: Whether or not to persist this info\n        \"\"\"\n        if file_item is None or not isinstance(file_item, File) or file_item.mime_type != EXCEL_XLSX_MIME_TYPE:\n            raise ValueError('This file is not a valid Excel xlsx file.')\n        if isinstance(file_item.protocol, MSOffice365Protocol):\n            raise ValueError('Excel capabilities are only allowed on the MSGraph protocol')\n        # append the workbook path\n        main_resource = '{}{}/workbook'.format(file_item.main_resource,\n                                               file_item._endpoints.get('item').format(id=file_item.object_id))\n        super().__init__(protocol=file_item.protocol, main_resource=main_resource)\n        persist = persist if use_session is True else True\n        self.session = WorkbookSession(parent=file_item, persist=persist, main_resource=main_resource)\n        if use_session:\n            self.session.create_session()\n        self.name = file_item.name\n        self.object_id = 'Workbook:{}'.format(file_item.object_id)  # Mangle the object id\n", "docstring": "Create a workbook representation"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_tables(self):\n        \"\"\" Returns a collection of this workbook tables\"\"\"\n        url = self.build_url(self._endpoints.get('get_tables'))\n        response = self.session.get(url)\n        if not response:\n            return []\n        data = response.json()\n        return [self.table_constructor(parent=self, **{self._cloud_data_key: table})\n                for table in data.get('value', [])]\n", "docstring": "Returns a collection of this workbook tables\n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_worksheet(self, id_or_name):\n        \"\"\" Gets a specific worksheet by id or name \"\"\"\n        url = self.build_url(self._endpoints.get('get_worksheet').format(id=quote(id_or_name)))\n        response = self.session.get(url)\n        if not response:\n            return None\n        return self.worksheet_constructor(parent=self, **{self._cloud_data_key: response.json()})\n", "docstring": "Gets a specific worksheet by id or name \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def delete_worksheet(self, worksheet_id):\n        \"\"\" Deletes a worksheet by it's id \"\"\"\n        url = self.build_url(self._endpoints.get('get_worksheet').format(id=quote(worksheet_id)))\n        return bool(self.session.delete(url))\n", "docstring": "Deletes a worksheet by it's id \n"}
{"repo": "python-o365-master/O365/excel.py", "original_string": "    def get_named_ranges(self):\n        \"\"\" Returns the list of named ranges for this Workbook \"\"\"\n        url = self.build_url(self._endpoints.get('get_names'))\n        response = self.session.get(url)\n        if not response:\n            return []\n        data = response.json()\n        return [self.named_range_constructor(parent=self, **{self._cloud_data_key: nr})\n                for nr in data.get('value', [])]\n", "docstring": "Returns the list of named ranges for this Workbook \n"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def __init__(self, event, recurrence=None):\n        \"\"\" A representation of an event recurrence properties\n        :param Event event: event object\n        :param dict recurrence: recurrence information\n        \"\"\"\n        super().__init__(protocol=event.protocol,\n                         main_resource=event.main_resource)\n        self._event = event\n        recurrence = recurrence or {}\n        # recurrence pattern\n        recurrence_pattern = recurrence.get(self._cc('pattern'), {})\n        self.__interval = recurrence_pattern.get(self._cc('interval'), None)\n        self.__days_of_week = recurrence_pattern.get(self._cc('daysOfWeek'),\n                                                     set())\n        self.__first_day_of_week = recurrence_pattern.get(\n            self._cc('firstDayOfWeek'), None)\n        if 'type' in recurrence_pattern.keys():\n            if 'weekly' not in recurrence_pattern['type'].lower():\n                self.__first_day_of_week = None\n                \n        self.__day_of_month = recurrence_pattern.get(self._cc('dayOfMonth'),\n                                                     None)\n        self.__month = recurrence_pattern.get(self._cc('month'), None)\n        self.__index = recurrence_pattern.get(self._cc('index'), 'first')\n        # recurrence range\n        recurrence_range = recurrence.get(self._cc('range'), {})\n        self.__occurrences = recurrence_range.get(\n            self._cc('numberOfOccurrences'), None)\n        self.__start_date = recurrence_range.get(self._cc('startDate'), None)\n        self.__end_date = recurrence_range.get(self._cc('endDate'), None)\n        self.__recurrence_time_zone = recurrence_range.get(\n            self._cc('recurrenceTimeZone'),\n            get_windows_tz(self.protocol.timezone))\n        # time and time zones are not considered in recurrence ranges...\n        # I don't know why 'recurrenceTimeZone' is present here\n        # Sending a startDate datetime to the server results in an Error:\n        # Cannot convert the literal 'datetime' to the expected type 'Edm.Date'\n        if recurrence_range:\n            self.__start_date = parse(\n                self.__start_date).date() if self.__start_date else None\n            self.__end_date = parse(\n                self.__end_date).date() if self.__end_date else None\n", "docstring": "A representation of an event recurrence properties"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def _track_changes(self):\n        \"\"\" Update the track_changes on the event to reflect a needed\n        update on this field \"\"\"\n        self._event._track_changes.add('recurrence')\n", "docstring": "Update the track_changes on the event to reflect a needed"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def interval(self):\n        \"\"\" Repeat interval for the event\n        :getter: Get the current interval\n        :setter: Update to a new interval\n        :type: int\n        \"\"\"\n        return self.__interval\n", "docstring": "Repeat interval for the event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def days_of_week(self):\n        \"\"\" Days in week to repeat\n        :getter: Get the current list of days\n        :setter: Set the list of days to repeat\n        :type: set(str)\n        \"\"\"\n        return self.__days_of_week\n", "docstring": "Days in week to repeat"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def first_day_of_week(self):\n        \"\"\" Which day to consider start of the week\n        :getter: Get the current start of week\n        :setter: Set the start day of week\n        :type: str\n        \"\"\"\n        return self.__first_day_of_week\n", "docstring": "Which day to consider start of the week"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def day_of_month(self):\n        \"\"\" Repeat on this day of month\n        :getter: Get the repeat day of month\n        :setter: Set the repeat day of month\n        :type: int\n        \"\"\"\n        return self.__day_of_month\n", "docstring": "Repeat on this day of month"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def month(self):\n        \"\"\" Month of the event\n        :getter: Get month\n        :setter: Update month\n        :type: int\n        \"\"\"\n        return self.__month\n", "docstring": "Month of the event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def occurrences(self):\n        \"\"\" No. of occurrences\n        :getter: Get the no. of occurrences\n        :setter: Set the no. of occurrences\n        :type: int\n        \"\"\"\n        return self.__occurrences\n", "docstring": "No. of occurrences"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def recurrence_time_zone(self):\n        \"\"\" Timezone to consider for repeating\n        :getter: Get the timezone\n        :setter: Set the timezone\n        :type: str\n        \"\"\"\n        return self.__recurrence_time_zone\n", "docstring": "Timezone to consider for repeating"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def start_date(self):\n        \"\"\" Start date of repetition\n        :getter: get the start date\n        :setter: set the start date\n        :type: date\n        \"\"\"\n        return self.__start_date\n", "docstring": "Start date of repetition"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def end_date(self):\n        \"\"\" End date of repetition\n        :getter: get the end date\n        :setter: set the end date\n        :type: date\n        \"\"\"\n        return self.__end_date\n", "docstring": "End date of repetition"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def _clear_pattern(self):\n        \"\"\" Clears this event recurrence \"\"\"\n        # pattern group\n        self.__interval = None\n        self.__days_of_week = set()\n        self.__first_day_of_week = None\n        self.__day_of_month = None\n        self.__month = None\n        self.__index = 'first'\n        # range group\n        self.__start_date = None\n        self.__end_date = None\n        self.__occurrences = None\n", "docstring": "Clears this event recurrence \n"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def set_daily(self, interval, **kwargs):\n        \"\"\" Set to repeat every x no. of days\n        :param int interval: no. of days to repeat at\n        :keyword date start: Start date of repetition (kwargs)\n        :keyword date end: End date of repetition (kwargs)\n        :keyword int occurrences: no of occurrences (kwargs)\n        \"\"\"\n        self._clear_pattern()\n        self.__interval = interval\n        self.set_range(**kwargs)\n", "docstring": "Set to repeat every x no. of days"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def __init__(self, parent, response_status):\n        \"\"\" An event response status (status, time)\n        :param parent: parent of this\n        :type parent: Attendees or Event\n        :param dict response_status: status info frm cloud\n        \"\"\"\n        super().__init__(protocol=parent.protocol,\n                         main_resource=parent.main_resource)\n        self.status = response_status.get(self._cc('response'), 'none')\n        self.status = None if self.status == 'none' else EventResponse.from_value(self.status)\n        if self.status:\n            self.response_time = response_status.get(self._cc('time'), None)\n            if self.response_time == '0001-01-01T00:00:00Z':\n                # consider there's no response time\n                # this way we don't try to convert this Iso 8601 datetime to the\n                #  local timezone which generated parse errors\n                self.response_time = None\n            if self.response_time:\n                try:\n                    self.response_time = parse(self.response_time).astimezone(\n                        self.protocol.timezone)\n                except OverflowError:\n                    log.debug(\"Couldn't parse event response time: {}\".format(self.response_time))\n                    self.response_time = None\n        else:\n            self.response_time = None\n", "docstring": "An event response status (status, time)"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def address(self):\n        \"\"\" Email address\n        :getter: Get the email address of attendee\n        :setter: Set the email address of attendee\n        :type: str\n        \"\"\"\n        return self._address\n", "docstring": "Email address"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def response_status(self):\n        \"\"\" Response status of the attendee\n        :type: ResponseStatus\n        \"\"\"\n        return self.__response_status\n", "docstring": "Response status of the attendee"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def attendee_type(self):\n        \"\"\" Requirement of the attendee\n        :getter: Get the requirement of attendee\n        :setter: Set the requirement of attendee\n        :type: AttendeeType\n        \"\"\"\n        return self.__attendee_type\n", "docstring": "Requirement of the attendee"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def __init__(self, event, attendees=None):\n        \"\"\" Create a collection of attendees\n        :param Event event: event for which to assign the attendees\n        :param attendees: list of attendees to add\n        :type attendees: str or tuple(str, str) or Attendee or list[str] or\n         list[tuple(str,str)] or list[Attendee]\n        \"\"\"\n        super().__init__(protocol=event.protocol,\n                         main_resource=event.main_resource)\n        self._event = event\n        self.__attendees = []\n        self.untrack = True\n        if attendees:\n            self.add(attendees)\n        self.untrack = False\n", "docstring": "Create a collection of attendees"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def _track_changes(self):\n        \"\"\" Update the track_changes on the event to reflect a needed\n        update on this field \"\"\"\n        if self.untrack is False:\n            self._event._track_changes.add('attendees')\n", "docstring": "Update the track_changes on the event to reflect a needed"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def remove(self, attendees):\n        \"\"\" Remove the provided attendees from the event\n        :param attendees: list of attendees to add\n        :type attendees: str or tuple(str, str) or Attendee or list[str] or\n         list[tuple(str,str)] or list[Attendee]\n        \"\"\"\n        if isinstance(attendees, (list, tuple)):\n            attendees = {\n                attendee.address if isinstance(attendee, Attendee) else attendee\n                for\n                attendee in attendees}\n        elif isinstance(attendees, str):\n            attendees = {attendees}\n        elif isinstance(attendees, Attendee):\n            attendees = {attendees.address}\n        else:\n            raise ValueError('Incorrect parameter type for attendees')\n        new_attendees = []\n        for attendee in self.__attendees:\n            if attendee.address not in attendees:\n                new_attendees.append(attendee)\n        self.__attendees = new_attendees\n        self._track_changes()\n", "docstring": "Remove the provided attendees from the event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def to_api_data(self, restrict_keys=None):\n        \"\"\" Returns a dict to communicate with the server\n        :param restrict_keys: a set of keys to restrict the returned data to\n        :rtype: dict\n        \"\"\"\n        cc = self._cc  # alias\n        if self.__location:\n            if isinstance(self.__location, dict):\n                location = self.__location\n            else:\n                location = {cc('displayName'): self.__location}\n        else:\n            location = {cc('displayName'): ''}\n        data = {\n            cc('subject'): self.__subject,\n            cc('body'): {\n                cc('contentType'): self.body_type,\n                cc('content'): self.__body},\n            cc('start'): self._build_date_time_time_zone(self.__start),\n            cc('end'): self._build_date_time_time_zone(self.__end),\n            cc('attendees'): self.__attendees.to_api_data(),\n            cc('location'): location,\n            cc('categories'): self.__categories,\n            cc('isAllDay'): self.__is_all_day,\n            cc('importance'): cc(self.__importance.value),\n            cc('isReminderOn'): self.__is_reminder_on,\n            cc('reminderMinutesBeforeStart'): self.__remind_before_minutes,\n            cc('responseRequested'): self.__response_requested,\n            cc('sensitivity'): cc(self.__sensitivity.value),\n            cc('showAs'): cc(self.__show_as.value),\n            cc('isOnlineMeeting'): cc(self.__is_online_meeting),\n            cc('onlineMeetingProvider'): cc(self.__online_meeting_provider.value),\n        }\n        if self.__recurrence:\n            data[cc('recurrence')] = self.__recurrence.to_api_data()\n        \n        if self.has_attachments:\n            data[cc('attachments')] = self.__attachments.to_api_data()\n        if restrict_keys:\n            if 'attachments' in restrict_keys:\n                self.attachments._update_attachments_to_cloud()\n            for key in list(data.keys()):\n                if key not in restrict_keys:\n                    del data[key]\n        return data\n", "docstring": "Returns a dict to communicate with the server"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def created(self):\n        \"\"\" Created time of the event\n        :rtype: datetime\n        \"\"\"\n        return self.__created\n", "docstring": "Created time of the event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def modified(self):\n        \"\"\" Last modified time of the event\n        :rtype: datetime\n        \"\"\"\n        return self.__modified\n", "docstring": "Last modified time of the event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def body(self):\n        \"\"\" Body of the event\n        :getter: Get body text\n        :setter: Set body of event\n        :type: str\n        \"\"\"\n        return self.__body\n", "docstring": "Body of the event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def subject(self):\n        \"\"\" Subject of the event\n        :getter: Get subject\n        :setter: Set subject of event\n        :type: str\n        \"\"\"\n        return self.__subject\n", "docstring": "Subject of the event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def start(self):\n        \"\"\" Start Time of event\n        :getter: get the start time\n        :setter: set the start time\n        :type: datetime\n        \"\"\"\n        return self.__start\n", "docstring": "Start Time of event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def end(self):\n        \"\"\" End Time of event\n        :getter: get the end time\n        :setter: set the end time\n        :type: datetime\n        \"\"\"\n        return self.__end\n", "docstring": "End Time of event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def importance(self):\n        \"\"\" Event Priority\n        :getter: get importance of event\n        :setter: set the importance of event\n        :type: ImportanceLevel\n        \"\"\"\n        return self.__importance\n", "docstring": "Event Priority"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def is_all_day(self):\n        \"\"\" Is the event for whole day\n        :getter: get the current status of is_all_day property\n        :setter: set if the event is all day or not\n        :type: bool\n        \"\"\"\n        return self.__is_all_day\n", "docstring": "Is the event for whole day"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def location(self):\n        \"\"\" Location of event\n        :getter: get current location configured for the event\n        :setter: set a location for the event\n        :type: str\n        \"\"\"\n        return self.__location\n", "docstring": "Location of event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def is_reminder_on(self):\n        \"\"\" Status of the Reminder\n        :getter: check is reminder enabled or not\n        :setter: enable or disable reminder option\n        :type: bool\n        \"\"\"\n        return self.__is_reminder_on\n", "docstring": "Status of the Reminder"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def remind_before_minutes(self):\n        \"\"\" No. of minutes to remind before the meeting\n        :getter: get current minutes\n        :setter: set to remind before new x minutes\n        :type: int\n        \"\"\"\n        return self.__remind_before_minutes\n", "docstring": "No. of minutes to remind before the meeting"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def response_requested(self):\n        \"\"\" Is response requested or not\n        :getter: Is response requested or not\n        :setter: set the event to request response or not\n        :type: bool\n        \"\"\"\n        return self.__response_requested\n", "docstring": "Is response requested or not"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def recurrence(self):\n        \"\"\" Recurrence information of the event\n        :rtype: EventRecurrence\n        \"\"\"\n        return self.__recurrence\n", "docstring": "Recurrence information of the event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def organizer(self):\n        \"\"\" Organizer of the meeting event\n        :rtype: Recipient\n        \"\"\"\n        return self.__organizer\n", "docstring": "Organizer of the meeting event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def show_as(self):\n        \"\"\" Show as \"busy\" or any other status during the event\n        :getter: Current status during the event\n        :setter: update show as status\n        :type: EventShowAs\n        \"\"\"\n        return self.__show_as\n", "docstring": "Show as \"busy\" or any other status during the event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def sensitivity(self):\n        \"\"\" Sensitivity of the Event\n        :getter: Get the current sensitivity\n        :setter: Set a new sensitivity\n        :type: EventSensitivity\n        \"\"\"\n        return self.__sensitivity\n", "docstring": "Sensitivity of the Event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def response_status(self):\n        \"\"\" Your response\n        :rtype: ResponseStatus\n        \"\"\"\n        return self.__response_status\n", "docstring": "Your response"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def attachments(self):\n        \"\"\" List of attachments\n        :rtype: EventAttachments\n        \"\"\"\n        return self.__attachments\n", "docstring": "List of attachments"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def attendees(self):\n        \"\"\" List of meeting attendees\n        :rtype: Attendees\n        \"\"\"\n        return self.__attendees\n", "docstring": "List of meeting attendees"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def categories(self):\n        \"\"\" Categories of the event\n        :getter: get the list of categories\n        :setter: set the list of categories\n        :type: list[str]\n        \"\"\"\n        return self.__categories\n", "docstring": "Categories of the event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def is_online_meeting(self):\n        \"\"\" Status of the online_meeting\n        :getter: check is online_meeting enabled or not\n        :setter: enable or disable online_meeting option\n        :type: bool\n        \"\"\"\n        return self.__is_online_meeting\n", "docstring": "Status of the online_meeting"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def online_meeting_provider(self):\n        \"\"\" online_meeting_provider of event\n        :getter: get current online_meeting_provider configured for the event\n        :setter: set a online_meeting_provider for the event\n        :type: OnlineMeetingProviderType\n        \"\"\"\n        return self.__online_meeting_provider\n", "docstring": "online_meeting_provider of event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def delete(self):\n        \"\"\" Deletes a stored event\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        if self.object_id is None:\n            raise RuntimeError('Attempting to delete an unsaved event')\n        url = self.build_url(\n            self._endpoints.get('event').format(id=self.object_id))\n        response = self.con.delete(url)\n        return bool(response)\n", "docstring": "Deletes a stored event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def cancel_event(self, comment=None, *, send_response=True):\n        \"\"\" Cancel the event\n        :param str comment: comment to add\n        :param bool send_response: whether or not to send response back\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        if not self.object_id:\n            raise RuntimeError(\"Can't accept event that doesn't exist\")\n        url = self.build_url(\n            self._endpoints.get('event').format(id=self.object_id))\n        url = url + '/cancel'\n        data = {}\n        if comment and isinstance(comment, str):\n            data[self._cc('comment')] = comment\n        if send_response is False:\n            data[self._cc('sendResponse')] = send_response\n        response = self.con.post(url, data=data or None)\n        return bool(response)\n", "docstring": "Cancel the event"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def get_body_soup(self):\n        \"\"\" Returns the beautifulsoup4 of the html body\n        :return: Html body\n        :rtype: BeautifulSoup\n        \"\"\"\n        if self.body_type != 'HTML':\n            return None\n        else:\n            return bs(self.body, 'html.parser')\n", "docstring": "Returns the beautifulsoup4 of the html body"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" Create a Calendar Representation\n        :param parent: parent for this operation\n        :type parent: Schedule\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.name = cloud_data.get(self._cc('name'), '')\n        self.calendar_id = cloud_data.get(self._cc('id'), None)\n        self.__owner = self._recipient_from_cloud(\n            cloud_data.get(self._cc('owner'), {}), field='owner')\n        color = cloud_data.get(self._cc('color'), 'auto')\n        try:\n            self.color = CalendarColor.from_value(color)\n        except:\n            self.color = CalendarColor.from_value('auto')\n        self.can_edit = cloud_data.get(self._cc('canEdit'), False)\n        self.can_share = cloud_data.get(self._cc('canShare'), False)\n        self.can_view_private_items = cloud_data.get(\n            self._cc('canViewPrivateItems'), False)\n", "docstring": "Create a Calendar Representation"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def owner(self):\n        \"\"\" Owner of the calendar\n        :rtype: str\n        \"\"\"\n        return self.__owner\n", "docstring": "Owner of the calendar"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def delete(self):\n        \"\"\" Deletes this calendar\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        if not self.calendar_id:\n            return False\n        url = self.build_url(\n            self._endpoints.get('calendar').format(id=self.calendar_id))\n        response = self.con.delete(url)\n        if not response:\n            return False\n        self.calendar_id = None\n        return True\n", "docstring": "Deletes this calendar"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def new_event(self, subject=None):\n        \"\"\" Returns a new (unsaved) Event object\n        :rtype: Event\n        \"\"\"\n        return self.event_constructor(parent=self, subject=subject,\n                                      calendar_id=self.calendar_id)\n", "docstring": "Returns a new (unsaved) Event object"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" Create a wrapper around calendars and events\n        :param parent: parent for this operation\n        :type parent: Account\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n", "docstring": "Create a wrapper around calendars and events"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def new_calendar(self, calendar_name):\n        \"\"\" Creates a new calendar\n        :param str calendar_name: name of the new calendar\n        :return: a new Calendar instance\n        :rtype: Calendar\n        \"\"\"\n        if not calendar_name:\n            return None\n        url = self.build_url(self._endpoints.get('root_calendars'))\n        response = self.con.post(url, data={self._cc('name'): calendar_name})\n        if not response:\n            return None\n        data = response.json()\n        # Everything received from cloud must be passed as self._cloud_data_key\n        return self.calendar_constructor(parent=self,\n                                         **{self._cloud_data_key: data})\n", "docstring": "Creates a new calendar"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def get_default_calendar(self):\n        \"\"\" Returns the default calendar for the current user\n        :rtype: Calendar\n        \"\"\"\n        url = self.build_url(self._endpoints.get('default_calendar'))\n        response = self.con.get(url)\n        if not response:\n            return None\n        data = response.json()\n        # Everything received from cloud must be passed as self._cloud_data_key\n        return self.calendar_constructor(parent=self,\n                                         **{self._cloud_data_key: data})\n", "docstring": "Returns the default calendar for the current user"}
{"repo": "python-o365-master/O365/calendar.py", "original_string": "    def new_event(self, subject=None):\n        \"\"\" Returns a new (unsaved) Event object in the default calendar\n        :param str subject: subject text for the new event\n        :return: new event\n        :rtype: Event\n        \"\"\"\n        return self.event_constructor(parent=self, subject=subject)\n", "docstring": "Returns a new (unsaved) Event object in the default calendar"}
{"repo": "python-o365-master/O365/sharepoint.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" A Sharepoint ListItem within a SharepointList\n        :param parent: parent object\n        :type parent: SharepointList\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        self._parent = parent\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self._track_changes = TrackerSet(casing=self._cc)\n        self.object_id = cloud_data.get('id')\n        created = cloud_data.get(self._cc('createdDateTime'), None)\n        modified = cloud_data.get(self._cc('lastModifiedDateTime'), None)\n        local_tz = self.protocol.timezone\n        self.created = parse(created).astimezone(local_tz) if created else None\n        self.modified = parse(modified).astimezone(local_tz) if modified else None\n        created_by = cloud_data.get(self._cc('createdBy'), {}).get('user', None)\n        self.created_by = Contact(con=self.con, protocol=self.protocol,\n                                  **{self._cloud_data_key: created_by}) if created_by else None\n        modified_by = cloud_data.get(self._cc('lastModifiedBy'), {}).get('user', None)\n        self.modified_by = Contact(con=self.con, protocol=self.protocol,\n                                   **{self._cloud_data_key: modified_by}) if modified_by else None\n        self.web_url = cloud_data.get(self._cc('webUrl'), None)\n        self.content_type_id = cloud_data.get(self._cc('contentType'), {}).get('id', None)\n        self.fields = cloud_data.get(self._cc('fields'), None)\n", "docstring": "A Sharepoint ListItem within a SharepointList"}
{"repo": "python-o365-master/O365/sharepoint.py", "original_string": "    def _valid_field(self, field):\n        # Verify the used field names are valid internal field names\n        valid_field_names = self.fields if self.fields \\\n            else self._parent.column_name_cw.values() \\\n            if self._parent \\\n            else None\n        if valid_field_names:\n            return field in valid_field_names\n        # If no parent is given, and no internal fields are defined assume correct, API will check\n        return True\n", "docstring": "Verify the used field names are valid internal field names"}
{"repo": "python-o365-master/O365/sharepoint.py", "original_string": "    def save_updates(self):\n        \"\"\"Save the updated fields to the cloud\"\"\"\n        if not self._track_changes:\n            return True  # there's nothing to update\n        url = self.build_url(self._endpoints.get('update_list_item').format(item_id=self.object_id))\n        update = {field: value for field, value in self.fields.items()\n                  if self._cc(field) in self._track_changes}\n        response = self.con.patch(url, update)\n        if not response:\n            return False\n        self._clear_tracker()\n        return True\n", "docstring": "Save the updated fields to the cloud\n"}
{"repo": "python-o365-master/O365/sharepoint.py", "original_string": "    def get_item_by_id(self, item_id, expand_fields=None):\n        \"\"\" Returns a sharepoint list item based on id\n        :param int item_id: item id to search for\n        :param expand_fields: specify user-defined fields to return,\n         True will return all fields\n        :type expand_fields: list or bool         \n        :return: Sharepoint Item\n        :rtype: SharepointListItem\n        \"\"\"\n        url = self.build_url(self._endpoints.get('get_item_by_id').format(item_id=item_id))\n        \n        params = {}\n        \n        if expand_fields is not None:\n            params['expand'] = self.build_field_filter(expand_fields)\n            \n        response = self.con.get(url, params=params)\n        if not response:\n            return []\n        data = response.json()\n        return self.list_item_constructor(parent=self, **{self._cloud_data_key: data})\n", "docstring": "Returns a sharepoint list item based on id"}
{"repo": "python-o365-master/O365/sharepoint.py", "original_string": "    def create_list_item(self, new_data):\n        \"\"\"Create new list item\n        :param new_data: dictionary of {'col_name': col_value}\n        :rtype: SharepointListItem\n        \"\"\"\n        url = self.build_url(self._endpoints.get('get_items'))\n        response = self.con.post(url, {'fields': new_data})\n        if not response:\n            return False\n        data = response.json()\n        return self.list_item_constructor(parent=self, **{self._cloud_data_key: data})\n", "docstring": "Create new list item"}
{"repo": "python-o365-master/O365/sharepoint.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" A Sharepoint site List\n        :param parent: parent object\n        :type parent: Sharepoint\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.object_id = cloud_data.get('id')\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        # prefix with the current known site\n        resource_prefix = 'sites/{site_id}'.format(site_id=self.object_id)\n        main_resource = (resource_prefix if isinstance(parent, Site)\n                         else '{}{}'.format(main_resource, resource_prefix))\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        self.root = 'root' in cloud_data  # True or False\n        # Fallback to manual site\n        self.name = cloud_data.get(self._cc('name'), kwargs.get('name', ''))\n        self.display_name = cloud_data.get(self._cc('displayName'), '')\n        if not self.name:\n            self.name = self.display_name\n        self.description = cloud_data.get(self._cc('description'), '')\n        self.web_url = cloud_data.get(self._cc('webUrl'))\n        created = cloud_data.get(self._cc('createdDateTime'), None)\n        modified = cloud_data.get(self._cc('lastModifiedDateTime'), None)\n        local_tz = self.protocol.timezone\n        self.created = parse(created).astimezone(local_tz) if created else None\n        self.modified = parse(modified).astimezone(\n            local_tz) if modified else None\n        # site storage to access Drives and DriveItems\n        self.site_storage = Storage(parent=self,\n                                    main_resource='/sites/{id}'.format(\n                                        id=self.object_id))\n", "docstring": "A Sharepoint site List"}
{"repo": "python-o365-master/O365/sharepoint.py", "original_string": "    def get_default_document_library(self, request_drive=False):\n        \"\"\" Returns the default document library of this site (Drive instance)\n        :param request_drive: True will make an api call to retrieve\n         the drive data\n        :rtype: Drive\n        \"\"\"\n        return self.site_storage.get_default_drive(request_drive=request_drive)\n", "docstring": "Returns the default document library of this site (Drive instance)"}
{"repo": "python-o365-master/O365/sharepoint.py", "original_string": "    def list_document_libraries(self):\n        \"\"\" Returns a collection of document libraries for this site\n        (a collection of Drive instances)\n        :return: list of items in this folder\n        :rtype: list[Drive] or Pagination\n        \"\"\"\n        return self.site_storage.get_drives()\n", "docstring": "Returns a collection of document libraries for this site"}
{"repo": "python-o365-master/O365/sharepoint.py", "original_string": "    def get_lists(self):\n        \"\"\" Returns a collection of lists within this site\n        :rtype: list[SharepointList]\n        \"\"\"\n        url = self.build_url(self._endpoints.get('get_lists'))\n        response = self.con.get(url)\n        if not response:\n            return []\n        data = response.json()\n        return [self.list_constructor(parent=self, **{self._cloud_data_key: lst}) for lst in data.get('value', [])]\n", "docstring": "Returns a collection of lists within this site"}
{"repo": "python-o365-master/O365/sharepoint.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" A Sharepoint site List\n        :param parent: parent object\n        :type parent: Account\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        # Choose the main_resource passed in kwargs over the host_name\n        main_resource = kwargs.pop('main_resource',\n                                   '')  # defaults to blank resource\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n", "docstring": "A Sharepoint site List"}
{"repo": "python-o365-master/O365/sharepoint.py", "original_string": "    def __repr__(self):\n        return 'Sharepoint'\n", "docstring": "return 'Sharepoint'"}
{"repo": "python-o365-master/O365/sharepoint.py", "original_string": "    def get_root_site(self):\n        \"\"\" Returns the root site\n        :rtype: Site\n        \"\"\"\n        return self.get_site('root')\n", "docstring": "Returns the root site"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def created(self):\n        \"\"\" Created Time\n        :rtype: datetime\n        \"\"\"\n        return self.__created\n", "docstring": "Created Time"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def modified(self):\n        \"\"\" Last Modified Time\n        :rtype: datetime\n        \"\"\"\n        return self.__modified\n", "docstring": "Last Modified Time"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def display_name(self):\n        \"\"\" Display Name\n        :getter: Get the display name of the contact\n        :setter: Update the display name\n        :type: str\n        \"\"\"\n        return self.__display_name\n", "docstring": "Display Name"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def name(self):\n        \"\"\" First Name\n        :getter: Get the name of the contact\n        :setter: Update the name\n        :type: str\n        \"\"\"\n        return self.__name\n", "docstring": "First Name"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def surname(self):\n        \"\"\" Surname of Contact\n        :getter: Get the surname of the contact\n        :setter: Update the surname\n        :type: str\n        \"\"\"\n        return self.__surname\n", "docstring": "Surname of Contact"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def full_name(self):\n        \"\"\" Full Name (Name + Surname)\n        :rtype: str\n        \"\"\"\n        return '{} {}'.format(self.name, self.surname).strip()\n", "docstring": "Full Name (Name + Surname)"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def title(self):\n        \"\"\" Title (Mr., Ms., etc..)\n        :getter: Get the title of the contact\n        :setter: Update the title\n        :type: str\n        \"\"\"\n        return self.__title\n", "docstring": "Title (Mr., Ms., etc..)"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def job_title(self):\n        \"\"\" Job Title\n        :getter: Get the job title of contact\n        :setter: Update the job title\n        :type: str\n        \"\"\"\n        return self.__job_title\n", "docstring": "Job Title"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def company_name(self):\n        \"\"\" Name of the company\n        :getter: Get the company name of contact\n        :setter: Update the company name\n        :type: str\n        \"\"\"\n        return self.__company_name\n", "docstring": "Name of the company"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def department(self):\n        \"\"\" Department\n        :getter: Get the department of contact\n        :setter: Update the department\n        :type: str\n        \"\"\"\n        return self.__department\n", "docstring": "Department"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def office_location(self):\n        \"\"\" Office Location\n        :getter: Get the office location of contact\n        :setter: Update the office location\n        :type: str\n        \"\"\"\n        return self.__office_location\n", "docstring": "Office Location"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def business_phones(self):\n        \"\"\" Business Contact numbers\n        :getter: Get the contact numbers of contact\n        :setter: Update the contact numbers\n        :type: list[str]\n        \"\"\"\n        return self.__business_phones\n", "docstring": "Business Contact numbers"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def mobile_phone(self):\n        \"\"\" Personal Contact numbers\n        :getter: Get the contact numbers of contact\n        :setter: Update the contact numbers\n        :type: list[str]\n        \"\"\"\n        return self.__mobile_phone\n", "docstring": "Personal Contact numbers"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def home_phones(self):\n        \"\"\" Home Contact numbers\n        :getter: Get the contact numbers of contact\n        :setter: Update the contact numbers\n        :type: list[str]\n        \"\"\"\n        return self.__home_phones\n", "docstring": "Home Contact numbers"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def emails(self):\n        \"\"\" List of email ids of the Contact\n        :rtype: Recipients\n        \"\"\"\n        return self.__emails\n", "docstring": "List of email ids of the Contact"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def main_email(self):\n        \"\"\" Primary(First) email id of the Contact\n        :rtype: str\n        \"\"\"\n        if not self.emails:\n            return None\n        return self.emails[0].address\n", "docstring": "Primary(First) email id of the Contact"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def business_address(self):\n        \"\"\" Business Address\n        :getter: Get the address of contact\n        :setter: Update the address\n        :type: dict\n        \"\"\"\n        return self.__business_address\n", "docstring": "Business Address"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def home_address(self):\n        \"\"\" Home Address\n        :getter: Get the address of contact\n        :setter: Update the address\n        :type: dict\n        \"\"\"\n        return self.__home_address\n", "docstring": "Home Address"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def other_address(self):\n        \"\"\" Other Address\n        :getter: Get the address of contact\n        :setter: Update the address\n        :type: dict\n        \"\"\"\n        return self.__other_address\n", "docstring": "Other Address"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def preferred_language(self):\n        \"\"\" Preferred Language\n        :getter: Get the language of contact\n        :setter: Update the language\n        :type: str\n        \"\"\"\n        return self.__preferred_language\n", "docstring": "Preferred Language"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def categories(self):\n        \"\"\" Assigned Categories\n        :getter: Get the categories\n        :setter: Update the categories\n        :type: list[str]\n        \"\"\"\n        return self.__categories\n", "docstring": "Assigned Categories"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def folder_id(self):\n        \"\"\" ID of the folder\n        :rtype: str\n        \"\"\"\n        return self.__folder_id\n", "docstring": "ID of the folder"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def delete(self):\n        \"\"\" Deletes this contact\n        :return: Success or Failure\n        :rtype: bool\n        :raises RuntimeError: if contact is not yet saved to cloud\n        \"\"\"\n        if not self.object_id:\n            raise RuntimeError('Attempting to delete an unsaved Contact')\n        url = self.build_url(\n            self._endpoints.get('root_contact').format(id=self.object_id))\n        response = self.con.delete(url)\n        return bool(response)\n", "docstring": "Deletes this contact"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def new_message(self, recipient=None, *, recipient_type=RecipientType.TO):\n        \"\"\" This method returns a new draft Message instance with\n        contacts first email as a recipient\n        :param Recipient recipient: a Recipient instance where to send this\n         message. If None first email of this contact will be used\n        :param RecipientType recipient_type: section to add recipient into\n        :return: newly created message\n        :rtype: Message or None\n        \"\"\"\n        if isinstance(recipient_type, str):\n            recipient_type = RecipientType(recipient_type)\n        recipient = recipient or self.emails.get_first_recipient_with_address()\n        if not recipient:\n            return None\n        new_message = self.message_constructor(parent=self, is_draft=True)\n        target_recipients = getattr(new_message, str(recipient_type.value))\n        target_recipients.add(recipient)\n        return new_message\n", "docstring": "This method returns a new draft Message instance with"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def update_profile_photo(self, photo):\n        \"\"\" Updates this contact profile photo\n        :param bytes photo: the photo data in bytes\n        \"\"\"\n        url = self.build_url(self._endpoints.get('photo').format(id=self.object_id))\n        response = self.con.patch(url, data=photo, headers={'Content-type': 'image/jpeg'})\n        return bool(response)\n", "docstring": "Updates this contact profile photo"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" Create a contact folder component\n        :param parent: parent folder/account for this folder\n        :type parent: BaseContactFolder or Account\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        # This folder has no parents if root = True.\n        self.root = kwargs.pop('root', False)\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        # Fallback to manual folder if nothing available on cloud data\n        self.name = cloud_data.get(self._cc('displayName'),\n                                   kwargs.get('name',\n                                              ''))\n        # TODO: Most of above code is same as mailbox.Folder __init__\n        self.folder_id = cloud_data.get(self._cc('id'), None)\n        self.parent_id = cloud_data.get(self._cc('parentFolderId'), None)\n", "docstring": "Create a contact folder component"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def get_contacts(self, limit=100, *, query=None, order_by=None, batch=None):\n        \"\"\" Gets a list of contacts from this address book\n        To use query an order_by check the OData specification here:\n        http://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/\n        part2-url-conventions/odata-v4.0-errata03-os-part2-url-conventions\n        -complete.html\n        :param limit: max no. of contacts to get. Over 999 uses batch.\n        :type limit: int or None\n        :param query: applies a OData filter to the request\n        :type query: Query or str\n        :param order_by: orders the result set based on this condition\n        :type order_by: Query or str\n        :param int batch: batch size, retrieves items in\n         batches allowing to retrieve more items than the limit.\n        :return: list of contacts\n        :rtype: list[Contact] or Pagination\n        \"\"\"\n        if self.root:\n            url = self.build_url(self._endpoints.get('root_contacts'))\n        else:\n            url = self.build_url(\n                self._endpoints.get('folder_contacts').format(\n                    id=self.folder_id))\n        if limit is None or limit > self.protocol.max_top_value:\n            batch = self.protocol.max_top_value\n        params = {'$top': batch if batch else limit}\n        if order_by:\n            params['$orderby'] = order_by\n        if query:\n            if isinstance(query, str):\n                params['$filter'] = query\n            else:\n                params.update(query.as_params())\n        response = self.con.get(url, params=params)\n        if not response:\n            return iter(())\n        data = response.json()\n        # Everything received from cloud must be passed as self._cloud_data_key\n        contacts = (self.contact_constructor(parent=self,\n                                             **{self._cloud_data_key: contact})\n                    for contact in data.get('value', []))\n        next_link = data.get(NEXT_LINK_KEYWORD, None)\n        if batch and next_link:\n            return Pagination(parent=self, data=contacts,\n                              constructor=self.contact_constructor,\n                              next_link=next_link, limit=limit)\n        else:\n            return contacts\n", "docstring": "Gets a list of contacts from this address book"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def get_folder(self, folder_id=None, folder_name=None):\n        \"\"\" Returns a Contact Folder by it's id or child folders by name\n        :param folder_id: the folder_id to be retrieved.\n         Can be any folder Id (child or not)\n        :param folder_name: the folder name to be retrieved.\n         Must be a child of this folder\n        :return: a single contact folder\n        :rtype: ContactFolder\n        \"\"\"\n        if folder_id and folder_name:\n            raise RuntimeError('Provide only one of the options')\n        if not folder_id and not folder_name:\n            raise RuntimeError('Provide one of the options')\n        if folder_id:\n            # get folder by it's id, independent of the parent of this folder_id\n            url = self.build_url(\n                self._endpoints.get('get_folder').format(id=folder_id))\n            params = None\n        else:\n            # get folder by name. Only looks up in child folders.\n            if self.root:\n                url = self.build_url(self._endpoints.get('root_folders'))\n            else:\n                url = self.build_url(\n                    self._endpoints.get('child_folders').format(\n                        id=self.folder_id))\n            params = {'$filter': \"{} eq '{}'\".format(self._cc('displayName'),\n                                                     folder_name), '$top': 1}\n        response = self.con.get(url, params=params)\n        if not response:\n            return None\n        if folder_id:\n            folder = response.json()\n        else:\n            folder = response.json().get('value')\n            folder = folder[0] if folder else None\n            if folder is None:\n                return None\n        # Everything received from cloud must be passed as self._cloud_data_key\n        # we don't pass parent, as this folder may not be a child of self.\n        return self.__class__(con=self.con, protocol=self.protocol,\n                              main_resource=self.main_resource,\n                              **{self._cloud_data_key: folder})\n", "docstring": "Returns a Contact Folder by it's id or child folders by name"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def create_child_folder(self, folder_name):\n        \"\"\" Creates a new child folder\n        :param str folder_name: name of the new folder to create\n        :return: newly created folder\n        :rtype: ContactFolder or None\n        \"\"\"\n        if not folder_name:\n            return None\n        if self.root:\n            url = self.build_url(self._endpoints.get('root_folders'))\n        else:\n            url = self.build_url(\n                self._endpoints.get('child_folders').format(id=self.folder_id))\n        response = self.con.post(url,\n                                 data={self._cc('displayName'): folder_name})\n        if not response:\n            return None\n        folder = response.json()\n        # Everything received from cloud must be passed as self._cloud_data_key\n        return self.__class__(parent=self, **{self._cloud_data_key: folder})\n", "docstring": "Creates a new child folder"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def move_folder(self, to_folder):\n        \"\"\" Change this folder name\n        :param to_folder: folder_id/ContactFolder to move into\n        :type to_folder: str or ContactFolder\n        :return: Moved or Not\n        :rtype: bool\n        \"\"\"\n        if self.root:\n            return False\n        if not to_folder:\n            return False\n        url = self.build_url(\n            self._endpoints.get('get_folder').format(id=self.folder_id))\n        if isinstance(to_folder, ContactFolder):\n            folder_id = to_folder.folder_id\n        elif isinstance(to_folder, str):\n            folder_id = to_folder\n        else:\n            return False\n        response = self.con.patch(url,\n                                  data={self._cc('parentFolderId'): folder_id})\n        if not response:\n            return False\n        folder = response.json()\n        self.name = folder.get(self._cc('displayName'), '')\n        self.parent_id = folder.get(self._cc('parentFolderId'), None)\n        return True\n", "docstring": "Change this folder name"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def new_contact(self):\n        \"\"\" Creates a new contact to be saved into it's parent folder\n        :return: newly created contact\n        :rtype: Contact\n        \"\"\"\n        contact = self.contact_constructor(parent=self)\n        if not self.root:\n            contact.__folder_id = self.folder_id\n        return contact\n", "docstring": "Creates a new contact to be saved into it's parent folder"}
{"repo": "python-o365-master/O365/address_book.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        # Set instance to be a root instance\n        super().__init__(parent=parent, con=con, root=True, **kwargs)\n", "docstring": "Set instance to be a root instance"}
{"repo": "python-o365-master/O365/connection.py", "original_string": "    def convert_case(self, key):\n        \"\"\" Returns a key converted with this protocol casing method\n        Converts case to send/read from the cloud\n        When using Microsoft Graph API, the keywords of the API use\n        lowerCamelCase Casing\n        When using Office 365 API, the keywords of the API use PascalCase Casing\n        Default case in this API is lowerCamelCase\n        :param str key: a dictionary key to convert\n        :return: key after case conversion\n        :rtype: str\n        \"\"\"\n        return key if self.use_default_casing else self.casing_function(key)\n", "docstring": "Returns a key converted with this protocol casing method"}
{"repo": "python-o365-master/O365/connection.py", "original_string": "    def to_api_case(key):\n        \"\"\" Converts key to snake_case\n        :param str key: key to convert into snake_case\n        :return: key after case conversion\n        :rtype: str\n        \"\"\"\n        return snakecase(key)\n", "docstring": "Converts key to snake_case"}
{"repo": "python-o365-master/O365/connection.py", "original_string": "    def prefix_scope(self, scope):\n        \"\"\" Inserts the protocol scope prefix if required\"\"\"\n        if self.protocol_scope_prefix:\n            if isinstance(scope, tuple):\n                return scope[0]\n            elif scope.startswith(self.protocol_scope_prefix):\n                return scope\n            else:\n                return '{}{}'.format(self.protocol_scope_prefix, scope)\n        else:\n            if isinstance(scope, tuple):\n                return scope[0]\n            else:\n                return scope\n", "docstring": "Inserts the protocol scope prefix if required\n"}
{"repo": "python-o365-master/O365/connection.py", "original_string": "    def oauth_request(self, url, method, **kwargs):\n        \"\"\" Makes a request to url using an oauth session\n        :param str url: url to send request to\n        :param str method: type of request (get/put/post/patch/delete)\n        :param kwargs: extra params to send to the request api\n        :return: Response of the request\n        :rtype: requests.Response\n        \"\"\"\n        # oauth authentication\n        if self.session is None:\n            self.session = self.get_session(load_token=True)\n        return self._internal_request(self.session, url, method, **kwargs)\n", "docstring": "Makes a request to url using an oauth session"}
{"repo": "python-o365-master/O365/connection.py", "original_string": "    def post(self, url, data=None, **kwargs):\n        \"\"\" Shorthand for self.oauth_request(url, 'post')\n        :param str url: url to send post oauth request to\n        :param dict data: post data to update the service\n        :param kwargs: extra params to send to request api\n        :return: Response of the request\n        :rtype: requests.Response\n        \"\"\"\n        return self.oauth_request(url, 'post', data=data, **kwargs)\n", "docstring": "Shorthand for self.oauth_request(url, 'post')"}
{"repo": "python-o365-master/O365/connection.py", "original_string": "    def patch(self, url, data=None, **kwargs):\n        \"\"\" Shorthand for self.oauth_request(url, 'patch')\n        :param str url: url to send patch oauth request to\n        :param dict data: patch data to update the service\n        :param kwargs: extra params to send to request api\n        :return: Response of the request\n        :rtype: requests.Response\n        \"\"\"\n        return self.oauth_request(url, 'patch', data=data, **kwargs)\n", "docstring": "Shorthand for self.oauth_request(url, 'patch')"}
{"repo": "python-o365-master/O365/category.py", "original_string": "    def __repr__(self):\n        return '{} (color: {})'.format(self.name, self.color.name if self.color else None)\n", "docstring": "return '{} (color: {})'.format(self.name, self.color.name if self.color else None)"}
{"repo": "python-o365-master/O365/category.py", "original_string": "    def delete(self):\n        \"\"\" Deletes this Category \"\"\"\n        url = self.build_url(self._endpoints.get('update').format(id=self.object_id))\n        response = self.con.delete(url)\n        return bool(response)\n", "docstring": "Deletes this Category \n"}
{"repo": "python-o365-master/O365/category.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" Object to retrive categories\n        :param parent: parent object\n        :type parent: Account\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n", "docstring": "Object to retrive categories"}
{"repo": "python-o365-master/O365/category.py", "original_string": "    def get_category(self, category_id):\n        \"\"\" Returns a category by id\"\"\"\n        url = self.build_url(self._endpoints.get('get').format(id=category_id))\n        response = self.con.get(url)\n        if not response:\n            return None\n        data = response.json()\n        return self.category_constructor(parent=self, **{self._cloud_data_key: data})\n", "docstring": "Returns a category by id\n"}
{"repo": "python-o365-master/O365/account.py", "original_string": "    def __init__(self, credentials, *, protocol=None, main_resource=None, **kwargs):\n        \"\"\" Creates an object which is used to access resources related to the\n        specified credentials\n        :param tuple credentials: a tuple containing the client_id\n         and client_secret\n        :param Protocol protocol: the protocol to be used in this account\n        :param str main_resource: the resource to be used by this account\n         ('me' or 'users', etc.)\n        :param kwargs: any extra args to be passed to the Connection instance\n        :raises ValueError: if an invalid protocol is passed\n        \"\"\"\n        protocol = protocol or MSGraphProtocol  # Defaults to Graph protocol\n        self.protocol = protocol(default_resource=main_resource,\n                                 **kwargs) if isinstance(protocol,\n                                                         type) else protocol\n        if not isinstance(self.protocol, Protocol):\n            raise ValueError(\"'protocol' must be a subclass of Protocol\")\n        auth_flow_type = kwargs.get('auth_flow_type', 'authorization')\n        scopes = kwargs.get('scopes', None)  # retrieve scopes\n        if auth_flow_type in ('authorization', 'public'):\n            # convert the provided scopes to protocol scopes:\n            if scopes is not None:\n                kwargs['scopes'] = self.protocol.get_scopes_for(scopes)\n        elif auth_flow_type == 'credentials':\n            # for client credential grant flow solely:\n            # append the default scope if it's not provided\n            if not scopes:\n                kwargs['scopes'] = [self.protocol.prefix_scope('.default')]\n            # set main_resource to blank when it's the 'ME' resource\n            if self.protocol.default_resource == ME_RESOURCE:\n                self.protocol.default_resource = ''\n            if main_resource == ME_RESOURCE:\n                main_resource = ''\n        else:\n            raise ValueError('\"auth_flow_type\" must be \"authorization\", \"credentials\" or \"public\"')\n        self.con = self.connection_constructor(credentials, **kwargs)\n        self.main_resource = main_resource or self.protocol.default_resource\n", "docstring": "Creates an object which is used to access resources related to the"}
{"repo": "python-o365-master/O365/account.py", "original_string": "    def get_current_user(self):\n        \"\"\" Returns the current user \"\"\"\n        if self.con.auth_flow_type in ('authorization', 'public'):\n            directory = self.directory(resource=ME_RESOURCE)\n            return directory.get_current_user()\n        else:\n            return None\n", "docstring": "Returns the current user \n"}
{"repo": "python-o365-master/O365/account.py", "original_string": "    def connection(self):\n        \"\"\" Alias for self.con\n        :rtype: type(self.connection_constructor)\n        \"\"\"\n        return self.con\n", "docstring": "Alias for self.con"}
{"repo": "python-o365-master/O365/account.py", "original_string": "    def mailbox(self, resource=None):\n        \"\"\" Get an instance to the mailbox for the specified account resource\n        :param str resource: Custom resource to be used in this mailbox\n         (Defaults to parent main_resource)\n        :return: a representation of account mailbox\n        :rtype: O365.mailbox.MailBox\n        \"\"\"\n        from .mailbox import MailBox\n        return MailBox(parent=self, main_resource=resource, name='MailBox')\n", "docstring": "Get an instance to the mailbox for the specified account resource"}
{"repo": "python-o365-master/O365/account.py", "original_string": "    def directory(self, resource=None):\n        \"\"\" Returns the active directory instance\"\"\"\n        from .directory import Directory, USERS_RESOURCE\n        return Directory(parent=self, main_resource=resource or USERS_RESOURCE)\n", "docstring": "Returns the active directory instance\n"}
{"repo": "python-o365-master/O365/account.py", "original_string": "    def storage(self, *, resource=None):\n        \"\"\" Get an instance to handle file storage (OneDrive / Sharepoint)\n        for the specified account resource\n        :param str resource: Custom resource to be used in this drive object\n         (Defaults to parent main_resource)\n        :return: a representation of OneDrive File Storage\n        :rtype: Storage\n        :raises RuntimeError: if protocol doesn't support the feature\n        \"\"\"\n        if not isinstance(self.protocol, MSGraphProtocol):\n            # TODO: Custom protocol accessing OneDrive/Sharepoint Api fails here\n            raise RuntimeError(\n                'Drive options only works on Microsoft Graph API')\n        from .drive import Storage\n        return Storage(parent=self, main_resource=resource)\n", "docstring": "Get an instance to handle file storage (OneDrive / Sharepoint)"}
{"repo": "python-o365-master/O365/account.py", "original_string": "    def planner(self, *, resource=''):\n        \"\"\" Get an instance to read information from Microsoft planner \"\"\"\n        if not isinstance(self.protocol, MSGraphProtocol):\n            # TODO: Custom protocol accessing OneDrive/Sharepoint Api fails here\n            raise RuntimeError(\n                'planner api only works on Microsoft Graph API')\n        from .planner import Planner\n        return Planner(parent=self, main_resource=resource)\n", "docstring": "Get an instance to read information from Microsoft planner \n"}
{"repo": "python-o365-master/O365/account.py", "original_string": "    def teams(self, *, resource=''):\n        \"\"\" Get an instance to read information from Microsoft Teams \"\"\"\n        if not isinstance(self.protocol, MSGraphProtocol):\n            raise RuntimeError(\n                'teams api only works on Microsoft Graph API')\n        from .teams import Teams\n        return Teams(parent=self, main_resource=resource)\n", "docstring": "Get an instance to read information from Microsoft Teams \n"}
{"repo": "python-o365-master/O365/directory.py", "original_string": "    def full_name(self):\n        \"\"\" Full Name (Name + Surname)\n        :rtype: str\n        \"\"\"\n        return '{} {}'.format(self.given_name, self.surname).strip()\n", "docstring": "Full Name (Name + Surname)"}
{"repo": "python-o365-master/O365/directory.py", "original_string": "    def get_profile_photo(self, size=None):\n        \"\"\" Returns the user profile photo\n        :param str size: 48x48, 64x64, 96x96, 120x120, 240x240,\n         360x360, 432x432, 504x504, and 648x648\n        \"\"\"\n        if size is None:\n            url = self.build_url(self._endpoints.get('photo'))\n        else:\n            url = self.build_url(self._endpoints.get('photo_size').format(size=size))\n        try:\n            response = self.con.get(url)\n        except HTTPError as e:\n            log.debug('Error while retrieving the user profile photo. Error: {}'.format(e))\n            return None\n        if not response:\n            return None\n        return response.content\n", "docstring": "Returns the user profile photo"}
{"repo": "python-o365-master/O365/directory.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" Represents the Active Directory\n        :param parent: parent object\n        :type parent: Account\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n", "docstring": "Represents the Active Directory"}
{"repo": "python-o365-master/O365/directory.py", "original_string": "    def get_users(self, limit=100, *, query=None, order_by=None, batch=None):\n        \"\"\" Gets a list of users from the active directory\n        When querying the Active Directory the Users endpoint will be used.\n        Only a limited set of information will be available unless you have\n        access to scope 'User.Read.All' which requires App Administration\n        Consent.\n        Also using endpoints has some limitations on the querying capabilities.\n        To use query an order_by check the OData specification here:\n        http://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/\n        part2-url-conventions/odata-v4.0-errata03-os-part2-url-conventions\n        -complete.html\n        :param limit: max no. of contacts to get. Over 999 uses batch.\n        :type limit: int or None\n        :param query: applies a OData filter to the request\n        :type query: Query or str\n        :param order_by: orders the result set based on this condition\n        :type order_by: Query or str\n        :param int batch: batch size, retrieves items in\n         batches allowing to retrieve more items than the limit.\n        :return: list of users\n        :rtype: list[User] or Pagination\n        \"\"\"\n        url = self.build_url('')  # target the main_resource\n        if limit is None or limit > self.protocol.max_top_value:\n            batch = self.protocol.max_top_value\n        params = {'$top': batch if batch else limit}\n        if order_by:\n            params['$orderby'] = order_by\n        if query:\n            if isinstance(query, str):\n                params['$filter'] = query\n            else:\n                params.update(query.as_params())\n        response = self.con.get(url, params=params)\n        if not response:\n            return iter(())\n        data = response.json()\n        # Everything received from cloud must be passed as self._cloud_data_key\n        users = (self.user_constructor(parent=self, **{self._cloud_data_key: user})\n                 for user in data.get('value', []))\n        next_link = data.get(NEXT_LINK_KEYWORD, None)\n        if batch and next_link:\n            return Pagination(parent=self, data=users,\n                              constructor=self.user_constructor,\n                              next_link=next_link, limit=limit)\n        else:\n            return users\n", "docstring": "Gets a list of users from the active directory"}
{"repo": "python-o365-master/O365/directory.py", "original_string": "    def get_user(self, user, query=None):\n        \"\"\" Returns a User by it's id or user principal name\n        :param str user: the user id or user principal name\n        :return: User for specified email\n        :rtype: User\n        \"\"\"\n        url = self.build_url(self._endpoints.get('get_user').format(email=user))\n        return self._get_user(url, query=query)\n", "docstring": "Returns a User by it's id or user principal name"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def save_as_eml(self, attachment, to_path=None):\n        \"\"\" Saves this message as and EML to the file system\n        :param MessageAttachment attachment: the MessageAttachment to store as eml.\n        :param Path or str to_path: the path where to store this file\n        \"\"\"\n        if not attachment or not isinstance(attachment, MessageAttachment) \\\n                or attachment.attachment_id is None or attachment.attachment_type != 'item':\n            raise ValueError('Must provide a saved \"item\" attachment of type MessageAttachment')\n        if to_path is None:\n            to_path = Path('message_eml.eml')\n        else:\n            if not isinstance(to_path, Path):\n                to_path = Path(to_path)\n        if not to_path.suffix:\n            to_path = to_path.with_suffix('.eml')\n        msg_id = self._parent.object_id\n        if msg_id is None:\n            raise RuntimeError('Attempting to get the mime contents of an unsaved message')\n        url = self.build_url(self._endpoints.get('get_mime').format(id=msg_id, ida=attachment.attachment_id))\n        response = self._parent.con.get(url)\n        if not response:\n            return False\n        mime_content = response.content\n        if mime_content:\n            with to_path.open('wb') as file_obj:\n                file_obj.write(mime_content)\n            return True\n        return False\n", "docstring": "Saves this message as and EML to the file system"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def __init__(self, parent, flag_data):\n        \"\"\" An flag on a message\n        Not available on Outlook Rest Api v2 (only in beta)\n        :param parent: parent of this\n        :type parent: Message\n        :param dict flag_data: flag data from cloud\n        \"\"\"\n        super().__init__(protocol=parent.protocol,\n                         main_resource=parent.main_resource)\n        self.__message = parent\n        self.__status = Flag.from_value(flag_data.get(self._cc('flagStatus'), 'notFlagged'))\n        start_obj = flag_data.get(self._cc('startDateTime'), {})\n        self.__start = self._parse_date_time_time_zone(start_obj)\n        due_date_obj = flag_data.get(self._cc('dueDateTime'), {})\n        self.__due_date = self._parse_date_time_time_zone(due_date_obj)\n        completed_date_obj = flag_data.get(self._cc('completedDateTime'), {})\n        self.__completed = self._parse_date_time_time_zone(completed_date_obj)\n", "docstring": "An flag on a message"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def _track_changes(self):\n        \"\"\" Update the track_changes on the message to reflect a\n        needed update on this field \"\"\"\n        self.__message._track_changes.add('flag')\n", "docstring": "Update the track_changes on the message to reflect a"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def set_completed(self, *, completition_date=None):\n        \"\"\" Sets this message flag as completed\n        :param completition_date: the datetime this followUp was completed\n        \"\"\"\n        self.__status = Flag.Complete\n        completition_date = completition_date or dt.datetime.now()\n        if completition_date.tzinfo is None:\n            completition_date = self.protocol.timezone.localize(completition_date)\n        self.__completed = completition_date\n        self._track_changes()\n", "docstring": "Sets this message flag as completed"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def is_read(self):\n        \"\"\" Check if the message is read or not\n        :getter: Get the status of message read\n        :setter: Mark the message as read\n        :type: bool\n        \"\"\"\n        return self.__is_read\n", "docstring": "Check if the message is read or not"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def is_draft(self):\n        \"\"\" Check if the message is marked as draft\n        :type: bool\n        \"\"\"\n        return self.__is_draft\n", "docstring": "Check if the message is marked as draft"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def subject(self):\n        \"\"\" Subject of the email message\n        :getter: Get the current subject\n        :setter: Assign a new subject\n        :type: str\n        \"\"\"\n        return self.__subject\n", "docstring": "Subject of the email message"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def body_preview(self):\n        \"\"\" Returns the body preview \"\"\"\n        return self.__body_preview\n", "docstring": "Returns the body preview \n"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def body(self):\n        \"\"\" Body of the email message\n        :getter: Get body text of current message\n        :setter: set html body of the message\n        :type: str\n        \"\"\"\n        return self.__body\n", "docstring": "Body of the email message"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def unique_body(self):\n        \"\"\" The unique body of this message\n            Requires a select to retrieve it.\n        :rtype: str\n        \"\"\"\n        return self.__unique_body\n", "docstring": "The unique body of this message"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def created(self):\n        \"\"\" Created time of the message \"\"\"\n        return self.__created\n", "docstring": "Created time of the message \n"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def modified(self):\n        \"\"\" Message last modified time \"\"\"\n        return self.__modified\n", "docstring": "Message last modified time \n"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def received(self):\n        \"\"\" Message received time\"\"\"\n        return self.__received\n", "docstring": "Message received time\n"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def sent(self):\n        \"\"\" Message sent time\"\"\"\n        return self.__sent\n", "docstring": "Message sent time\n"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def attachments(self):\n        \"\"\" List of attachments \"\"\"\n        return self.__attachments\n", "docstring": "List of attachments \n"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def sender(self):\n        \"\"\" Sender of the message\n        :getter: Get the current sender\n        :setter: Update the from address with new value\n        :type: str or Recipient\n        \"\"\"\n        return self.__sender\n", "docstring": "Sender of the message"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def sender(self, value):\n        \"\"\" sender is a property to force to be always a Recipient class \"\"\"\n        if isinstance(value, Recipient):\n            if value._parent is None:\n                value._parent = self\n                value._field = 'from'\n            self.__sender = value\n        elif isinstance(value, str):\n            self.__sender.address = value\n            self.__sender.name = ''\n        else:\n            raise ValueError(\n                'sender must be an address string or a Recipient object')\n        self._track_changes.add('from')\n", "docstring": "sender is a property to force to be always a Recipient class \n"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def to(self):\n        \"\"\" 'TO' list of recipients \"\"\"\n        return self.__to\n", "docstring": "'TO' list of recipients \n"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def cc(self):\n        \"\"\" 'CC' list of recipients \"\"\"\n        return self.__cc\n", "docstring": "'CC' list of recipients \n"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def bcc(self):\n        \"\"\" 'BCC' list of recipients \"\"\"\n        return self.__bcc\n", "docstring": "'BCC' list of recipients \n"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def reply_to(self):\n        \"\"\" Reply to address \"\"\"\n        return self.__reply_to\n", "docstring": "Reply to address \n"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def categories(self):\n        \"\"\" Categories of this message\n        :getter: Current list of categories\n        :setter: Set new categories for the message\n        :type: list[str] or str\n        \"\"\"\n        return self.__categories\n", "docstring": "Categories of this message"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def importance(self):\n        \"\"\" Importance of the message\n        :getter: Get the current priority of the message\n        :setter: Set a different importance level\n        :type: str or ImportanceLevel\n        \"\"\"\n        return self.__importance\n", "docstring": "Importance of the message"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def is_read_receipt_requested(self):\n        \"\"\" if the read receipt is requested for this message\n        :getter: Current state of isReadReceiptRequested\n        :setter: Set isReadReceiptRequested for the message\n        :type: bool\n        \"\"\"\n        return self.__is_read_receipt_requested\n", "docstring": "if the read receipt is requested for this message"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def is_delivery_receipt_requested(self):\n        \"\"\" if the delivery receipt is requested for this message\n        :getter: Current state of isDeliveryReceiptRequested\n        :setter: Set isDeliveryReceiptRequested for the message\n        :type: bool\n        \"\"\"\n        return self.__is_delivery_receipt_requested\n", "docstring": "if the delivery receipt is requested for this message"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def meeting_message_type(self):\n        \"\"\" If this message is a EventMessage, returns the\n        meeting type: meetingRequest, meetingCancelled, meetingAccepted,\n            meetingTentativelyAccepted, meetingDeclined\n        \"\"\"\n        return self.__meeting_message_type\n", "docstring": "If this message is a EventMessage, returns the"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def is_event_message(self):\n        \"\"\" Returns if this message is of type EventMessage\n        and therefore can return the related event.\n        \"\"\"\n        return self.__meeting_message_type is not None\n", "docstring": "Returns if this message is of type EventMessage"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def flag(self):\n        \"\"\" The Message Flag instance \"\"\"\n        return self.__flag\n", "docstring": "The Message Flag instance \n"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def send(self, save_to_sent_folder=True):\n        \"\"\" Sends this message\n        :param bool save_to_sent_folder: whether or not to save it to\n         sent folder\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        if self.object_id and not self.__is_draft:\n            return RuntimeError('Not possible to send a message that is not '\n                                'new or a draft. Use Reply or Forward instead.')\n        if self.__is_draft and self.object_id:\n            url = self.build_url(\n                self._endpoints.get('send_draft').format(id=self.object_id))\n            if self._track_changes:\n                # there are pending changes to be committed\n                self.save_draft()\n            data = None\n        else:\n            url = self.build_url(self._endpoints.get('send_mail'))\n            data = {self._cc('message'): self.to_api_data()}\n            if save_to_sent_folder is False:\n                data[self._cc('saveToSentItems')] = False\n        response = self.con.post(url, data=data)\n        # response evaluates to false if 4XX or 5XX status codes are returned\n        if not response:\n            return False\n        self.object_id = 'sent_message' if not self.object_id \\\n            else self.object_id\n        self.__is_draft = False\n        return True\n", "docstring": "Sends this message"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def forward(self):\n        \"\"\"  Creates a new message that is a forward this message\n        :return: new message\n        :rtype: Message\n        \"\"\"\n        if not self.object_id or self.__is_draft:\n            raise RuntimeError(\"Can't forward this message\")\n        url = self.build_url(\n            self._endpoints.get('forward_message').format(id=self.object_id))\n        response = self.con.post(url)\n        if not response:\n            return None\n        message = response.json()\n        # Everything received from cloud must be passed as self._cloud_data_key\n        return self.__class__(parent=self, **{self._cloud_data_key: message})\n", "docstring": "Creates a new message that is a forward this message"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def mark_as_read(self):\n        \"\"\" Marks this message as read in the cloud\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        if self.object_id is None or self.__is_draft:\n            raise RuntimeError('Attempting to mark as read an unsaved Message')\n        data = {self._cc('isRead'): True}\n        url = self.build_url(\n            self._endpoints.get('get_message').format(id=self.object_id))\n        response = self.con.patch(url, data=data)\n        if not response:\n            return False\n        self.__is_read = True\n        return True\n", "docstring": "Marks this message as read in the cloud"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def move(self, folder):\n        \"\"\" Move the message to a given folder\n        :param folder: Folder object or Folder id or Well-known name to\n         move this message to\n        :type folder: str or mailbox.Folder\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        if self.object_id is None:\n            raise RuntimeError('Attempting to move an unsaved Message')\n        url = self.build_url(\n            self._endpoints.get('move_message').format(id=self.object_id))\n        if isinstance(folder, str):\n            folder_id = folder\n        else:\n            folder_id = getattr(folder, 'folder_id', None)\n        if not folder_id:\n            raise RuntimeError('Must Provide a valid folder_id')\n        data = {self._cc('destinationId'): folder_id}\n        response = self.con.post(url, data=data)\n        if not response:\n            return False\n        message = response.json()\n        self.folder_id = folder_id\n        self.object_id = message.get('id')\n        return True\n", "docstring": "Move the message to a given folder"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def save_message(self):\n        \"\"\" Saves changes to a message.\n        If the message is a new or saved draft it will call 'save_draft' otherwise\n        this will save only properties of a message that are draft-independent such as:\n            - is_read\n            - category\n            - flag\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        if self.object_id and not self.__is_draft:\n            # we are only allowed to save some properties:\n            allowed_changes = {self._cc('isRead'), self._cc('categories'),\n                               self._cc('flag')}  # allowed changes to be saved by this method\n            changes = {tc for tc in self._track_changes if tc in allowed_changes}\n            if not changes:\n                return True  # there's nothing to update\n            url = self.build_url(self._endpoints.get('get_message').format(id=self.object_id))\n            data = self.to_api_data(restrict_keys=changes)\n            response = self.con.patch(url, data=data)\n            if not response:\n                return False\n            self._track_changes.clear()  # reset the tracked changes as they are all saved\n            self.__modified = self.protocol.timezone.localize(dt.datetime.now())\n            return True\n        else:\n            # fallback to save_draft\n            return self.save_draft()\n", "docstring": "Saves changes to a message."}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def get_body_text(self):\n        \"\"\" Parse the body html and returns the body text using bs4\n        :return: body as text\n        :rtype: str\n        \"\"\"\n        if self.body_type.upper() != 'HTML':\n            return self.body\n        try:\n            soup = bs(self.body, 'html.parser')\n        except RuntimeError:\n            return self.body\n        else:\n            return soup.body.text\n", "docstring": "Parse the body html and returns the body text using bs4"}
{"repo": "python-o365-master/O365/message.py", "original_string": "    def get_event(self):\n        \"\"\" If this is a EventMessage it should return the related Event\"\"\"\n        if not self.is_event_message:\n            return None\n        # select a dummy field (eg. subject) to avoid pull unneccesary data\n        query = self.q().select('subject').expand('event')\n        url = self.build_url(self._endpoints.get('get_message').format(id=self.object_id))\n        response = self.con.get(url, params=query.as_params())\n        if not response:\n            return None\n        data = response.json()\n        event_data = data.get(self._cc('event'))\n        return Event(parent=self, **{self._cloud_data_key: event_data})\n", "docstring": "If this is a EventMessage it should return the related Event\n"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" A Microsoft To-Do task\n        :param parent: parent object\n        :type parent: ToDo\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        :param str folder_id: id of the calender to add this task in\n         (kwargs)\n        :param str subject: subject of the task (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.task_id = cloud_data.get('id')\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        cc = self._cc  # alias\n        # internal to know which properties need to be updated on the server\n        self._track_changes = TrackerSet(casing=cc)\n        self.folder_id = kwargs.get('folder_id', None)\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.task_id = cloud_data.get(cc('id'), None)\n        self.__subject = cloud_data.get(cc('subject'),\n                                        kwargs.get('subject', '') or '')\n        body = cloud_data.get(cc('body'), {})\n        self.__body = body.get(cc('content'), '')\n        self.body_type = body.get(cc('contentType'),\n                                  'HTML')  # default to HTML for new messages\n        self.__created = cloud_data.get(cc('createdDateTime'), None)\n        self.__modified = cloud_data.get(cc('lastModifiedDateTime'), None)\n        self.__status = cloud_data.get(cc('status'), None)\n        self.__is_completed = self.__status == 'Completed'\n        self.__importance = cloud_data.get(cc('importance'), None)\n        \n        local_tz = self.protocol.timezone\n        self.__created = parse(self.__created).astimezone(\n            local_tz) if self.__created else None\n        self.__modified = parse(self.__modified).astimezone(\n            local_tz) if self.__modified else None\n        due_obj = cloud_data.get(cc('dueDateTime'), {})\n        self.__due = self._parse_date_time_time_zone(due_obj)\n        completed_obj = cloud_data.get(cc('completedDateTime'), {})\n        self.__completed = self._parse_date_time_time_zone(completed_obj)\n", "docstring": "A Microsoft To-Do task"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def to_api_data(self, restrict_keys=None):\n        \"\"\" Returns a dict to communicate with the server\n        :param restrict_keys: a set of keys to restrict the returned data to\n        :rtype: dict\n        \"\"\"\n        cc = self._cc  # alias\n        data = {\n            cc('subject'): self.__subject,\n            cc('body'): {\n                cc('contentType'): self.body_type,\n                cc('content'): self.__body},\n        }\n        if self.__is_completed:\n            data[cc('status')] = 'Completed'\n        else:\n            data[cc('status')] = 'NotStarted'\n        if self.__due:\n            data[cc('dueDateTime')] = self._build_date_time_time_zone(self.__due)\n        if self.__completed:\n            data[cc('completedDateTime')] = self._build_date_time_time_zone(self.__completed)\n        if restrict_keys:\n            for key in list(data.keys()):\n                if key not in restrict_keys:\n                    del data[key]\n        return data\n", "docstring": "Returns a dict to communicate with the server"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def created(self):\n        \"\"\" Created time of the task\n        :rtype: datetime\n        \"\"\"\n        return self.__created\n", "docstring": "Created time of the task"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def modified(self):\n        \"\"\" Last modified time of the task\n        :rtype: datetime\n        \"\"\"\n        return self.__modified\n", "docstring": "Last modified time of the task"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def body(self):\n        \"\"\" Body of the task\n        :getter: Get body text\n        :setter: Set body of task\n        :type: str\n        \"\"\"\n        return self.__body\n", "docstring": "Body of the task"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def importance(self):\n        \"\"\" Task importance (Low, Normal, High)\n        :getter: Get importance level\n        :type: str\n        \"\"\"\n        return self.__importance\n", "docstring": "Task importance (Low, Normal, High)"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def is_starred(self):\n        \"\"\" Is the task starred (high importance)\n        :getter: Check if importance is high\n        :type: bool\n        \"\"\"\n        return self.__importance.casefold() == \"High\".casefold()\n", "docstring": "Is the task starred (high importance)"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def subject(self):\n        \"\"\" Subject of the task\n        :getter: Get subject\n        :setter: Set subject of task\n        :type: str\n        \"\"\"\n        return self.__subject\n", "docstring": "Subject of the task"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def due(self):\n        \"\"\" Due Time of task\n        :getter: get the due time\n        :setter: set the due time\n        :type: datetime\n        \"\"\"\n        return self.__due\n", "docstring": "Due Time of task"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def completed(self):\n        \"\"\" Completed Time of task\n        :getter: get the completed time\n        :setter: set the completed time\n        :type: datetime\n        \"\"\"\n        return self.__completed\n", "docstring": "Completed Time of task"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def is_completed(self):\n        \"\"\" Is task completed or not\n        :getter: Is completed\n        :setter: set the task to completted\n        :type: bool\n        \"\"\"\n        return self.__is_completed\n", "docstring": "Is task completed or not"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def save(self):\n        \"\"\" Create a new task or update an existing one by checking what\n        values have changed and update them on the server\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        if self.task_id:\n            # update task\n            if not self._track_changes:\n                return True  # there's nothing to update\n            url = self.build_url(\n                self._endpoints.get('task').format(id=self.task_id))\n            method = self.con.patch\n            data = self.to_api_data(restrict_keys=self._track_changes)\n        else:\n            # new task\n            if self.folder_id:\n                url = self.build_url(\n                    self._endpoints.get('task_folder').format(\n                        id=self.folder_id))\n            else:\n                url = self.build_url(self._endpoints.get('task_default'))\n            method = self.con.post\n            data = self.to_api_data()\n        response = method(url, data=data)\n        if not response:\n            return False\n        self._track_changes.clear()  # clear the tracked changes\n        if not self.task_id:\n            # new task\n            task = response.json()\n            self.task_id = task.get(self._cc('id'), None)\n            self.__created = task.get(self._cc('createdDateTime'), None)\n            self.__modified = task.get(self._cc('lastModifiedDateTime'), None)\n            self.__completed = task.get(self._cc('Completed'), None)\n            self.__created = parse(self.__created).astimezone(\n                self.protocol.timezone) if self.__created else None\n            self.__modified = parse(self.__modified).astimezone(\n                self.protocol.timezone) if self.__modified else None\n            self.__is_completed = task.get(self._cc('status'), None) == 'Completed'\n        else:\n            self.__modified = self.protocol.timezone.localize(dt.datetime.now())\n        return True\n", "docstring": "Create a new task or update an existing one by checking what"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def get_body_soup(self):\n        \"\"\" Returns the beautifulsoup4 of the html body\n        :return: Html body\n        :rtype: BeautifulSoup\n        \"\"\"\n        if self.body_type != 'HTML':\n            return None\n        else:\n            return bs(self.body, 'html.parser')\n", "docstring": "Returns the beautifulsoup4 of the html body"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" A Microsoft To-Do Folder Representation\n        :param parent: parent object\n        :type parent: ToDo\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.name = cloud_data.get(self._cc('name'), '')\n        self.folder_id = cloud_data.get(self._cc('id'), None)\n        self._is_default = cloud_data.get(self._cc('isDefaultFolder'), '')\n", "docstring": "A Microsoft To-Do Folder Representation"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def update(self):\n        \"\"\" Updates this folder. Only name can be changed.\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        if not self.folder_id:\n            return False\n        url = self.build_url(self._endpoints.get('folder'))\n        data = {\n            self._cc('name'): self.name,\n        }\n        response = self.con.patch(url, data=data)\n        return bool(response)\n", "docstring": "Updates this folder. Only name can be changed."}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def get_tasks(self, batch=None, order_by=None):\n        \"\"\" Returns a list of tasks of a specified folder\n        :param batch: the batch on to retrieve tasks.\n        :param order_by: the order clause to apply to returned tasks.\n        :rtype: tasks\n        \"\"\"\n        if self.folder_id is None:\n            # I'm the default folder\n            url = self.build_url(self._endpoints.get('default_tasks'))\n        else:\n            url = self.build_url(\n                self._endpoints.get('get_tasks').format(id=self.folder_id))\n        # get tasks by the folder id\n        params = {}\n        if batch:\n            params['$top'] = batch\n        if order_by:\n            params['$orderby'] = order_by\n        response = self.con.get(url, params=params,\n                                headers={'Prefer': 'outlook.timezone=\"UTC\"'})\n        if not response:\n            return iter(())\n        data = response.json()\n        # Everything received from cloud must be passed as self._cloud_data_key\n        tasks = (self.task_constructor(parent=self,\n                                       **{self._cloud_data_key: task})\n                 for task in data.get('value', []))\n        return tasks\n", "docstring": "Returns a list of tasks of a specified folder"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def get_task(self, param):\n        \"\"\" Returns an Task instance by it's id\n        :param param: an task_id or a Query instance\n        :return: task for the specified info\n        :rtype: Event\n        \"\"\"\n        if param is None:\n            return None\n        if isinstance(param, str):\n            url = self.build_url(\n                self._endpoints.get('get_task').format(id=self.folder_id,\n                                                       ide=param))\n            params = None\n            by_id = True\n        else:\n            url = self.build_url(\n                self._endpoints.get('get_tasks').format(id=self.folder_id))\n            params = {'$top': 1}\n            params.update(param.as_params())\n            by_id = False\n        response = self.con.get(url, params=params,\n                                headers={'Prefer': 'outlook.timezone=\"UTC\"'})\n        if not response:\n            return None\n        if by_id:\n            task = response.json()\n        else:\n            task = response.json().get('value', [])\n            if task:\n                task = task[0]\n            else:\n                return None\n        return self.task_constructor(parent=self,\n                                     **{self._cloud_data_key: task})\n", "docstring": "Returns an Task instance by it's id"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" A ToDo object\n        :param parent: parent object\n        :type parent: Account\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n", "docstring": "A ToDo object"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def new_folder(self, folder_name):\n        \"\"\" Creates a new folder\n        :param str folder_name: name of the new folder\n        :return: a new Calendar instance\n        :rtype: Calendar\n        \"\"\"\n        if not folder_name:\n            return None\n        url = self.build_url(self._endpoints.get('root_folders'))\n        response = self.con.post(url, data={self._cc('name'): folder_name})\n        if not response:\n            return None\n        data = response.json()\n        # Everything received from cloud must be passed as self._cloud_data_key\n        return self.folder_constructor(parent=self,\n                                       **{self._cloud_data_key: data})\n", "docstring": "Creates a new folder"}
{"repo": "python-o365-master/O365/tasks.py", "original_string": "    def get_default_folder(self):\n        \"\"\" Returns the default folder for the current user\n        :rtype: Folder\n        \"\"\"\n        folders = self.list_folders()\n        for f in folders:\n            if f._is_default:\n                return f\n", "docstring": "Returns the default folder for the current user"}
{"repo": "python-o365-master/O365/teams.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" Microsoft Teams Presence\n        :param parent: parent object\n        :type parent: Teams\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.object_id = cloud_data.get('id')\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        main_resource = '{}{}'.format(main_resource, '')\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        self.availability = cloud_data.get('availability')\n        self.activity = cloud_data.get('activity')\n", "docstring": "Microsoft Teams Presence"}
{"repo": "python-o365-master/O365/teams.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" A Microsoft Teams team\n        :param parent: parent object\n        :type parent: Teams\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.object_id = cloud_data.get('id')\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        main_resource = '{}{}'.format(main_resource, '')\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        self.display_name = cloud_data.get(self._cc('displayName'), '')\n        self.description = cloud_data.get(self._cc('description'), '')\n        self.is_archived = cloud_data.get(self._cc('isArchived'), '')\n        self.web_url = cloud_data.get(self._cc('webUrl'), '')\n", "docstring": "A Microsoft Teams team"}
{"repo": "python-o365-master/O365/teams.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" A Microsoft Teams channel\n        :param parent: parent object\n        :type parent: Teams\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.object_id = cloud_data.get('id')\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        main_resource = '{}{}'.format(main_resource, '')\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        self.display_name = cloud_data.get(self._cc('displayName'), '')\n        self.description = cloud_data.get('description')\n        self.email = cloud_data.get('email')\n", "docstring": "A Microsoft Teams channel"}
{"repo": "python-o365-master/O365/teams.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" A Microsoft Teams app\n        :param parent: parent object\n        :type parent: Teams\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.object_id = cloud_data.get('id')\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        main_resource = '{}{}'.format(main_resource, '')\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        self.app_definition = cloud_data.get(self._cc('teamsAppDefinition'), '')\n", "docstring": "A Microsoft Teams app"}
{"repo": "python-o365-master/O365/teams.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" A Teams object\n        :param parent: parent object\n        :type parent: Account\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        # Choose the main_resource passed in kwargs over the host_name\n        main_resource = kwargs.pop('main_resource',\n                                   '')  # defaults to blank resource\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n", "docstring": "A Teams object"}
{"repo": "python-o365-master/O365/teams.py", "original_string": "    def get_my_teams(self, *args):\n        \"\"\" Returns a list of teams that I am in\n        :rtype: teams\n        \"\"\"\n        url = self.build_url(self._endpoints.get('get_my_teams'))\n        response = self.con.get(url)\n        if not response:\n            return None\n        data = response.json()\n        return [\n            self.team_constructor(parent=self, **{self._cloud_data_key: site})\n            for site in data.get('value', [])]\n", "docstring": "Returns a list of teams that I am in"}
{"repo": "python-o365-master/O365/teams.py", "original_string": "    def create_channel(self, team_id=None, display_name=None, description=None):\n        \"\"\" Creates a channel within a specified team\n        :param team_id: the team_id where the channel is created.\n        :rtype: channel\n        \"\"\"\n        if not team_id and display_name:\n            raise RuntimeError('Provide the team_id and the display_name')\n        if team_id:\n            # get channels by the team id\n            url = self.build_url(\n                self._endpoints.get('get_channels').format(team_id=team_id))\n        if display_name and description:\n            data = {\n                'displayName': display_name,\n                'description': description,\n            }\n        else:\n            data = {\n                'displayName': display_name,\n            }\n        response = self.con.post(url, data=data)\n        if not response:\n            return None\n        data = response.json()\n        return self.channel_constructor(parent=self, **{self._cloud_data_key: data})\n", "docstring": "Creates a channel within a specified team"}
{"repo": "python-o365-master/O365/mailbox.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" Create an instance to represent the specified folder un given\n        parent folder\n        :param parent: parent folder/account for this folder\n        :type parent: mailbox.Folder or Account\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        :param str name: name of the folder to get under the parent (kwargs)\n        :param str folder_id: id of the folder to get under the parent (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        self.parent = parent if isinstance(parent, Folder) else None\n        # This folder has no parents if root = True.\n        self.root = kwargs.pop('root', False)\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        # Fallback to manual folder if nothing available on cloud data\n        self.name = cloud_data.get(self._cc('displayName'),\n                                   kwargs.get('name',\n                                              ''))\n        if self.root is False:\n            # Fallback to manual folder if nothing available on cloud data\n            self.folder_id = cloud_data.get(self._cc('id'),\n                                            kwargs.get('folder_id',\n                                                       None))\n            self.parent_id = cloud_data.get(self._cc('parentFolderId'), None)\n            self.child_folders_count = cloud_data.get(\n                self._cc('childFolderCount'), 0)\n            self.unread_items_count = cloud_data.get(\n                self._cc('unreadItemCount'), 0)\n            self.total_items_count = cloud_data.get(self._cc('totalItemCount'),\n                                                    0)\n            self.updated_at = dt.datetime.now()\n        else:\n            self.folder_id = 'root'\n", "docstring": "Create an instance to represent the specified folder un given"}
{"repo": "python-o365-master/O365/mailbox.py", "original_string": "    def get_folders(self, limit=None, *, query=None, order_by=None, batch=None):\n        \"\"\" Returns a list of child folders matching the query\n        :param int limit: max no. of folders to get. Over 999 uses batch.\n        :param query: applies a filter to the request such as\n         \"displayName eq 'HelloFolder'\"\n        :type query: Query or str\n        :param order_by: orders the result set based on this condition\n        :type order_by: Query or str\n        :param int batch: batch size, retrieves items in\n         batches allowing to retrieve more items than the limit.\n        :return: list of folders\n        :rtype: list[mailbox.Folder] or Pagination\n        \"\"\"\n        if self.root:\n            url = self.build_url(self._endpoints.get('root_folders'))\n        else:\n            url = self.build_url(\n                self._endpoints.get('child_folders').format(id=self.folder_id))\n        if limit is None or limit > self.protocol.max_top_value:\n            batch = self.protocol.max_top_value\n        params = {'$top': batch if batch else limit}\n        if order_by:\n            params['$orderby'] = order_by\n        if query:\n            if isinstance(query, str):\n                params['$filter'] = query\n            else:\n                params.update(query.as_params())\n        response = self.con.get(url, params=params)\n        if not response:\n            return []\n        data = response.json()\n        # Everything received from cloud must be passed as self._cloud_data_key\n        self_class = getattr(self, 'folder_constructor', type(self))\n        folders = [self_class(parent=self, **{self._cloud_data_key: folder}) for\n                   folder in data.get('value', [])]\n        next_link = data.get(NEXT_LINK_KEYWORD, None)\n        if batch and next_link:\n            return Pagination(parent=self, data=folders, constructor=self_class,\n                              next_link=next_link, limit=limit)\n        else:\n            return folders\n", "docstring": "Returns a list of child folders matching the query"}
{"repo": "python-o365-master/O365/mailbox.py", "original_string": "    def get_folder(self, *, folder_id=None, folder_name=None):\n        \"\"\" Get a folder by it's id or name\n        :param str folder_id: the folder_id to be retrieved.\n         Can be any folder Id (child or not)\n        :param str folder_name: the folder name to be retrieved.\n         Must be a child of this folder.\n        :return: a single folder\n        :rtype: mailbox.Folder or None\n        \"\"\"\n        if folder_id and folder_name:\n            raise RuntimeError('Provide only one of the options')\n        if not folder_id and not folder_name:\n            raise RuntimeError('Provide one of the options')\n        if folder_id:\n            # get folder by it's id, independent of the parent of this folder_id\n            url = self.build_url(\n                self._endpoints.get('get_folder').format(id=folder_id))\n            params = None\n        else:\n            # get folder by name. Only looks up in child folders.\n            if self.root:\n                url = self.build_url(self._endpoints.get('root_folders'))\n            else:\n                url = self.build_url(\n                    self._endpoints.get('child_folders').format(\n                        id=self.folder_id))\n            params = {'$filter': \"{} eq '{}'\".format(self._cc('displayName'),\n                                                     folder_name), '$top': 1}\n        response = self.con.get(url, params=params)\n        if not response:\n            return None\n        if folder_id:\n            folder = response.json()\n        else:\n            folder = response.json().get('value')\n            folder = folder[0] if folder else None\n            if folder is None:\n                return None\n        self_class = getattr(self, 'folder_constructor', type(self))\n        # Everything received from cloud must be passed as self._cloud_data_key\n        # We don't pass parent, as this folder may not be a child of self.\n        return self_class(con=self.con, protocol=self.protocol,\n                          main_resource=self.main_resource,\n                          **{self._cloud_data_key: folder})\n", "docstring": "Get a folder by it's id or name"}
{"repo": "python-o365-master/O365/mailbox.py", "original_string": "    def get_parent_folder(self):\n        \"\"\" Get the parent folder from attribute self.parent or\n        getting it from the cloud\n        :return: Parent Folder\n        :rtype: mailbox.Folder or None\n        \"\"\"\n        if self.root:\n            return None\n        if self.parent:\n            return self.parent\n        if self.parent_id:\n            self.parent = self.get_folder(folder_id=self.parent_id)\n        return self.parent\n", "docstring": "Get the parent folder from attribute self.parent or"}
{"repo": "python-o365-master/O365/mailbox.py", "original_string": "    def delete(self):\n        \"\"\" Deletes this folder\n        :return: Deleted or Not\n        :rtype: bool\n        \"\"\"\n        if self.root or not self.folder_id:\n            return False\n        url = self.build_url(\n            self._endpoints.get('get_folder').format(id=self.folder_id))\n        response = self.con.delete(url)\n        if not response:\n            return False\n        self.folder_id = None\n        return True\n", "docstring": "Deletes this folder"}
{"repo": "python-o365-master/O365/mailbox.py", "original_string": "    def move_folder(self, to_folder, *, update_parent_if_changed=True):\n        \"\"\" Move this folder to another folder\n        :param to_folder: the destination Folder/folder_id to move into\n        :type to_folder: mailbox.Folder or str\n        :param bool update_parent_if_changed: updates self.parent with the\n         new parent Folder if changed\n        :return: The new folder after copying\n        :rtype: mailbox.Folder or None\n        \"\"\"\n        to_folder_id = to_folder.folder_id if isinstance(to_folder,\n                                                         Folder) else to_folder\n        if self.root or not self.folder_id or not to_folder_id:\n            return False\n        url = self.build_url(\n            self._endpoints.get('move_folder').format(id=self.folder_id))\n        response = self.con.post(url,\n                                 data={self._cc('destinationId'): to_folder_id})\n        if not response:\n            return False\n        folder = response.json()\n        parent_id = folder.get(self._cc('parentFolderId'), None)\n        if parent_id and self.parent_id:\n            if parent_id != self.parent_id:\n                self.parent_id = parent_id\n                self.parent = (self.get_parent_folder()\n                               if update_parent_if_changed else None)\n        return True\n", "docstring": "Move this folder to another folder"}
{"repo": "python-o365-master/O365/mailbox.py", "original_string": "    def delete_message(self, message):\n        \"\"\" Deletes a stored message\n        :param message: message/message_id to delete\n        :type message: Message or str\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        message_id = message.object_id if isinstance(message,\n                                                     Message) else message\n        if message_id is None:\n            raise RuntimeError('Provide a valid Message or a message id')\n        url = self.build_url(\n            self._endpoints.get('message').format(id=message_id))\n        response = self.con.delete(url)\n        return bool(response)\n", "docstring": "Deletes a stored message"}
{"repo": "python-o365-master/O365/mailbox.py", "original_string": "    def junk_folder(self):\n        \"\"\" Shortcut to get Junk Folder instance\n        :rtype: mailbox.Folder\n        \"\"\"\n        return self.folder_constructor(parent=self, name='Junk',\n                                       folder_id=OutlookWellKnowFolderNames\n                                       .JUNK.value)\n", "docstring": "Shortcut to get Junk Folder instance"}
{"repo": "python-o365-master/O365/mailbox.py", "original_string": "    def drafts_folder(self):\n        \"\"\" Shortcut to get Drafts Folder instance\n        :rtype: mailbox.Folder\n        \"\"\"\n        return self.folder_constructor(parent=self, name='Drafts',\n                                       folder_id=OutlookWellKnowFolderNames\n                                       .DRAFTS.value)\n", "docstring": "Shortcut to get Drafts Folder instance"}
{"repo": "python-o365-master/O365/mailbox.py", "original_string": "    def outbox_folder(self):\n        \"\"\" Shortcut to get Outbox Folder instance\n        :rtype: mailbox.Folder\n        \"\"\"\n        return self.folder_constructor(parent=self, name='Outbox',\n                                       folder_id=OutlookWellKnowFolderNames\n                                       .OUTBOX.value)\n", "docstring": "Shortcut to get Outbox Folder instance"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def check_status(self, delay=0):\n        \"\"\" Checks the api endpoint in a loop\n        :param delay: number of seconds to wait between api calls.\n         Note Connection 'requests_delay' also apply.\n        :return: tuple of status and percentage complete\n        :rtype: tuple(str, float)\n        \"\"\"\n        if not self.item_id:\n            while not self._request_status():\n                # wait until _request_status returns True\n                yield self.status, self.completion_percentage\n                if self.item_id is None:\n                    sleep(delay)\n        else:\n            yield self.status, self.completion_percentage\n", "docstring": "Checks the api endpoint in a loop"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" Version of DriveItem\n        :param parent: parent for this operation\n        :type parent: DriveItem\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        self._parent = parent if isinstance(parent, DriveItem) else None\n        protocol = parent.protocol if parent else kwargs.get('protocol')\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        resource_prefix = '/items/{item_id}'.format(\n            item_id=self._parent.object_id)\n        main_resource = '{}{}'.format(\n            main_resource or (protocol.default_resource if protocol else ''),\n            resource_prefix)\n        super().__init__(protocol=protocol, main_resource=main_resource)\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.driveitem_id = self._parent.object_id\n        self.object_id = cloud_data.get('id', '1.0')\n        self.name = self.object_id\n        modified = cloud_data.get(self._cc('lastModifiedDateTime'), None)\n        local_tz = self.protocol.timezone\n        self.modified = parse(modified).astimezone(\n            local_tz) if modified else None\n        self.size = cloud_data.get('size', 0)\n        modified_by = cloud_data.get(self._cc('lastModifiedBy'), {}).get('user',\n                                                                         None)\n        self.modified_by = Contact(con=self.con, protocol=self.protocol, **{\n            self._cloud_data_key: modified_by}) if modified_by else None\n", "docstring": "Version of DriveItem"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def __repr__(self):\n        return ('Version Id: {} | Modified on: {} | by: {}'\n                ''.format(self.name,\n                          self.modified,\n                          self.modified_by.display_name\n                          if self.modified_by else None))\n", "docstring": "return ('Version Id: {} | Modified on: {} | by: {}'"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" Permissions for DriveItem\n        :param parent: parent for this operation\n        :type parent: DriveItem\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        self._parent = parent if isinstance(parent, DriveItem) else None\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        protocol = parent.protocol if parent else kwargs.get('protocol')\n        super().__init__(protocol=protocol, main_resource=main_resource)\n        self.driveitem_id = self._parent.object_id\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.object_id = cloud_data.get(self._cc('id'))\n        self.inherited_from = cloud_data.get(self._cc('inheritedFrom'), None)\n        link = cloud_data.get(self._cc('link'), None)\n        self.permission_type = 'owner'\n        if link:\n            self.permission_type = 'link'\n            self.share_type = link.get('type', 'view')\n            self.share_scope = link.get('scope', 'anonymous')\n            self.share_link = link.get('webUrl', None)\n        invitation = cloud_data.get(self._cc('invitation'), None)\n        if invitation:\n            self.permission_type = 'invitation'\n            self.share_email = invitation.get('email', '')\n            invited_by = invitation.get('invitedBy', {})\n            self.invited_by = invited_by.get('user', {}).get(\n                self._cc('displayName'), None) or invited_by.get('application',\n                                                                 {}).get(\n                self._cc('displayName'), None)\n            self.require_sign_in = invitation.get(self._cc('signInRequired'),\n                                                  True)\n        self.roles = cloud_data.get(self._cc('roles'), [])\n        granted_to = cloud_data.get(self._cc('grantedTo'), {})\n        self.granted_to = granted_to.get('user', {}).get(\n            self._cc('displayName')) or granted_to.get('application', {}).get(\n            self._cc('displayName'))\n        self.share_id = cloud_data.get(self._cc('shareId'), None)\n", "docstring": "Permissions for DriveItem"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def delete(self):\n        \"\"\" Deletes this permission. Only permissions that are not\n        inherited can be deleted.\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        if not self.object_id:\n            return False\n        url = self.build_url(self._endpoints.get('permission').format(\n            driveitem_id=self.driveitem_id, id=self.object_id))\n        response = self.con.delete(url)\n        if not response:\n            return False\n        self.object_id = None\n        return True\n", "docstring": "Deletes this permission. Only permissions that are not"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def _classifier(item):\n        \"\"\" Subclass to change factory classes \"\"\"\n        if 'folder' in item:\n            return Folder\n        elif 'image' in item:\n            return Image\n        elif 'photo' in item:\n            return Photo\n        else:\n            return File\n", "docstring": "Subclass to change factory classes \n"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def is_folder(self):\n        \"\"\" Returns if this DriveItem is a Folder \"\"\"\n        return isinstance(self, Folder)\n", "docstring": "Returns if this DriveItem is a Folder \n"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def is_file(self):\n        \"\"\" Returns if this DriveItem is a File \"\"\"\n        return isinstance(self, File)\n", "docstring": "Returns if this DriveItem is a File \n"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def is_image(self):\n        \"\"\" Returns if this DriveItem is a Image \"\"\"\n        return isinstance(self, Image)\n", "docstring": "Returns if this DriveItem is a Image \n"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def is_photo(self):\n        \"\"\" Returns if this DriveItem is a Photo \"\"\"\n        return isinstance(self, Photo)\n", "docstring": "Returns if this DriveItem is a Photo \n"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def update(self, **kwargs):\n        \"\"\" Updates this item\n        :param kwargs: all the properties to be updated.\n         only name and description are allowed at the moment.\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        if not self.object_id:\n            return False\n        url = self.build_url(\n            self._endpoints.get('item').format(id=self.object_id))\n        data = {self._cc(key): value for key, value in kwargs.items() if\n                key in {'name',\n                        'description'}}  # convert keys to protocol casing\n        if not data:\n            return False\n        response = self.con.patch(url, data=data)\n        if not response:\n            return False\n        new_data = response.json()\n        for key in data:\n            value = new_data.get(key, None)\n            if value:\n                setattr(self, self.protocol.to_api_case(key), value)\n        return True\n", "docstring": "Updates this item"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def move(self, target):\n        \"\"\" Moves this DriveItem to another Folder.\n        Can't move between different Drives.\n        :param target: a Folder, Drive item or Item Id string.\n         If it's a drive the item will be moved to the root folder.\n        :type target: drive.Folder or DriveItem or str\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        if isinstance(target, Folder):\n            target_id = target.object_id\n        elif isinstance(target, Drive):\n            # we need the root folder id\n            root_folder = target.get_root_folder()\n            if not root_folder:\n                return False\n            target_id = root_folder.object_id\n        elif isinstance(target, str):\n            target_id = target\n        else:\n            raise ValueError('Target must be a Folder or Drive')\n        if not self.object_id or not target_id:\n            raise ValueError(\n                'Both self, and target must have a valid object_id.')\n        if target_id == 'root':\n            raise ValueError(\"When moving, target id can't be 'root'\")\n        url = self.build_url(\n            self._endpoints.get('item').format(id=self.object_id))\n        data = {'parentReference': {'id': target_id}}\n        response = self.con.patch(url, data=data)\n        if not response:\n            return False\n        self.parent_id = target_id\n        return True\n", "docstring": "Moves this DriveItem to another Folder."}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def get_versions(self):\n        \"\"\" Returns a list of available versions for this item\n        :return: list of versions\n        :rtype: list[DriveItemVersion]\n        \"\"\"\n        if not self.object_id:\n            return []\n        url = self.build_url(\n            self._endpoints.get('versions').format(id=self.object_id))\n        response = self.con.get(url)\n        if not response:\n            return []\n        data = response.json()\n        # Everything received from cloud must be passed as self._cloud_data_key\n        return [DriveItemVersion(parent=self, **{self._cloud_data_key: item})\n                for item in data.get('value', [])]\n", "docstring": "Returns a list of available versions for this item"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def share_with_link(self, share_type='view', share_scope='anonymous'):\n        \"\"\" Creates or returns a link you can share with others\n        :param str share_type: 'view' to allow only view access,\n         'edit' to allow editions, and\n         'embed' to allow the DriveItem to be embedded\n        :param str share_scope: 'anonymous': anyone with the link can access.\n         'organization' Only organization members can access\n        :return: link to share\n        :rtype: DriveItemPermission\n        \"\"\"\n        if not self.object_id:\n            return None\n        url = self.build_url(\n            self._endpoints.get('share_link').format(id=self.object_id))\n        data = {\n            'type': share_type,\n            'scope': share_scope\n        }\n        response = self.con.post(url, data=data)\n        if not response:\n            return None\n        data = response.json()\n        # return data.get('link', {}).get('webUrl')\n        return DriveItemPermission(parent=self, **{self._cloud_data_key: data})\n", "docstring": "Creates or returns a link you can share with others"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def get_permissions(self):\n        \"\"\" Returns a list of DriveItemPermissions with the\n        permissions granted for this DriveItem.\n        :return: List of Permissions\n        :rtype: list[DriveItemPermission]\n        \"\"\"\n        if not self.object_id:\n            return []\n        url = self.build_url(\n            self._endpoints.get('permissions').format(id=self.object_id))\n        response = self.con.get(url)\n        if not response:\n            return None\n        data = response.json()\n        # Everything received from cloud must be passed as self._cloud_data_key\n        return [DriveItemPermission(parent=self, **{self._cloud_data_key: item})\n                for item in data.get('value', [])]\n", "docstring": "Returns a list of DriveItemPermissions with the"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.mime_type = cloud_data.get(self._cc('file'), {}).get(\n            self._cc('mimeType'), None)\n", "docstring": "super().__init__(**kwargs)"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def dimensions(self):\n        \"\"\" Dimension of the Image\n        :return: width x height\n        :rtype: str\n        \"\"\"\n        return '{}x{}'.format(self.width, self.height)\n", "docstring": "Dimension of the Image"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def get_child_folders(self, limit=None, *, query=None, order_by=None, batch=None):\n        \"\"\" Returns all the folders inside this folder\n        :param int limit: max no. of folders to get. Over 999 uses batch.\n        :param query: applies a OData filter to the request\n        :type query: Query or str\n        :param order_by: orders the result set based on this condition\n        :type order_by: Query or str\n        :param int batch: batch size, retrieves items in\n         batches allowing to retrieve more items than the limit.\n        :return: folder items in this folder\n        :rtype: generator of DriveItem or Pagination\n        \"\"\"\n        if query:\n            query = query.on_attribute('folder').unequal(None)\n        else:\n            query = self.q('folder').unequal(None)\n        return self.get_items(limit=limit, query=query, order_by=order_by, batch=batch)\n", "docstring": "Returns all the folders inside this folder"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def download_contents(self, to_folder=None):\n        \"\"\" This will download each file and folder sequentially.\n        Caution when downloading big folder structures\n        :param drive.Folder to_folder: folder where to store the contents\n        \"\"\"\n        if to_folder is None:\n            try:\n                to_folder = Path() / self.name\n            except Exception as e:\n                log.error('Could not create folder with name: {}. Error: {}'.format(self.name, e))\n                to_folder = Path()  # fallback to the same folder\n        else:\n            to_folder = Path() / to_folder\n            if not to_folder.exists():\n                to_folder.mkdir()\n        if not isinstance(to_folder,str):\n            if not to_folder.exists():\n                to_folder.mkdir()\n        else:\n            to_folder = Path() / self.name\n        \n        for item in self.get_items(query=self.new_query().select('id', 'size', 'folder', 'name')):\n            if item.is_folder and item.child_count > 0:\n                item.download_contents(to_folder=to_folder / item.name)\n            elif item.is_folder and item.child_count == 0:\n                # Create child folder without contents.\n                child_folder = to_folder / item.name\n                if not child_folder.exists():\n                    child_folder.mkdir()\n            else:\n                item.download(to_folder)\n", "docstring": "This will download each file and folder sequentially."}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" Create a drive representation\n        :param parent: parent for this operation\n        :type parent: Drive or Storage\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        self.parent = parent if isinstance(parent, Drive) else None\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None)\n        if main_resource is None:\n            main_resource = getattr(parent, 'main_resource', None) if parent else None\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        self._update_data(kwargs)\n", "docstring": "Create a drive representation"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def get_child_folders(self, limit=None, *, query=None, order_by=None, batch=None):\n        \"\"\" Returns all the folders inside this folder\n        :param int limit: max no. of folders to get. Over 999 uses batch.\n        :param query: applies a OData filter to the request\n        :type query: Query or str\n        :param order_by: orders the result set based on this condition\n        :type order_by: Query or str\n        :param int batch: batch size, retrieves items in\n         batches allowing to retrieve more items than the limit.\n        :return: folder items in this folder\n        :rtype: generator of DriveItem or Pagination\n        \"\"\"\n        if query:\n            query = query.on_attribute('folder').unequal(None)\n        else:\n            query = self.q('folder').unequal(None)\n        return self.get_items(limit=limit, query=query, order_by=order_by, batch=batch)\n", "docstring": "Returns all the folders inside this folder"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def get_item_by_path(self, item_path):\n        \"\"\" Returns a DriveItem by it's path: /path/to/file\n        :return: one item\n        :rtype: DriveItem\n        \"\"\"\n        if self.object_id:\n            # reference the current drive_id\n            url = self.build_url(\n                self._endpoints.get('get_item_by_path').format(id=self.object_id,\n                                                               item_path=item_path))\n        else:\n            # we don't know the drive_id so go to the default drive\n            url = self.build_url(\n                self._endpoints.get('get_item_by_path_default').format(item_path=item_path))\n        response = self.con.get(url)\n        if not response:\n            return None\n        data = response.json()\n        # Everything received from cloud must be passed as self._cloud_data_key\n        return self._classifier(data)(parent=self,\n                                      **{self._cloud_data_key: data})\n", "docstring": "Returns a DriveItem by it's path: /path/to/file"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def _classifier(item):\n        \"\"\" Subclass to change factory classes \"\"\"\n        if 'folder' in item:\n            return Folder\n        elif 'image' in item:\n            return Image\n        elif 'photo' in item:\n            return Photo\n        else:\n            return File\n", "docstring": "Subclass to change factory classes \n"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" Create a storage representation\n        :param parent: parent for this operation\n        :type parent: Account\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n", "docstring": "Create a storage representation"}
{"repo": "python-o365-master/O365/drive.py", "original_string": "    def get_drive(self, drive_id):\n        \"\"\" Returns a Drive instance\n        :param drive_id: the drive_id to be retrieved\n        :return: Drive for the id\n        :rtype: Drive\n        \"\"\"\n        if not drive_id:\n            return None\n        url = self.build_url(\n            self._endpoints.get('get_drive').format(id=drive_id))\n        response = self.con.get(url)\n        if not response:\n            return None\n        drive = response.json()\n        # Everything received from cloud must be passed as self._cloud_data_key\n        return self.drive_constructor(con=self.con, protocol=self.protocol,\n                                      main_resource=self.main_resource,\n                                      **{self._cloud_data_key: drive})\n", "docstring": "Returns a Drive instance"}
{"repo": "python-o365-master/O365/planner.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" A Microsoft planner task\n        :param parent: parent object\n        :type parent: Planner\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        cloud_data = kwargs.get(self._cloud_data_key, {})\n        self.object_id = cloud_data.get('id')\n        # Choose the main_resource passed in kwargs over parent main_resource\n        main_resource = kwargs.pop('main_resource', None) or (\n            getattr(parent, 'main_resource', None) if parent else None)\n        main_resource = '{}{}'.format(main_resource, '')\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n        self.plan_id = cloud_data.get('plan_id')\n        self.bucket_id = cloud_data.get('bucketId')\n        self.title = cloud_data.get(self._cc('title'), '')\n        self.order_hint = cloud_data.get(self._cc('orderHint'), '')\n        self.assignee_priority = cloud_data.get(self._cc('assigneePriority'), '')\n        self.percent_complete = cloud_data.get(self._cc('percentComplete'), '')\n        self.title = cloud_data.get(self._cc('title'), '')\n        self.has_description = cloud_data.get(self._cc('hasDescription'), '')\n        created = cloud_data.get(self._cc('createdDateTime'), None)\n        due_date = cloud_data.get(self._cc('dueDateTime'), None)\n        start_date = cloud_data.get(self._cc('startDateTime'), None)\n        completed_date = cloud_data.get(self._cc('completedDateTime'), None)\n        local_tz = self.protocol.timezone\n        self.start_date = parse(start_date).astimezone(local_tz) if start_date else None\n        self.created_date = parse(created).astimezone(local_tz) if created else None\n        self.due_date = parse(due_date).astimezone(local_tz) if due_date else None\n        self.completed_date = parse(completed_date).astimezone(local_tz) if completed_date else None\n        self.preview_type = cloud_data.get(self._cc('previewType'), None)\n        self.reference_count = cloud_data.get(self._cc('referenceCount'), None)\n        self.checklist_item_count = cloud_data.get(self._cc('checklistItemCount'), None)\n        self.active_checklist_item_count = cloud_data.get(self._cc('activeChecklistItemCount'), None)\n        self.conversation_thread_id = cloud_data.get(self._cc('conversationThreadId'), None)\n", "docstring": "A Microsoft planner task"}
{"repo": "python-o365-master/O365/planner.py", "original_string": "    def __init__(self, *, parent=None, con=None, **kwargs):\n        \"\"\" A Planner object\n        :param parent: parent object\n        :type parent: Account\n        :param Connection con: connection to use if no parent specified\n        :param Protocol protocol: protocol to use if no parent specified\n         (kwargs)\n        :param str main_resource: use this resource instead of parent resource\n         (kwargs)\n        \"\"\"\n        if parent and con:\n            raise ValueError('Need a parent or a connection but not both')\n        self.con = parent.con if parent else con\n        # Choose the main_resource passed in kwargs over the host_name\n        main_resource = kwargs.pop('main_resource',\n                                   '')  # defaults to blank resource\n        super().__init__(\n            protocol=parent.protocol if parent else kwargs.get('protocol'),\n            main_resource=main_resource)\n", "docstring": "A Planner object"}
{"repo": "python-o365-master/O365/utils/token.py", "original_string": "    def __init__(self):\n        self._token = None\n", "docstring": "self._token = None"}
{"repo": "python-o365-master/O365/utils/token.py", "original_string": "    def token(self):\n        \"\"\" The stored Token dict \"\"\"\n        return self._token\n", "docstring": "The stored Token dict \n"}
{"repo": "python-o365-master/O365/utils/token.py", "original_string": "    def token(self, value):\n        \"\"\" Setter to convert any token dict into Token instance \"\"\"\n        if value and not isinstance(value, Token):\n            value = Token(value)\n        self._token = value\n", "docstring": "Setter to convert any token dict into Token instance \n"}
{"repo": "python-o365-master/O365/utils/token.py", "original_string": "    def load_token(self):\n        \"\"\" Abstract method that will retrieve the oauth token \"\"\"\n        raise NotImplementedError\n", "docstring": "Abstract method that will retrieve the oauth token \n"}
{"repo": "python-o365-master/O365/utils/token.py", "original_string": "    def save_token(self):\n        \"\"\" Abstract method that will save the oauth token \"\"\"\n        raise NotImplementedError\n", "docstring": "Abstract method that will save the oauth token \n"}
{"repo": "python-o365-master/O365/utils/token.py", "original_string": "    def check_token(self):\n        \"\"\" Optional Abstract method to check for the token existence \"\"\"\n        raise NotImplementedError\n", "docstring": "Optional Abstract method to check for the token existence \n"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def from_value(cls, value):\n        \"\"\" Gets a member by a snaked-case provided value\"\"\"\n        try:\n            return cls(snakecase(value))\n        except ValueError:\n            return None\n", "docstring": "Gets a member by a snaked-case provided value\n"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def __init__(self, *args, casing=None, **kwargs):\n        \"\"\" A Custom Set that changes the casing of it's keys\n        :param func casing: a function to convert into specified case\n        \"\"\"\n        self.cc = casing\n        super().__init__(*args, **kwargs)\n", "docstring": "A Custom Set that changes the casing of it's keys"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def __init__(self, address=None, name=None, parent=None, field=None):\n        \"\"\" Create a recipient with provided information\n        :param str address: email address of the recipient\n        :param str name: name of the recipient\n        :param HandleRecipientsMixin parent: parent recipients handler\n        :param str field: name of the field to update back\n        \"\"\"\n        self._address = address or ''\n        self._name = name or ''\n        self._parent = parent\n        self._field = field\n", "docstring": "Create a recipient with provided information"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def _track_changes(self):\n        \"\"\" Update the track_changes on the parent to reflect a\n        needed update on this field \"\"\"\n        if self._field and getattr(self._parent, '_track_changes',\n                                   None) is not None:\n            self._parent._track_changes.add(self._field)\n", "docstring": "Update the track_changes on the parent to reflect a"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def address(self):\n        \"\"\" Email address of the recipient\n        :getter: Get the email address\n        :setter: Set and update the email address\n        :type: str\n        \"\"\"\n        return self._address\n", "docstring": "Email address of the recipient"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def name(self):\n        \"\"\" Name of the recipient\n        :getter: Get the name\n        :setter: Set and update the name\n        :type: str\n        \"\"\"\n        return self._name\n", "docstring": "Name of the recipient"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def __init__(self, recipients=None, parent=None, field=None):\n        \"\"\" Recipients must be a list of either address strings or\n        tuples (name, address) or dictionary elements\n        :param recipients: list of either address strings or\n         tuples (name, address) or dictionary elements\n        :type recipients: list[str] or list[tuple] or list[dict]\n         or list[Recipient]\n        :param HandleRecipientsMixin parent: parent recipients handler\n        :param str field: name of the field to update back\n        \"\"\"\n        self._parent = parent\n        self._field = field\n        self._recipients = []\n        self.untrack = True\n        if recipients:\n            self.add(recipients)\n        self.untrack = False\n", "docstring": "Recipients must be a list of either address strings or"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def _track_changes(self):\n        \"\"\" Update the track_changes on the parent to reflect a\n        needed update on this field \"\"\"\n        if self._field and getattr(self._parent, '_track_changes',\n                                   None) is not None and self.untrack is False:\n            self._parent._track_changes.add(self._field)\n", "docstring": "Update the track_changes on the parent to reflect a"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def add(self, recipients):\n        \"\"\" Add the supplied recipients to the exiting list\n        :param recipients: list of either address strings or\n         tuples (name, address) or dictionary elements\n        :type recipients: list[str] or list[tuple] or list[dict]\n        \"\"\"\n        if recipients:\n            if isinstance(recipients, str):\n                self._recipients.append(\n                    Recipient(address=recipients, parent=self._parent,\n                              field=self._field))\n            elif isinstance(recipients, Recipient):\n                self._recipients.append(recipients)\n            elif isinstance(recipients, tuple):\n                name, address = recipients\n                if address:\n                    self._recipients.append(\n                        Recipient(address=address, name=name,\n                                  parent=self._parent, field=self._field))\n            elif isinstance(recipients, list):\n                for recipient in recipients:\n                    self.add(recipient)\n            else:\n                raise ValueError('Recipients must be an address string, a '\n                                 'Recipient instance, a (name, address) '\n                                 'tuple or a list')\n            self._track_changes()\n", "docstring": "Add the supplied recipients to the exiting list"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def get_first_recipient_with_address(self):\n        \"\"\" Returns the first recipient found with a non blank address\n        :return: First Recipient\n        :rtype: Recipient\n        \"\"\"\n        recipients_with_address = [recipient for recipient in self._recipients\n                                   if recipient.address]\n        if recipients_with_address:\n            return recipients_with_address[0]\n        else:\n            return None\n", "docstring": "Returns the first recipient found with a non blank address"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def _recipients_from_cloud(self, recipients, field=None):\n        \"\"\" Transform a recipient from cloud data to object data \"\"\"\n        recipients_data = []\n        for recipient in recipients:\n            recipients_data.append(\n                self._recipient_from_cloud(recipient, field=field))\n        return Recipients(recipients_data, parent=self, field=field)\n", "docstring": "Transform a recipient from cloud data to object data \n"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def _recipient_to_cloud(self, recipient):\n        \"\"\" Transforms a Recipient object to a cloud dict \"\"\"\n        data = None\n        if recipient:\n            data = {self._cc('emailAddress'): {\n                self._cc('address'): recipient.address}}\n            if recipient.name:\n                data[self._cc('emailAddress')][\n                    self._cc('name')] = recipient.name\n        return data\n", "docstring": "Transforms a Recipient object to a cloud dict \n"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def __init__(self, *, protocol=None, main_resource=None, **kwargs):\n        \"\"\" Object initialization\n        :param Protocol protocol: A protocol class or instance to be used with\n         this connection\n        :param str main_resource: main_resource to be used in these API\n         communications\n        \"\"\"\n        self.protocol = protocol() if isinstance(protocol, type) else protocol\n        if self.protocol is None:\n            raise ValueError('Protocol not provided to Api Component')\n        mr, bu = self.build_base_url(main_resource)\n        self.main_resource = mr\n        self._base_url = bu\n        super().__init__()\n", "docstring": "Object initialization"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def _parse_resource(resource):\n        \"\"\" Parses and completes resource information \"\"\"\n        resource = resource.strip() if resource else resource\n        if resource in {ME_RESOURCE, USERS_RESOURCE, GROUPS_RESOURCE, SITES_RESOURCE}:\n            return resource\n        elif resource.startswith('user:'):\n            # user resource shorthand\n            resource = resource.replace('user:', '', 1)\n            return '{}/{}'.format(USERS_RESOURCE, resource)\n        elif '@' in resource and not resource.startswith(USERS_RESOURCE):\n            # user resource backup\n            # when for example accessing a shared mailbox the\n            # resource is set to the email address. we have to prefix\n            # the email with the resource 'users/' so --> 'users/email_address'\n            return '{}/{}'.format(USERS_RESOURCE, resource)\n        elif resource.startswith('group:'):\n            # group resource shorthand\n            resource = resource.replace('group:', '', 1)\n            return '{}/{}'.format(GROUPS_RESOURCE, resource)\n        elif resource.startswith('site:'):\n            # sharepoint site resource shorthand\n            resource = resource.replace('site:', '', 1)\n            return '{}/{}'.format(SITES_RESOURCE, resource)\n        else:\n            return resource\n", "docstring": "Parses and completes resource information \n"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def _gk(self, keyword):\n        \"\"\" Alias for protocol.get_service_keyword \"\"\"\n        return self.protocol.get_service_keyword(keyword)\n", "docstring": "Alias for protocol.get_service_keyword \n"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def _parse_date_time_time_zone(self, date_time_time_zone):\n        \"\"\" Parses and convert to protocol timezone a dateTimeTimeZone resource\n        This resource is a dict with a date time and a windows timezone\n        This is a common structure on Microsoft apis so it's included here.\n        \"\"\"\n        if date_time_time_zone is None:\n            return None\n        local_tz = self.protocol.timezone\n        if isinstance(date_time_time_zone, dict):\n            try:\n                timezone = pytz.timezone(\n                    get_iana_tz(date_time_time_zone.get(self._cc('timeZone'), 'UTC')))\n            except pytz.UnknownTimeZoneError:\n                timezone = local_tz\n            date_time = date_time_time_zone.get(self._cc('dateTime'), None)\n            try:\n                date_time = timezone.localize(parse(date_time)) if date_time else None\n            except OverflowError as e:\n                log.debug('Could not parse dateTimeTimeZone: {}. Error: {}'.format(date_time_time_zone, str(e)))\n                date_time = None\n            if date_time and timezone != local_tz:\n                date_time = date_time.astimezone(local_tz)\n        else:\n            # Outlook v1.0 api compatibility (fallback to datetime string)\n            try:\n                date_time = local_tz.localize(parse(date_time_time_zone)) if date_time_time_zone else None\n            except Exception as e:\n                log.debug('Could not parse dateTimeTimeZone: {}. Error: {}'.format(date_time_time_zone, str(e)))\n                date_time = None\n        return date_time\n", "docstring": "Parses and convert to protocol timezone a dateTimeTimeZone resource"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def new_query(self, attribute=None):\n        \"\"\" Create a new query to filter results\n        :param str attribute: attribute to apply the query for\n        :return: new Query\n        :rtype: Query\n        \"\"\"\n        return Query(attribute=attribute, protocol=self.protocol)\n", "docstring": "Create a new query to filter results"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def __init__(self, *, parent=None, data=None, constructor=None,\n                 next_link=None, limit=None, **kwargs):\n        \"\"\" Returns an iterator that returns data until it's exhausted.\n        Then will request more data (same amount as the original request)\n        to the server until this data is exhausted as well.\n        Stops when no more data exists or limit is reached.\n        :param parent: the parent class. Must implement attributes:\n         con, api_version, main_resource\n        :param data: the start data to be return\n        :param constructor: the data constructor for the next batch.\n         It can be a function.\n        :param str next_link: the link to request more data to\n        :param int limit: when to stop retrieving more data\n        :param kwargs: any extra key-word arguments to pass to the\n         construtctor.\n        \"\"\"\n        if parent is None:\n            raise ValueError('Parent must be another Api Component')\n        super().__init__(protocol=parent.protocol,\n                         main_resource=parent.main_resource)\n        self.parent = parent\n        self.con = parent.con\n        self.constructor = constructor\n        self.next_link = next_link\n        self.limit = limit\n        self.data = data = list(data) if data else []\n        data_count = len(data)\n        if limit and limit < data_count:\n            self.data_count = limit\n            self.total_count = limit\n        else:\n            self.data_count = data_count\n            self.total_count = data_count\n        self.state = 0\n        self.extra_args = kwargs\n", "docstring": "Returns an iterator that returns data until it's exhausted."}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def __init__(self, attribute=None, *, protocol):\n        \"\"\" Build a query to apply OData filters\n        https://docs.microsoft.com/en-us/graph/query-parameters\n        :param str attribute: attribute to apply the query for\n        :param Protocol protocol: protocol to use for connecting\n        \"\"\"\n        self.protocol = protocol() if isinstance(protocol, type) else protocol\n        self._attribute = None\n        self._chain = None\n        self.new(attribute)\n        self._negation = False\n        self._filters = []  # store all the filters\n        self._order_by = OrderedDict()\n        self._selects = set()\n        self._expands = set()\n        self._search = None\n        self._open_group_flag = []  # stores if the next attribute must be grouped\n        self._close_group_flag = []  # stores if the last attribute must be closing a group\n", "docstring": "Build a query to apply OData filters"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def select(self, *attributes):\n        \"\"\" Adds the attribute to the $select parameter\n        :param str attributes: the attributes tuple to select.\n         If empty, the on_attribute previously set is added.\n        :rtype: Query\n        \"\"\"\n        if attributes:\n            for attribute in attributes:\n                attribute = self.protocol.convert_case(\n                    attribute) if attribute and isinstance(attribute,\n                                                           str) else None\n                if attribute:\n                    if '/' in attribute:\n                        # only parent attribute can be selected\n                        attribute = attribute.split('/')[0]\n                    self._selects.add(attribute)\n        else:\n            if self._attribute:\n                self._selects.add(self._attribute)\n        return self\n", "docstring": "Adds the attribute to the $select parameter"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def expand(self, *relationships):\n        \"\"\" Adds the relationships (e.g. \"event\" or \"attachments\")\n        that should be expanded with the $expand parameter\n        Important: The ApiComponent using this should know how to handle this relationships.\n            eg: Message knows how to handle attachments, and event (if it's an EventMessage).\n        Important: When using expand on multi-value relationships a max of 20 items will be returned.\n        :param str relationships: the relationships tuple to expand.\n        :rtype: Query\n        \"\"\"\n        for relationship in relationships:\n            if relationship == 'event':\n                relationship = '{}/event'.format(self.protocol.get_service_keyword('event_message_type'))\n            self._expands.add(relationship)\n        return self\n", "docstring": "Adds the relationships (e.g. \"event\" or \"attachments\")"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def has_filters(self):\n        \"\"\" Whether the query has filters or not\n        :rtype: bool\n        \"\"\"\n        return bool(self._filters)\n", "docstring": "Whether the query has filters or not"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def has_order(self):\n        \"\"\" Whether the query has order_by or not\n        :rtype: bool\n        \"\"\"\n        return bool(self._order_by)\n", "docstring": "Whether the query has order_by or not"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def has_selects(self):\n        \"\"\" Whether the query has select filters or not\n        :rtype: bool\n        \"\"\"\n        return bool(self._selects)\n", "docstring": "Whether the query has select filters or not"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def has_expands(self):\n        \"\"\" Whether the query has relationships that should be expanded or not\n         :rtype: bool\n        \"\"\"\n        return bool(self._expands)\n", "docstring": "Whether the query has relationships that should be expanded or not"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def get_order(self):\n        \"\"\" Returns the result order by clauses\n        :rtype: str or None\n        \"\"\"\n        # first get the filtered attributes in order as they must appear\n        # in the order_by first\n        if not self.has_order:\n            return None\n        return ','.join(['{} {}'.format(attribute, direction or '').strip()\n                         for attribute, direction in self._order_by.items()])\n", "docstring": "Returns the result order by clauses"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def get_expands(self):\n        \"\"\" Returns the result expand clause\n         :rtype: str or None\n        \"\"\"\n        if self._expands:\n            return ','.join(self._expands)\n        else:\n            return None\n", "docstring": "Returns the result expand clause"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def new(self, attribute, operation=ChainOperator.AND):\n        \"\"\" Combine with a new query\n        :param str attribute: attribute of new query\n        :param ChainOperator operation: operation to combine to new query\n        :rtype: Query\n        \"\"\"\n        if isinstance(operation, str):\n            operation = ChainOperator(operation)\n        self._chain = operation\n        self._attribute = self._get_mapping(attribute) if attribute else None\n        self._negation = False\n        return self\n", "docstring": "Combine with a new query"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def clear_order(self):\n        \"\"\" Clears any order commands \"\"\"\n        self._order_by = OrderedDict()\n", "docstring": "Clears any order commands \n"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def clear(self):\n        \"\"\" Clear everything\n        :rtype: Query\n        \"\"\"\n        self._filters = []\n        self._order_by = OrderedDict()\n        self._selects = set()\n        self._negation = False\n        self._attribute = None\n        self._chain = None\n        self._search = None\n        self._open_group_flag = []\n        self._close_group_flag = []\n        return self\n", "docstring": "Clear everything"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def negate(self):\n        \"\"\" Apply a not operator\n        :rtype: Query\n        \"\"\"\n        self._negation = not self._negation\n        return self\n", "docstring": "Apply a not operator"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def chain(self, operation=ChainOperator.AND):\n        \"\"\" Start a chain operation\n        :param ChainOperator, str operation: how to combine with a new one\n        :rtype: Query\n        \"\"\"\n        if isinstance(operation, str):\n            operation = ChainOperator(operation)\n        self._chain = operation\n        return self\n", "docstring": "Start a chain operation"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def on_attribute(self, attribute):\n        \"\"\" Apply query on attribute, to be used along with chain()\n        :param str attribute: attribute name\n        :rtype: Query\n        \"\"\"\n        self._attribute = self._get_mapping(attribute)\n        return self\n", "docstring": "Apply query on attribute, to be used along with chain()"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def on_list_field(self, field):\n        \"\"\" Apply query on a list field, to be used along with chain()\n        :param str field: field name (note: name is case sensitive)\n        :rtype: Query\n        \"\"\"\n        self._attribute = 'fields/' + field\n        return self\n", "docstring": "Apply query on a list field, to be used along with chain()"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def _add_filter(self, *filter_data):\n        if self._attribute:\n            if self._filters and not isinstance(self._filters[-1],\n                                                ChainOperator):\n                self._filters.append(self._chain)\n            sentence, attrs = filter_data\n            for i, group in enumerate(self._open_group_flag):\n                if group is True:\n                    # Open a group\n                    sentence = '(' + sentence\n                    self._open_group_flag[i] = False  # set to done\n            self._filters.append([self._attribute, sentence, attrs])\n        else:\n            raise ValueError(\n                'Attribute property needed. call on_attribute(attribute) '\n                'or new(attribute)')\n", "docstring": "if self._attribute:"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def logical_operator(self, operation, word):\n        \"\"\" Apply a logical operator\n        :param str operation: how to combine with a new one\n        :param word: other parameter for the operation\n         (a = b) would be like a.logical_operator('eq', 'b')\n        :rtype: Query\n        \"\"\"\n        word = self._parse_filter_word(word)\n        self._add_filter(\n            *self._prepare_sentence(self._attribute, operation, word,\n                                    self._negation))\n        return self\n", "docstring": "Apply a logical operator"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def equals(self, word):\n        \"\"\" Add a equals check\n        :param word: word to compare with\n        :rtype: Query\n        \"\"\"\n        return self.logical_operator('eq', word)\n", "docstring": "Add a equals check"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def unequal(self, word):\n        \"\"\" Add a unequals check\n        :param word: word to compare with\n        :rtype: Query\n        \"\"\"\n        return self.logical_operator('ne', word)\n", "docstring": "Add a unequals check"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def greater(self, word):\n        \"\"\" Add a greater than check\n        :param word: word to compare with\n        :rtype: Query\n        \"\"\"\n        return self.logical_operator('gt', word)\n", "docstring": "Add a greater than check"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def greater_equal(self, word):\n        \"\"\" Add a greater than or equal to check\n        :param word: word to compare with\n        :rtype: Query\n        \"\"\"\n        return self.logical_operator('ge', word)\n", "docstring": "Add a greater than or equal to check"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def less(self, word):\n        \"\"\" Add a less than check\n        :param word: word to compare with\n        :rtype: Query\n        \"\"\"\n        return self.logical_operator('lt', word)\n", "docstring": "Add a less than check"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def less_equal(self, word):\n        \"\"\" Add a less than or equal to check\n        :param word: word to compare with\n        :rtype: Query\n        \"\"\"\n        return self.logical_operator('le', word)\n", "docstring": "Add a less than or equal to check"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def function(self, function_name, word):\n        \"\"\" Apply a function on given word\n        :param str function_name: function to apply\n        :param str word: word to apply function on\n        :rtype: Query\n        \"\"\"\n        word = self._parse_filter_word(word)\n        self._add_filter(\n            *self._prepare_function(function_name, self._attribute, word,\n                                    self._negation))\n        return self\n", "docstring": "Apply a function on given word"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def contains(self, word):\n        \"\"\" Adds a contains word check\n        :param str word: word to check\n        :rtype: Query\n        \"\"\"\n        return self.function('contains', word)\n", "docstring": "Adds a contains word check"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def startswith(self, word):\n        \"\"\" Adds a startswith word check\n        :param str word: word to check\n        :rtype: Query\n        \"\"\"\n        return self.function('startswith', word)\n", "docstring": "Adds a startswith word check"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def endswith(self, word):\n        \"\"\" Adds a endswith word check\n        :param str word: word to check\n        :rtype: Query\n        \"\"\"\n        return self.function('endswith', word)\n", "docstring": "Adds a endswith word check"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def any(self, *, collection, word, attribute=None, func=None, operation=None):\n        \"\"\" Performs a filter with the OData 'any' keyword on the collection\n        For example:\n        q.any(collection='email_addresses', attribute='address',\n        operation='eq', word='george@best.com')\n        will transform to a filter such as:\n        emailAddresses/any(a:a/address eq 'george@best.com')\n        :param str collection: the collection to apply the any keyword on\n        :param str word: the word to check\n        :param str attribute: the attribute of the collection to check\n        :param str func: the logical function to apply to the attribute\n         inside the collection\n        :param str operation: the logical operation to apply to the\n         attribute inside the collection\n        :rtype: Query\n        \"\"\"\n        return self.iterable('any', collection=collection, word=word,\n                             attribute=attribute, func=func, operation=operation)\n", "docstring": "Performs a filter with the OData 'any' keyword on the collection"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def all(self, *, collection, word, attribute=None, func=None, operation=None):\n        \"\"\" Performs a filter with the OData 'all' keyword on the collection\n        For example:\n        q.any(collection='email_addresses', attribute='address',\n        operation='eq', word='george@best.com')\n        will transform to a filter such as:\n        emailAddresses/all(a:a/address eq 'george@best.com')\n        :param str collection: the collection to apply the any keyword on\n        :param str word: the word to check\n        :param str attribute: the attribute of the collection to check\n        :param str func: the logical function to apply to the attribute\n         inside the collection\n        :param str operation: the logical operation to apply to the\n         attribute inside the collection\n        :rtype: Query\n        \"\"\"\n        return self.iterable('all', collection=collection, word=word,\n                             attribute=attribute, func=func, operation=operation)\n", "docstring": "Performs a filter with the OData 'all' keyword on the collection"}
{"repo": "python-o365-master/O365/utils/utils.py", "original_string": "    def order_by(self, attribute=None, *, ascending=True):\n        \"\"\" Applies a order_by clause\n        :param str attribute: attribute to apply on\n        :param bool ascending: should it apply ascending order or descending\n        :rtype: Query\n        \"\"\"\n        attribute = self._get_mapping(attribute) or self._attribute\n        if attribute:\n            self._order_by[attribute] = None if ascending else 'desc'\n        else:\n            raise ValueError(\n                'Attribute property needed. call on_attribute(attribute) '\n                'or new(attribute)')\n        return self\n", "docstring": "Applies a order_by clause"}
{"repo": "python-o365-master/O365/utils/windows_tz.py", "original_string": "def get_iana_tz(windows_tz):\n    \"\"\" Returns a valid pytz TimeZone (Iana/Olson Timezones) from a given\n    windows TimeZone\n    :param windows_tz: windows format timezone usually returned by\n     microsoft api response\n    :return:\n    :rtype:\n    \"\"\"\n    timezone = WIN_TO_IANA.get(windows_tz)\n    if timezone is None:\n        # Nope, that didn't work. Try adding \"Standard Time\",\n        # it seems to work a lot of times:\n        timezone = WIN_TO_IANA.get(windows_tz + ' Standard Time')\n    # Return what we have.\n    if timezone is None:\n        raise pytz.UnknownTimeZoneError(\n            \"Can't find Windows TimeZone \" + windows_tz)\n    return timezone\n", "docstring": "Returns a valid pytz TimeZone (Iana/Olson Timezones) from a given"}
{"repo": "python-o365-master/O365/utils/decorators.py", "original_string": "def deprecated(version, *replacement):\n    \"\"\" Decorator to mark a specified function as deprecated\n    :param version: version in which it is deprecated\n    :param replacement: replacement functions to use\n    \"\"\"\n    def deprecated_wrapper(func):\n        replacement_message = 'Use {} instead'.format(', '.join(\n            [\"'{}'\".format(_get_func_fq_name(x))\n             for x in replacement]))\n        log_message = (\"'{}' is deprecated, {}\"\n                       \"\".format(_get_func_fq_name(func), replacement_message))\n        # func.__doc__ = replacement[0].__doc__\n        func_path = _get_func_path(func)\n        doc_replacement = []\n        for x in replacement:\n            if func_path == _get_func_path(x):\n                doc_replacement.append(':func:`{}`'.format(_func_name(x)))\n            else:\n                doc_replacement.append(\n                    ':func:`{}`'.format(_get_func_fq_name(x)))\n        func.__doc__ = \"\"\"\n            .. deprecated:: {}\n               Use {} instead\n               \n               {} \n            \"\"\".format(version,\n                       ', '.join(doc_replacement),\n                       func.__doc__ if func.__doc__ else '')\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            log.warning(log_message)\n            return func(*args, **kwargs)\n        return wrapper\n    return deprecated_wrapper\n", "docstring": "Decorator to mark a specified function as deprecated"}
{"repo": "python-o365-master/O365/utils/attachment.py", "original_string": "    def __init__(self, attachment_name_property=None, attachment_type=None):\n        \"\"\" Defines the functionality for an object to be attachable.\n        Any object that inherits from this class will be attachable\n        (if the underlying api allows that)\n        \"\"\"\n        self.__attachment_name = None\n        self.__attachment_name_property = attachment_name_property\n        self.__attachment_type = self._gk(attachment_type)\n", "docstring": "Defines the functionality for an object to be attachable."}
{"repo": "python-o365-master/O365/utils/attachment.py", "original_string": "    def attachment_name(self):\n        \"\"\" Name of the attachment\n        :getter: get attachment name\n        :setter: set new name for the attachment\n        :type: str\n        \"\"\"\n        if self.__attachment_name is not None:\n            return self.__attachment_name\n        if self.__attachment_name_property:\n            return getattr(self, self.__attachment_name_property, '')\n        else:\n            # property order resolution:\n            # 1) try property 'subject'\n            # 2) try property 'name'\n            try:\n                attachment_name = getattr(self, 'subject')\n            except AttributeError:\n                attachment_name = getattr(self, 'name', '')\n            return attachment_name\n", "docstring": "Name of the attachment"}
{"repo": "python-o365-master/O365/utils/attachment.py", "original_string": "    def attachment_type(self):\n        \"\"\" Type of attachment\n        :rtype: str\n        \"\"\"\n        return self.__attachment_type\n", "docstring": "Type of attachment"}
{"repo": "python-o365-master/O365/utils/attachment.py", "original_string": "    def save(self, location=None, custom_name=None):\n        \"\"\"  Save the attachment locally to disk\n        :param str location: path string to where the file is to be saved.\n        :param str custom_name: a custom name to be saved as\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        if not self.content:\n            return False\n        location = Path(location or '')\n        if not location.exists():\n            log.debug('the location provided does not exist')\n            return False\n        name = custom_name or self.name\n        name = name.replace('/', '-').replace('\\\\', '')\n        try:\n            path = location / name\n            with path.open('wb') as file:\n                file.write(base64.b64decode(self.content))\n            self.attachment = path\n            self.on_disk = True\n            self.size = self.attachment.stat().st_size\n            log.debug('file saved locally.')\n        except Exception as e:\n            log.error('file failed to be saved: %s', str(e))\n            return False\n        return True\n", "docstring": "Save the attachment locally to disk"}
{"repo": "python-o365-master/O365/utils/attachment.py", "original_string": "    def __init__(self, parent, attachments=None):\n        \"\"\" Attachments must be a list of path strings or dictionary elements\n        :param Account parent: parent object\n        :param attachments: list of attachments\n        :type attachments: list[str] or list[Path] or str or Path or dict\n        \"\"\"\n        super().__init__(protocol=parent.protocol,\n                         main_resource=parent.main_resource)\n        self._parent = parent\n        self.__attachments = []\n        # holds on_cloud attachments removed from the parent object\n        self.__removed_attachments = []\n        self.untrack = True\n        if attachments:\n            self.add(attachments)\n        self.untrack = False\n", "docstring": "Attachments must be a list of path strings or dictionary elements"}
{"repo": "python-o365-master/O365/utils/attachment.py", "original_string": "    def to_api_data(self):\n        \"\"\" Returns a dict to communicate with the server\n        :rtype: dict\n        \"\"\"\n        return [attachment.to_api_data() for attachment in self.__attachments if\n                attachment.on_cloud is False]\n", "docstring": "Returns a dict to communicate with the server"}
{"repo": "python-o365-master/O365/utils/attachment.py", "original_string": "    def _track_changes(self):\n        \"\"\" Update the track_changes on the parent to reflect\n        a needed update on this field \"\"\"\n        if getattr(self._parent, '_track_changes',\n                   None) is not None and self.untrack is False:\n            # noinspection PyProtectedMember\n            self._parent._track_changes.add('attachments')\n", "docstring": "Update the track_changes on the parent to reflect"}
{"repo": "python-o365-master/O365/utils/attachment.py", "original_string": "    def add(self, attachments):\n        \"\"\" Add more attachments\n        :param attachments: list of attachments\n        :type attachments: list[str] or list[Path] or str or Path or dict\n        \"\"\"\n        if attachments:\n            if isinstance(attachments, (str, Path)):\n                attachments = [attachments]\n            if isinstance(attachments, (list, tuple, set)):\n                # User provided attachments\n                attachments_temp = [\n                    self._attachment_constructor(attachment, parent=self)\n                    for attachment in attachments]\n            elif isinstance(attachments,\n                            dict) and self._cloud_data_key in attachments:\n                # Cloud downloaded attachments. We pass on_cloud=True\n                # to track if this attachment is saved on the server\n                attachments_temp = [self._attachment_constructor(\n                    {self._cloud_data_key: attachment}, parent=self,\n                    on_cloud=True)\n                    for attachment in\n                    attachments.get(self._cloud_data_key, [])]\n            else:\n                raise ValueError('Attachments must be a str or Path or a '\n                                 'list, tuple or set of the former')\n            self.__attachments.extend(attachments_temp)\n            self._update_parent_attachments()\n            self._track_changes()\n", "docstring": "Add more attachments"}
{"repo": "python-o365-master/O365/utils/attachment.py", "original_string": "    def download_attachments(self):\n        \"\"\" Downloads this message attachments into memory.\n        Need a call to 'attachment.save' to save them on disk.\n        :return: Success / Failure\n        :rtype: bool\n        \"\"\"\n        if not self._parent.has_attachments:\n            log.debug(\n                'Parent {} has no attachments, skipping out early.'.format(\n                    self._parent.__class__.__name__))\n            return False\n        if not self._parent.object_id:\n            raise RuntimeError(\n                'Attempted to download attachments of an unsaved {}'.format(\n                    self._parent.__class__.__name__))\n        url = self.build_url(self._endpoints.get('attachments').format(\n            id=self._parent.object_id))\n        response = self._parent.con.get(url)\n        if not response:\n            return False\n        attachments = response.json().get('value', [])\n        # Everything received from cloud must be passed as self._cloud_data_key\n        self.untrack = True\n        self.add({self._cloud_data_key: attachments})\n        self.untrack = False\n        # TODO: when it's a item attachment the attachment itself\n        #  is not downloaded. We must download it...\n        # TODO: idea: retrieve the attachments ids' only with\n        #  select and then download one by one.\n        return True\n", "docstring": "Downloads this message attachments into memory."}
{"repo": "python-o365-master/docs/source/_themes/sphinx_rtd_theme/__init__.py", "original_string": "def get_html_theme_path():\n    \"\"\"Return list of HTML theme paths.\"\"\"\n    cur_dir = path.abspath(path.dirname(path.dirname(__file__)))\n    return cur_dir\n", "docstring": "Return list of HTML theme paths.\n"}
{"repo": "maltrail-master/sensor.py", "original_string": "    def update_timer():\n        retries = 0\n        if not config.offline:\n            while retries < CHECK_CONNECTION_MAX_RETRIES and not check_connection():\n                sys.stdout.write(\"[!] can't update because of lack of Internet connection (waiting...\" if not retries else '.')\n                sys.stdout.flush()\n                time.sleep(10)\n                retries += 1\n            if retries:\n                print(\")\")\n        if config.offline or retries == CHECK_CONNECTION_MAX_RETRIES:\n            if retries == CHECK_CONNECTION_MAX_RETRIES:\n                print(\"[x] going to continue without online update\")\n            _ = update_trails(offline=True)\n        else:\n            _ = update_trails()\n            update_ipcat()\n        if _:\n            trails.clear()\n            trails.update(_)\n        elif not trails:\n            _ = load_trails()\n            trails.update(_)\n        _regex = \"\"\n        for trail in trails:\n            if \"static\" in trails[trail][1]:\n                if re.search(r\"[\\].][*+]|\\[[a-z0-9_.\\-]+\\]\", trail, re.I):\n                    try:\n                        re.compile(trail)\n                    except re.error:\n                        pass\n                    else:\n                        if re.escape(trail) != trail:\n                            index = _regex.count(\"(?P<g\")\n                            if index < 100:  # Reference: https://stackoverflow.com/questions/478458/python-regular-expressions-with-more-than-100-groups\n                                _regex += \"|(?P<g%s>%s)\" % (index, trail)\n        trails._regex = _regex.strip('|')\n        thread = threading.Timer(config.UPDATE_PERIOD, update_timer)\n        thread.daemon = True\n        thread.start()\n", "docstring": "retries = 0"}
{"repo": "maltrail-master/sensor.py", "original_string": "    def packet_handler(datalink, header, packet):\n        global _count\n        ip_offset = None\n        try:\n            dlt_offset = DLT_OFFSETS[datalink]\n        except KeyError:\n            log_error(\"Received unexpected datalink (%d)\" % datalink, single=True)\n            return\n        try:\n            if datalink == pcapy.DLT_RAW:\n                ip_offset = dlt_offset\n            elif datalink == pcapy.DLT_PPP:\n                if packet[2:4] in (b\"\\x00\\x21\", b\"\\x00\\x57\"):  # (IPv4, IPv6)\n                    ip_offset = dlt_offset\n            elif datalink == pcapy.DLT_NULL:\n                if packet[0:4] in (b\"\\x02\\x00\\x00\\x00\", b\"\\x23\\x00\\x00\\x00\"):  # (IPv4, IPv6)\n                    ip_offset = dlt_offset\n            elif dlt_offset >= 2:\n                if packet[dlt_offset - 2:dlt_offset] == b\"\\x81\\x00\":  # VLAN\n                    dlt_offset += 4\n                if packet[dlt_offset - 2:dlt_offset] in (b\"\\x08\\x00\", b\"\\x86\\xdd\"):  # (IPv4, IPv6)\n                    ip_offset = dlt_offset\n        except IndexError:\n            pass\n        if ip_offset is None:\n            return\n        try:\n            if six.PY3:  # https://github.com/helpsystems/pcapy/issues/37#issuecomment-530795813\n                sec, usec = [int(_) for _ in (\"%.6f\" % time.time()).split('.')]\n            else:\n                sec, usec = header.getts()\n            if _multiprocessing:\n                block = struct.pack(\"=III\", sec, usec, ip_offset) + packet\n                if _locks.count:\n                    _locks.count.acquire()\n                write_block(_buffer, _count, block)\n                _n.value = _count = _count + 1\n                if _locks.count:\n                    _locks.count.release()\n            else:\n                _process_packet(packet, sec, usec, ip_offset)\n        except socket.timeout:\n            pass\n", "docstring": "global _count"}
{"repo": "maltrail-master/core/update.py", "original_string": "def main():\n    if \"-c\" in sys.argv:\n        read_config(sys.argv[sys.argv.index(\"-c\") + 1])\n    try:\n        offline = \"--offline\" in sys.argv\n        update_trails(force=True, offline=offline)\n        if not offline:\n            update_ipcat()\n    except KeyboardInterrupt:\n        print(\"\\r[x] Ctrl-C pressed\")\n    else:\n        if \"-r\" in sys.argv:\n            results = []\n            with _fopen(config.TRAILS_FILE, \"rb\" if six.PY2 else 'r', open if six.PY2 else codecs.open) as f:\n                for line in f:\n                    if line and line[0].isdigit():\n                        items = line.split(',', 2)\n                        if re.search(r\"\\A[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\Z\", items[0]):\n                            ip = items[0]\n                            reputation = 1\n                            lists = items[-1]\n                            if '+' in lists:\n                                reputation = 2 + lists.count(',')\n                            if \"(custom)\" in lists:\n                                reputation -= 1\n                            if \"(static)\" in lists:\n                                reputation -= 1\n                            reputation -= max(0, lists.count(\"prox\") + lists.count(\"maxmind\") + lists.count(\"spys.ru\") + lists.count(\"rosinstrument\") - 1)      # remove duplicate proxy hits\n                            reputation -= max(0, lists.count(\"blutmagie\") + lists.count(\"torproject\") - 1)                                                      # remove duplicate tor hits\n                            if reputation > 0:\n                                results.append((ip, reputation))\n            results = sorted(results, key=lambda _: _[1], reverse=True)\n            for result in results:\n                sys.stderr.write(\"%s\\t%s\\n\" % (result[0], result[1]))\n                sys.stderr.flush()\n        if \"--console\" in sys.argv:\n            with _fopen(config.TRAILS_FILE, \"rb\" if six.PY2 else 'r', open if six.PY2 else codecs.open) as f:\n                for line in f:\n                    sys.stdout.write(line)\n", "docstring": "if \"-c\" in sys.argv:"}
{"repo": "maltrail-master/core/common.py", "original_string": "def worst_asns(address):\n    if not address:\n        return None\n    try:\n        _ = addr_to_int(address)\n        for prefix, mask, name in WORST_ASNS.get(address.split('.')[0], {}):\n            if _ & mask == prefix:\n                return name\n    except (IndexError, ValueError):\n        pass\n    return None\n", "docstring": "if not address:"}
{"repo": "maltrail-master/thirdparty/six/__init__.py", "original_string": "def _add_doc(func, doc):\n    \"\"\"Add documentation to a function.\"\"\"\n    func.__doc__ = doc\n", "docstring": "Add documentation to a function.\n"}
{"repo": "maltrail-master/thirdparty/six/__init__.py", "original_string": "    def create_module(self, spec):\n        return self.load_module(spec.name)\n", "docstring": "return self.load_module(spec.name)"}
{"repo": "maltrail-master/thirdparty/six/__init__.py", "original_string": "def add_move(move):\n    \"\"\"Add an item to six.moves.\"\"\"\n    setattr(_MovedItems, move.name, move)\n", "docstring": "Add an item to six.moves.\n"}
{"repo": "maltrail-master/thirdparty/six/__init__.py", "original_string": "    def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n", "docstring": "Execute code in a namespace.\n"}
{"repo": "maltrail-master/thirdparty/six/__init__.py", "original_string": "    def print_(*args, **kwargs):\n        \"\"\"The new-style print function for Python 2.4 and 2.5.\"\"\"\n        fp = kwargs.pop(\"file\", sys.stdout)\n        if fp is None:\n            return\n        def write(data):\n            if not isinstance(data, basestring):\n                data = str(data)\n            # If the file has an encoding, encode unicode with it.\n            if (isinstance(fp, file) and\n                    isinstance(data, unicode) and\n                    fp.encoding is not None):\n                errors = getattr(fp, \"errors\", None)\n                if errors is None:\n                    errors = \"strict\"\n                data = data.encode(fp.encoding, errors)\n            fp.write(data)\n        want_unicode = False\n        sep = kwargs.pop(\"sep\", None)\n        if sep is not None:\n            if isinstance(sep, unicode):\n                want_unicode = True\n            elif not isinstance(sep, str):\n                raise TypeError(\"sep must be None or a string\")\n        end = kwargs.pop(\"end\", None)\n        if end is not None:\n            if isinstance(end, unicode):\n                want_unicode = True\n            elif not isinstance(end, str):\n                raise TypeError(\"end must be None or a string\")\n        if kwargs:\n            raise TypeError(\"invalid keyword arguments to print()\")\n        if not want_unicode:\n            for arg in args:\n                if isinstance(arg, unicode):\n                    want_unicode = True\n                    break\n        if want_unicode:\n            newline = unicode(\"\\n\")\n            space = unicode(\" \")\n        else:\n            newline = \"\\n\"\n            space = \" \"\n        if sep is None:\n            sep = space\n        if end is None:\n            end = newline\n        for i, arg in enumerate(args):\n            if i:\n                write(sep)\n            write(arg)\n        write(end)\n", "docstring": "The new-style print function for Python 2.4 and 2.5.\n"}
{"repo": "maltrail-master/thirdparty/six/__init__.py", "original_string": "def with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    # This requires a bit of explanation: the basic idea is to make a dummy\n    # metaclass for one level of class instantiation that replaces itself with\n    # the actual metaclass.\n    class metaclass(type):\n        def __new__(cls, name, this_bases, d):\n            if sys.version_info[:2] >= (3, 7):\n                # This version introduced PEP 560 that requires a bit\n                # of extra care (we mimic what is done by __build_class__).\n                resolved_bases = types.resolve_bases(bases)\n                if resolved_bases is not bases:\n                    d['__orig_bases__'] = bases\n            else:\n                resolved_bases = bases\n            return meta(name, resolved_bases, d)\n        @classmethod\n        def __prepare__(cls, name, this_bases):\n            return meta.__prepare__(name, bases)\n    return type.__new__(metaclass, 'temporary_class', (), {})\n", "docstring": "Create a base class with a metaclass.\n"}
{"repo": "maltrail-master/thirdparty/six/__init__.py", "original_string": "def ensure_binary(s, encoding='utf-8', errors='strict'):\n    \"\"\"Coerce **s** to six.binary_type.\n    For Python 2:\n      - `unicode` -> encoded to `str`\n      - `str` -> `str`\n    For Python 3:\n      - `str` -> encoded to `bytes`\n      - `bytes` -> `bytes`\n    \"\"\"\n    if isinstance(s, binary_type):\n        return s\n    if isinstance(s, text_type):\n        return s.encode(encoding, errors)\n    raise TypeError(\"not expecting type '%s'\" % type(s))\n", "docstring": "Coerce **s** to six.binary_type."}
{"repo": "maltrail-master/thirdparty/six/__init__.py", "original_string": "def ensure_text(s, encoding='utf-8', errors='strict'):\n    \"\"\"Coerce *s* to six.text_type.\n    For Python 2:\n      - `unicode` -> `unicode`\n      - `str` -> `unicode`\n    For Python 3:\n      - `str` -> `str`\n      - `bytes` -> decoded to `str`\n    \"\"\"\n    if isinstance(s, binary_type):\n        return s.decode(encoding, errors)\n    elif isinstance(s, text_type):\n        return s\n    else:\n        raise TypeError(\"not expecting type '%s'\" % type(s))\n", "docstring": "Coerce *s* to six.text_type."}
{"repo": "weibo_scrapy-master/weibo_login.py", "original_string": "def get_user(username):\n    username_ = urllib.quote(username)\n    username = base64.encodestring(username_)[:-1]\n    return username\n", "docstring": "username_ = urllib.quote(username)"}
{"repo": "weibo_scrapy-master/weibo_scrapy.py", "original_string": "    def __load_configuration__(self, config_file):\n        config = ConfigParser.RawConfigParser(allow_no_value=True)\n        config.read(config_file)\n        settings = {}\n        #get login account user info\n        settings['login_username'] = config.get('login_account_info', 'login_username')\n        settings['login_uid'] = config.get('login_account_info', 'login_uid')\n        settings['login_password'] = config.get('login_account_info', 'login_password')\n        settings['cookies_file'] = config.get('login_account_info', 'cookies_file')\n        \n        #get scrapy settings\n        settings['thread_number'] = config.getint('scrapy_settings', 'thread_number')\n        settings['start_uid'] = config.get('scrapy_settings', 'start_uid')\n        settings['uids_file'] = config.get('scrapy_settings', 'uids_file')\n        settings['wanted'] = config.getint('scrapy_settings', 'wanted')\n        \n        return settings\n", "docstring": "config = ConfigParser.RawConfigParser(allow_no_value=True)"}
{"repo": "weibo_scrapy-master/weibo_scrapy.py", "original_string": "    def __init__(self, task, wanted):\n        threading.Thread.__init__(self)\n        self.do_task = task\n        self.wanted = wanted\n        \n", "docstring": "threading.Thread.__init__(self)"}
{"repo": "tably-master/tably.py", "original_string": "    def create_table(self, file):\n        \"\"\"Creates a table from a given .csv file.\n        This method gives the procedure of converting a .csv file to a LaTeX table.\n        Unless -f is specified, the output is a ready-to-use LaTeX table environment.\n        All other methods that need to obtain a LaTeX table from a .csv file call this method.\n        \"\"\"\n        rows = []\n        indent = 4*' ' if not self.no_indent else ''\n        try:\n            with open(file) as infile:\n                for i, columns in enumerate(csv.reader(infile, delimiter=self.sep)):\n                    if i < self.skip:\n                        continue\n                    rows.append(self.create_row(columns, indent))\n        except FileNotFoundError:\n            print(\"File {} doesn't exist!!\\n\".format(file))\n            return ''\n        if not rows:\n            print(\"No table created from the {} file. Check if the file is empty \"\n                  \"or you used too high skip value.\\n\".format(file))\n            return ''\n        if not self.no_header:\n            rows.insert(1, r'{0}{0}\\midrule'.format(indent))\n            if self.units:\n                rows[0] = rows[0] + r'\\relax' # fixes problem with \\[\n                units = self.get_units()\n                rows.insert(1, r'{0}{0}{1} \\\\'.format(indent, units))\n        content = '\\n'.join(rows)\n        if not self.fragment:\n            header = HEADER.format(\n            label=add_label(self.label, indent),\n            caption=add_caption(self.caption, indent),\n            align=format_alignment(self.align, len(columns)),\n            indent=indent,\n            )\n            footer = FOOTER.format(indent=indent)\n            return '\\n'.join((header, content, footer))\n        else:\n            return content\n", "docstring": "Creates a table from a given .csv file."}
{"repo": "tably-master/tably.py", "original_string": "    def combine_tables(self):\n        \"\"\"Combine all tables together and add a preamble if required.\n        Unless -oo is specified, this is how input tables are arranged.\n        \"\"\"\n        all_tables = []\n        if self.label and len(self.files) > 1:\n            all_tables.append(\"% don't forget to manually re-label the tables\")\n        for file in self.files:\n            table = self.create_table(file)\n            if table:\n                all_tables.append(table)\n        if not all_tables:\n            return None\n        if self.preamble:\n            all_tables.insert(0, PREAMBLE)\n            all_tables.append('\\\\end{document}\\n')\n        return '\\n\\n'.join(all_tables)\n", "docstring": "Combine all tables together and add a preamble if required."}
{"repo": "tably-master/tably.py", "original_string": "    def get_units(self):\n        \"\"\"Writes the units as a row of the LaTeX table\"\"\"\n        formatted_units = []\n        for unit in self.tex_str(self.units):\n            if unit in '-/0':\n                formatted_units.append('')\n            else:\n                formatted_units.append('[{}]'.format(unit))\n        return ' & '.join(formatted_units)\n", "docstring": "Writes the units as a row of the LaTeX table\n"}
{"repo": "tably-master/tably.py", "original_string": "def escape(line):\n    \"\"\"Escapes special LaTeX characters by prefixing them with backslash\"\"\"\n    for char in '#$%&_}{':\n        line = [column.replace(char, '\\\\'+char) for column in line]\n    return line\n", "docstring": "Escapes special LaTeX characters by prefixing them with backslash\n"}
{"repo": "tably-master/tably.py", "original_string": "def add_label(label, indent):\n    \"\"\"Creates a table label\"\"\"\n    return LABEL.format(label=label, indent=indent) if label else ''\n", "docstring": "Creates a table label\n"}
{"repo": "tably-master/tably.py", "original_string": "def save_content(content, outfile, replace):\n    \"\"\"Saves the content to a file.\n    If an existing file is provided, the content is appended to the end\n    of the file by default. If -r is passed, the file is overwritten.\n    \"\"\"\n    if replace:\n        with open(outfile, 'w') as out:\n            out.writelines(content)\n        print('The content is written to', outfile)\n    else:\n        with open(outfile, 'a') as out:\n            out.writelines(content)\n        print('The content is appended to', outfile)\n", "docstring": "Saves the content to a file."}
{"repo": "tably-master/tably.py", "original_string": "def main():\n    options = arg_parser()\n    tably = Tably(options)\n    tably.run()\n", "docstring": "options = arg_parser()"}
{"repo": "PyTorch-NLP-master/examples/awd-lstm-lm/splitcross.py", "original_string": "    def __init__(self, hidden_size, splits, verbose=False):\n        # We assume splits is [0, split1, split2, N] where N >= |V|\n        # For example, a vocab of 1000 words may have splits [0] + [100, 500] + [inf]\n        super(SplitCrossEntropyLoss, self).__init__()\n        self.hidden_size = hidden_size\n        self.splits = [0] + splits + [100 * 1000000]\n        self.nsplits = len(self.splits) - 1\n        self.stats = defaultdict(list)\n        self.verbose = verbose\n        # Each of the splits that aren't in the head require a pretend token, we'll call them tombstones\n        # The probability given to this tombstone is the probability of selecting an item from the represented split\n        if self.nsplits > 1:\n            self.tail_vectors = nn.Parameter(torch.zeros(self.nsplits - 1, hidden_size))\n            self.tail_bias = nn.Parameter(torch.zeros(self.nsplits - 1))\n", "docstring": "We assume splits is [0, split1, split2, N] where N >= |V|"}
{"repo": "PyTorch-NLP-master/examples/awd-lstm-lm/splitcross.py", "original_string": "    def split_on_targets(self, hiddens, targets):\n        # Split the targets into those in the head and in the tail\n        split_targets = []\n        split_hiddens = []\n        # Determine to which split each element belongs (for each start split value, add 1 if equal or greater)\n        # This method appears slower at least for WT-103 values for approx softmax\n        #masks = [(targets >= self.splits[idx]).view(1, -1) for idx in range(1, self.nsplits)]\n        #mask = torch.sum(torch.cat(masks, dim=0), dim=0)\n        ###\n        # This is equally fast for smaller splits as method below but scales linearly\n        mask = None\n        for idx in range(1, self.nsplits):\n            partial_mask = targets >= self.splits[idx]\n            mask = mask + partial_mask if mask is not None else partial_mask\n        ###\n        #masks = torch.stack([targets] * (self.nsplits - 1))\n        #mask = torch.sum(masks >= self.split_starts, dim=0)\n        for idx in range(self.nsplits):\n            # If there are no splits, avoid costly masked select\n            if self.nsplits == 1:\n                split_targets, split_hiddens = [targets], [hiddens]\n                continue\n            # If all the words are covered by earlier targets, we have empties so later stages don't freak out\n            if sum(len(t) for t in split_targets) == len(targets):\n                split_targets.append([])\n                split_hiddens.append([])\n                continue\n            # Are you in our split?\n            tmp_mask = mask == idx\n            split_targets.append(torch.masked_select(targets, tmp_mask))\n            split_hiddens.append(hiddens.masked_select(tmp_mask.unsqueeze(1).expand_as(hiddens)).view(-1, hiddens.size(1)))\n        return split_targets, split_hiddens\n", "docstring": "Split the targets into those in the head and in the tail"}
{"repo": "PyTorch-NLP-master/examples/awd-lstm-lm/main.py", "original_string": "def evaluate(data_source, source_sampler, target_sampler, batch_size=10):\n    # Turn on evaluation mode which disables dropout.\n    model.eval()\n    if args.model == 'QRNN':\n        model.reset()\n    total_loss = 0\n    hidden = model.init_hidden(batch_size)\n    for source_sample, target_sample in zip(source_sampler, target_sampler):\n        model.train()\n        data = torch.stack([data_source[i] for i in source_sample])\n        targets = torch.stack([data_source[i] for i in target_sample]).view(-1)\n        with torch.no_grad():\n            output, hidden = model(data, hidden)\n        total_loss += len(data) * criterion(model.decoder.weight, model.decoder.bias, output,\n                                            targets).item()\n        hidden = repackage_hidden(hidden)\n    return total_loss / len(data_source)\n", "docstring": "Turn on evaluation mode which disables dropout."}
{"repo": "PyTorch-NLP-master/examples/snli/util.py", "original_string": "def makedirs(name):\n    \"\"\"helper function for python 2 and 3 to call os.makedirs()\n       avoiding an error if the directory to be created already exists\"\"\"\n    import os, errno\n    try:\n        os.makedirs(name)\n    except OSError as ex:\n        if ex.errno == errno.EEXIST and os.path.isdir(name):\n            # ignore existing directory\n            pass\n        else:\n            # a different error happened\n            raise\n", "docstring": "helper function for python 2 and 3 to call os.makedirs()"}
{"repo": "PyTorch-NLP-master/torchnlp/download.py", "original_string": "def _reporthook(t):\n    \"\"\" ``reporthook`` to use with ``urllib.request`` that prints the process of the download.\n    Uses ``tqdm`` for progress bar.\n    **Reference:**\n    https://github.com/tqdm/tqdm\n    Args:\n        t (tqdm.tqdm) Progress bar.\n    Example:\n        >>> with tqdm(unit='B', unit_scale=True, miniters=1, desc=filename) as t:  # doctest: +SKIP\n        ...   urllib.request.urlretrieve(file_url, filename=full_path, reporthook=reporthook(t))\n    \"\"\"\n    last_b = [0]\n    def inner(b=1, bsize=1, tsize=None):\n        \"\"\"\n        Args:\n            b (int, optional): Number of blocks just transferred [default: 1].\n            bsize (int, optional): Size of each block (in tqdm units) [default: 1].\n            tsize (int, optional): Total size (in tqdm units). If [default: None] remains unchanged.\n        \"\"\"\n        if tsize is not None:\n            t.total = tsize\n        t.update((b - last_b[0]) * bsize)\n        last_b[0] = b\n    return inner\n", "docstring": "``reporthook`` to use with ``urllib.request`` that prints the process of the download."}
{"repo": "PyTorch-NLP-master/torchnlp/download.py", "original_string": "def _maybe_extract(compressed_filename, directory, extension=None):\n    \"\"\" Extract a compressed file to ``directory``.\n    Args:\n        compressed_filename (str): Compressed file.\n        directory (str): Extract to directory.\n        extension (str, optional): Extension of the file; Otherwise, attempts to extract extension\n            from the filename.\n    \"\"\"\n    logger.info('Extracting {}'.format(compressed_filename))\n    if extension is None:\n        basename = os.path.basename(compressed_filename)\n        extension = basename.split('.', 1)[1]\n    if 'zip' in extension:\n        with zipfile.ZipFile(compressed_filename, \"r\") as zip_:\n            zip_.extractall(directory)\n    elif 'tar.gz' in extension or 'tgz' in extension:\n        # `tar` is much faster than python's `tarfile` implementation\n        subprocess.call(['tar', '-C', directory, '-zxvf', compressed_filename])\n    elif 'tar' in extension:\n        subprocess.call(['tar', '-C', directory, '-xvf', compressed_filename])\n    logger.info('Extracted {}'.format(compressed_filename))\n", "docstring": "Extract a compressed file to ``directory``."}
{"repo": "PyTorch-NLP-master/torchnlp/download.py", "original_string": "def download_file_maybe_extract(url, directory, filename=None, extension=None, check_files=[]):\n    \"\"\" Download the file at ``url`` to ``directory``. Extract to ``directory`` if tar or zip.\n    Args:\n        url (str or Path): Url of file.\n        directory (str): Directory to download to.\n        filename (str, optional): Name of the file to download; Otherwise, a filename is extracted\n            from the url.\n        extension (str, optional): Extension of the file; Otherwise, attempts to extract extension\n            from the filename.\n        check_files (list of str or Path): Check if these files exist, ensuring the download\n            succeeded. If these files exist before the download, the download is skipped.\n    Returns:\n        (str): Filename of download file.\n    Raises:\n        ValueError: Error if one of the ``check_files`` are not found following the download.\n    \"\"\"\n    if filename is None:\n        filename = _get_filename_from_url(url)\n    directory = str(directory)\n    filepath = os.path.join(directory, filename)\n    check_files = [os.path.join(directory, str(f)) for f in check_files]\n    if len(check_files) > 0 and _check_download(*check_files):\n        return filepath\n    if not os.path.isdir(directory):\n        os.makedirs(directory)\n    logger.info('Downloading {}'.format(filename))\n    # Download\n    if 'drive.google.com' in url:\n        _download_file_from_drive(filepath, url)\n    else:\n        with tqdm(unit='B', unit_scale=True, miniters=1, desc=filename) as t:\n            urllib.request.urlretrieve(url, filename=filepath, reporthook=_reporthook(t))\n    _maybe_extract(compressed_filename=filepath, directory=directory, extension=extension)\n    if not _check_download(*check_files):\n        raise ValueError('[DOWNLOAD FAILED] `*check_files` not found')\n    return filepath\n", "docstring": "Download the file at ``url`` to ``directory``. Extract to ``directory`` if tar or zip."}
{"repo": "PyTorch-NLP-master/torchnlp/random.py", "original_string": "def get_random_generator_state(cuda: bool = torch.cuda.is_available()) -> RandomGeneratorState:\n    \"\"\" Get the `torch`, `numpy` and `random` random generator state.\n    Args:\n        cuda (bool, optional): If `True` saves the `cuda` seed also. Note that getting and setting\n            the random generator state for CUDA can be quite slow if you have a lot of GPUs.\n    Returns:\n        RandomGeneratorState\n    \"\"\"\n    return RandomGeneratorState(random.getstate(), torch.random.get_rng_state(),\n                                np.random.get_state(),\n                                torch.cuda.get_rng_state_all() if cuda else None)\n", "docstring": "Get the `torch`, `numpy` and `random` random generator state."}
{"repo": "PyTorch-NLP-master/torchnlp/random.py", "original_string": "def fork_rng(seed=None, cuda=torch.cuda.is_available()):\n    \"\"\" Forks the `torch`, `numpy` and `random` random generators, so that when you return, the\n    random generators are reset to the state that they were previously in.\n    Args:\n        seed (int or None, optional): If defined this sets the seed values for the random\n            generator fork. This is a convenience parameter.\n        cuda (bool, optional): If `True` saves the `cuda` seed also. Getting and setting the random\n            generator state can be quite slow if you have a lot of GPUs.\n    \"\"\"\n    state = get_random_generator_state(cuda)\n    if seed is not None:\n        set_seed(seed, cuda)\n    try:\n        yield\n    finally:\n        set_random_generator_state(state)\n", "docstring": "Forks the `torch`, `numpy` and `random` random generators, so that when you return, the"}
{"repo": "PyTorch-NLP-master/torchnlp/_third_party/weighted_random_sampler.py", "original_string": "    def __init__(self, weights, num_samples=None, replacement=True):\n        # NOTE: Adapted `WeightedRandomSampler` to accept `num_samples=0` and `num_samples=None`.\n        if num_samples is None:\n            num_samples = len(weights)\n        if not isinstance(num_samples, int) or isinstance(num_samples, bool) or \\\n                num_samples < 0:\n            raise ValueError(\"num_samples should be a positive integer \"\n                             \"value, but got num_samples={}\".format(num_samples))\n        if not isinstance(replacement, bool):\n            raise ValueError(\"replacement should be a boolean value, but got \"\n                             \"replacement={}\".format(replacement))\n        self.weights = torch.as_tensor(weights, dtype=torch.double)\n        self.num_samples = num_samples\n        self.replacement = replacement\n", "docstring": "NOTE: Adapted `WeightedRandomSampler` to accept `num_samples=0` and `num_samples=None`."}
{"repo": "PyTorch-NLP-master/torchnlp/word_to_vector/pretrained_word_vectors.py", "original_string": "    def _get_token_vector(self, token):\n        \"\"\"Return embedding for token or for UNK if token not in vocabulary\"\"\"\n        if token in self.token_to_index:\n            return self.vectors[self.token_to_index[token]]\n        else:\n            return self.unk_init(torch.Tensor(self.dim))\n", "docstring": "Return embedding for token or for UNK if token not in vocabulary\n"}
{"repo": "PyTorch-NLP-master/torchnlp/samplers/oom_batch_sampler.py", "original_string": "def get_number_of_elements(object_):\n    \"\"\" Get the sum of the number of elements in all tensors stored in `object_`.\n    This is particularly useful for sampling the largest objects based on tensor size like in:\n    `OomBatchSampler.__init__.get_item_size`.\n    Args:\n        object (any)\n    Returns:\n        (int): The number of elements in the `object_`.\n    \"\"\"\n    return sum([t.numel() for t in get_tensors(object_)])\n", "docstring": "Get the sum of the number of elements in all tensors stored in `object_`."}
{"repo": "PyTorch-NLP-master/torchnlp/metrics/accuracy.py", "original_string": "def get_accuracy(targets, outputs, k=1, ignore_index=None):\n    \"\"\" Get the accuracy top-k accuracy between two tensors.\n    Args:\n      targets (1 - 2D :class:`torch.Tensor`): Target or true vector against which to measure\n          saccuracy\n      outputs (1 - 3D :class:`torch.Tensor`): Prediction or output vector\n      ignore_index (int, optional): Specifies a target index that is ignored\n    Returns:\n      :class:`tuple` consisting of accuracy (:class:`float`), number correct (:class:`int`) and\n      total (:class:`int`)\n    Example:\n        >>> import torch\n        >>> from torchnlp.metrics import get_accuracy\n        >>> targets = torch.LongTensor([1, 2, 3, 4, 5])\n        >>> outputs = torch.LongTensor([1, 2, 2, 3, 5])\n        >>> accuracy, n_correct, n_total = get_accuracy(targets, outputs, ignore_index=3)\n        >>> accuracy\n        0.8\n        >>> n_correct\n        4\n        >>> n_total\n        5\n    \"\"\"\n    n_correct = 0.0\n    for target, output in zip(targets, outputs):\n        if not torch.is_tensor(target) or is_scalar(target):\n            target = torch.LongTensor([target])\n        if not torch.is_tensor(output) or is_scalar(output):\n            output = torch.LongTensor([[output]])\n        predictions = output.topk(k=min(k, len(output)), dim=0)[0]\n        for prediction in predictions:\n            if torch_equals_ignore_index(\n                    target.squeeze(), prediction.squeeze(), ignore_index=ignore_index):\n                n_correct += 1\n                break\n    return n_correct / len(targets), int(n_correct), len(targets)\n", "docstring": "Get the accuracy top-k accuracy between two tensors."}
{"repo": "PyTorch-NLP-master/torchnlp/encoders/text/text_encoder.py", "original_string": "def pad_tensor(tensor, length, padding_index=DEFAULT_PADDING_INDEX):\n    \"\"\" Pad a ``tensor`` to ``length`` with ``padding_index``.\n    Args:\n        tensor (torch.Tensor [n, ...]): Tensor to pad.\n        length (int): Pad the ``tensor`` up to ``length``.\n        padding_index (int, optional): Index to pad tensor with.\n    Returns\n        (torch.Tensor [length, ...]) Padded Tensor.\n    \"\"\"\n    n_padding = length - tensor.shape[0]\n    assert n_padding >= 0\n    if n_padding == 0:\n        return tensor\n    padding = tensor.new(n_padding, *tensor.shape[1:]).fill_(padding_index)\n    return torch.cat((tensor, padding), dim=0)\n", "docstring": "Pad a ``tensor`` to ``length`` with ``padding_index``."}
{"repo": "PyTorch-NLP-master/torchnlp/encoders/text/text_encoder.py", "original_string": "def stack_and_pad_tensors(batch, padding_index=DEFAULT_PADDING_INDEX, dim=0):\n    \"\"\" Pad a :class:`list` of ``tensors`` (``batch``) with ``padding_index``.\n    Args:\n        batch (:class:`list` of :class:`torch.Tensor`): Batch of tensors to pad.\n        padding_index (int, optional): Index to pad tensors with.\n        dim (int, optional): Dimension on to which to concatenate the batch of tensors.\n    Returns\n        SequenceBatch: Padded tensors and original lengths of tensors.\n    \"\"\"\n    lengths = [tensor.shape[0] for tensor in batch]\n    max_len = max(lengths)\n    padded = [pad_tensor(tensor, max_len, padding_index) for tensor in batch]\n    lengths = torch.tensor(lengths, dtype=torch.long)\n    padded = torch.stack(padded, dim=dim).contiguous()\n    for _ in range(dim):\n        lengths = lengths.unsqueeze(0)\n    return SequenceBatch(padded, lengths)\n", "docstring": "Pad a :class:`list` of ``tensors`` (``batch``) with ``padding_index``."}
{"repo": "PyTorch-NLP-master/torchnlp/encoders/text/text_encoder.py", "original_string": "    def decode(self, encoded):\n        \"\"\" Decodes an object.\n        Args:\n            object_ (object): Encoded object.\n        Returns:\n            object: Object decoded.\n        \"\"\"\n        if self.enforce_reversible:\n            self.enforce_reversible = False\n            decoded_encoded = self.encode(self.decode(encoded))\n            self.enforce_reversible = True\n            if not torch.equal(decoded_encoded, encoded):\n                raise ValueError('Decoding is not reversible for \"%s\"' % encoded)\n        return encoded\n", "docstring": "Decodes an object."}
{"repo": "PyTorch-NLP-master/torchnlp/encoders/text/subword_text_tokenizer.py", "original_string": "def get_alphanumeric_char_set():\n    \"\"\" This set contains all letter and number characters. \"\"\"\n    return set(\n        six.unichr(i)\n        for i in six.moves.xrange(sys.maxunicode)\n        if (unicodedata.category(six.unichr(i)).startswith(\"L\") or\n            unicodedata.category(six.unichr(i)).startswith(\"N\")))\n", "docstring": "This set contains all letter and number characters. \n"}
{"repo": "PyTorch-NLP-master/torchnlp/encoders/text/subword_text_tokenizer.py", "original_string": "    def match(m):\n        if m.group(1) is None:\n            return u\"_\" if m.group(0) == u\"\\\\u\" else u\"\\\\\"\n        try:\n            return six.unichr(int(m.group(1)))\n        except (ValueError, OverflowError):\n            return \"\"\n", "docstring": "if m.group(1) is None:"}
{"repo": "PyTorch-NLP-master/torchnlp/encoders/text/subword_text_tokenizer.py", "original_string": "    def __init__(self):\n        \"\"\"Initialize and read from a file, if provided.\"\"\"\n        self._alphabet = set()\n", "docstring": "Initialize and read from a file, if provided.\n"}
{"repo": "PyTorch-NLP-master/torchnlp/encoders/text/subword_text_tokenizer.py", "original_string": "    def decode(self, subtokens):\n        \"\"\"Converts a sequence of subtoken to a native string.\n        Args:\n          subtokens: a list of integers in the range [0, vocab_size)\n        Returns:\n          a native string\n        \"\"\"\n        return unicode_to_native(decode(self._subtoken_to_tokens(subtokens)))\n", "docstring": "Converts a sequence of subtoken to a native string."}
{"repo": "PyTorch-NLP-master/torchnlp/encoders/text/subword_text_tokenizer.py", "original_string": "    def _subtoken_to_tokens(self, subtokens):\n        \"\"\" Converts a list of subtoken to a list of tokens.\n        Args:\n          subtokens: a list of integers in the range [0, vocab_size)\n        Returns:\n          a list of strings.\n        \"\"\"\n        concatenated = \"\".join(subtokens)\n        split = concatenated.split(\"_\")\n        return [_unescape_token(t + \"_\") for t in split if t]\n", "docstring": "Converts a list of subtoken to a list of tokens."}
{"repo": "PyTorch-NLP-master/torchnlp/nn/weight_drop.py", "original_string": "    def __init__(self, module, weights, dropout=0.0):\n        super(WeightDrop, self).__init__()\n        _weight_drop(module, weights, dropout)\n        self.forward = module.forward\n", "docstring": "super(WeightDrop, self).__init__()"}
{"repo": "PyTorch-NLP-master/docs/conf.py", "original_string": "def patched_make_field(self, types, domain, items, **kw):\n    # `kw` catches `env=None` needed for newer sphinx while maintaining\n    #  backwards compatibility when passed along further down!\n    # type: (List, unicode, Tuple) -> nodes.field\n    def handle_item(fieldarg, content):\n        par = nodes.paragraph()\n        par += addnodes.literal_strong('', fieldarg)  # Patch: this line added\n        # par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n        #                           addnodes.literal_strong))\n        if fieldarg in types:\n            par += nodes.Text(' (')\n            # NOTE: using .pop() here to prevent a single type node to be\n            # inserted twice into the doctree, which leads to\n            # inconsistencies later when references are resolved\n            fieldtype = types.pop(fieldarg)\n            if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                typename = u''.join(n.astext() for n in fieldtype)\n                typename = typename.replace('int', 'python:int')\n                typename = typename.replace('long', 'python:long')\n                typename = typename.replace('float', 'python:float')\n                typename = typename.replace('type', 'python:type')\n                par.extend(\n                    self.make_xrefs(self.typerolename, domain, typename, addnodes.literal_emphasis,\n                                    **kw))\n            else:\n                par += fieldtype\n            par += nodes.Text(')')\n        par += nodes.Text(' -- ')\n        par += content\n        return par\n    fieldname = nodes.field_name('', self.label)\n    if len(items) == 1 and self.can_collapse:\n        fieldarg, content = items[0]\n        bodynode = handle_item(fieldarg, content)\n    else:\n        bodynode = self.list_type()\n        for fieldarg, content in items:\n            bodynode += nodes.list_item('', handle_item(fieldarg, content))\n    fieldbody = nodes.field_body('', bodynode)\n    return nodes.field('', fieldname, fieldbody)\n", "docstring": "`kw` catches `env=None` needed for newer sphinx while maintaining"}
{"repo": "PyTorch-NLP-master/tests/test_random.py", "original_string": "def test_random_generator_state():\n    # TODO: Test `torch.cuda` random as well.\n    state = get_random_generator_state()\n    randint = random.randint(1, 2**31)\n    numpy_randint = numpy.random.randint(1, 2**31)\n    torch_randint = int(torch.randint(1, 2**31, (1,)))\n    set_random_generator_state(state)\n    post_randint = random.randint(1, 2**31)\n    post_numpy_randint = numpy.random.randint(1, 2**31)\n    post_torch_randint = int(torch.randint(1, 2**31, (1,)))\n    assert randint == post_randint\n    assert numpy_randint == post_numpy_randint\n    assert torch_randint == post_torch_randint\n", "docstring": "TODO: Test `torch.cuda` random as well."}
{"repo": "PyTorch-NLP-master/tests/datasets/utils.py", "original_string": "def urlretrieve_side_effect(url, **kwargs):\n    # TODO: Fix failure case if internet does not work\n    assert urllib.request.urlopen(url).getcode() == 200\n", "docstring": "TODO: Fix failure case if internet does not work"}
{"repo": "PyTorch-NLP-master/tests/samplers/test_deterministic_sampler.py", "original_string": "def test_deterministic_sampler__side_effects():\n    \"\"\" Ensure that the sampler does not affect random generation after it's finished. \"\"\"\n    set_seed(123)\n    pre_randint = [random.randint(1, 2**31), random.randint(1, 2**31)]\n    sampler = DeterministicSampler(list(range(10)), random_seed=123)\n    list(iter(sampler))\n    post_randint = [random.randint(1, 2**31), random.randint(1, 2**31)]\n    set_seed(123)\n    assert pre_randint == [random.randint(1, 2**31), random.randint(1, 2**31)]\n    assert post_randint == [random.randint(1, 2**31), random.randint(1, 2**31)]\n", "docstring": "Ensure that the sampler does not affect random generation after it's finished. \n"}
{"repo": "PyTorch-NLP-master/tests/encoders/text/test_moses_encoder.py", "original_string": "def test_moses_encoder(encoder, input_):\n    # TEST adapted from example in http://www.nltk.org/_modules/nltk/tokenize/moses.html\n    expected_tokens = [\n        'This', 'ain', '&apos;t', 'funny', '.', 'It', '&apos;s', 'actually', 'hillarious', ',',\n        'yet', 'double', 'Ls', '.', '&#124;', '&#91;', '&#93;', '&lt;', '&gt;', '&#91;', '&#93;',\n        '&amp;', 'You', '&apos;re', 'gonna', 'shake', 'it', 'off', '?', 'Don', '&apos;t', '?'\n    ]\n    expected_decode = (\"This ain't funny. It's actually hillarious, yet double Ls. | [] < > [] & \" +\n                       \"You're gonna shake it off? Don't?\")\n    tokens = encoder.encode(input_)\n    assert [encoder.index_to_token[i] for i in tokens] == expected_tokens\n    assert encoder.decode(tokens) == expected_decode\n", "docstring": "TEST adapted from example in http://www.nltk.org/_modules/nltk/tokenize/moses.html"}
{"repo": "PyTorch-NLP-master/tests/encoders/text/test_spacy_encoder.py", "original_string": "def test_spacy_encoder_issue_44():\n    # https://github.com/PetrochukM/PyTorch-NLP/issues/44\n    encoder = SpacyEncoder([\"This ain't funny.\"])\n    assert 'ai' in encoder.vocab\n    assert 'n\\'t' in encoder.vocab\n", "docstring": "https://github.com/PetrochukM/PyTorch-NLP/issues/44"}
{"repo": "PyTorch-NLP-master/tests/nn/test_weight_drop.py", "original_string": "def test_weight_drop_linear():\n    # Input is (seq, batch, input)\n    x = torch.randn(2, 1, 10)\n    lin = WeightDropLinear(10, 10, weight_dropout=0.9)\n    run1 = [x.sum() for x in lin(x).data]\n    run2 = [x.sum() for x in lin(x).data]\n    assert run1[0] != run2[0]\n    assert run1[1] != run2[1]\n", "docstring": "Input is (seq, batch, input)"}
{"repo": "PyTorch-NLP-master/tests/nn/test_attention.py", "original_string": "    def setUpClass(self):\n        # Some random small constants to set up the hidden state sizes\n        self.batch_size = random.randint(1, 10)\n        self.dimensions = random.randint(1, 10)\n        self.output_seq_len = random.randint(1, 10)\n        self.input_seq_len = random.randint(1, 10)\n        # Constant randomly generated tensors\n        self.input_ = torch.FloatTensor(self.batch_size, self.output_seq_len,\n                                        self.dimensions).random_()\n        self.context = torch.FloatTensor(self.batch_size, self.input_seq_len,\n                                         self.dimensions).random_()\n", "docstring": "Some random small constants to set up the hidden state sizes"}
{"repo": "menpo-master/setup.py", "original_string": "def get_version_and_cmdclass(package_path):\n    \"\"\"Load version.py module without importing the whole package.\n    Template code from miniver\n    \"\"\"\n    import os\n    from importlib.util import module_from_spec, spec_from_file_location\n    spec = spec_from_file_location(\"version\", os.path.join(package_path, \"_version.py\"))\n    module = module_from_spec(spec)\n    spec.loader.exec_module(module)\n    return module.__version__, module.cmdclass\n", "docstring": "Load version.py module without importing the whole package."}
{"repo": "menpo-master/menpo/_version.py", "original_string": "def _write_version(fname):\n    # This could be a hard link, so try to delete it first.  Is there any way\n    # to do this atomically together with opening?\n    try:\n        os.remove(fname)\n    except OSError:\n        pass\n    with open(fname, \"w\") as f:\n        f.write(\n            \"# This file has been created by setup.py.\\n\"\n            \"version = '{}'\\n\".format(__version__)\n        )\n", "docstring": "This could be a hard link, so try to delete it first.  Is there any way"}
{"repo": "menpo-master/menpo/base.py", "original_string": "    def __repr__(self):\n        # Most classes in Menpo derive from Copyable, so it's a handy place\n        # to implement Menpo-wide behavior. For use in the notebook, we find\n        # __repr__ representations not of very much use, so we default to\n        # showing the string representation for this case. See\n        # https://github.com/menpo/menpo/issues/752 for discussion.\n        return self.__str__()\n", "docstring": "Most classes in Menpo derive from Copyable, so it's a handy place"}
{"repo": "menpo-master/menpo/base.py", "original_string": "    def n_dims(self):\n        r\"\"\"The number of dimensions of the :attr:`target`.\n        :type: `int`\n        \"\"\"\n        return self.target.n_dims\n", "docstring": "r\"\"\"The number of dimensions of the :attr:`target`."}
{"repo": "menpo-master/menpo/base.py", "original_string": "        def foo():\n            # Do something, but inherit the documentation from the method\n            # called 'foo' found on the super() chain.\n", "docstring": "Do something, but inherit the documentation from the method"}
{"repo": "menpo-master/menpo/base.py", "original_string": "        def foo():\n            # Do something, but inherit the documentation from the method\n            # called 'foo2' found on the super() chain.\n", "docstring": "Do something, but inherit the documentation from the method"}
{"repo": "menpo-master/menpo/base.py", "original_string": "    def __get__(self, obj, cls):\n        # Implement the descriptor protocol. There are two different calling\n        # strategies that involve whether the wrapped method has been passed\n        # an instance or not.\n        if obj:\n            return self._get_with_instance(obj, cls)\n        else:\n            return self._get_with_no_instance(cls)\n", "docstring": "Implement the descriptor protocol. There are two different calling"}
{"repo": "menpo-master/menpo/base.py", "original_string": "    def _get_with_no_instance(self, cls):\n        # This case is more complicated (than when an instance is passed). Here\n        # we use reflection to try and lookup the method. When found, we drop\n        # out the loop.\n        for parent in cls.__mro__[1:]:\n            overridden = getattr(parent, self.name, None)\n            if overridden:\n                break\n        # Return the wrapped method, passing through the arguments and the\n        # object instance.\n        @wraps(self.mthd, assigned=(\"__name__\", \"__module__\"))\n        def f(*args, **kwargs):\n            return self.mthd(*args, **kwargs)\n        return self._use_parent_doc(f, overridden)\n", "docstring": "This case is more complicated (than when an instance is passed). Here"}
{"repo": "menpo-master/menpo/testing.py", "original_string": "    def function():\n        from sys.my import cool\n        from sys.my.cool import module1\n        from sys.my.cool import module2\n", "docstring": "from sys.my import cool"}
{"repo": "menpo-master/menpo/testing.py", "original_string": "    def nothing_to_stub(self):\n        \"\"\"Check if there are no modules to stub\"\"\"\n        return len(self.elements) == 0\n", "docstring": "Check if there are no modules to stub\n"}
{"repo": "menpo-master/menpo/testing.py", "original_string": "    def restore(self):\n        \"\"\"Post-actions to restore initial state of the system\"\"\"\n        self._remove_module_stubs()\n        self._restore_base_module()\n", "docstring": "Post-actions to restore initial state of the system\n"}
{"repo": "menpo-master/menpo/testing.py", "original_string": "    def _create_module_stubs(self):\n        \"\"\"Create stubs for all not-existing modules\"\"\"\n        # last module in our sequence\n        # it should be loaded\n        last_module = type(\n            self.elements[-1],\n            (object,),\n            {\"__all__\": [], \"_importing_path\": self._get_importing_path(self.elements)},\n        )\n        modules = [last_module]\n        # now we create a module stub for each\n        # element in a path.\n        # each module stub contains `__all__`\n        # list and a member that\n        # points to the next module stub in\n        # sequence\n        for element in reversed(self.elements[:-1]):\n            next_module = modules[-1]\n            module = type(\n                element,\n                (object,),\n                {next_module.__name__: next_module, \"__all__\": [next_module.__name__]},\n            )\n            modules.append(module)\n        self.modules = list(reversed(modules))\n        self.modules[0].__path__ = []\n", "docstring": "Create stubs for all not-existing modules\n"}
{"repo": "menpo-master/menpo/testing.py", "original_string": "    def _remove_module_stubs(self):\n        \"\"\"Remove fake modules from sys.modules\"\"\"\n        for module in reversed(self.modules):\n            if module._importing_path in sys.modules:\n                del sys.modules[module._importing_path]\n", "docstring": "Remove fake modules from sys.modules\n"}
{"repo": "menpo-master/menpo/image/boolean.py", "original_string": "    def __init__(self, mask_data, copy=True):\n        # Add a channel dimension. We do this little reshape trick to add\n        # the axis because this maintains C-contiguous'ness\n        mask_data = mask_data.reshape((1,) + mask_data.shape)\n        # If we are trying not to copy, but the data we have isn't boolean,\n        # then unfortunately, we forced to copy anyway!\n        if mask_data.dtype != bool:\n            mask_data = np.array(mask_data, dtype=bool, copy=True, order=\"C\")\n            if not copy:\n                warn(\n                    \"The copy flag was NOT honoured. A copy HAS been made. \"\n                    \"Please ensure the data you pass is C-contiguous.\"\n                )\n        super(BooleanImage, self).__init__(mask_data, copy=copy)\n", "docstring": "Add a channel dimension. We do this little reshape trick to add"}
{"repo": "menpo-master/menpo/image/test/test_image_warp.py", "original_string": "def interpolation_method(mocker, method):\n    # This uses the pytest-mock package in order to provide a fixture that will\n    # mock the global variable in the image module that determines if OpenCV\n    # should be used or not. Useful for running the unit tests with and without\n    # opencv\n    interp = PropertyMock()\n    interp.return_value = method\n    mocker.patch(\"menpo.image.base.cv2_perspective_interpolation\", new_callable=interp)\n", "docstring": "This uses the pytest-mock package in order to provide a fixture that will"}
{"repo": "menpo-master/menpo/io/output/pickle.py", "original_string": "def _pure_path_reduce(self):\n    # Pickled paths should go to pure paths so pickles are\n    # useful across different OSes\n    return PurePath(self).__class__, tuple(self.parts)\n", "docstring": "Pickled paths should go to pure paths so pickles are"}
{"repo": "menpo-master/menpo/io/test/test_io_import.py", "original_string": "def test_path():\n    # choose a random asset (all should have it!)\n    img = mio.import_builtin_asset(\"einstein.jpg\")\n    path = mio.data_path_to(\"einstein.jpg\")\n    assert img.path == path\n    assert img.path.stem == \"einstein\"\n    assert img.path.suffix == \".jpg\"\n    assert img.path.parent == mio.data_dir_path()\n    assert img.path.name == \"einstein.jpg\"\n", "docstring": "choose a random asset (all should have it!)"}
{"repo": "menpo-master/menpo/io/input/pickle.py", "original_string": "def _unpickle_with_encoding(f, encoding=None):\n    # Support the encoding kwarg on Python 3.x only.\n    if encoding is not None and sys.version_info.major > 2:\n        return pickle.load(f, encoding=encoding)\n    else:\n        return pickle.load(f)\n", "docstring": "Support the encoding kwarg on Python 3.x only."}
{"repo": "menpo-master/menpo/landmark/base.py", "original_string": "    def __len__(self):\n        return len(self._landmark_groups)\n", "docstring": "return len(self._landmark_groups)"}
{"repo": "menpo-master/menpo/landmark/base.py", "original_string": "    def _ipython_key_completions_(self):\n        # Opt in to IPython tab completion - see\n        # https://github.com/ipython/ipython/blob/5.2.2/docs/source/config/integrating.rst\n        return list(self)\n", "docstring": "Opt in to IPython tab completion - see"}
{"repo": "menpo-master/menpo/landmark/test/test_labels.py", "original_string": "def check_label_func(func, input_n_points, output_n_points):\n    # Could be any dimensionality\n    array = np.zeros([input_n_points, 2])\n    pcloud = PointCloud(array)\n    array_result = func(array)\n    assert isinstance(array_result, PointCloud)\n    assert array_result.n_points == output_n_points\n    pcloud_result = func(pcloud)\n    assert isinstance(pcloud_result, PointCloud)\n    assert pcloud_result.n_points == output_n_points\n", "docstring": "Could be any dimensionality"}
{"repo": "menpo-master/menpo/model/gmrf.py", "original_string": "def _increment_multivariate_gaussian_mean(X, m, n):\n    # Get new number of samples\n    new_n = X.shape[0]\n    # Update mean vector\n    # m_{new} = (n m + \\sum_{i=1}^{n_{new}} x_i) / (n + n_{new})\n    # where: m       -> old mean vector\n    #        n_{new} -> new number of samples\n    #        n       -> old number of samples\n    #        x_i     -> new data vectors\n    return (n * m + np.sum(X, axis=0)) / (n + new_n)\n", "docstring": "Get new number of samples"}
{"repo": "menpo-master/menpo/model/gmrf.py", "original_string": "    def _data_to_matrix(self, data, n_samples):\n        # build a data matrix from all the samples\n        if n_samples is None:\n            n_samples = len(data)\n        # Assumed data is ndarray of (n_samples, n_features) or list of samples\n        if not isinstance(data, np.ndarray):\n            # Make sure we have an array, slice of the number of requested\n            # samples\n            data = np.array(data)[:n_samples]\n        return data, n_samples\n", "docstring": "build a data matrix from all the samples"}
{"repo": "menpo-master/menpo/model/pca.py", "original_string": "    def _data_to_matrix(self, data, n_samples):\n        # build a data matrix from all the samples\n        if n_samples is None:\n            n_samples = len(data)\n        # Assumed data is ndarray of (n_samples, n_features) or list of samples\n        if not isinstance(data, np.ndarray):\n            # Make sure we have an array, slice of the number of requested\n            # samples\n            data = np.array(data)[:n_samples]\n        return data, n_samples\n", "docstring": "build a data matrix from all the samples"}
{"repo": "menpo-master/menpo/model/test/test_gmrf.py", "original_string": "def test_mahalanobis_distance():\n    # arguments values\n    mode_values = [\"concatenation\", \"subtraction\"]\n    n_features_per_vertex_values = [2, 3]\n    sparse_values = [True, False]\n    subtract_mean_values = [True, False]\n    n_components_values = [None, 30]\n    # create graph\n    n_vertices = 6\n    edges = np.array([[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0]])\n    graphs = [\n        DirectedGraph.init_from_edges(edges, n_vertices),\n        UndirectedGraph(np.zeros((n_vertices, n_vertices))),\n    ]\n    for n_features_per_vertex in n_features_per_vertex_values:\n        # create samples\n        n_samples = 50\n        samples = []\n        for i in range(n_samples):\n            samples.append(\n                PointCloud(np.random.rand(n_vertices, n_features_per_vertex))\n            )\n        test_sample = PointCloud(np.random.rand(n_vertices, n_features_per_vertex))\n        for graph in graphs:\n            for mode in mode_values:\n                for sparse in sparse_values:\n                    for n_components in n_components_values:\n                        # train GMRF\n                        gmrf = GMRFModel(\n                            samples,\n                            graph,\n                            mode=mode,\n                            sparse=sparse,\n                            n_components=n_components,\n                            dtype=np.float64,\n                        )\n                        for subtract_mean in subtract_mean_values:\n                            # compute costs\n                            if graph.n_edges == 0:\n                                cost1 = _compute_sum_cost_block_diagonal(\n                                    samples,\n                                    test_sample,\n                                    graph,\n                                    n_features_per_vertex,\n                                    subtract_mean,\n                                )\n                            else:\n                                cost1 = _compute_sum_cost_block_sparse(\n                                    samples,\n                                    test_sample,\n                                    graph,\n                                    n_features_per_vertex,\n                                    subtract_mean,\n                                    mode,\n                                )\n                            cost2 = gmrf.mahalanobis_distance(\n                                test_sample, subtract_mean=subtract_mean\n                            )\n                            assert_almost_equal(cost1, cost2)\n", "docstring": "arguments values"}
{"repo": "menpo-master/menpo/shape/pointcloud.py", "original_string": "    def lms(self):\n        \"\"\"Deprecated.\n        Maintained for compatibility, will be removed in a future version.\n        Returns a copy of this object, which previously would have held\n        the 'underlying' :map:`PointCloud` subclass.\n        :type: self\n        \"\"\"\n        from menpo.base import MenpoDeprecationWarning\n        warnings.warn(\n            \"The .lms property is deprecated. LandmarkGroups are \"\n            \"now shapes themselves - so you can use them directly \"\n            \"anywhere you previously used .lms.\"\n            'Simply remove \".lms\" from your code and things '\n            \"will work as expected (and this warning will go away)\",\n            MenpoDeprecationWarning,\n        )\n        return self.copy()\n", "docstring": "Deprecated."}
{"repo": "menpo-master/menpo/shape/adjacency.py", "original_string": "def mask_adjacency_array(mask, adjacency_array):\n    # Find the indices that have been asked to be removed\n    indices_to_remove = np.nonzero(~mask)[0]\n    # Set intersection to find any rows containing those elements,\n    # reshape back in to the same size as adjacency array\n    entries_to_remove = np.in1d(adjacency_array, indices_to_remove)\n    entries_to_remove = entries_to_remove.reshape([-1, adjacency_array.shape[1]])\n    # Only keep those entries that are not flagged for removal\n    indices_to_keep = ~entries_to_remove.any(axis=1)\n    return adjacency_array[indices_to_keep, :]\n", "docstring": "Find the indices that have been asked to be removed"}
{"repo": "menpo-master/menpo/shape/labelled.py", "original_string": "    def __setstate__(self, state_dict):\n        # TODO: Deprecate this - this handles importing old-style LandmarkGroup\n        if \"_pointcloud\" in state_dict:\n            from menpo.base import MenpoDeprecationWarning\n            warnings.warn(\n                \"menpo.landmark.LandmarkGroup is now deprecated and \"\n                \"has been moved to menpo.shape.LandmarkGroup.\",\n                MenpoDeprecationWarning,\n            )\n            _pointcloud = state_dict.pop(\"_pointcloud\")\n            state_dict[\"points\"] = _pointcloud.points\n            # the shape on old landmarks *itself* was allowed to have landmarks\n            # (of course it was very frequently None though, see\n            # https://github.com/menpo/menpo/blob/v0.7.7/menpo/landmark/base.py#L24)\n            # In the new word, self has the same behavior, so move the\n            # landmarks across here.\n            # In the vast majority of cases, this will simply be None.\n            state_dict[\"_landmarks\"] = _pointcloud._landmarks\n            if type(_pointcloud) == PointCloud:\n                adj_mat = _convert_edges_to_symmetric_adjacency_matrix(\n                    [], _pointcloud.n_points\n                )\n            elif isinstance(_pointcloud, PointGraph):\n                a = _pointcloud.adjacency_matrix\n                # Ensure that the matrix is symmetric\n                adj_mat = a.maximum(a.T)\n            elif isinstance(_pointcloud, TriMesh):\n                warnings.warn(\n                    \"menpo.landmark.LandmarkGroup is now deprecated.\"\n                    \"The underlying ._pointcloud was a \"\n                    \"menpo.shape.TriMesh and this has been cast down \"\n                    \"to an UndirectedPointGraph subclass.\"\n                )\n                adj_mat = _pointcloud.as_pointgraph(copy=False).adjacency_matrix\n            else:\n                raise ValueError(\n                    \"Unexpected PointCloud type ({})\".format(type(_pointcloud))\n                )\n            state_dict[\"adjacency_matrix\"] = adj_mat\n        self.__dict__.update(state_dict)\n", "docstring": "TODO: Deprecate this - this handles importing old-style LandmarkGroup"}
{"repo": "menpo-master/menpo/shape/labelled.py", "original_string": "    def without_labels(self, labels):\n        \"\"\"A new labelled point undirected graph that excludes certain labels.\n        Parameters\n        ----------\n        labels : `str` or `list` of `str`\n            Label(s) that should be excluded in the returned labelled point\n            graph.\n        Returns\n        -------\n        labelled_pointgraph : :map:`LabelledPointUndirectedGraph`\n            A new labelled point undirected graph with the same group label but\n            containing all labels except the given label.\n        \"\"\"\n        # Make it easier to use by accepting a single string as well as a list\n        if isinstance(labels, str):\n            labels = [labels]\n        labels_to_keep = list(set(self.labels).difference(labels))\n        return self._new_group_with_only_labels(labels_to_keep)\n", "docstring": "A new labelled point undirected graph that excludes certain labels."}
{"repo": "menpo-master/menpo/shape/graph.py", "original_string": "    def __init__(self, adjacency_matrix, copy=True, skip_checks=False):\n        # check if adjacency_matrix is numpy.ndarray or scipy.sparse.csr_matrix\n        if isinstance(adjacency_matrix, np.ndarray):\n            # it is numpy.ndarray, thus convert it to scipy.sparse.csr_matrix\n            adjacency_matrix = csr_matrix(adjacency_matrix)\n        elif not (\n            isinstance(adjacency_matrix, np.ndarray)\n            or isinstance(adjacency_matrix, csr_matrix)\n        ):\n            raise ValueError(\n                \"adjacency_matrix must be either a numpy.ndarray\"\n                \"or a scipy.sparse.csr_matrix.\"\n            )\n        if not skip_checks:\n            # check that adjacency_matrix has expected shape\n            if adjacency_matrix.shape[0] == 0:\n                raise ValueError(\"Graph must have at least one vertex.\")\n            elif adjacency_matrix.shape[0] != adjacency_matrix.shape[1]:\n                raise ValueError(\n                    \"adjacency_matrix must be square \"\n                    \"(n_vertices, n_vertices, ), ({}, {}) given \"\n                    \"instead\".format(\n                        adjacency_matrix.shape[0], adjacency_matrix.shape[1]\n                    )\n                )\n            # check if adjacency matrix of undirected graph is symmetric\n            if not self._directed and not _is_symmetric(adjacency_matrix):\n                raise ValueError(\n                    \"The adjacency matrix of an undirected graph \" \"must be symmetric.\"\n                )\n        # store adjacency_matrix\n        if copy:\n            self.adjacency_matrix = adjacency_matrix.copy()\n        else:\n            self.adjacency_matrix = adjacency_matrix\n", "docstring": "check if adjacency_matrix is numpy.ndarray or scipy.sparse.csr_matrix"}
{"repo": "menpo-master/menpo/shape/mesh/base.py", "original_string": "    def _isolated_mask(self, mask):\n        # Find the triangles we need to keep\n        masked_adj = mask_adjacency_array(mask, self.trilist)\n        # Find isolated vertices (vertices that don't exist in valid\n        # triangles)\n        isolated_indices = np.setdiff1d(np.nonzero(mask)[0], masked_adj)\n        # Create a 'new mask' that contains the points the use asked\n        # for MINUS the points that we can't create triangles for\n        new_mask = mask.copy()\n        new_mask[isolated_indices] = False\n        return new_mask\n", "docstring": "Find the triangles we need to keep"}
{"repo": "menpo-master/menpo/transform/thinplatesplines.py", "original_string": "    def _sync_state_from_target(self):\n        # now the target is updated, we only have to rebuild the\n        # coefficients.\n        self._build_coefficients()\n", "docstring": "now the target is updated, we only have to rebuild the"}
{"repo": "menpo-master/menpo/transform/base/composable.py", "original_string": "    def __init__(self, transforms):\n        # TODO Should TransformChain copy on input?\n        self.transforms = transforms\n", "docstring": "TODO Should TransformChain copy on input?"}
{"repo": "menpo-master/menpo/transform/homogeneous/base.py", "original_string": "    def _compose_after_inplace(self, transform):\n        # Compose machinery will guarantee this is only invoked in the right\n        # circumstances (e.g. the types will match) so we don't need to block\n        # the setting of the matrix\n        self._set_h_matrix(\n            np.dot(self.h_matrix, transform.h_matrix), copy=False, skip_checks=True\n        )\n", "docstring": "Compose machinery will guarantee this is only invoked in the right"}
{"repo": "menpo-master/menpo/transform/homogeneous/affine.py", "original_string": "    def __init__(self, source, target):\n        # first, initialize the alignment\n        HomogFamilyAlignment.__init__(self, source, target)\n        # now, the Affine\n        optimal_h = self._build_alignment_h_matrix(source, target)\n        Affine.__init__(self, optimal_h, copy=False, skip_checks=True)\n", "docstring": "first, initialize the alignment"}
{"repo": "menpo-master/menpo/transform/test/test_h_compose.py", "original_string": "def test_rotation_compose_before_homog():\n    # can't do this inplace - so should just give transform chain\n    rotation = Rotation(np.array([[1, 0], [0, 1]]))\n    homog = Homogeneous(np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]]))\n    res = rotation.compose_before(homog)\n    assert type(res) == Homogeneous\n", "docstring": "can't do this inplace - so should just give transform chain"}
{"repo": "menpo-master/menpo/transform/test/test_h_compose.py", "original_string": "def test_scale_compose_after_inplace_homog():\n    # can't do this inplace - so should just give transform chain\n    homog = Homogeneous(np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]]))\n    s = Scale([3, 4])\n    with raises(ValueError):\n        s.compose_after_inplace(homog)\n", "docstring": "can't do this inplace - so should just give transform chain"}
{"repo": "menpo-master/menpo/transform/test/test_h_scale.py", "original_string": "def test_uniformscale2d_update_from_vector():\n    # make a uniform scale of 1, 2 dimensional\n    uniform_scale = UniformScale(1, 2)\n    new_scale = 2\n    homo = np.array([[new_scale, 0, 0], [0, new_scale, 0], [0, 0, 1]])\n    uniform_scale._from_vector_inplace(new_scale)\n    assert_almost_equal(uniform_scale.h_matrix, homo)\n", "docstring": "make a uniform scale of 1, 2 dimensional"}
{"repo": "menpo-master/menpo/transform/test/test_procrustes.py", "original_string": "def test_procrustes_no_target():\n    # square\n    src_1 = PointCloud(np.array([[1.0, 1.0], [1.0, -1.0], [-1.0, -1.0], [-1.0, 1.0]]))\n    # rhombus\n    src_2 = PointCloud(np.array([[2.0, 0.0], [4.0, 2.0], [6.0, 0.0], [4.0, -2.0]]))\n    # trapezoid\n    src_3 = PointCloud(np.array([[-0.5, -1.5], [2.5, -1.5], [2.8, -2.5], [-0.2, -2.5]]))\n    gpa = GeneralizedProcrustesAnalysis([src_1, src_2, src_3], allow_mirror=True)\n    aligned_1 = gpa.transforms[0].apply(gpa.sources[0])\n    aligned_2 = gpa.transforms[1].apply(gpa.sources[1])\n    aligned_3 = gpa.transforms[2].apply(gpa.sources[2])\n    assert gpa.converged is True\n    assert gpa.n_iterations == 5\n    assert gpa.n_sources == 3\n    assert np.round(gpa.initial_target_scale * 100) == 195.0\n    assert np.round(gpa.mean_alignment_error() * 10) == 4.0\n    assert_allclose(\n        np.around(aligned_1.points, decimals=1), np.around(aligned_2.points, decimals=1)\n    )\n    res_3 = np.array([[0.7, -0.3], [2.6, -0.4], [2.7, -1.0], [0.9, -0.9]])\n    assert_allclose(np.around(aligned_3.points, decimals=1), res_3)\n    assert_allclose(gpa.target.points, gpa.mean_aligned_shape().points)\n", "docstring": "square"}
{"repo": "menpo-master/menpo/transform/piecewiseaffine/base.py", "original_string": "    def _apply_batched(self, x, batch_size, **kwargs):\n        # This is a rare case where we need to override the batched apply\n        # method. In this case, we override it because we want to the\n        # possibly raised TriangleContainmentError to contain ALL the points\n        # that were considered, and not just the first batch of points.\n        if batch_size is None:\n            return self._apply(x, **kwargs)\n        else:\n            outputs = []\n            points_outside_source_domain = []\n            n_points = x.shape[0]\n            exception_thrown = False\n            for lo_ind in range(0, n_points, batch_size):\n                try:\n                    hi_ind = lo_ind + batch_size\n                    outputs.append(self._apply(x[lo_ind:hi_ind], **kwargs))\n                except TriangleContainmentError as e:\n                    exception_thrown = True\n                    points_outside_source_domain.append(e.points_outside_source_domain)\n                else:\n                    # No exception was thrown, so all points were inside\n                    points_outside_source_domain.append(\n                        np.zeros(batch_size, dtype=bool)\n                    )\n            if exception_thrown:\n                raise TriangleContainmentError(np.hstack(points_outside_source_domain))\n            else:\n                return np.vstack(outputs)\n", "docstring": "This is a rare case where we need to override the batched apply"}
{"repo": "menpo-master/menpo/transform/piecewiseaffine/base.py", "original_string": "    def __init__(self, source, target):\n        super(PythonPWA, self).__init__(source, target)\n        si, sij, sik = barycentric_vectors(self.source.points, self.trilist)\n        self.s, self.sij, self.sik = si, sij, sik\n", "docstring": "super(PythonPWA, self).__init__(source, target)"}
{"repo": "pydriller-master/pydriller/repository.py", "original_string": "    def _get_repo_name_from_url(url: str) -> str:\n        last_slash_index = url.rfind(\"/\")\n        last_suffix_index = url.rfind(\".git\")\n        if last_suffix_index < 0:\n            last_suffix_index = len(url)\n        if last_slash_index < 0 or last_suffix_index <= last_slash_index:\n            raise MalformedUrl(\"Badly formatted url {}\".format(url))\n        return url[last_slash_index + 1:last_suffix_index]\n", "docstring": "last_slash_index = url.rfind(\"/\")"}
{"repo": "pydriller-master/pydriller/git.py", "original_string": "    def _open_repository(self):\n        self._repo = Repo(str(self.path))\n        self._repo.config_writer().set_value(\"blame\", \"markUnblamableLines\", \"true\").release()\n        if self._conf.get(\"main_branch\") is None:\n            self._discover_main_branch(self._repo)\n", "docstring": "self._repo = Repo(str(self.path))"}
{"repo": "pydriller-master/pydriller/git.py", "original_string": "    def get_commits_last_modified_lines(self, commit: Commit,\n                                        modification: ModifiedFile = None,\n                                        hashes_to_ignore_path: str = None) \\\n            -> Dict[str, Set[str]]:\n        \"\"\"\n        Given the Commit object, returns the set of commits that last\n        \"touched\" the lines that are modified in the files included in the\n        commit. It applies SZZ.\n        The algorithm works as follow: (for every file in the commit)\n        1- obtain the diff\n        2- obtain the list of deleted lines\n        3- blame the file and obtain the commits were those lines were added\n        Can also be passed as parameter a single Modification, in this case\n        only this file will be analyzed.\n        :param Commit commit: the commit to analyze\n        :param Modification modification: single modification to analyze\n        :param str hashes_to_ignore_path: path to a file containing hashes of\n               commits to ignore.\n        :return: Dict commits: a dictionary having as keys the files of the commit,\n                 and as values the commits that last touched those files.\n        \"\"\"\n        if modification is not None:\n            modifications = [modification]\n        else:\n            modifications = commit.modified_files\n        return self._calculate_last_commits(commit, modifications,\n                                            hashes_to_ignore_path)\n", "docstring": "modification: ModifiedFile = None,"}
{"repo": "pydriller-master/pydriller/git.py", "original_string": "    def _useless_line(line: str):\n        # this covers comments in Java and Python, as well as empty lines.\n        # More have to be added!\n        return not line or \\\n               line.startswith('//') or \\\n               line.startswith('#') or \\\n               line.startswith(\"/*\") or \\\n               line.startswith(\"'''\") or \\\n               line.startswith('\"\"\"') or \\\n               line.startswith(\"*\")\n", "docstring": "this covers comments in Java and Python, as well as empty lines."}
{"repo": "pydriller-master/pydriller/domain/commit.py", "original_string": "    def __hash__(self):\n        # parameters are used in hashing in order to\n        # prevent collisions when overloading method names\n        return hash(\n            (\n                \"name\",\n                self.name,\n                \"long_name\",\n                self.long_name,\n                \"params\",\n                (x for x in self.parameters),\n            )\n        )\n", "docstring": "parameters are used in hashing in order to"}
{"repo": "pydriller-master/pydriller/domain/commit.py", "original_string": "    def _get_line_numbers(line):\n        token = line.split(\" \")\n        numbers_old_file = token[1]\n        numbers_new_file = token[2]\n        delete_line_number = (\n            int(numbers_old_file.split(\",\")[0].replace(\"-\", \"\")) - 1\n        )\n        additions_line_number = int(numbers_new_file.split(\",\")[0]) - 1\n        return delete_line_number, additions_line_number\n", "docstring": "token = line.split(\" \")"}
{"repo": "pydriller-master/pydriller/domain/commit.py", "original_string": "    def _risk_profile(\n        methods: List[Method], dmm_prop: DMMProperty\n", "docstring": "methods: List[Method], dmm_prop: DMMProperty"}
{"repo": "pydriller-master/pydriller/domain/commit.py", "original_string": "    def __eq__(self, other):\n        if not isinstance(other, ModifiedFile):\n            return NotImplemented\n        if self is other:\n            return True\n        return self.__dict__ == other.__dict__\n", "docstring": "if not isinstance(other, ModifiedFile):"}
{"repo": "pydriller-master/pydriller/domain/commit.py", "original_string": "    def _parse_diff(self, diff_index) -> List[ModifiedFile]:\n        modified_files_list = []\n        for diff in diff_index:\n            old_path = diff.a_path\n            new_path = diff.b_path\n            change_type = self._from_change_to_modification_type(diff)\n            diff_and_sc = {\n                \"diff\": self._get_decoded_str(diff.diff),\n                \"source_code_before\": self._get_decoded_sc_str(diff.a_blob),\n                \"source_code\": self._get_decoded_sc_str(diff.b_blob),\n            }\n            modified_files_list.append(\n                ModifiedFile(old_path, new_path, change_type, diff_and_sc)\n            )\n        return modified_files_list\n", "docstring": "modified_files_list = []"}
{"repo": "pydriller-master/pydriller/domain/commit.py", "original_string": "    def _delta_risk_profile(\n        self, dmm_prop: DMMProperty\n", "docstring": "self, dmm_prop: DMMProperty"}
{"repo": "pydriller-master/pydriller/utils/conf.py", "original_string": "    def __init__(self, options):\n        # insert all the configurations in a local dictionary\n        self._options = {}\n        for key, val in options.items():\n            self._options[key] = val\n        self._sanity_check_repos(self.get('path_to_repo'))\n        if isinstance(self.get('path_to_repo'), str):\n            self.set_value('path_to_repos', [self.get('path_to_repo')])\n        else:\n            self.set_value('path_to_repos', self.get('path_to_repo'))\n", "docstring": "insert all the configurations in a local dictionary"}
{"repo": "pydriller-master/pydriller/utils/conf.py", "original_string": "    def _check_only_one_to_commit(self):\n        if not self.only_one_filter([self.get('to'),\n                                     self.get('to_commit'),\n                                     self.get('to_tag')]):\n            raise Exception('You can only specify one between since, from_tag and from_commit')\n", "docstring": "if not self.only_one_filter([self.get('to'),"}
{"repo": "pydriller-master/pydriller/utils/conf.py", "original_string": "    def _is_commit_before(commit_before: Commit, commit_after: Commit):\n        if commit_before.committer_date < commit_after.committer_date:\n            return True\n        if commit_before.committer_date == commit_after.committer_date and \\\n                commit_before.author_date < commit_after.author_date:\n            return True\n        return False\n", "docstring": "if commit_before.committer_date < commit_after.committer_date:"}
{"repo": "pydriller-master/pydriller/utils/conf.py", "original_string": "    def is_commit_filtered(self, commit: Commit):\n        # pylint: disable=too-many-branches,too-many-return-statements\n        \"\"\"\n        Check if commit has to be filtered according to the filters provided\n        by the user.\n        :param Commit commit: Commit to check\n        :return:\n        \"\"\"\n        if self.get('only_modifications_with_file_types') is not None:\n            if not self._has_modification_with_file_type(commit):\n                logger.debug('Commit filtered for modification types')\n                return True\n        if self.get('only_commits') is not None and commit.hash not in self.get('only_commits'):\n            logger.debug(\"Commit filtered because it is not one of the specified commits\")\n            return True\n        if self.get('filepath_commits') is not None and commit.hash not in self.get('filepath_commits'):\n            logger.debug(\"Commit filtered because it did not modify the specified file\")\n            return True\n        if self.get('tagged_commits') is not None and commit.hash not in self.get('tagged_commits'):\n            logger.debug(\"Commit filtered because it is not tagged\")\n            return True\n        return False\n", "docstring": "pylint: disable=too-many-branches,too-many-return-statements"}
{"repo": "pydriller-master/pydriller/utils/conf.py", "original_string": "    def _check_timezones(self):\n        if self.get('since') is not None:\n            self.set_value('since', self._replace_timezone(self.get('since')))\n        if self.get('to') is not None:\n            self.set_value('to', self._replace_timezone(self.get('to')))\n", "docstring": "if self.get('since') is not None:"}
{"repo": "pydriller-master/tests/test_repository_mining.py", "original_string": "def test_diff_without_histogram(git_repo):\n    # without histogram\n    commit = list(Repository('test-repos/histogram',\n                             single=\"93df8676e6fab70d9677e94fd0f6b17db095e890\").traverse_commits())[0]\n    diff = commit.modified_files[0].diff_parsed\n    assert len(diff['added']) == 11\n    assert (3, '    if (path == null)') in diff['added']\n    assert (5, '        log.error(\"Icon path is null\");') in diff['added']\n    assert (6, '        return null;') in diff['added']\n    assert (8, '') in diff['added']\n    assert (9, '    java.net.URL imgURL = GuiImporter.class.getResource(path);') in diff['added']\n    assert (10, '') in diff['added']\n    assert (11, '    if (imgURL == null)') in diff['added']\n    assert (12, '    {') in diff['added']\n    assert (14, '        return null;') in diff['added']\n    assert (16, '    else') in diff['added']\n    assert (17, '        return new ImageIcon(imgURL);') in diff['added']\n    assert len(diff['deleted']) == 7\n    assert (3, '    java.net.URL imgURL = GuiImporter.class.getResource(path);') in diff['deleted']\n    assert (4, '') in diff['deleted']\n    assert (5, '    if (imgURL != null)') in diff['deleted']\n    assert (7, '        return new ImageIcon(imgURL);') in diff['deleted']\n    assert (9, '    else') in diff['deleted']\n    assert (10, '    {') in diff['deleted']\n    assert (13, '    return null;') in diff['deleted']\n", "docstring": "without histogram"}
{"repo": "pydriller-master/tests/test_repository_mining.py", "original_string": "def test_diff_with_histogram(git_repo):\n    # with histogram\n    commit = list(Repository('test-repos/histogram',\n                             single=\"93df8676e6fab70d9677e94fd0f6b17db095e890\",\n                             histogram_diff=True).traverse_commits())[0]\n    diff = commit.modified_files[0].diff_parsed\n    assert (4, '    {') in diff[\"added\"]\n    assert (5, '        log.error(\"Icon path is null\");') in diff[\"added\"]\n    assert (6, '        return null;') in diff[\"added\"]\n    assert (7, '    }') in diff[\"added\"]\n    assert (8, '') in diff[\"added\"]\n    assert (11, '    if (imgURL == null)') in diff[\"added\"]\n    assert (12, '    {') in diff[\"added\"]\n    assert (13, '        log.error(\"Couldn\\'t find icon: \" + imgURL);') in diff[\"added\"]\n    assert (14, '        return null;') in diff[\"added\"]\n    assert (17, '        return new ImageIcon(imgURL);') in diff[\"added\"]\n    assert (6, '    {') in diff[\"deleted\"]\n    assert (7, '        return new ImageIcon(imgURL);') in diff[\"deleted\"]\n    assert (10, '    {') in diff[\"deleted\"]\n    assert (11, '        log.error(\"Couldn\\'t find icon: \" + imgURL);') in diff[\"deleted\"]\n    assert (12, '    }') in diff[\"deleted\"]\n    assert (13, '    return null;') in diff[\"deleted\"]\n", "docstring": "with histogram"}
{"repo": "pydriller-master/tests/test_dmm.py", "original_string": "def test_mixin_unsupported_language(repo: Git):\n    # Add .txt file and update (comments in) .java files\n    commit = commit_by_msg(repo, 'Release under Apache 2 license')\n    assert commit.dmm_unit_size is None\n", "docstring": "Add .txt file and update (comments in) .java files"}
{"repo": "pockyt-master/pockyt/client.py", "original_string": "    def _validate_format(self):\n        # interpret escape sequences\n        try:\n            self._args.format = bytes(self._args.format,\n                                      API.ENCODING).decode(API.DECODING)\n        except TypeError:\n            self._args.format = self._args.format.decode(API.DECODING)\n        info = dict((key, None) for key in API.INFO_KEYS)\n        try:\n            self._args.format.format(**info)\n        except KeyError:\n            print(\"Invalid Format Specifier !\")\n            sys.exit(1)\n        else:\n            self._format_spec = self._args.format + \"\\n\"\n            self._unformat_spec = parse.compile(self._args.format)\n", "docstring": "interpret escape sequences"}
{"repo": "pockyt-master/pockyt/wrapper.py", "original_string": "    def __init__(self):\n        self.orig_stdout = sys.stdout.fileno()\n        self.copy_stdout = os.dup(self.orig_stdout)\n        self.devnull = None\n", "docstring": "self.orig_stdout = sys.stdout.fileno()"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def __init__(self):\n        \"\"\"Initializes a LexemeMeta object\"\"\"\n        self.flags = 0\n        self.lang = 0\n        self.id = 0\n        self.length = 0\n        self.orth = 0\n        self.lower = 0\n        self.shape = 0\n        self.prefix = 0\n        self.suffix = 0\n", "docstring": "Initializes a LexemeMeta object\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def check_flag(self, flag_id: int) -> bool:\n        \"\"\"This method checks the value of flag corresponding to given flag_id.\n        It check if bit at index corresponding to flag_id is 1 or 0. This method\n        is inspired from Spacy.\n        Args:\n            flag_id(int): The flag_id for corresponding attribute to check.\n        Returns:\n            bool: Returns True if the value of `lex_meta.flags` bit at index flag_id is 1 else 0.\n        \"\"\"\n        one = 1\n        # Check if bit at index corresponding to flag_id is 1 or 0\n        # if one return True otherwise if 0  return False\n        if self.flags & (one << flag_id):\n            return True\n        else:\n            return False\n", "docstring": "This method checks the value of flag corresponding to given flag_id."}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def __init__(self, vocab: \"Vocab\", orth: int) -> None:\n        \"\"\"Initializes a Lexeme object.\n        Args:\n            vocab (Vocab): The parent vocabulary.\n            orth (int): The orth id of the lexeme, i.e, the token's hash.\n        \"\"\"\n        self.vocab = vocab\n        self.orth = orth\n        # Get the LexMeta stored in Vocab's lex_store\n        # Note: This creates no entry in lex_store if the LexemeMeta is not already present\n        self.lex_meta = vocab.get_lex_meta(orth)\n", "docstring": "Initializes a Lexeme object."}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def set_flag(self, flag_id: int, value: bool) -> None:\n        \"\"\"Set the sets the value of flag corresponding to flag_id to 1 or zero\n        according to provided attribute value. This method is inspired from Spacy.\n        Args:\n            flag_id(int): The flag_id for corresponding attribute to set.\n            value(bool): boolean value used to set flag.\n        \"\"\"\n        # Sets the value of flag which is inside lexememeta object\n        self.lex_meta.set_flag(flag_id=flag_id, value=value)\n", "docstring": "Set the sets the value of flag corresponding to flag_id to 1 or zero"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def has_vector(self):\n        \"\"\"Whether the word has a vector in vocabulary or not.\"\"\"\n        return self.vocab.has_vector(self.orth_)\n", "docstring": "Whether the word has a vector in vocabulary or not.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def vector_norm(self) -> float:\n        \"\"\"The L2 norm of the vector.\"\"\"\n        return torch.sqrt((self.vector ** 2).sum())\n", "docstring": "The L2 norm of the vector.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def vector(self):\n        \"\"\" Returns the  vector of a given word in the vocabulary.\"\"\"\n        return self.vocab.get_vector(self.lex_meta.orth)\n", "docstring": "Returns the  vector of a given word in the vocabulary.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def rank(self):\n        \"\"\" The key to index in the vectors array.\"\"\"\n        return self.lex_meta.id\n", "docstring": "The key to index in the vectors array.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def orth_(self):\n        \"\"\"The original text of the lexeme (identical to `Lexeme.text`).\n        This method is defined for consistency with the other attributes.\n        \"\"\"\n        return self.vocab.store[self.lex_meta.orth]\n", "docstring": "The original text of the lexeme (identical to `Lexeme.text`)."}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def text(self):\n        \"\"\" The original text of the lexeme.\"\"\"\n        return self.orth_\n", "docstring": "The original text of the lexeme.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def lower(self):\n        \"\"\"Orth id of lowercase form of the lexeme.\"\"\"\n        return self.lex_meta.lower\n", "docstring": "Orth id of lowercase form of the lexeme.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def flags(self):\n        \"\"\"Returns the flags Integer value.\n        One can get the value assigned to a specific flag_id by\n        looking at the bit corresponding to flag_id index of flags.\n        \"\"\"\n        return self.lex_meta.flags\n", "docstring": "Returns the flags Integer value."}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def shape(self):\n        \"\"\"Orth id of the transform of the word's text, to show orthographic features.\"\"\"\n        return self.lex_meta.shape\n", "docstring": "Orth id of the transform of the word's text, to show orthographic features.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def prefix(self):\n        \"\"\"Orth id of length-1 substring from the start of the word. \"\"\"\n        return self.lex_meta.prefix\n", "docstring": "Orth id of length-1 substring from the start of the word. \n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def suffix(self):\n        \"\"\"Orth id of length-3 substring from the end of the word.\"\"\"\n        return self.lex_meta.suffix\n", "docstring": "Orth id of length-3 substring from the end of the word.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def lang(self):\n        \"\"\"Orth id of language of the parent vocabulary.\"\"\"\n        return self.lex_meta.lang\n", "docstring": "Orth id of language of the parent vocabulary.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def lower_(self):\n        \"\"\"Lowercase form of the word.\"\"\"\n        return self.vocab.store[self.lower]\n", "docstring": "Lowercase form of the word.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def shape_(self):\n        \"\"\"Transform of the word's string, to show orthographic features.\"\"\"\n        return self.vocab.store[self.lex_meta.shape]\n", "docstring": "Transform of the word's string, to show orthographic features.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def prefix_(self):\n        \"\"\"Length-1 substring from the start of the word.\"\"\"\n        return self.vocab.store[self.lex_meta.prefix]\n", "docstring": "Length-1 substring from the start of the word.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def suffix_(self):\n        \"\"\"Length-3 substring from the end of the word.\"\"\"\n        return self.vocab.store[self.lex_meta.suffix]\n", "docstring": "Length-3 substring from the end of the word.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def lang_(self):\n        \"\"\"Language of the parent vocabulary.\"\"\"\n        return self.vocab.store[self.lex_meta.lang]\n", "docstring": "Language of the parent vocabulary.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_oov(self):\n        \"\"\"Whether the lexeme is out-of-vocabulary.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_OOV)\n", "docstring": "Whether the lexeme is out-of-vocabulary.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_stop(self):\n        \"\"\"Whether the lexeme is a stop word.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_STOP)\n", "docstring": "Whether the lexeme is a stop word.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_alpha(self):\n        \"\"\"Whether the lexeme consists of alphabetical characters only.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_ALPHA)\n", "docstring": "Whether the lexeme consists of alphabetical characters only.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_ascii(self):\n        \"\"\"Whether the lexeme consists of ASCII characters.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_ASCII)\n", "docstring": "Whether the lexeme consists of ASCII characters.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_digit(self) -> bool:\n        \"\"\"Whether the lexeme consists of digits.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_DIGIT)\n", "docstring": "Whether the lexeme consists of digits.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_lower(self) -> bool:\n        \"\"\"Whether the lexeme is in lowercase.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_LOWER)\n", "docstring": "Whether the lexeme is in lowercase.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_upper(self) -> bool:\n        \"\"\"Whether the lexeme is in uppercase.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_UPPER)\n", "docstring": "Whether the lexeme is in uppercase.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_title(self) -> bool:\n        \"\"\"Whether the lexeme is in titlecase.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_TITLE)\n", "docstring": "Whether the lexeme is in titlecase.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_punct(self) -> bool:\n        \"\"\"Whether the lexeme is punctuation.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_PUNCT)\n", "docstring": "Whether the lexeme is punctuation.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_space(self) -> bool:\n        \"\"\"Whether the lexeme consists of only whitespace characters.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_SPACE)\n", "docstring": "Whether the lexeme consists of only whitespace characters.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_bracket(self) -> bool:\n        \"\"\"Whether the lexeme is a bracket.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_BRACKET)\n", "docstring": "Whether the lexeme is a bracket.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_quote(self) -> bool:\n        \"\"\"Whether the lexeme is a quotation mark.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_QUOTE)\n", "docstring": "Whether the lexeme is a quotation mark.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_left_punct(self) -> bool:\n        \"\"\"Whether the lexeme is a left punctuation mark.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_LEFT_PUNCT)\n", "docstring": "Whether the lexeme is a left punctuation mark.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_right_punct(self) -> bool:\n        \"\"\"Whether the lexeme is a right punctuation mark.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_RIGHT_PUNCT)\n", "docstring": "Whether the lexeme is a right punctuation mark.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def is_currency(self) -> bool:\n        \"\"\"Whether the lexeme is a currency symbol.\"\"\"\n        return self.lex_meta.check_flag(Attributes.IS_CURRENCY)\n", "docstring": "Whether the lexeme is a currency symbol.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def like_url(self) -> bool:\n        \"\"\"Whether the lexeme resembles a URL.\"\"\"\n        return self.lex_meta.check_flag(Attributes.LIKE_URL)\n", "docstring": "Whether the lexeme resembles a URL.\n"}
{"repo": "SyferText-master/src/syfertext/lexeme.py", "original_string": "    def like_num(self) -> bool:\n        \"\"\"Whether the lexeme resembles a number, e.g. \"10.9\", \"10\", etc.\"\"\"\n        return self.lex_meta.check_flag(Attributes.LIKE_NUM)\n", "docstring": "Whether the lexeme resembles a number, e.g. \"10.9\", \"10\", etc.\n"}
{"repo": "SyferText-master/src/syfertext/data/units/text_doc.py", "original_string": "    def __init__(self):\n        # This list is populated in the __call__ method of the Tokenizer object.\n        # Its members are objects of the TokenMeta class\n        self.token_metas = list()\n        # A dictionary to hold custom attributes\n        self.attributes: Dict[str, List[str]] = dict()\n", "docstring": "This list is populated in the __call__ method of the Tokenizer object."}
{"repo": "SyferText-master/src/syfertext/data/units/text_doc.py", "original_string": "    def __len__(self):\n        \"\"\"Return the number of tokens in the Doc.\"\"\"\n        return len(self.token_metas)\n", "docstring": "Return the number of tokens in the Doc.\n"}
{"repo": "SyferText-master/src/syfertext/data/units/token.py", "original_string": "    def text(self):\n        \"\"\"Get the token text in str type\"\"\"\n        return self.token_meta.text\n", "docstring": "Get the token text in str type\n"}
{"repo": "SyferText-master/src/syfertext/data/units/token.py", "original_string": "    def space_after(self):\n        \"\"\"Whether the current token's text is followed by a white space or not\n        \"\"\"\n        return self.token_meta.space_after\n", "docstring": "Whether the current token's text is followed by a white space or not"}
{"repo": "SyferText-master/src/syfertext/data/units/token.py", "original_string": "    def text_with_ws(self):\n        \"\"\"The text content of the token with the trailing whitespace(if any).\"\"\"\n        if self.space_after:\n            return self.text + \" \"\n        else:\n            return self.text\n", "docstring": "The text content of the token with the trailing whitespace(if any).\n"}
{"repo": "SyferText-master/src/syfertext/data/units/span.py", "original_string": "    def __init__(self, doc: \"TextDoc\", start: int, end: int):\n        \"\"\"Create a `Span` object from the slice `doc[start : end]`.\n        Args:\n            doc (Doc): The parent document.\n            start (int): The index of the first token of the span.\n            end (int): The index of the first token after the span.\n        Returns (Span):\n            The newly constructed object.\n        \"\"\"\n        self.doc = doc\n        self.start = start\n        # We don't need to handle `None` here\n        # it will be handled by normalize slice\n        # Invalid ranges handled by normalize function\n        self.end = end\n        # A dictionary to hold custom attributes\n        self.attributes = token_meta.attributes\n", "docstring": "Create a `Span` object from the slice `doc[start : end]`."}
{"repo": "SyferText-master/src/syfertext/data/units/span.py", "original_string": "    def __len__(self):\n        \"\"\"Return the number of tokens in the Span.\"\"\"\n        return self.end - self.start\n", "docstring": "Return the number of tokens in the Span.\n"}
{"repo": "SyferText-master/src/syfertext/data/iterators/language_modeling.py", "original_string": "    def load(self, dataset_meta):\n        # Read the dataset\n        self.dataset_reader.read(dataset_meta=dataset_meta)\n        print(self.dataset_reader.encoded_text)\n", "docstring": "Read the dataset"}
{"repo": "SyferText-master/src/syfertext/data/iterators/language_modeling.py", "original_string": "    def __iter__(self):\n        # Reset the iterator\n        self.index = 0\n        return self\n", "docstring": "Reset the iterator"}
{"repo": "SyferText-master/src/syfertext/data/iterators/language_modeling.py", "original_string": "    def num_examples(self):\n        \"\"\"Returns that number of non-overlapping  examples\n        in the dataset\n        \"\"\"\n        num_examples = (len(self.dataset_reader.encoded_text) - 1) // self.bptt_len\n        return num_examples\n", "docstring": "Returns that number of non-overlapping  examples"}
{"repo": "SyferText-master/src/syfertext/data/iterators/language_modeling.py", "original_string": "    def num_batches(self):\n        \"\"\"Returns the total number of batches. The last batch\n        is dropped if its size is less than self.batch_size.\n        \"\"\"\n        num_batches = self.num_examples // self.batch_size\n        return num_batches\n", "docstring": "Returns the total number of batches. The last batch"}
{"repo": "SyferText-master/src/syfertext/tokenizers/utils.py", "original_string": "def compile_prefix_regex(entries: Tuple) -> Pattern:\n    \"\"\"Compile a sequence of prefix rules into a regex object.\n    Args:\n        entries (tuple): The prefix rules, e.g. syfertext.punctuation.TOKENIZER_PREFIXES.\n    Returns:\n        The regex object. to be used for Tokenizer.prefix_search.\n    \"\"\"\n    if \"(\" in entries:\n        # Handle deprecated data\n        expression = \"|\".join([\"^\" + re.escape(piece) for piece in entries if piece.strip()])\n        return re.compile(expression)\n    else:\n        expression = \"|\".join([\"^\" + piece for piece in entries if piece.strip()])\n        return re.compile(expression)\n", "docstring": "Compile a sequence of prefix rules into a regex object."}
{"repo": "SyferText-master/src/syfertext/tokenizers/spacy_tokenizer.py", "original_string": "    def _split_affixes(self, substring: str) -> Tuple[str, DefaultDict, List[TokenMeta]]:\n        \"\"\"Process substring for tokenizing prefixes, infixes, suffixes and exceptions.\n        Args:\n            substring: The substring to tokenize.\n        Returns:\n            substring: The substring to tokenize.\n            affixes: Dict holding TokenMeta lists of each affix\n                types as a result of splitting affixes\n            exception_tokens: The list of exception tokens TokenMeta objects.\n        \"\"\"\n        infixes = []\n        exception_tokens = []\n        next_affix = [\"prefix\", \"suffix\"]\n        # Dict holding TokenMeta lists of each affix types(prefix, suffix, infix)\n        affixes = defaultdict(list)\n        # The first element in the `next_affix` list is 'prefix'.\n        # since we should start by finding prefixes, we fix the\n        # index i = 0.\n        # Start by finding prefixes.\n        i = 0\n        # Holds the last value of `i` at the moment when either a prefix or a suffix is matched.\n        # If the difference between `i` and l`ast_i` is greater than 2, it means that neither a\n        # prefix nor a suffix is found.\n        last_i = 0\n        # In each iteration, `substring` is searched for a prefix first, then for a suffix, and thus\n        # alternatively. The loop terminates when an exception substring is encountered,\n        # or when the substring is not updated for 2 continuous iterations, i.e, when\n        # neither a prefix nor a suffix is matched in the substring.\n        while i - last_i <= 2:\n            if substring in self.exceptions:\n                # Get a list of exception  `TokenMeta` objects to be added to the TextDoc.\n                exception_tokens, substring = self._get_exception_token_metas(substring)\n                break\n            # Get affix type (prefix or suffix)\n            affix_type = next_affix[i % 2]\n            affix_finder = getattr(self, f\"find_{affix_type}\")\n            if affix_finder(substring):\n                # Get the `TokenMeta` object of the affix along with updated\n                # substring after removing the affix\n                token_meta, substring = getattr(self, f\"_get_{affix_type}_token_meta\")(substring)\n                affixes[f\"{affix_type}\"].append(token_meta)\n                last_i = i\n            # Change the affix type.\n            i += 1\n        # Get infix TokenMeta objects if any.\n        if self.infix_matches(substring):\n            infixes, substring = self._get_infix_token_metas(substring)\n            affixes[\"infix\"].extend(infixes)\n        return substring, affixes, exception_tokens\n", "docstring": "Process substring for tokenizing prefixes, infixes, suffixes and exceptions."}
{"repo": "SyferText-master/src/syfertext/tokenizers/spacy_tokenizer.py", "original_string": "    def _get_prefix_token_meta(self, substring: str) -> Tuple[TokenMeta, str]:\n        \"\"\"Makes TokenMeta data for substring which are prefixes.\n        Args:\n            substring: The substring to tokenize.\n        Returns:\n            token_meta: The TokenMeta object with TokenMeta data of prefix.\n            substring: The updated substring after removing prefix.\n        \"\"\"\n        # Get the length of prefix match in the substring.\n        pre_len = self.find_prefix(substring)\n        # break if pattern matches the empty string\n        if pre_len == 0:\n            return None, substring\n        # Create the TokenMeta object\n        token_meta = TokenMeta(\n            text=str(substring[:pre_len]),\n            space_after=False,  # for the last token space_after will be updated explicitly according to the original substring.\n        )\n        # Update the remaining substring after removing the prefix.\n        substring = substring[pre_len:]\n        return token_meta, substring\n", "docstring": "Makes TokenMeta data for substring which are prefixes."}
{"repo": "SyferText-master/src/syfertext/tokenizers/spacy_tokenizer.py", "original_string": "    def _get_infix_token_metas(self, substring: str) -> Tuple[List[TokenMeta], str]:\n        \"\"\"Makes list of TokenMeta data for substring which are infixes.\n        Args:\n            substring: The substring to tokenize.\n        Returns:\n            infix_tokens_metas: the list of TokenMeta objects of infixes\n                found in `substring`.\n            substring: The updated substring after processing for all infixes.\n        \"\"\"\n        # Get all the infix matches in list\n        infixes = self.infix_matches(substring)\n        # List to hold `TokenMeta` object of all infixes\n        infix_tokens_metas = []\n        # List holding start and end position of tokens\n        # created due to infixes relative to substring, starting at 0\n        positions = [0]\n        for match in infixes:\n            positions.extend([match.start(), match.end()])\n        # Adding the endpos of last token\n        positions.append(len(substring))\n        for i in range(len(positions) - 1):\n            # start and end postion of token relative to substring\n            start_pos = positions[i]\n            end_pos = positions[i + 1]\n            # Check if at the end of the substring\n            if start_pos == end_pos:\n                break\n            else:\n                # Create the TokenMeta object\n                token_meta = TokenMeta(\n                    text=str(substring[start_pos:end_pos]),\n                    space_after=False,  #  For this token space_after will be updated explicitly in end.\n                )\n                # Append the token to the infix_list\n                infix_tokens_metas.append(token_meta)\n        # There is no remaining substring\n        substring = \"\"\n        return infix_tokens_metas, substring\n", "docstring": "Makes list of TokenMeta data for substring which are infixes."}
{"repo": "SyferText-master/src/syfertext/tokenizers/spacy_tokenizer.py", "original_string": "    def infix_matches(self, substring: str) -> List[Match]:\n        \"\"\"Find internal split points of the string, such as hyphens.\n        Args:\n            substring : The string to segment.\n        Returns:\n            A list of `re.MatchObject` objects that have `.start()`\n                and `.end()` methods, denoting the placement of internal\n                segment separators, e.g. hyphens.\n        \"\"\"\n        # Return empty list if no infix matches are in substring.\n        if self.infix_finditer is None:\n            return []\n        # Return a list of MatchObject instances over all non-overlapping\n        # matches for the infixes in the substring.\n        return list(self.infix_finditer(substring))\n", "docstring": "Find internal split points of the string, such as hyphens."}
{"repo": "sqlitedict-master/sqlitedict.py", "original_string": "    def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n", "docstring": "Execute code in a namespace.\n"}
{"repo": "sqlitedict-master/sqlitedict.py", "original_string": "def open(*args, **kwargs):\n    \"\"\"See documentation of the SqliteDict class.\"\"\"\n    return SqliteDict(*args, **kwargs)\n", "docstring": "See documentation of the SqliteDict class.\n"}
{"repo": "sqlitedict-master/sqlitedict.py", "original_string": "def decode(obj):\n    \"\"\"Deserialize objects retrieved from SQLite.\"\"\"\n    return loads(bytes(obj))\n", "docstring": "Deserialize objects retrieved from SQLite.\n"}
{"repo": "sqlitedict-master/sqlitedict.py", "original_string": "    def __len__(self):\n        # `select count (*)` is super slow in sqlite (does a linear scan!!)\n        # As a result, len() is very slow too once the table size grows beyond trivial.\n        # We could keep the total count of rows ourselves, by means of triggers,\n        # but that seems too complicated and would slow down normal operation\n        # (insert/delete etc).\n        GET_LEN = 'SELECT COUNT(*) FROM \"%s\"' % self.tablename\n        rows = self.conn.select_one(GET_LEN)[0]\n        return rows if rows is not None else 0\n", "docstring": "`select count (*)` is super slow in sqlite (does a linear scan!!)"}
{"repo": "sqlitedict-master/sqlitedict.py", "original_string": "    def get_tablenames(filename):\n        \"\"\"get the names of the tables in an sqlite db as a list\"\"\"\n        if not os.path.isfile(filename):\n            raise IOError('file %s does not exist' % (filename))\n        GET_TABLENAMES = 'SELECT name FROM sqlite_master WHERE type=\"table\"'\n        with sqlite3.connect(filename) as conn:\n            cursor = conn.execute(GET_TABLENAMES)\n            res = cursor.fetchall()\n        return [name[0] for name in res]\n", "docstring": "get the names of the tables in an sqlite db as a list\n"}
{"repo": "sqlitedict-master/sqlitedict.py", "original_string": "    def __del__(self):\n        # like close(), but assume globals are gone by now (do not log!)\n        try:\n            self.close(do_log=False, force=True)\n        except Exception:\n            # prevent error log flood in case of multiple SqliteDicts\n            # closed after connection lost (exceptions are always ignored\n            # in __del__ method.\n            pass\n", "docstring": "like close(), but assume globals are gone by now (do not log!)"}
{"repo": "sqlitedict-master/sqlitedict.py", "original_string": "    def executemany(self, req, items):\n        for item in items:\n            self.execute(req, item)\n        self.check_raise_error()\n", "docstring": "for item in items:"}
{"repo": "sqlitedict-master/sqlitedict.py", "original_string": "    def select_one(self, req, arg=None):\n        \"\"\"Return only the first row of the SELECT, or None if there are no matching rows.\"\"\"\n        try:\n            return next(iter(self.select(req, arg)))\n        except StopIteration:\n            return None\n", "docstring": "Return only the first row of the SELECT, or None if there are no matching rows.\n"}
{"repo": "sqlitedict-master/tests/test_temp_db.py", "original_string": "    def test_create_sqlitedict(self):\n        ''' test_create_sqlitedict\n        '''\n        self.assertIsInstance(self.d, sqlitedict.SqliteDict)\n        self.assertEqual(dict(self.d), {})\n        self.assertEqual(list(self.d), [])\n        self.assertEqual(len(self.d), 0)\n", "docstring": "test_create_sqlitedict"}
{"repo": "sqlitedict-master/tests/test_temp_db.py", "original_string": "    def test_clear_data(self):\n        ''' test_clear_data\n        '''\n        self.d.update(a=1, b=2, c=3)\n        self.assertEqual(len(self.d), 3)\n        self.d.clear()\n        self.assertEqual(len(self.d), 0)\n", "docstring": "test_clear_data"}
{"repo": "sqlitedict-master/tests/test_temp_db.py", "original_string": "    def test_manage_few_records(self):\n        ''' test_manage_few_records\n        '''\n        self.d['abc'] = 'lmno'\n        self.d['xyz'] = 'pdq'\n        self.assertEqual(len(self.d), 2)\n        if major_version == 2:\n            self.assertEqual(list(self.d.iteritems()), [('abc', 'lmno'), ('xyz', 'pdq')])\n        self.assertEqual(list(self.d.items()), [('abc', 'lmno'), ('xyz', 'pdq')])\n        self.assertEqual(list(self.d.values()), ['lmno', 'pdq'])\n        self.assertEqual(list(self.d.keys()), ['abc', 'xyz'])\n        self.assertEqual(list(self.d), ['abc', 'xyz'])\n", "docstring": "test_manage_few_records"}
{"repo": "sqlitedict-master/tests/test_core.py", "original_string": "    def test_with_statement(self):\n        \"\"\"Verify using sqlitedict as a contextmanager . \"\"\"\n        with SqliteDict() as d:\n            self.assertTrue(isinstance(d, SqliteDict))\n            self.assertEqual(dict(d), {})\n            self.assertEqual(list(d), [])\n            self.assertEqual(len(d), 0)\n", "docstring": "Verify using sqlitedict as a contextmanager . \n"}
{"repo": "sqlitedict-master/tests/test_core.py", "original_string": "    def test_as_str(self):\n        \"\"\"Verify SqliteDict.__str__().\"\"\"\n        # given,\n        db = SqliteDict()\n        # exercise\n        db.__str__()\n        # test when db closed\n        db.close()\n        db.__str__()\n", "docstring": "Verify SqliteDict.__str__().\n"}
{"repo": "sqlitedict-master/tests/test_core.py", "original_string": "    def test_directory_notfound(self):\n        \"\"\"Verify RuntimeError: directory does not exist.\"\"\"\n        # given: a non-existent directory,\n        folder = tempfile.mkdtemp(prefix='sqlitedict-test')\n        os.rmdir(folder)\n        # exercise,\n        with self.assertRaises(RuntimeError):\n            SqliteDict(filename=os.path.join(folder, 'nonexistent'))\n", "docstring": "Verify RuntimeError: directory does not exist.\n"}
{"repo": "sqlitedict-master/tests/test_core.py", "original_string": "    def test_default_reuse_existing_flag_c(self):\n        \"\"\"Re-opening of a database does not destroy it.\"\"\"\n        # given,\n        fname = norm_file('tests/db/sqlitedict-override-test.sqlite')\n        orig_db = SqliteDict(filename=fname)\n        orig_db['key'] = 'value'\n        orig_db.commit()\n        orig_db.close()\n        next_db = SqliteDict(filename=fname)\n        self.assertIn('key', next_db.keys())\n        self.assertEqual(next_db['key'], 'value')\n", "docstring": "Re-opening of a database does not destroy it.\n"}
{"repo": "sqlitedict-master/tests/test_core.py", "original_string": "        def __test_irregular_tablenames(tablename):\n            filename = ':memory:'\n            db = SqliteDict(filename, tablename=tablename)\n            db['key'] = 'value'\n            db.commit()\n            self.assertEqual(db['key'], 'value')\n            db.close()\n", "docstring": "filename = ':memory:'"}
{"repo": "sqlitedict-master/tests/test_core.py", "original_string": "    def test_overwrite_using_flag_w(self):\n        \"\"\"Re-opening of a database with flag='w' destroys only the target table.\"\"\"\n        # given,\n        fname = norm_file('tests/db/sqlitedict-override-test.sqlite')\n        orig_db_1 = SqliteDict(filename=fname, tablename='one')\n        orig_db_1['key'] = 'value'\n        orig_db_1.commit()\n        orig_db_1.close()\n        orig_db_2 = SqliteDict(filename=fname, tablename='two')\n        orig_db_2['key'] = 'value'\n        orig_db_2.commit()\n        orig_db_2.close()\n        # verify, when re-opening table space 'one' with flag='2', we destroy\n        # its contents.  However, when re-opening table space 'two' with\n        # default flag='r', its contents remain.\n        next_db_1 = SqliteDict(filename=fname, tablename='one', flag='w')\n        self.assertNotIn('key', next_db_1.keys())\n        next_db_2 = SqliteDict(filename=fname, tablename='two')\n        self.assertIn('key', next_db_2.keys())\n", "docstring": "Re-opening of a database with flag='w' destroys only the target table.\n"}
{"repo": "sqlitedict-master/tests/test_core.py", "original_string": "    def test_terminate_instead_close(self):\n        ''' make terminate() instead of close()\n        '''\n        d = sqlitedict.open('tests/db/sqlitedict-terminate.sqlite')\n        d['abc'] = 'def'\n        d.commit()\n        self.assertEqual(d['abc'], 'def')\n        d.terminate()\n        self.assertFalse(os.path.isfile('tests/db/sqlitedict-terminate.sqlite'))\n", "docstring": "make terminate() instead of close()"}
{"repo": "sqlitedict-master/tests/test_core.py", "original_string": "    def test_terminate_cannot_delete(self):\n        # exercise,\n        self.db.terminate()  # deletion failed, but no exception raised!\n        # verify,\n        os.chmod(os.path.dirname(self.fname), 0o700)\n        os.chmod(self.fname, 0o600)\n        self.assertTrue(os.path.exists(self.fname))\n", "docstring": "exercise,"}
{"repo": "sqlitedict-master/tests/test_onimport.py", "original_string": "    def test_cpickle_fallback_to_pickle(self):\n        # exercise,\n        sqlitedict = __import__(\"sqlitedict\")\n        # verify,\n        self.assertIn('pickle', sys.modules.keys())\n        self.assertIs(sqlitedict.dumps, sys.modules['pickle'].dumps)\n", "docstring": "exercise,"}
{"repo": "sqlitedict-master/tests/test_onimport.py", "original_string": "    def setUp(self):\n        # manually monkeypatch sys.version_info\n        self._orig_version_info = sys.version_info\n        sys.version_info = (2, 4, 0, 'does-not-matter', 0)\n        self.orig_sqlitedict = sys.modules.pop('sqlitedict', None)\n", "docstring": "manually monkeypatch sys.version_info"}
{"repo": "pexpect-master/tools/display-terminalinfo.py", "original_string": "def display_bitmask(kind, bitmap, value):\n    \"\"\" Display all matching bitmask values for ``value`` given ``bitmap``. \"\"\"\n    col1_width = max(map(len, list(bitmap.keys()) + [kind]))\n    col2_width = 7\n    FMT = '{name:>{col1_width}} {value:>{col2_width}}   {description}'\n    print(FMT.format(name=kind,\n                     value='Value',\n                     description='Description',\n                     col1_width=col1_width,\n                     col2_width=col2_width))\n    print('{0} {1}   {2}'.format('-' * col1_width,\n                                 '-' * col2_width,\n                                 '-' * max(map(len, bitmap.values()))))\n    for flag_name, description in bitmap.items():\n        try:\n            bitmask = getattr(termios, flag_name)\n            bit_val = 'on' if bool(value & bitmask) else 'off'\n        except AttributeError:\n            bit_val = 'undef'\n        print(FMT.format(name=flag_name,\n                         value=bit_val,\n                         description=description,\n                         col1_width=col1_width,\n                         col2_width=col2_width))\n    print()\n", "docstring": "Display all matching bitmask values for ``value`` given ``bitmap``. \n"}
{"repo": "pexpect-master/examples/chess2.py", "original_string": "        def expect_region (self):\n            '''This is another method that would be moved into the\n            screen class.\n            '''\n            pass\n", "docstring": "This is another method that would be moved into the"}
{"repo": "pexpect-master/examples/topip.py", "original_string": "def send_alert (message, subject, addr_from, addr_to, smtp_server='localhost'):\n    '''This sends an email alert.\n    '''\n    message = ( 'From: %s\\r\\nTo: %s\\r\\nSubject: %s\\r\\n\\r\\n'\n            % (addr_from, addr_to, subject) + message )\n    server = smtplib.SMTP(smtp_server)\n    server.sendmail(addr_from, addr_to, message)\n    server.quit()\n", "docstring": "This sends an email alert."}
{"repo": "pexpect-master/examples/ssh_tunnel.py", "original_string": "def get_process_info ():\n    # This seems to work on both Linux and BSD, but should otherwise be considered highly UNportable.\n    ps = pexpect.run ('ps ax -O ppid')\n    pass\n", "docstring": "This seems to work on both Linux and BSD, but should otherwise be considered highly UNportable."}
{"repo": "pexpect-master/examples/script.py", "original_string": "def sigwinch_passthrough (sig, data):\n    # Check for buggy platforms (see pexpect.setwinsize()).\n    if 'TIOCGWINSZ' in dir(termios):\n        TIOCGWINSZ = termios.TIOCGWINSZ\n    else:\n        TIOCGWINSZ = 1074295912 # assume\n    s = struct.pack (\"HHHH\", 0, 0, 0, 0)\n    a = struct.unpack ('HHHH', fcntl.ioctl(sys.stdout.fileno(), TIOCGWINSZ , s))\n    global global_pexpect_instance\n    global_pexpect_instance.setwinsize(a[0],a[1])\n", "docstring": "Check for buggy platforms (see pexpect.setwinsize())."}
{"repo": "pexpect-master/examples/hive.py", "original_string": "def login (args, cli_username=None, cli_password=None):\n    # I have to keep a separate list of host names because Python dicts are not ordered.\n    # I want to keep the same order as in the args list.\n    host_names = []\n    hive_connect_info = {}\n    hive = {}\n    # build up the list of connection information (hostname, username, password, port)\n    for host_connect_string in args:\n        hcd = parse_host_connect_string (host_connect_string)\n        hostname = hcd['hostname']\n        port     = hcd['port']\n        if port == '':\n            port = None\n        if len(hcd['username']) > 0:\n            username = hcd['username']\n        elif cli_username is not None:\n            username = cli_username\n        else:\n            username = raw_input('%s username: ' % hostname)\n        if len(hcd['password']) > 0:\n            password = hcd['password']\n        elif cli_password is not None:\n            password = cli_password\n        else:\n            password = getpass.getpass('%s password: ' % hostname)\n        host_names.append(hostname)\n        hive_connect_info[hostname] = (hostname, username, password, port)\n    # build up the list of hive connections using the connection information.\n    for hostname in host_names:\n        print('connecting to', hostname)\n        try:\n            fout = file(\"log_\"+hostname, \"w\")\n            hive[hostname] = pxssh.pxssh()\n            # Disable host key checking.\n            hive[hostname].SSH_OPTS = (hive[hostname].SSH_OPTS\n                    + \" -o 'StrictHostKeyChecking=no'\"\n                    + \" -o 'UserKnownHostsFile /dev/null' \")\n            hive[hostname].force_password = True\n            hive[hostname].login(*hive_connect_info[hostname])\n            print(hive[hostname].before)\n            hive[hostname].logfile = fout\n            print('- OK')\n        except Exception as e:\n            print('- ERROR', end=' ')\n            print(str(e))\n            print('Skipping', hostname)\n            hive[hostname] = None\n    return host_names, hive\n", "docstring": "I have to keep a separate list of host names because Python dicts are not ordered."}
{"repo": "pexpect-master/examples/hive.py", "original_string": "def refresh (hive, hive_names, timeout=0.5):\n    '''This waits for the TIMEOUT on each host.\n    '''\n    # TODO This is ideal for threading.\n    for hostname in hive_names:\n        if hive[hostname] is not None:\n            hive[hostname].expect([pexpect.TIMEOUT,pexpect.EOF],timeout=timeout)\n", "docstring": "This waits for the TIMEOUT on each host."}
{"repo": "pexpect-master/examples/hive.py", "original_string": "def parse_host_connect_string (hcs):\n    '''This parses a host connection string in the form\n    username:password@hostname:port. All fields are optional except hostname. A\n    dictionary is returned with all four keys. Keys that were not included are\n    set to empty strings ''. Note that if your password has the '@' character\n    then you must backslash escape it. '''\n    if '@' in hcs:\n        p = re.compile (r'(?P<username>[^@:]*)(:?)(?P<password>.*)(?!\\\\)@(?P<hostname>[^:]*):?(?P<port>[0-9]*)')\n    else:\n        p = re.compile (r'(?P<username>)(?P<password>)(?P<hostname>[^:]*):?(?P<port>[0-9]*)')\n    m = p.search (hcs)\n    d = m.groupdict()\n    d['password'] = d['password'].replace('\\\\@','@')\n    return d\n", "docstring": "This parses a host connection string in the form"}
{"repo": "pexpect-master/pexpect/_async.py", "original_string": "def expect_async(expecter, timeout=None):\n    # First process data that was previously read - if it maches, we don't need\n    # async stuff.\n    idx = expecter.existing_data()\n    if idx is not None:\n        return idx\n    if not expecter.spawn.async_pw_transport:\n        pw = PatternWaiter()\n        pw.set_expecter(expecter)\n        transport, pw = yield from asyncio.get_event_loop()\\\n            .connect_read_pipe(lambda: pw, expecter.spawn)\n        expecter.spawn.async_pw_transport = pw, transport\n    else:\n        pw, transport = expecter.spawn.async_pw_transport\n        pw.set_expecter(expecter)\n        transport.resume_reading()\n    try:\n        return (yield from asyncio.wait_for(pw.fut, timeout))\n    except asyncio.TimeoutError as e:\n        transport.pause_reading()\n        return expecter.timeout(e)\n", "docstring": "First process data that was previously read - if it maches, we don't need"}
{"repo": "pexpect-master/pexpect/expect.py", "original_string": "    def existing_data(self):\n        # First call from a new call to expect_loop or expect_async.\n        # self.searchwindowsize may have changed.\n        # Treat all data as fresh.\n        spawn = self.spawn\n        before_len = spawn._before.tell()\n        buf_len = spawn._buffer.tell()\n        freshlen = before_len\n        if before_len > buf_len:\n            if not self.searchwindowsize:\n                spawn._buffer = spawn.buffer_type()\n                window = spawn._before.getvalue()\n                spawn._buffer.write(window)\n            elif buf_len < self.searchwindowsize:\n                spawn._buffer = spawn.buffer_type()\n                spawn._before.seek(\n                    max(0, before_len - self.searchwindowsize))\n                window = spawn._before.read()\n                spawn._buffer.write(window)\n            else:\n                spawn._buffer.seek(max(0, buf_len - self.searchwindowsize))\n                window = spawn._buffer.read()\n        else:\n            if self.searchwindowsize:\n                spawn._buffer.seek(max(0, buf_len - self.searchwindowsize))\n                window = spawn._buffer.read()\n            else:\n                window = spawn._buffer.getvalue()\n        return self.do_search(window, freshlen)\n", "docstring": "First call from a new call to expect_loop or expect_async."}
{"repo": "pexpect-master/pexpect/expect.py", "original_string": "    def __init__(self, strings):\n        '''This creates an instance of searcher_string. This argument 'strings'\n        may be a list; a sequence of strings; or the EOF or TIMEOUT types. '''\n        self.eof_index = -1\n        self.timeout_index = -1\n        self._strings = []\n        self.longest_string = 0\n        for n, s in enumerate(strings):\n            if s is EOF:\n                self.eof_index = n\n                continue\n            if s is TIMEOUT:\n                self.timeout_index = n\n                continue\n            self._strings.append((n, s))\n            if len(s) > self.longest_string:\n                self.longest_string = len(s)\n", "docstring": "This creates an instance of searcher_string. This argument 'strings'"}
{"repo": "pexpect-master/pexpect/expect.py", "original_string": "    def search(self, buffer, freshlen, searchwindowsize=None):\n        '''This searches 'buffer' for the first occurrence of one of the search\n        strings.  'freshlen' must indicate the number of bytes at the end of\n        'buffer' which have not been searched before. It helps to avoid\n        searching the same, possibly big, buffer over and over again.\n        See class spawn for the 'searchwindowsize' argument.\n        If there is a match this returns the index of that string, and sets\n        'start', 'end' and 'match'. Otherwise, this returns -1. '''\n        first_match = None\n        # 'freshlen' helps a lot here. Further optimizations could\n        # possibly include:\n        #\n        # using something like the Boyer-Moore Fast String Searching\n        # Algorithm; pre-compiling the search through a list of\n        # strings into something that can scan the input once to\n        # search for all N strings; realize that if we search for\n        # ['bar', 'baz'] and the input is '...foo' we need not bother\n        # rescanning until we've read three more bytes.\n        #\n        # Sadly, I don't know enough about this interesting topic. /grahn\n        for index, s in self._strings:\n            if searchwindowsize is None:\n                # the match, if any, can only be in the fresh data,\n                # or at the very end of the old data\n                offset = -(freshlen + len(s))\n            else:\n                # better obey searchwindowsize\n                offset = -searchwindowsize\n            n = buffer.find(s, offset)\n            if n >= 0 and (first_match is None or n < first_match):\n                first_match = n\n                best_index, best_match = index, s\n        if first_match is None:\n            return -1\n        self.match = best_match\n        self.start = first_match\n        self.end = self.start + len(self.match)\n        return best_index\n", "docstring": "This searches 'buffer' for the first occurrence of one of the search"}
{"repo": "pexpect-master/pexpect/expect.py", "original_string": "    def __init__(self, patterns):\n        '''This creates an instance that searches for 'patterns' Where\n        'patterns' may be a list or other sequence of compiled regular\n        expressions, or the EOF or TIMEOUT types.'''\n        self.eof_index = -1\n        self.timeout_index = -1\n        self._searches = []\n        for n, s in enumerate(patterns):\n            if s is EOF:\n                self.eof_index = n\n                continue\n            if s is TIMEOUT:\n                self.timeout_index = n\n                continue\n            self._searches.append((n, s))\n", "docstring": "This creates an instance that searches for 'patterns' Where"}
{"repo": "pexpect-master/pexpect/popen_spawn.py", "original_string": "    def write(self, s):\n        '''This is similar to send() except that there is no return value.\n        '''\n        self.send(s)\n", "docstring": "This is similar to send() except that there is no return value."}
{"repo": "pexpect-master/pexpect/popen_spawn.py", "original_string": "    def send(self, s):\n        '''Send data to the subprocess' stdin.\n        Returns the number of bytes written.\n        '''\n        s = self._coerce_send_string(s)\n        self._log(s, 'send')\n        b = self._encoder.encode(s, final=False)\n        if PY3:\n            return self.proc.stdin.write(b)\n        else:\n            # On Python 2, .write() returns None, so we return the length of\n            # bytes written ourselves. This assumes they all got written.\n            self.proc.stdin.write(b)\n            return len(b)\n", "docstring": "Send data to the subprocess' stdin."}
{"repo": "pexpect-master/pexpect/popen_spawn.py", "original_string": "    def wait(self):\n        '''Wait for the subprocess to finish.\n        Returns the exit code.\n        '''\n        status = self.proc.wait()\n        if status >= 0:\n            self.exitstatus = status\n            self.signalstatus = None\n        else:\n            self.exitstatus = None\n            self.signalstatus = -status\n        self.terminated = True\n        return status\n", "docstring": "Wait for the subprocess to finish."}
{"repo": "pexpect-master/pexpect/utils.py", "original_string": "def is_executable_file(path):\n    \"\"\"Checks that path is an executable regular file, or a symlink towards one.\n    This is roughly ``os.path isfile(path) and os.access(path, os.X_OK)``.\n    \"\"\"\n    # follow symlinks,\n    fpath = os.path.realpath(path)\n    if not os.path.isfile(fpath):\n        # non-files (directories, fifo, etc.)\n        return False\n    mode = os.stat(fpath).st_mode\n    if (sys.platform.startswith('sunos')\n            and os.getuid() == 0):\n        # When root on Solaris, os.X_OK is True for *all* files, irregardless\n        # of their executability -- instead, any permission bit of any user,\n        # group, or other is fine enough.\n        #\n        # (This may be true for other \"Unix98\" OS's such as HP-UX and AIX)\n        return bool(mode & (stat.S_IXUSR |\n                            stat.S_IXGRP |\n                            stat.S_IXOTH))\n    return os.access(fpath, os.X_OK)\n", "docstring": "Checks that path is an executable regular file, or a symlink towards one."}
{"repo": "pexpect-master/pexpect/utils.py", "original_string": "def split_command_line(command_line):\n    '''This splits a command line into a list of arguments. It splits arguments\n    on spaces, but handles embedded quotes, doublequotes, and escaped\n    characters. It's impossible to do this with a regular expression, so I\n    wrote a little state machine to parse the command line. '''\n    arg_list = []\n    arg = ''\n    # Constants to name the states we can be in.\n    state_basic = 0\n    state_esc = 1\n    state_singlequote = 2\n    state_doublequote = 3\n    # The state when consuming whitespace between commands.\n    state_whitespace = 4\n    state = state_basic\n    for c in command_line:\n        if state == state_basic or state == state_whitespace:\n            if c == '\\\\':\n                # Escape the next character\n                state = state_esc\n            elif c == r\"'\":\n                # Handle single quote\n                state = state_singlequote\n            elif c == r'\"':\n                # Handle double quote\n                state = state_doublequote\n            elif c.isspace():\n                # Add arg to arg_list if we aren't in the middle of whitespace.\n                if state == state_whitespace:\n                    # Do nothing.\n                    None\n                else:\n                    arg_list.append(arg)\n                    arg = ''\n                    state = state_whitespace\n            else:\n                arg = arg + c\n                state = state_basic\n        elif state == state_esc:\n            arg = arg + c\n            state = state_basic\n        elif state == state_singlequote:\n            if c == r\"'\":\n                state = state_basic\n            else:\n                arg = arg + c\n        elif state == state_doublequote:\n            if c == r'\"':\n                state = state_basic\n            else:\n                arg = arg + c\n    if arg != '':\n        arg_list.append(arg)\n    return arg_list\n", "docstring": "This splits a command line into a list of arguments. It splits arguments"}
{"repo": "pexpect-master/pexpect/fdpexpect.py", "original_string": "    def isalive (self):\n        '''This checks if the file descriptor is still valid. If :func:`os.fstat`\n        does not raise an exception then we assume it is alive. '''\n        if self.child_fd == -1:\n            return False\n        try:\n            os.fstat(self.child_fd)\n            return True\n        except:\n            return False\n", "docstring": "This checks if the file descriptor is still valid. If :func:`os.fstat`"}
{"repo": "pexpect-master/pexpect/pty_spawn.py", "original_string": "def _wrap_ptyprocess_err():\n    \"\"\"Turn ptyprocess errors into our own ExceptionPexpect errors\"\"\"\n    try:\n        yield\n    except ptyprocess.PtyProcessError as e:\n        raise ExceptionPexpect(*e.args)\n", "docstring": "Turn ptyprocess errors into our own ExceptionPexpect errors\n"}
{"repo": "pexpect-master/pexpect/pty_spawn.py", "original_string": "    def close(self, force=True):\n        '''This closes the connection with the child application. Note that\n        calling close() more than once is valid. This emulates standard Python\n        behavior with files. Set force to True if you want to make sure that\n        the child is terminated (SIGKILL is sent if the child ignores SIGHUP\n        and SIGINT). '''\n        self.flush()\n        with _wrap_ptyprocess_err():\n            # PtyProcessError may be raised if it is not possible to terminate\n            # the child.\n            self.ptyproc.close(force=force)\n        self.isalive()  # Update exit status from ptyproc\n        self.child_fd = -1\n        self.closed = True\n", "docstring": "This closes the connection with the child application. Note that"}
{"repo": "pexpect-master/pexpect/pty_spawn.py", "original_string": "    def waitnoecho(self, timeout=-1):\n        '''This waits until the terminal ECHO flag is set False. This returns\n        True if the echo mode is off. This returns False if the ECHO flag was\n        not set False before the timeout. This can be used to detect when the\n        child is waiting for a password. Usually a child application will turn\n        off echo mode when it is waiting for the user to enter a password. For\n        example, instead of expecting the \"password:\" prompt you can wait for\n        the child to set ECHO off::\n            p = pexpect.spawn('ssh user@example.com')\n            p.waitnoecho()\n            p.sendline(mypassword)\n        If timeout==-1 then this method will use the value in self.timeout.\n        If timeout==None then this method to block until ECHO flag is False.\n        '''\n        if timeout == -1:\n            timeout = self.timeout\n        if timeout is not None:\n            end_time = time.time() + timeout\n        while True:\n            if not self.getecho():\n                return True\n            if timeout < 0 and timeout is not None:\n                return False\n            if timeout is not None:\n                timeout = end_time - time.time()\n            time.sleep(0.1)\n", "docstring": "This waits until the terminal ECHO flag is set False. This returns"}
{"repo": "pexpect-master/pexpect/pty_spawn.py", "original_string": "    def setecho(self, state):\n        '''This sets the terminal echo mode on or off. Note that anything the\n        child sent before the echo will be lost, so you should be sure that\n        your input buffer is empty before you call setecho(). For example, the\n        following will work as expected::\n            p = pexpect.spawn('cat') # Echo is on by default.\n            p.sendline('1234') # We expect see this twice from the child...\n            p.expect(['1234']) # ... once from the tty echo...\n            p.expect(['1234']) # ... and again from cat itself.\n            p.setecho(False) # Turn off tty echo\n            p.sendline('abcd') # We will set this only once (echoed by cat).\n            p.sendline('wxyz') # We will set this only once (echoed by cat)\n            p.expect(['abcd'])\n            p.expect(['wxyz'])\n        The following WILL NOT WORK because the lines sent before the setecho\n        will be lost::\n            p = pexpect.spawn('cat')\n            p.sendline('1234')\n            p.setecho(False) # Turn off tty echo\n            p.sendline('abcd') # We will set this only once (echoed by cat).\n            p.sendline('wxyz') # We will set this only once (echoed by cat)\n            p.expect(['1234'])\n            p.expect(['1234'])\n            p.expect(['abcd'])\n            p.expect(['wxyz'])\n        Not supported on platforms where ``isatty()`` returns False.\n        '''\n        return self.ptyproc.setecho(state)\n", "docstring": "This sets the terminal echo mode on or off. Note that anything the"}
{"repo": "pexpect-master/pexpect/pty_spawn.py", "original_string": "    def write(self, s):\n        '''This is similar to send() except that there is no return value.\n        '''\n        self.send(s)\n", "docstring": "This is similar to send() except that there is no return value."}
{"repo": "pexpect-master/pexpect/pty_spawn.py", "original_string": "    def send(self, s):\n        '''Sends string ``s`` to the child process, returning the number of\n        bytes written. If a logfile is specified, a copy is written to that\n        log.\n        The default terminal input mode is canonical processing unless set\n        otherwise by the child process. This allows backspace and other line\n        processing to be performed prior to transmitting to the receiving\n        program. As this is buffered, there is a limited size of such buffer.\n        On Linux systems, this is 4096 (defined by N_TTY_BUF_SIZE). All\n        other systems honor the POSIX.1 definition PC_MAX_CANON -- 1024\n        on OSX, 256 on OpenSolaris, and 1920 on FreeBSD.\n        This value may be discovered using fpathconf(3)::\n            >>> from os import fpathconf\n            >>> print(fpathconf(0, 'PC_MAX_CANON'))\n            256\n        On such a system, only 256 bytes may be received per line. Any\n        subsequent bytes received will be discarded. BEL (``'\\a'``) is then\n        sent to output if IMAXBEL (termios.h) is set by the tty driver.\n        This is usually enabled by default.  Linux does not honor this as\n        an option -- it behaves as though it is always set on.\n        Canonical input processing may be disabled altogether by executing\n        a shell, then stty(1), before executing the final program::\n            >>> bash = pexpect.spawn('/bin/bash', echo=False)\n            >>> bash.sendline('stty -icanon')\n            >>> bash.sendline('base64')\n            >>> bash.sendline('x' * 5000)\n        '''\n        if self.delaybeforesend is not None:\n            time.sleep(self.delaybeforesend)\n        s = self._coerce_send_string(s)\n        self._log(s, 'send')\n        b = self._encoder.encode(s, final=False)\n        return os.write(self.child_fd, b)\n", "docstring": "Sends string ``s`` to the child process, returning the number of"}
{"repo": "pexpect-master/pexpect/pty_spawn.py", "original_string": "    def _log_control(self, s):\n        \"\"\"Write control characters to the appropriate log files\"\"\"\n        if self.encoding is not None:\n            s = s.decode(self.encoding, 'replace')\n        self._log(s, 'send')\n", "docstring": "Write control characters to the appropriate log files\n"}
{"repo": "pexpect-master/pexpect/pty_spawn.py", "original_string": "    def sendeof(self):\n        '''This sends an EOF to the child. This sends a character which causes\n        the pending parent output buffer to be sent to the waiting child\n        program without waiting for end-of-line. If it is the first character\n        of the line, the read() in the user program returns 0, which signifies\n        end-of-file. This means to work as expected a sendeof() has to be\n        called at the beginning of a line. This method does not send a newline.\n        It is the responsibility of the caller to ensure the eof is sent at the\n        beginning of a line. '''\n        n, byte = self.ptyproc.sendeof()\n        self._log_control(byte)\n", "docstring": "This sends an EOF to the child. This sends a character which causes"}
{"repo": "pexpect-master/pexpect/pty_spawn.py", "original_string": "    def terminate(self, force=False):\n        '''This forces a child process to terminate. It starts nicely with\n        SIGHUP and SIGINT. If \"force\" is True then moves onto SIGKILL. This\n        returns True if the child was terminated. This returns False if the\n        child could not be terminated. '''\n        if not self.isalive():\n            return True\n        try:\n            self.kill(signal.SIGHUP)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            self.kill(signal.SIGCONT)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            self.kill(signal.SIGINT)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            if force:\n                self.kill(signal.SIGKILL)\n                time.sleep(self.delayafterterminate)\n                if not self.isalive():\n                    return True\n                else:\n                    return False\n            return False\n        except OSError:\n            # I think there are kernel timing issues that sometimes cause\n            # this to happen. I think isalive() reports True, but the\n            # process is dead to the kernel.\n            # Make one last attempt to see if the kernel is up to date.\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            else:\n                return False\n", "docstring": "This forces a child process to terminate. It starts nicely with"}
{"repo": "pexpect-master/pexpect/pty_spawn.py", "original_string": "    def isalive(self):\n        '''This tests if the child process is running or not. This is\n        non-blocking. If the child was terminated then this will read the\n        exitstatus or signalstatus of the child. This returns True if the child\n        process appears to be running or False if not. It can take literally\n        SECONDS for Solaris to return the right status. '''\n        ptyproc = self.ptyproc\n        with _wrap_ptyprocess_err():\n            alive = ptyproc.isalive()\n        if not alive:\n            self.status = ptyproc.status\n            self.exitstatus = ptyproc.exitstatus\n            self.signalstatus = ptyproc.signalstatus\n            self.terminated = True\n        return alive\n", "docstring": "This tests if the child process is running or not. This is"}
{"repo": "pexpect-master/pexpect/pty_spawn.py", "original_string": "    def getwinsize(self):\n        '''This returns the terminal window size of the child tty. The return\n        value is a tuple of (rows, cols). '''\n        return self.ptyproc.getwinsize()\n", "docstring": "This returns the terminal window size of the child tty. The return"}
{"repo": "pexpect-master/pexpect/pty_spawn.py", "original_string": "    def __interact_read(self, fd):\n        '''This is used by the interact() method.\n        '''\n        return os.read(fd, 1000)\n", "docstring": "This is used by the interact() method."}
{"repo": "pexpect-master/pexpect/spawnbase.py", "original_string": "    def read_nonblocking(self, size=1, timeout=None):\n        \"\"\"This reads data from the file descriptor.\n        This is a simple implementation suitable for a regular file. Subclasses using ptys or pipes should override it.\n        The timeout parameter is ignored.\n        \"\"\"\n        try:\n            s = os.read(self.child_fd, size)\n        except OSError as err:\n            if err.args[0] == errno.EIO:\n                # Linux-style EOF\n                self.flag_eof = True\n                raise EOF('End Of File (EOF). Exception style platform.')\n            raise\n        if s == b'':\n            # BSD-style EOF\n            self.flag_eof = True\n            raise EOF('End Of File (EOF). Empty string style platform.')\n        s = self._decoder.decode(s, final=False)\n        self._log(s, 'read')\n        return s\n", "docstring": "This reads data from the file descriptor."}
{"repo": "pexpect-master/pexpect/spawnbase.py", "original_string": "    def compile_pattern_list(self, patterns):\n        '''This compiles a pattern-string or a list of pattern-strings.\n        Patterns must be a StringType, EOF, TIMEOUT, SRE_Pattern, or a list of\n        those. Patterns may also be None which results in an empty list (you\n        might do this if waiting for an EOF or TIMEOUT condition without\n        expecting any pattern).\n        This is used by expect() when calling expect_list(). Thus expect() is\n        nothing more than::\n             cpl = self.compile_pattern_list(pl)\n             return self.expect_list(cpl, timeout)\n        If you are using expect() within a loop it may be more\n        efficient to compile the patterns first and then call expect_list().\n        This avoid calls in a loop to compile_pattern_list()::\n             cpl = self.compile_pattern_list(my_pattern)\n             while some_condition:\n                ...\n                i = self.expect_list(cpl, timeout)\n                ...\n        '''\n        if patterns is None:\n            return []\n        if not isinstance(patterns, list):\n            patterns = [patterns]\n        # Allow dot to match \\n\n        compile_flags = re.DOTALL\n        if self.ignorecase:\n            compile_flags = compile_flags | re.IGNORECASE\n        compiled_pattern_list = []\n        for idx, p in enumerate(patterns):\n            if isinstance(p, self.allowed_string_types):\n                p = self._coerce_expect_string(p)\n                compiled_pattern_list.append(re.compile(p, compile_flags))\n            elif p is EOF:\n                compiled_pattern_list.append(EOF)\n            elif p is TIMEOUT:\n                compiled_pattern_list.append(TIMEOUT)\n            elif isinstance(p, type(re.compile(''))):\n                compiled_pattern_list.append(p)\n            else:\n                self._pattern_type_err(p)\n        return compiled_pattern_list\n", "docstring": "This compiles a pattern-string or a list of pattern-strings."}
{"repo": "pexpect-master/pexpect/spawnbase.py", "original_string": "    def expect_loop(self, searcher, timeout=-1, searchwindowsize=-1):\n        '''This is the common loop used inside expect. The 'searcher' should be\n        an instance of searcher_re or searcher_string, which describes how and\n        what to search for in the input.\n        See expect() for other arguments, return value and exceptions. '''\n        exp = Expecter(self, searcher, searchwindowsize)\n        return exp.expect_loop(timeout)\n", "docstring": "This is the common loop used inside expect. The 'searcher' should be"}
{"repo": "pexpect-master/pexpect/spawnbase.py", "original_string": "    def readline(self, size=-1):\n        '''This reads and returns one entire line. The newline at the end of\n        line is returned as part of the string, unless the file ends without a\n        newline. An empty string is returned if EOF is encountered immediately.\n        This looks for a newline as a CR/LF pair (\\\\r\\\\n) even on UNIX because\n        this is what the pseudotty device returns. So contrary to what you may\n        expect you will receive newlines as \\\\r\\\\n.\n        If the size argument is 0 then an empty string is returned. In all\n        other cases the size argument is ignored, which is not standard\n        behavior for a file-like object. '''\n        if size == 0:\n            return self.string_type()\n        # delimiter default is EOF\n        index = self.expect([self.crlf, self.delimiter])\n        if index == 0:\n            return self.before + self.crlf\n        else:\n            return self.before\n", "docstring": "This reads and returns one entire line. The newline at the end of"}
{"repo": "pexpect-master/pexpect/spawnbase.py", "original_string": "    def readlines(self, sizehint=-1):\n        '''This reads until EOF using readline() and returns a list containing\n        the lines thus read. The optional 'sizehint' argument is ignored.\n        Remember, because this reads until EOF that means the child\n        process should have closed its stdout. If you run this method on\n        a child that is still running with its stdout open then this\n        method will block until it timesout.'''\n        lines = []\n        while True:\n            line = self.readline()\n            if not line:\n                break\n            lines.append(line)\n        return lines\n", "docstring": "This reads until EOF using readline() and returns a list containing"}
{"repo": "pexpect-master/pexpect/spawnbase.py", "original_string": "    def flush(self):\n        '''This does nothing. It is here to support the interface for a\n        File-like object. '''\n        pass\n", "docstring": "This does nothing. It is here to support the interface for a"}
{"repo": "pexpect-master/pexpect/FSM.py", "original_string": "    def __init__(self, initial_state, memory=None):\n        '''This creates the FSM. You set the initial state here. The \"memory\"\n        attribute is any object that you want to pass along to the action\n        functions. It is not used by the FSM. For parsing you would typically\n        pass a list to be used as a stack. '''\n        # Map (input_symbol, current_state) --> (action, next_state).\n        self.state_transitions = {}\n        # Map (current_state) --> (action, next_state).\n        self.state_transitions_any = {}\n        self.default_transition = None\n        self.input_symbol = None\n        self.initial_state = initial_state\n        self.current_state = self.initial_state\n        self.next_state = None\n        self.action = None\n        self.memory = memory\n", "docstring": "This creates the FSM. You set the initial state here. The \"memory\""}
{"repo": "pexpect-master/pexpect/FSM.py", "original_string": "    def add_transition (self, input_symbol, state, action=None, next_state=None):\n        '''This adds a transition that associates:\n                (input_symbol, current_state) --> (action, next_state)\n        The action may be set to None in which case the process() method will\n        ignore the action and only set the next_state. The next_state may be\n        set to None in which case the current state will be unchanged.\n        You can also set transitions for a list of symbols by using\n        add_transition_list(). '''\n        if next_state is None:\n            next_state = state\n        self.state_transitions[(input_symbol, state)] = (action, next_state)\n", "docstring": "This adds a transition that associates:"}
{"repo": "pexpect-master/pexpect/FSM.py", "original_string": "    def add_transition_any (self, state, action=None, next_state=None):\n        '''This adds a transition that associates:\n                (current_state) --> (action, next_state)\n        That is, any input symbol will match the current state.\n        The process() method checks the \"any\" state associations after it first\n        checks for an exact match of (input_symbol, current_state).\n        The action may be set to None in which case the process() method will\n        ignore the action and only set the next_state. The next_state may be\n        set to None in which case the current state will be unchanged. '''\n        if next_state is None:\n            next_state = state\n        self.state_transitions_any [state] = (action, next_state)\n", "docstring": "This adds a transition that associates:"}
{"repo": "pexpect-master/pexpect/FSM.py", "original_string": "    def get_transition (self, input_symbol, state):\n        '''This returns (action, next state) given an input_symbol and state.\n        This does not modify the FSM state, so calling this method has no side\n        effects. Normally you do not call this method directly. It is called by\n        process().\n        The sequence of steps to check for a defined transition goes from the\n        most specific to the least specific.\n        1. Check state_transitions[] that match exactly the tuple,\n            (input_symbol, state)\n        2. Check state_transitions_any[] that match (state)\n            In other words, match a specific state and ANY input_symbol.\n        3. Check if the default_transition is defined.\n            This catches any input_symbol and any state.\n            This is a handler for errors, undefined states, or defaults.\n        4. No transition was defined. If we get here then raise an exception.\n        '''\n        if (input_symbol, state) in self.state_transitions:\n            return self.state_transitions[(input_symbol, state)]\n        elif state in self.state_transitions_any:\n            return self.state_transitions_any[state]\n        elif self.default_transition is not None:\n            return self.default_transition\n        else:\n            raise ExceptionFSM ('Transition is undefined: (%s, %s).' %\n                (str(input_symbol), str(state)) )\n", "docstring": "This returns (action, next state) given an input_symbol and state."}
{"repo": "pexpect-master/pexpect/FSM.py", "original_string": "    def process_list (self, input_symbols):\n        '''This takes a list and sends each element to process(). The list may\n        be a string or any iterable object. '''\n        for s in input_symbols:\n            self.process (s)\n", "docstring": "This takes a list and sends each element to process(). The list may"}
{"repo": "pexpect-master/pexpect/FSM.py", "original_string": "def main():\n    '''This is where the example starts and the FSM state transitions are\n    defined. Note that states are strings (such as 'INIT'). This is not\n    necessary, but it makes the example easier to read. '''\n    f = FSM ('INIT', [])\n    f.set_default_transition (Error, 'INIT')\n    f.add_transition_any  ('INIT', None, 'INIT')\n    f.add_transition      ('=',               'INIT',            DoEqual,          'INIT')\n    f.add_transition_list (string.digits,     'INIT',            BeginBuildNumber, 'BUILDING_NUMBER')\n    f.add_transition_list (string.digits,     'BUILDING_NUMBER', BuildNumber,      'BUILDING_NUMBER')\n    f.add_transition_list (string.whitespace, 'BUILDING_NUMBER', EndBuildNumber,   'INIT')\n    f.add_transition_list ('+-*/',            'INIT',            DoOperator,       'INIT')\n    print()\n    print('Enter an RPN Expression.')\n    print('Numbers may be integers. Operators are * / + -')\n    print('Use the = sign to evaluate and print the expression.')\n    print('For example: ')\n    print('    167 3 2 2 * * * 1 - =')\n    inputstr = (input if PY3 else raw_input)('> ')  # analysis:ignore\n    f.process_list(inputstr)\n", "docstring": "This is where the example starts and the FSM state transitions are"}
{"repo": "pexpect-master/pexpect/exceptions.py", "original_string": "    def get_trace(self):\n        '''This returns an abbreviated stack trace with lines that only concern\n        the caller. In other words, the stack trace inside the Pexpect module\n        is not included. '''\n        tblist = traceback.extract_tb(sys.exc_info()[2])\n        tblist = [item for item in tblist if ('pexpect/__init__' not in item[0])\n                                           and ('pexpect/expect' not in item[0])]\n        tblist = traceback.format_list(tblist)\n        return ''.join(tblist)\n", "docstring": "This returns an abbreviated stack trace with lines that only concern"}
{"repo": "pexpect-master/pexpect/replwrap.py", "original_string": "def python(command=sys.executable):\n    \"\"\"Start a Python shell and return a :class:`REPLWrapper` object.\"\"\"\n    return REPLWrapper(command, u\">>> \", u\"import sys; sys.ps1={0!r}; sys.ps2={1!r}\")\n", "docstring": "Start a Python shell and return a :class:`REPLWrapper` object.\n"}
{"repo": "pexpect-master/pexpect/pxssh.py", "original_string": "    def quote(s):\n        \"\"\"Return a shell-escaped version of the string *s*.\"\"\"\n        if not s:\n            return \"''\"\n        if _find_unsafe(s) is None:\n            return s\n        # use single quotes, and put single quotes into double quotes\n        # the string $'b is then quoted as '$'\"'\"'b'\n        return \"'\" + s.replace(\"'\", \"'\\\"'\\\"'\") + \"'\"\n", "docstring": "Return a shell-escaped version of the string *s*.\n"}
{"repo": "pexpect-master/pexpect/pxssh.py", "original_string": "    def levenshtein_distance(self, a, b):\n        '''This calculates the Levenshtein distance between a and b.\n        '''\n        n, m = len(a), len(b)\n        if n > m:\n            a,b = b,a\n            n,m = m,n\n        current = range(n+1)\n        for i in range(1,m+1):\n            previous, current = current, [i]+[0]*n\n            for j in range(1,n+1):\n                add, delete = previous[j]+1, current[j-1]+1\n                change = previous[j-1]\n                if a[j-1] != b[i-1]:\n                    change = change + 1\n                current[j] = min(add, delete, change)\n        return current[n]\n", "docstring": "This calculates the Levenshtein distance between a and b."}
{"repo": "pexpect-master/pexpect/pxssh.py", "original_string": "    def sync_original_prompt (self, sync_multiplier=1.0):\n        '''This attempts to find the prompt. Basically, press enter and record\n        the response; press enter again and record the response; if the two\n        responses are similar then assume we are at the original prompt.\n        This can be a slow function. Worst case with the default sync_multiplier\n        can take 12 seconds. Low latency connections are more likely to fail\n        with a low sync_multiplier. Best case sync time gets worse with a\n        high sync multiplier (500 ms with default). '''\n        # All of these timing pace values are magic.\n        # I came up with these based on what seemed reliable for\n        # connecting to a heavily loaded machine I have.\n        self.sendline()\n        time.sleep(0.1)\n        try:\n            # Clear the buffer before getting the prompt.\n            self.try_read_prompt(sync_multiplier)\n        except TIMEOUT:\n            pass\n        self.sendline()\n        x = self.try_read_prompt(sync_multiplier)\n        self.sendline()\n        a = self.try_read_prompt(sync_multiplier)\n        self.sendline()\n        b = self.try_read_prompt(sync_multiplier)\n        ld = self.levenshtein_distance(a,b)\n        len_a = len(a)\n        if len_a == 0:\n            return False\n        if float(ld)/len_a < 0.4:\n            return True\n        return False\n", "docstring": "This attempts to find the prompt. Basically, press enter and record"}
{"repo": "pexpect-master/pexpect/pxssh.py", "original_string": "    def prompt(self, timeout=-1):\n        '''Match the next shell prompt.\n        This is little more than a short-cut to the :meth:`~pexpect.spawn.expect`\n        method. Note that if you called :meth:`login` with\n        ``auto_prompt_reset=False``, then before calling :meth:`prompt` you must\n        set the :attr:`PROMPT` attribute to a regex that it will use for\n        matching the prompt.\n        Calling :meth:`prompt` will erase the contents of the :attr:`before`\n        attribute even if no prompt is ever matched. If timeout is not given or\n        it is set to -1 then self.timeout is used.\n        :return: True if the shell prompt was matched, False if the timeout was\n                 reached.\n        '''\n        if timeout == -1:\n            timeout = self.timeout\n        i = self.expect([self.PROMPT, TIMEOUT], timeout=timeout)\n        if i==1:\n            return False\n        return True\n", "docstring": "Match the next shell prompt."}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "def constrain (n, min, max):\n    '''This returns a number, n constrained to the min and max bounds. '''\n    if n < min:\n        return min\n    if n > max:\n        return max\n    return n\n", "docstring": "This returns a number, n constrained to the min and max bounds. '''"}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def __init__(self, r=24, c=80, encoding='latin-1', encoding_errors='replace'):\n        '''This initializes a blank screen of the given dimensions.'''\n        self.rows = r\n        self.cols = c\n        self.encoding = encoding\n        self.encoding_errors = encoding_errors\n        if encoding is not None:\n            self.decoder = codecs.getincrementaldecoder(encoding)(encoding_errors)\n        else:\n            self.decoder = None\n        self.cur_r = 1\n        self.cur_c = 1\n        self.cur_saved_r = 1\n        self.cur_saved_c = 1\n        self.scroll_row_start = 1\n        self.scroll_row_end = self.rows\n        self.w = [ [SPACE] * self.cols for _ in range(self.rows)]\n", "docstring": "This initializes a blank screen of the given dimensions.'''"}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def _unicode(self):\n        '''This returns a printable representation of the screen as a unicode\n        string (which, under Python 3.x, is the same as 'str'). The end of each\n        screen line is terminated by a newline.'''\n        return u'\\n'.join ([ u''.join(c) for c in self.w ])\n", "docstring": "This returns a printable representation of the screen as a unicode"}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "        def __str__(self):\n            '''This returns a printable representation of the screen. The end of\n            each screen line is terminated by a newline. '''\n            encoding = self.encoding or 'ascii'\n            return self._unicode().encode(encoding, 'replace')\n", "docstring": "This returns a printable representation of the screen. The end of"}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def pretty (self):\n        '''This returns a copy of the screen as a unicode string with an ASCII\n        text box around the screen border. This is similar to\n        __str__/__unicode__ except that it adds a box.'''\n        top_bot = u'+' + u'-'*self.cols + u'+\\n'\n        return top_bot + u'\\n'.join([u'|'+line+u'|' for line in unicode(self).split(u'\\n')]) + u'\\n' + top_bot\n", "docstring": "This returns a copy of the screen as a unicode string with an ASCII"}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def lf (self):\n        '''This moves the cursor down with scrolling.\n        '''\n        old_r = self.cur_r\n        self.cursor_down()\n        if old_r == self.cur_r:\n            self.scroll_up ()\n            self.erase_line()\n", "docstring": "This moves the cursor down with scrolling."}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def newline (self):\n        '''This is an alias for crlf().\n        '''\n        self.crlf()\n", "docstring": "This is an alias for crlf()."}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def put (self, ch):\n        '''This puts a characters at the current cursor position.\n        '''\n        if isinstance(ch, bytes):\n            ch = self._decode(ch)\n        self.put_abs (self.cur_r, self.cur_c, ch)\n", "docstring": "This puts a characters at the current cursor position."}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def cursor_constrain (self):\n        '''This keeps the cursor within the screen area.\n        '''\n        self.cur_r = constrain (self.cur_r, 1, self.rows)\n        self.cur_c = constrain (self.cur_c, 1, self.cols)\n", "docstring": "This keeps the cursor within the screen area."}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def cursor_save (self): # <ESC>[s\n        '''Save current cursor position.'''\n        self.cursor_save_attrs()\n", "docstring": "Save current cursor position.'''"}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def cursor_save_attrs (self): # <ESC>7\n        '''Save current cursor position.'''\n        self.cur_saved_r = self.cur_r\n        self.cur_saved_c = self.cur_c\n", "docstring": "Save current cursor position.'''"}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def scroll_constrain (self):\n        '''This keeps the scroll region within the screen region.'''\n        if self.scroll_row_start <= 0:\n            self.scroll_row_start = 1\n        if self.scroll_row_end > self.rows:\n            self.scroll_row_end = self.rows\n", "docstring": "This keeps the scroll region within the screen region.'''"}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def scroll_screen_rows (self, rs, re): # <ESC>[{start};{end}r\n        '''Enable scrolling from row {start} to row {end}.'''\n        self.scroll_row_start = rs\n        self.scroll_row_end = re\n        self.scroll_constrain()\n", "docstring": "Enable scrolling from row {start} to row {end}.'''"}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def scroll_up (self): # <ESC>M\n        '''Scroll display up one line.'''\n        # Screen is indexed from 1, but arrays are indexed from 0.\n        s = self.scroll_row_start - 1\n        e = self.scroll_row_end - 1\n        self.w[s:e] = copy.deepcopy(self.w[s+1:e+1])\n", "docstring": "Scroll display up one line.'''"}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def erase_start_of_line (self): # <ESC>[1K\n        '''Erases from the current cursor position to the start of the current\n        line.'''\n        self.fill_region (self.cur_r, 1, self.cur_r, self.cur_c)\n", "docstring": "Erases from the current cursor position to the start of the current"}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def erase_down (self): # <ESC>[0J -or- <ESC>[J\n        '''Erases the screen from the current line down to the bottom of the\n        screen.'''\n        self.erase_end_of_line ()\n        self.fill_region (self.cur_r + 1, 1, self.rows, self.cols)\n", "docstring": "Erases the screen from the current line down to the bottom of the"}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def erase_screen (self): # <ESC>[2J\n        '''Erases the screen with the background color.'''\n        self.fill ()\n", "docstring": "Erases the screen with the background color.'''"}
{"repo": "pexpect-master/pexpect/screen.py", "original_string": "    def clear_tab (self): # <ESC>[g\n        '''Clears tab at the current position.'''\n        pass\n", "docstring": "Clears tab at the current position.'''"}
{"repo": "pexpect-master/pexpect/ANSI.py", "original_string": "    def process (self, c):\n        \"\"\"Process a single character. Called by :meth:`write`.\"\"\"\n        if isinstance(c, bytes):\n            c = self._decode(c)\n        self.state.process(c)\n", "docstring": "Process a single character. Called by :meth:`write`.\n"}
{"repo": "pexpect-master/pexpect/ANSI.py", "original_string": "    def write (self, s):\n        \"\"\"Process text, writing it to the virtual screen while handling\n        ANSI escape codes.\n        \"\"\"\n        if isinstance(s, bytes):\n            s = self._decode(s)\n        for c in s:\n            self.process(c)\n", "docstring": "Process text, writing it to the virtual screen while handling"}
{"repo": "pexpect-master/pexpect/ANSI.py", "original_string": "    def write_ch (self, ch):\n        '''This puts a character at the current cursor position. The cursor\n        position is moved forward with wrap-around, but no scrolling is done if\n        the cursor hits the lower-right corner of the screen. '''\n        if isinstance(ch, bytes):\n            ch = self._decode(ch)\n        #\\r and \\n both produce a call to cr() and lf(), respectively.\n        ch = ch[0]\n        if ch == u'\\r':\n            self.cr()\n            return\n        if ch == u'\\n':\n            self.crlf()\n            return\n        if ch == chr(screen.BS):\n            self.cursor_back()\n            return\n        self.put_abs(self.cur_r, self.cur_c, ch)\n        old_r = self.cur_r\n        old_c = self.cur_c\n        self.cursor_forward()\n        if old_c == self.cur_c:\n            self.cursor_down()\n            if old_r != self.cur_r:\n                self.cursor_home (self.cur_r, 1)\n            else:\n                self.scroll_up ()\n                self.cursor_home (self.cur_r, 1)\n                self.erase_line()\n", "docstring": "This puts a character at the current cursor position. The cursor"}
{"repo": "pexpect-master/pexpect/ANSI.py", "original_string": "    def do_decsca (self, fsm):\n        '''Select character protection attribute. '''\n        screen = fsm.memory[0]\n        fsm.memory = [screen]\n", "docstring": "Select character protection attribute. '''"}
{"repo": "pexpect-master/tests/test_ansi.py", "original_string": "    def test_number_x(self):\n        \"\"\"Test the FSM state used to handle more than 2 numeric parameters.\"\"\"\n        class TestANSI(ANSI.ANSI):\n            captured_memory = None\n            def do_sgr(self, fsm):\n                assert self.captured_memory is None\n                self.captured_memory = fsm.memory\n        s = TestANSI(1, 20)\n        s.write('\\x1b[0;1;32;45mtest')\n        assert str(s) == ('test                ')\n        assert s.captured_memory is not None\n        assert s.captured_memory == [s, '0', '1', '32', '45']\n", "docstring": "Test the FSM state used to handle more than 2 numeric parameters.\n"}
{"repo": "pexpect-master/tests/test_ansi.py", "original_string": "    def test_utf8_bytes(self):\n        \"\"\"Test that when bytes are passed in containing UTF-8 encoded\n        characters, where the encoding of each character consists of\n        multiple bytes, the characters are correctly decoded.\n        Incremental decoding is also tested.\"\"\"\n        s = ANSI.ANSI(2, 10, encoding='utf-8')\n        # This is the UTF-8 encoding of the UCS character \"HOURGLASS\"\n        # followed by the UTF-8 encoding of the UCS character\n        # \"KEYBOARD\".  These characters can't be encoded in cp437 or\n        # latin-1.  The \"KEYBOARD\" character is split into two\n        # separate writes.\n        s.write(b'\\xe2\\x8c\\x9b')\n        s.write(b'\\xe2\\x8c')\n        s.write(b'\\xa8')\n        if PY3:\n            assert str(s) == u'\\u231b\\u2328        \\n          '\n        else:\n            assert unicode(s) == u'\\u231b\\u2328        \\n          '\n            assert str(s) == b'\\xe2\\x8c\\x9b\\xe2\\x8c\\xa8        \\n          '\n        assert s.dump() == u'\\u231b\\u2328                  '\n        assert s.pretty() == u'+----------+\\n|\\u231b\\u2328        |\\n|          |\\n+----------+\\n'\n        assert s.get_abs(1, 1) == u'\\u231b'\n        assert s.get_region(1, 1, 1, 5) == [u'\\u231b\\u2328   ']\n", "docstring": "Test that when bytes are passed in containing UTF-8 encoded"}
{"repo": "pexpect-master/tests/test_ansi.py", "original_string": "    def test_decode_error(self):\n        \"\"\"Test that default handling of decode errors replaces the\n        invalid characters.\"\"\"\n        s = ANSI.ANSI(2, 10, encoding=\"ascii\")\n        s.write(b'\\xff') # a non-ASCII character\n        # In unicode, the non-ASCII character is replaced with\n        # REPLACEMENT CHARACTER.\n        if PY3:\n            assert str(s) == u'\\ufffd         \\n          '\n        else:\n            assert unicode(s) == u'\\ufffd         \\n          '\n            assert str(s) == b'?         \\n          '\n        assert s.dump() == u'\\ufffd                   '\n        assert s.pretty() == u'+----------+\\n|\\ufffd         |\\n|          |\\n+----------+\\n'\n        assert s.get_abs(1, 1) == u'\\ufffd'\n        assert s.get_region(1, 1, 1, 5) == [u'\\ufffd    ']\n", "docstring": "Test that default handling of decode errors replaces the"}
{"repo": "pexpect-master/tests/test_screen.py", "original_string": "    def make_screen_with_box_cp437(self, *args, **kwargs):\n        '''Creates a screen containing a box drawn using double-line\n        line drawing characters. The characters are fed in as\n        CP437. '''\n        s = screen.screen (2,2,*args,**kwargs)\n        s.put_abs (1,1,b'\\xc9')\n        s.put_abs (1,2,b'\\xbb')\n        s.put_abs (2,1,b'\\xc8')\n        s.put_abs (2,2,b'\\xbc')\n        return s\n", "docstring": "Creates a screen containing a box drawn using double-line"}
{"repo": "pexpect-master/tests/test_screen.py", "original_string": "    def test_unicode_ascii (self):\n        # With the default encoding set to ASCII, we should still be\n        # able to feed in unicode strings and get them back out:\n        s = self.make_screen_with_box_unicode('ascii')\n        if PY3:\n            assert str(s) == unicode_box_unicode_result\n        else:\n            assert unicode(s) == unicode_box_unicode_result\n            # And we should still get something for Python 2 str(), though\n            # it might not be very useful\n            str(s)\n        assert s.pretty() == unicode_box_pretty_result\n", "docstring": "With the default encoding set to ASCII, we should still be"}
{"repo": "pexpect-master/tests/test_screen.py", "original_string": "    def test_unicode_cp437 (self):\n        # Verify decoding from and re-encoding to CP437.\n        s = self.make_screen_with_box_cp437('cp437','strict')\n        if PY3:\n            assert str(s) == unicode_box_unicode_result\n        else:\n            assert unicode(s) == unicode_box_unicode_result\n            assert str(s) == unicode_box_cp437_bytes_result\n        assert s.pretty() == unicode_box_pretty_result\n", "docstring": "Verify decoding from and re-encoding to CP437."}
{"repo": "pexpect-master/tests/test_isalive.py", "original_string": "    def test_expect_wait(self):\n        \"\"\"Ensure consistency in wait() and isalive().\"\"\"\n        p = pexpect.spawn('sleep 1')\n        assert p.isalive()\n        assert p.wait() == 0\n        assert not p.isalive()\n        # In previous versions of ptyprocess/pexpect, calling wait() a second\n        # time would raise an exception, but not since v4.0\n        assert p.wait() == 0\n", "docstring": "Ensure consistency in wait() and isalive().\n"}
{"repo": "pexpect-master/tests/test_isalive.py", "original_string": "    def test_signal_wait(self):\n        '''Test calling wait with a process terminated by a signal.'''\n        if not hasattr(signal, 'SIGALRM'):\n            return 'SKIP'\n        p = pexpect.spawn(self.PYTHONBIN, ['alarm_die.py'])\n        p.wait()\n        assert p.exitstatus is None\n        self.assertEqual(p.signalstatus, signal.SIGALRM)\n", "docstring": "Test calling wait with a process terminated by a signal.'''"}
{"repo": "pexpect-master/tests/test_isalive.py", "original_string": "    def test_expect_isalive_consistent_multiple_calls (self):\n        '''This tests that multiple calls to isalive() return same value.\n        '''\n        p = pexpect.spawn('cat')\n        assert p.isalive()\n        assert p.isalive()\n        p.sendeof()\n        p.expect(pexpect.EOF)\n        assert not p.isalive()\n        assert not p.isalive()\n", "docstring": "This tests that multiple calls to isalive() return same value."}
{"repo": "pexpect-master/tests/test_repr.py", "original_string": "    def test_str_spawnu(self):\n        \"\"\" Exercise spawnu.__str__() \"\"\"\n        # given,\n        p = pexpect.spawnu('cat')\n        # exercise,\n        value = str(p)\n        # verify\n        assert isinstance(value, str)\n", "docstring": "Exercise spawnu.__str__() \n"}
{"repo": "pexpect-master/tests/test_winsize.py", "original_string": "    def test_initial_winsize(self):\n        \"\"\" Assert initial window dimension size (24, 80). \"\"\"\n        p = pexpect.spawn('{self.PYTHONBIN} sigwinch_report.py'\n                          .format(self=self), timeout=3)\n        # default size by PtyProcess class is 24 rows by 80 columns.\n        p.expect_exact('Initial Size: (24, 80)')\n        p.close()\n", "docstring": "Assert initial window dimension size (24, 80). \n"}
{"repo": "pexpect-master/tests/test_winsize.py", "original_string": "    def test_setwinsize(self):\n        \"\"\" Ensure method .setwinsize() sends signal caught by child. \"\"\"\n        p = pexpect.spawn('{self.PYTHONBIN} sigwinch_report.py'\n                          .format(self=self), timeout=3)\n        # Note that we must await the installation of the child process'\n        # signal handler,\n        p.expect_exact('READY')\n        p.setwinsize(19, 84)\n        p.expect_exact('SIGWINCH: (19, 84)')\n        p.close()\n", "docstring": "Ensure method .setwinsize() sends signal caught by child. \n"}
{"repo": "pexpect-master/tests/deprecated_test_run_out_of_pty.py", "original_string": "    def OFF_test_run_out_of_pty (self):\n        '''This assumes that the tested platform has < 10000 pty devices.\n        This test currently does not work under Solaris.\n        Under Solaris it runs out of file descriptors first and\n        ld.so starts to barf:\n            ld.so.1: pt_chmod: fatal: /usr/lib/libc.so.1: Too many open files\n        '''\n        plist=[]\n        for count in range (0,10000):\n                try:\n                        plist.append (pexpect.spawn('ls -l'))\n                except pexpect.ExceptionPexpect:\n                        for c in range (0, count):\n                            plist[c].close()\n                        return\n                except Exception:\n                        err = sys.exc_info()[1]\n                        self.fail ('Expected ExceptionPexpect. ' + str(err))\n        self.fail ('Could not run out of pty devices. This may be OK.')\n", "docstring": "This assumes that the tested platform has < 10000 pty devices."}
{"repo": "pexpect-master/tests/test_timeout_pattern.py", "original_string": "    def test_matches_exp_timeout (self):\n        '''This tests that we can raise and catch TIMEOUT.\n        '''\n        try:\n            raise pexpect.TIMEOUT(\"TIMEOUT match test\")\n        except pexpect.TIMEOUT:\n            pass\n            #print \"Correctly caught TIMEOUT when raising TIMEOUT.\"\n        else:\n            self.fail('TIMEOUT not caught by an except TIMEOUT clause.')\n", "docstring": "This tests that we can raise and catch TIMEOUT."}
{"repo": "pexpect-master/tests/test_timeout_pattern.py", "original_string": "    def test_exp_timeout_notThrown (self):\n        '''Verify that a TIMEOUT is not thrown when we match what we expect.'''\n        try:\n            p = pexpect.spawn('cat')\n            p.sendline('Hello')\n            p.expect('Hello')\n        except pexpect.TIMEOUT:\n            self.fail(\"TIMEOUT caught when it shouldn't be raised because we match the proper pattern.\")\n", "docstring": "Verify that a TIMEOUT is not thrown when we match what we expect.'''"}
{"repo": "pexpect-master/tests/test_timeout_pattern.py", "original_string": "    def test_correctStackTrace (self):\n        '''Verify that the stack trace returned with a TIMEOUT instance correctly handles function calls.'''\n        def nestedFunction (spawnInstance):\n            spawnInstance.expect(\"junk\", timeout=3)\n        try:\n            p = pexpect.spawn('cat')\n            p.sendline('Hello')\n            nestedFunction(p)\n        except pexpect.TIMEOUT:\n            err = sys.exc_info()[1]\n            if err.get_trace().count(\"nestedFunction\") == 0:\n                self.fail(\"The TIMEOUT get_trace() did not show the call \"\n                    \"to the nestedFunction function.\\n\" + str(err) + \"\\n\"\n                    + err.get_trace())\n", "docstring": "Verify that the stack trace returned with a TIMEOUT instance correctly handles function calls.'''"}
{"repo": "pexpect-master/tests/sigwinch_report.py", "original_string": "def getwinsize():\n    '''This returns the window size of the child tty.\n    The return value is a tuple of (rows, cols).\n    '''\n    if 'TIOCGWINSZ' in dir(termios):\n        TIOCGWINSZ = termios.TIOCGWINSZ\n    else:\n        TIOCGWINSZ = 1074295912 # Assume\n    s = struct.pack('HHHH', 0, 0, 0, 0)\n    x = fcntl.ioctl(sys.stdout.fileno(), TIOCGWINSZ, s)\n    return struct.unpack('HHHH', x)[0:2]\n", "docstring": "This returns the window size of the child tty."}
{"repo": "pexpect-master/tests/test_expect.py", "original_string": "    def test_expect_ignore_case(self):\n        '''This test that the ignorecase flag will match patterns\n        even if case is different using the regex (?i) directive.\n        '''\n        p = pexpect.spawn('cat', echo=False, timeout=5)\n        p.sendline (b'HELLO')\n        p.sendline (b'there')\n        p.expect (b'(?i)hello')\n        p.expect (b'(?i)THERE')\n        p.sendeof ()\n        p.expect (pexpect.EOF)\n", "docstring": "This test that the ignorecase flag will match patterns"}
{"repo": "pexpect-master/tests/test_expect.py", "original_string": "    def test_expect_order (self):\n        '''This tests that patterns are matched in the same order as given in the pattern_list.\n        (Or does it?  Doesn't it also pass if expect() always chooses\n        (one of the) the leftmost matches in the input? -- grahn)\n        ... agreed! -jquast, the buffer ptr isn't forwarded on match, see first two test cases\n        '''\n        p = pexpect.spawn('cat', echo=False, timeout=5)\n        self._expect_order(p)\n", "docstring": "This tests that patterns are matched in the same order as given in the pattern_list."}
{"repo": "pexpect-master/tests/test_expect.py", "original_string": "    def test_waitnoecho_order(self):\n        ''' This tests that we can wait on a child process to set echo mode.\n        For example, this tests that we could wait for SSH to set ECHO False\n        when asking of a password. This makes use of an external script\n        echo_wait.py. '''\n        p1 = pexpect.spawn('%s echo_wait.py' % self.PYTHONBIN)\n        start = time.time()\n        try:\n            p1.waitnoecho(timeout=10)\n        except IOError:\n            if sys.platform.lower().startswith('sunos'):\n                if hasattr(unittest, 'SkipTest'):\n                    raise unittest.SkipTest(\"Not supported on this platform.\")\n                return 'skip'\n            raise\n        end_time = time.time() - start\n        assert end_time < 10 and end_time > 2, \"waitnoecho did not set ECHO off in the expected window of time.\"\n        # test that we actually timeout and return False if ECHO is never set off.\n        p1 = pexpect.spawn('cat')\n        start = time.time()\n        retval = p1.waitnoecho(timeout=4)\n        end_time = time.time() - start\n        assert end_time > 3, \"waitnoecho should have waited longer than 2 seconds. retval should be False, retval=%d\"%retval\n        assert retval==False, \"retval should be False, retval=%d\"%retval\n        # This one is mainly here to test default timeout for code coverage.\n        p1 = pexpect.spawn('%s echo_wait.py' % self.PYTHONBIN)\n        start = time.time()\n        p1.waitnoecho()\n        end_time = time.time() - start\n        assert end_time < 10, \"waitnoecho did not set ECHO off in the expected window of time.\"\n", "docstring": "This tests that we can wait on a child process to set echo mode."}
{"repo": "pexpect-master/tests/test_expect.py", "original_string": "    def test_expect_echo_exact (self):\n        '''Like test_expect_echo(), but using expect_exact().\n        '''\n        p = pexpect.spawn('cat', echo=True, timeout=5)\n        p.expect = p.expect_exact\n        self._expect_echo(p)\n", "docstring": "Like test_expect_echo(), but using expect_exact()."}
{"repo": "pexpect-master/tests/test_expect.py", "original_string": "    def test_expect_index_exact (self):\n        '''Like test_expect_index(), but using expect_exact().\n        '''\n        p = pexpect.spawn('cat', echo=False, timeout=5)\n        p.expect = p.expect_exact\n        self._expect_index(p)\n", "docstring": "Like test_expect_index(), but using expect_exact()."}
{"repo": "pexpect-master/tests/test_expect.py", "original_string": "    def test_before_across_chunks(self):\n        # https://github.com/pexpect/pexpect/issues/478\n        child = pexpect.spawn(\n            '''/bin/bash -c \"openssl rand -base64 {} 2>/dev/null | head -500 | nl --number-format=rz --number-width=5 2>&1 ; echo 'PATTERN!!!'\"'''.format(1024 * 1024 * 2),\n            searchwindowsize=128\n        )\n        child.expect(['PATTERN'])\n        assert len(child.before.splitlines()) == 500\n        assert child.after == b'PATTERN'\n        assert child.buffer == b'!!!\\r\\n'\n", "docstring": "https://github.com/pexpect/pexpect/issues/478"}
{"repo": "pexpect-master/tests/test_expect.py", "original_string": "    def test_before_after(self):\n        '''This tests expect() for some simple before/after things.\n        '''\n        p = pexpect.spawn('%s -Wi list100.py' % self.PYTHONBIN, env=no_coverage_env())\n        self._before_after(p)\n", "docstring": "This tests expect() for some simple before/after things."}
{"repo": "pexpect-master/tests/test_expect.py", "original_string": "    def test_before_after_timeout(self):\n        '''Tests that timeouts do not truncate before, a bug in 4.4-4.7.'''\n        child = pexpect.spawn('cat', echo=False)\n        child.sendline('BEGIN')\n        for i in range(100):\n            child.sendline('foo' * 100)\n        e = child.expect([b'xyzzy', pexpect.TIMEOUT],\n                         searchwindowsize=10, timeout=0.001)\n        self.assertEqual(e, 1)\n        child.sendline('xyzzy')\n        e = child.expect([b'xyzzy', pexpect.TIMEOUT],\n                         searchwindowsize=10, timeout=30)\n        self.assertEqual(e, 0)\n        self.assertEqual(child.before[0:5], b'BEGIN')\n        child.sendeof()\n        child.expect(pexpect.EOF)\n", "docstring": "Tests that timeouts do not truncate before, a bug in 4.4-4.7.'''"}
{"repo": "pexpect-master/tests/test_expect.py", "original_string": "    def test_searchwindowsize(self):\n        '''Tests that we don't match outside the window, a bug in 4.4-4.7.'''\n        p = pexpect.spawn('echo foobarbazbop')\n        e = p.expect([b'bar', b'bop'], searchwindowsize=6)\n        self.assertEqual(e, 1)\n", "docstring": "Tests that we don't match outside the window, a bug in 4.4-4.7.'''"}
{"repo": "pexpect-master/tests/test_expect.py", "original_string": "    def test_ordering(self):\n        '''This tests expect() for which pattern is returned\n        when many may eventually match. I (Grahn) am a bit\n        confused about what should happen, but this test passes\n        with pexpect 2.1.\n        '''\n        p = pexpect.spawn(self.PYTHONBIN)\n        self._ordering(p)\n", "docstring": "This tests expect() for which pattern is returned"}
{"repo": "pexpect-master/tests/test_expect.py", "original_string": "    def _greed(self, expect):\n        # End at the same point: the one with the earliest start should win\n        self.assertEqual(expect([b'3, 4', b'2, 3, 4']), 1)\n        # Start at the same point: first pattern passed wins\n        self.assertEqual(expect([b'5,', b'5, 6']), 0)\n        # Same pattern passed twice: first instance wins\n        self.assertEqual(expect([b'7, 8', b'7, 8, 9', b'7, 8']), 0)\n", "docstring": "End at the same point: the one with the earliest start should win"}
{"repo": "pexpect-master/tests/test_expect.py", "original_string": "            def run(self):\n                sys.__stdin__.close()\n                cat = pexpect.spawn('cat')\n                cat.sendeof()\n                cat.expect(pexpect.EOF)\n", "docstring": "sys.__stdin__.close()"}
{"repo": "pexpect-master/tests/test_constructor.py", "original_string": "    def test_constructor (self):\n        '''This tests that the constructor will work and give\n        the same results for different styles of invoking __init__().\n        This assumes that the root directory / is static during the test.\n        '''\n        p1 = pexpect.spawn('uname -m -n -p -r -s -v')\n        p2 = pexpect.spawn('uname', ['-m', '-n', '-p', '-r', '-s', '-v'])\n        p1.expect(pexpect.EOF)\n        p2.expect(pexpect.EOF)\n        assert p1.before == p2.before\n", "docstring": "This tests that the constructor will work and give"}
{"repo": "pexpect-master/tests/test_replwrap.py", "original_string": "    def test_bash_env(self):\n        \"\"\"env, which displays PS1=..., should not mess up finding the prompt.\n        \"\"\"\n        bash = replwrap.bash()\n        res = bash.run_command(\"export PS1\")\n        res = bash.run_command(\"env\")\n        self.assertIn('PS1', res)\n        res = bash.run_command(\"echo $HOME\")\n        assert res.startswith('/'), res\n", "docstring": "env, which displays PS1=..., should not mess up finding the prompt."}
{"repo": "pexpect-master/tests/test_misc.py", "original_string": "    def _test_searcher_as(self, searcher, plus=None):\n        # given,\n        given_words = ['alpha', 'beta', 'gamma', 'delta', ]\n        given_search = given_words\n        if searcher == pexpect.searcher_re:\n            given_search = [re.compile(word) for word in given_words]\n        if plus is not None:\n            given_search = given_search + [plus]\n        search_string = searcher(given_search)\n        basic_fmt = '\\n    {0}: {1}'\n        fmt = basic_fmt\n        if searcher is pexpect.searcher_re:\n            fmt = '\\n    {0}: re.compile({1})'\n        expected_output = '{0}:'.format(searcher.__name__)\n        idx = 0\n        for word in given_words:\n            expected_output += fmt.format(idx, \"'{0}'\".format(word))\n            idx += 1\n        if plus is not None:\n            if plus == pexpect.EOF:\n                expected_output += basic_fmt.format(idx, 'EOF')\n            elif plus == pexpect.TIMEOUT:\n                expected_output += basic_fmt.format(idx, 'TIMEOUT')\n        # exercise,\n        assert search_string.__str__() == expected_output\n", "docstring": "given,"}
{"repo": "pexpect-master/tests/test_ctrl_chars.py", "original_string": "    def test_bad_sendcontrol_chars (self):\n        '''This tests that sendcontrol will return 0 for an unknown char. '''\n        child = pexpect.spawn(self.getch_cmd, echo=False, timeout=5)\n        child.expect('READY')\n        assert 0 == child.sendcontrol('1')\n", "docstring": "This tests that sendcontrol will return 0 for an unknown char. '''"}
{"repo": "packyou-master/travis_pypi_setup.py", "original_string": "def load_key(pubkey):\n    \"\"\"Load public RSA key, with work-around for keys using\n    incorrect header/footer format.\n    Read more about RSA encryption with cryptography:\n    https://cryptography.io/latest/hazmat/primitives/asymmetric/rsa/\n    \"\"\"\n    try:\n        return load_pem_public_key(pubkey.encode(), default_backend())\n    except ValueError:\n        # workaround for https://github.com/travis-ci/travis-api/issues/196\n        pubkey = pubkey.replace('BEGIN RSA', 'BEGIN').replace('END RSA', 'END')\n        return load_pem_public_key(pubkey.encode(), default_backend())\n", "docstring": "Load public RSA key, with work-around for keys using"}
{"repo": "packyou-master/travis_pypi_setup.py", "original_string": "def fetch_public_key(repo):\n    \"\"\"Download RSA public key Travis will use for this repo.\n    Travis API docs: http://docs.travis-ci.com/api/#repository-keys\n    \"\"\"\n    keyurl = 'https://api.travis-ci.org/repos/{0}/key'.format(repo)\n    data = json.loads(urlopen(keyurl).read().decode())\n    if 'key' not in data:\n        errmsg = \"Could not find public key for repo: {}.\\n\".format(repo)\n        errmsg += \"Have you already added your GitHub repo to Travis?\"\n        raise ValueError(errmsg)\n    return data['key']\n", "docstring": "Download RSA public key Travis will use for this repo."}
{"repo": "packyou-master/travis_pypi_setup.py", "original_string": "def update_travis_deploy_password(encrypted_password):\n    \"\"\"Update the deploy section of the .travis.yml file\n    to use the given encrypted password.\n    \"\"\"\n    config = load_yaml_config(TRAVIS_CONFIG_FILE)\n    config['deploy']['password'] = dict(secure=encrypted_password)\n    save_yaml_config(TRAVIS_CONFIG_FILE, config)\n    line = ('# This file was autogenerated and will overwrite'\n            ' each time you run travis_pypi_setup.py\\n')\n    prepend_line(TRAVIS_CONFIG_FILE, line)\n", "docstring": "Update the deploy section of the .travis.yml file"}
{"repo": "packyou-master/packyou/py3.py", "original_string": "    def __init__(self, fullname, path, repo_url=None):\n        # Get token\n        self.github_token = token = os.environ.get(\"GITHUB_TOKEN\")\n        if not token:\n            self.repo_url = repo_url\n        else:\n            base = repo_url[len(\"https://\"):]\n            self.repo_url = \"https://\" + token + \":x-oauth-basic@\" + base\n        self.name = fullname\n        if path:\n            self.path = path[0]\n        self.username = None\n        self.repository_name = None\n        self.root_module = None\n", "docstring": "Get token"}
{"repo": "packyou-master/packyou/py3.py", "original_string": "    def get_data(self, path):\n        LOGGER.info('get data from {0}'.format(path))\n        with open(path, 'r') as data_file:\n            return data_file.read()\n", "docstring": "LOGGER.info('get data from {0}'.format(path))"}
{"repo": "packyou-master/packyou/py3.py", "original_string": "    def find_module_in_cloned_repos(self, fullname):\n        return find_module_path_in_cloned_repos(fullname, GithubLoader)\n", "docstring": "return find_module_path_in_cloned_repos(fullname, GithubLoader)"}
{"repo": "packyou-master/packyou/py2.py", "original_string": "    def project_fullname(self):\n        return 'packyou.github.{0}.{1}'.format(self.username, self.repository_name)\n", "docstring": "return 'packyou.github.{0}.{1}'.format(self.username, self.repository_name)"}
{"repo": "sage-master/build/pkgs/sage_sws2rst/src/sage_sws2rst/worksheet2rst.py", "original_string": "def add_title_if_there_is_none(text):\n    if not HEADER_RE.search(text):\n        return '<h1>Please write a title for this worksheet!</h1>\\n' + text\n    else:\n        return text\n", "docstring": "if not HEADER_RE.search(text):"}
{"repo": "sage-master/build/pkgs/atlas/enums.py", "original_string": "def check_enums_ATLAS_OSTYPE(lines):\n    for i, os_type in enumerate(ATLAS_OSTYPE):\n        got = lines.pop(0).strip()\n        expect = \"{0} = '{1}'\".format(i, os_type)\n        if got != expect:\n            raise RuntimeError('ATLAS_OSTYPE mismatch at position '+str(i)+\n                               ': got >>'+got+'<<, expected >>'+expect+'<<')\n", "docstring": "for i, os_type in enumerate(ATLAS_OSTYPE):"}
{"repo": "sage-master/build/pkgs/atlas/configuration.py", "original_string": "    def __init__(self, filename):\n        self.filename = filename\n        f = open(filename, 'r')\n        self.data = f.read()\n        f.close()\n", "docstring": "self.filename = filename"}
{"repo": "sage-master/build/pkgs/atlas/spkg-install.py", "original_string": "def configure_options_from_environment():\n    # Figure out architecture (see ATLAS_MACHTYPE) and isa extensions (see\n    # ATLAS_ISAEXT) from environment variables:\n    arch = None\n    isa_ext = None\n    thread_limit = None\n    if conf['generic_binary?']:\n        print('Sage \"fat\" binary mode set: Building \"base\" binary')\n        print('NOTE: This can result in a Sage that is significantly slower at certain numerical')\n        print('linear algebra since full FAT binary support has not been implemented yet.')\n        arch = 'generic'\n    if 'SAGE_ATLAS_ARCH' not in os.environ:\n        return (arch, isa_ext, thread_limit)\n    for opt in os.environ['SAGE_ATLAS_ARCH'].split(','):\n        if opt.startswith('thread'):\n            thread_limit = int(opt.split(':')[-1])\n        elif opt == 'static':\n            global INSTALL_STATIC_LIBRARIES\n            INSTALL_STATIC_LIBRARIES = True\n        elif opt in ATLAS_MACHTYPE + ('fast', 'base'):\n            if arch is not None:\n                raise ValueError('multiple architectures specified: {0} and {1}'.format(arch, opt))\n            arch = opt\n        elif opt in ATLAS_ISAEXT:\n            if isa_ext is None:\n                isa_ext = [opt]\n            else:\n                isa_ext.append(opt)\n        else:\n            print('unknown SAGE_ATLAS_ARCH option: '+opt)\n            print('SAGE_ATLAS_ARCH architecture must be \"fast\", \"base\", or one of '+ \\\n                ', '.join(ATLAS_MACHTYPE))\n            print('SAGE_ATLAS_ARCH ISA extension must be one of '+ ', '.join(ATLAS_ISAEXT))\n            sys.exit(1)\n    return (arch, isa_ext, thread_limit)\n", "docstring": "Figure out architecture (see ATLAS_MACHTYPE) and isa extensions (see"}
{"repo": "sage-master/build/pkgs/atlas/spkg-install.py", "original_string": "def configure_shared_library():\n    os.chdir(BUILD_LIB_DIR)\n    static_library_dir = os.path.join(BUILD_DIR, 'lib')\n    for static_lib in glob.glob(os.path.join(static_library_dir, 'lib*.a')):\n        shutil.copy(static_lib, BUILD_LIB_DIR)\n    cmd = './configure'\n    cmd += ' --prefix=' + conf['SAGE_LOCAL']\n    cmd += ' --libdir=' + os.path.join(conf['SAGE_LOCAL'],'lib')\n    cmd += ' --disable-static'\n    return system_with_flush(cmd)\n", "docstring": "os.chdir(BUILD_LIB_DIR)"}
{"repo": "sage-master/build/sage_bootstrap/flock.py", "original_string": "    def __init__(self, mode='r', makedirs=False):\n        # Note, the base class __init__ takes other arguments too depending on\n        # the Python version but we don't care about them for this purpose\n        super(FileType, self).__init__(mode=mode)\n        self._makedirs = makedirs\n", "docstring": "Note, the base class __init__ takes other arguments too depending on"}
{"repo": "sage-master/build/sage_bootstrap/uninstall.py", "original_string": "def run(argv=None):\n    parser = make_parser()\n    args = parser.parse_args(argv if argv is not None else sys.argv[1:])\n    if args.sage_local is None:\n        print('Error: SAGE_LOCAL must be specified either at the command '\n              'line or in the $SAGE_LOCAL environment variable',\n              file=sys.stderr)\n        sys.exit(1)\n    try:\n        uninstall(args.spkg, args.sage_local, keep_files=args.keep_files,\n                  verbose=args.verbose)\n    except Exception as exc:\n        print(\"Error during uninstallation of '{0}': {1}\".format(\n            args.spkg, exc), file=sys.stderr)\n        if args.debug:\n            raise\n        sys.exit(1)\n", "docstring": "parser = make_parser()"}
{"repo": "sage-master/build/sage_bootstrap/tarball.py", "original_string": "    def _compute_hash(self, algorithm):\n        with open(self.upstream_fqn, 'rb') as f:\n            while True:\n                buf = f.read(0x100000)\n                if not buf:\n                    break\n                algorithm.update(buf)\n        return algorithm.hexdigest()\n", "docstring": "with open(self.upstream_fqn, 'rb') as f:"}
{"repo": "sage-master/build/sage_bootstrap/download/cmdline.py", "original_string": "def format_error(message):\n    stars = '*' * 72 + '\\n'\n    sys.stderr.write(stars)\n    try:\n        import traceback\n        traceback.print_exc(file=sys.stderr)\n        sys.stderr.write(stars)\n    except BaseException:\n        pass\n    sys.stderr.write(message)\n    sys.stderr.write(stars)\n                \n", "docstring": "stars = '*' * 72 + '\\n'"}
{"repo": "sage-master/build/sage_bootstrap/download/mirror_list.py", "original_string": "    def __init__(self):\n        self.filename = MIRRORLIST_FILENAME\n        self.mirrors = None\n        try:\n            self.mirrorfile = open(self.filename, 'r+t')\n        except IOError:\n            self.mirrorfile = open(self.filename, 'w+t')\n        with self.mirrorfile:\n            self.mirrorfd = self.mirrorfile.fileno()\n            try_lock(self.mirrorfd, LOCK_SH)  # shared (read) lock\n            if self._must_refresh():\n                try_lock(self.mirrorfd, LOCK_EX)  # exclusive (write) lock\n                # Maybe the mirror list file was updated by a different\n                # process while we waited for the lock?  Check again.\n                if self._must_refresh():\n                    self._refresh()\n            if self.mirrors is None:\n                self.mirrors = self._load()\n", "docstring": "self.filename = MIRRORLIST_FILENAME"}
{"repo": "sage-master/build/sage_bootstrap/uncompress/tar_file.py", "original_string": "    def utime(self, tarinfo, targetpath):\n        \"\"\"Override to keep the extraction time as the file's timestamp.\"\"\"\n        tarinfo.mtime = self._extracted_mtime\n        return super(SageBaseTarFile, self).utime(tarinfo, targetpath)\n", "docstring": "Override to keep the extraction time as the file's timestamp.\n"}
{"repo": "sage-master/build/sage_bootstrap/uncompress/tar_file.py", "original_string": "    def __new__(cls, filename):\n        return SageBaseTarFile.open(filename)\n", "docstring": "return SageBaseTarFile.open(filename)"}
{"repo": "sage-master/build/sage_bootstrap/uncompress/tar_file.py", "original_string": "    def __new__(cls, filename):\n        # Read uncompressed data through a pipe\n        proc = subprocess.Popen([\"xz\", \"-d\", \"-c\", filename], stdout=subprocess.PIPE)\n        data, _ = proc.communicate()\n        return SageBaseTarFile(mode=\"r\", fileobj=BytesIO(data))\n", "docstring": "Read uncompressed data through a pipe"}
{"repo": "sage-master/src/sage_docbuild/utils.py", "original_string": "    def wait_for_one():\n        \"\"\"Wait for a single process and return its pid and exit code.\"\"\"\n        try:\n            pid, sts = os.wait()\n        except OSError as exc:\n            # No more processes to wait on if ECHILD\n            if exc.errno != errno.ECHILD:\n                raise\n            else:\n                return None, None\n        if os.WIFSIGNALED(sts):\n            exitcode = -os.WTERMSIG(sts)\n        else:\n            exitcode = os.WEXITSTATUS(sts)\n        return pid, exitcode\n", "docstring": "Wait for a single process and return its pid and exit code.\n"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "def identity(x):\n    # type: (Any) -> Any\n    return x\n", "docstring": "type: (Any) -> Any"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "def members_option(arg):\n    # type: (Any) -> Union[object, List[unicode]]\n    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n    if arg is None:\n        return ALL\n    return [x.strip() for x in arg.split(',')]\n", "docstring": "type: (Any) -> Union[object, List[unicode]]"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "def annotation_option(arg):\n    # type: (Any) -> Any\n    if arg is None:\n        # suppress showing the representation of the object\n        return SUPPRESS\n    else:\n        return arg\n", "docstring": "type: (Any) -> Any"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def __init__(self, viewlist, reporter):\n        # type: (ViewList, Reporter) -> None\n        self.viewlist = viewlist\n        self.reporter = reporter\n", "docstring": "type: (ViewList, Reporter) -> None"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def system_message(self, level, message, *children, **kwargs):\n        # type: (int, unicode, Any, Any) -> nodes.system_message\n        if 'line' in kwargs and 'source' not in kwargs:\n            try:\n                source, line = self.viewlist.items[kwargs['line']]\n            except IndexError:\n                pass\n            else:\n                kwargs['source'] = source\n                kwargs['line'] = line\n        return self.reporter.system_message(level, message,\n                                            *children, **kwargs)\n", "docstring": "type: (int, unicode, Any, Any) -> nodes.system_message"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def info(self, *args, **kwargs):\n        # type: (Any, Any) -> nodes.system_message\n        return self.system_message(1, *args, **kwargs)\n", "docstring": "type: (Any, Any) -> nodes.system_message"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def error(self, *args, **kwargs):\n        # type: (Any, Any) -> nodes.system_message\n        return self.system_message(3, *args, **kwargs)\n", "docstring": "type: (Any, Any) -> nodes.system_message"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "def cut_lines(pre, post=0, what=None):\n    # type: (int, int, unicode) -> Callable\n    \"\"\"Return a listener that removes the first *pre* and last *post*\n    lines of every docstring.  If *what* is a sequence of strings,\n    only docstrings of a type in *what* will be processed.\n    Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::\n       from sphinx.ext.autodoc import cut_lines\n       app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n    This can (and should) be used in place of :confval:`automodule_skip_lines`.\n    \"\"\"\n    def process(app, what_, name, obj, options, lines):\n        # type: (Sphinx, unicode, unicode, Any, Any, List[unicode]) -> None\n        if what and what_ not in what:\n            return\n        del lines[:pre]\n        if post:\n            # remove one trailing blank line.\n            if lines and not lines[-1]:\n                lines.pop(-1)\n            del lines[-post:]\n        # make sure there is a blank line at the end\n        if lines and lines[-1]:\n            lines.append('')\n    return process\n", "docstring": "type: (int, int, unicode) -> Callable"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def process(app, what_, name, obj, options, lines):\n        # type: (Sphinx, unicode, unicode, Any, Any, List[unicode]) -> None\n        if what and what_ not in what:\n            return\n        deleted = 0\n        delete = not exclude\n        orig_lines = lines[:]\n        for i, line in enumerate(orig_lines):\n            if delete:\n                lines.pop(i - deleted)\n                deleted += 1\n            if marker_re.match(line):\n                delete = not delete\n                if delete:\n                    lines.pop(i - deleted)\n                    deleted += 1\n        if not lines and not keepempty:\n            lines[:] = orig_lines\n        # make sure there is a blank line at the end\n        if lines and lines[-1]:\n            lines.append('')\n", "docstring": "type: (Sphinx, unicode, unicode, Any, Any, List[unicode]) -> None"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def get_attr(self, obj, name, *defargs):\n        # type: (Any, unicode, Any) -> Any\n        \"\"\"getattr() override for types such as Zope interfaces.\"\"\"\n        return autodoc_attrgetter(self.env.app, obj, name, *defargs)\n", "docstring": "type: (Any, unicode, Any) -> Any"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def can_document_member(cls, member, membername, isattr, parent):\n        # type: (Any, unicode, bool, Any) -> bool\n        \"\"\"Called to see if a member can be documented by this documenter.\"\"\"\n        raise NotImplementedError('must be implemented in subclasses')\n", "docstring": "type: (Any, unicode, bool, Any) -> bool"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def documenters(self):\n        # type: () -> Dict[unicode, Type[Documenter]]\n        \"\"\"Returns registered Documenter classes\"\"\"\n        return get_documenters(self.env.app)\n", "docstring": "type: () -> Dict[unicode, Type[Documenter]]"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def resolve_name(self, modname, parents, path, base):\n        # type: (str, Any, str, Any) -> Tuple[str, List[unicode]]\n        \"\"\"Resolve the module and name of the object to document given by the\n        arguments and the current module/class.\n        Must return a pair of the module name and a chain of attributes; for\n        example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the\n        ``zipfile.ZipFile.open`` method.\n        \"\"\"\n        raise NotImplementedError('must be implemented in subclasses')\n", "docstring": "type: (str, Any, str, Any) -> Tuple[str, List[unicode]]"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def import_object(self):\n        # type: () -> bool\n        \"\"\"Import the object given by *self.modname* and *self.objpath* and set\n        it as *self.object*.\n        Returns True if successful, False if an error occurred.\n        \"\"\"\n        with mock(self.env.config.autodoc_mock_imports):\n            try:\n                ret = import_object(self.modname, self.objpath, self.objtype,\n                                    attrgetter=self.get_attr,\n                                    warningiserror=self.env.config.autodoc_warningiserror)\n                self.module, self.parent, self.object_name, self.object = ret\n                return True\n            except ImportError as exc:\n                logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n                self.env.note_reread()\n                return False\n", "docstring": "type: () -> bool"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def check_module(self):\n        # type: () -> bool\n        \"\"\"Check if *self.object* is really defined in the module given by\n        *self.modname*.\n        \"\"\"\n        if self.options.imported_members:\n            return True\n        modname = self.get_attr(self.object, '__module__', None)\n        if modname and modname != self.modname:\n            return False\n        return True\n", "docstring": "type: () -> bool"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def format_name(self):\n        # type: () -> unicode\n        \"\"\"Format the name of *self.object*.\n        This normally should be something that can be parsed by the generated\n        directive, but doesn't need to be (Sphinx will display it unparsed\n        then).\n        \"\"\"\n        # normally the name doesn't contain the module (except for module\n        # directives of course)\n        return '.'.join(self.objpath) or self.modname\n", "docstring": "type: () -> unicode"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def add_directive_header(self, sig):\n        # type: (unicode) -> None\n        \"\"\"Add the directive header and options to the generated content.\"\"\"\n        domain = getattr(self, 'domain', 'py')\n        directive = getattr(self, 'directivetype', self.objtype)\n        name = self.format_name()\n        sourcename = self.get_sourcename()\n        self.add_line(u'.. %s:%s:: %s%s' % (domain, directive, name, sig),\n                      sourcename)\n        if self.options.noindex:\n            self.add_line(u'   :noindex:', sourcename)\n        if self.objpath:\n            # Be explicit about the module, this is necessary since .. class::\n            # etc. don't support a prepended module name\n            self.add_line(u'   :module: %s' % self.modname, sourcename)\n", "docstring": "type: (unicode) -> None"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def process_doc(self, docstrings):\n        # type: (List[List[unicode]]) -> Iterator[unicode]\n        \"\"\"Let the user process the docstrings before adding them.\"\"\"\n        for docstringlines in docstrings:\n            if self.env.app:\n                # let extensions preprocess docstrings\n                self.env.app.emit('autodoc-process-docstring',\n                                  self.objtype, self.fullname, self.object,\n                                  self.options, docstringlines)\n            for line in docstringlines:\n                yield line\n", "docstring": "type: (List[List[unicode]]) -> Iterator[unicode]"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def add_content(self, more_content, no_docstring=False):\n        # type: (Any, bool) -> None\n        \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n        # set sourcename and add content from attribute documentation\n        sourcename = self.get_sourcename()\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n            if self.objpath:\n                key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n                if key in attr_docs:\n                    no_docstring = True\n                    docstrings = [attr_docs[key]]\n                    for i, line in enumerate(self.process_doc(docstrings)):\n                        self.add_line(line, sourcename, i)\n        # add content from docstrings\n        if not no_docstring:\n            encoding = self.analyzer and self.analyzer._encoding\n            docstrings = self.get_doc(encoding)\n            if not docstrings:\n                # append at least a dummy docstring, so that the event\n                # autodoc-process-docstring is fired and can add some\n                # content if desired\n                docstrings.append([])\n            for i, line in enumerate(self.process_doc(docstrings)):\n                self.add_line(line, sourcename, i)\n        # add additional content (e.g. from document), if present\n        if more_content:\n            for line, src in zip(more_content.data, more_content.items):\n                self.add_line(line, src[0], src[1])\n", "docstring": "type: (Any, bool) -> None"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "            def keyfunc(entry):\n                # type: (Tuple[Documenter, bool]) -> int\n                fullname = entry[0].name.split('::')[1]\n                return tagorder.get(fullname, len(tagorder))\n", "docstring": "type: (Tuple[Documenter, bool]) -> int"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def can_document_member(cls, member, membername, isattr, parent):\n        # type: (Any, unicode, bool, Any) -> bool\n        # don't document submodules automatically\n        return False\n", "docstring": "type: (Any, unicode, bool, Any) -> bool"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def parse_name(self):\n        # type: () -> bool\n        ret = Documenter.parse_name(self)\n        if self.args or self.retann:\n            logger.warning('signature arguments or return annotation '\n                           'given for automodule %s' % self.fullname)\n        return ret\n", "docstring": "type: () -> bool"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def get_object_members(self, want_all):\n        # type: (bool) -> Tuple[bool, List[Tuple[unicode, object]]]\n        if want_all:\n            if not hasattr(self.object, '__all__'):\n                # for implicit module members, check __module__ to avoid\n                # documenting imported objects\n                return True, get_module_members(self.object)\n            else:\n                memberlist = self.object.__all__\n                # Sometimes __all__ is broken...\n                if not isinstance(memberlist, (list, tuple)) or not \\\n                   all(isinstance(entry, str) for entry in memberlist):\n                    logger.warning(\n                        '__all__ should be a list of strings, not %r '\n                        '(in module %s) -- ignoring __all__' %\n                        (memberlist, self.fullname))\n                    # fall back to all members\n                    return True, get_module_members(self.object)\n        else:\n            memberlist = self.options.members or []\n        ret = []\n        for mname in memberlist:\n            try:\n                ret.append((mname, safe_getattr(self.object, mname)))\n            except AttributeError:\n                logger.warning(\n                    'missing attribute mentioned in :members: or __all__: '\n                    'module %s, attribute %s' %\n                    (safe_getattr(self.object, '__name__', '???'), mname))\n        return False, ret\n", "docstring": "type: (bool) -> Tuple[bool, List[Tuple[unicode, object]]]"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def resolve_name(self, modname, parents, path, base):\n        # type: (str, Any, str, Any) -> Tuple[str, List[unicode]]\n        if modname is None:\n            if path:\n                modname = path.rstrip('.')\n            else:\n                # if documenting a toplevel object without explicit module,\n                # it can be contained in another auto directive ...\n                modname = self.env.temp_data.get('autodoc:module')\n                # ... or in the scope of a module directive\n                if not modname:\n                    modname = self.env.ref_context.get('py:module')\n                # ... else, it stays None, which means invalid\n        return modname, parents + [base]\n", "docstring": "type: (str, Any, str, Any) -> Tuple[str, List[unicode]]"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def resolve_name(self, modname, parents, path, base):\n        # type: (str, Any, str, Any) -> Tuple[str, List[unicode]]\n        if modname is None:\n            if path:\n                mod_cls = path.rstrip('.')\n            else:\n                mod_cls = None\n                # if documenting a class-level object without path,\n                # there must be a current class, either from a parent\n                # auto directive ...\n                mod_cls = self.env.temp_data.get('autodoc:class')\n                # ... or from a class directive\n                if mod_cls is None:\n                    mod_cls = self.env.ref_context.get('py:class')\n                # ... if still None, there's no way to know\n                if mod_cls is None:\n                    return None, []\n            modname, cls = rpartition(mod_cls, '.')  # type: ignore\n            parents = [cls]\n            # if the module name is still missing, get it like above\n            if not modname:\n                modname = self.env.temp_data.get('autodoc:module')\n            if not modname:\n                modname = self.env.ref_context.get('py:module')\n            # ... else, it stays None, which means invalid\n        return modname, parents + [base]\n", "docstring": "type: (str, Any, str, Any) -> Tuple[str, List[unicode]]"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def _find_signature(self, encoding=None):\n        # type: (unicode) -> Tuple[str, str]\n        docstrings = self.get_doc(encoding)\n        self._new_docstrings = docstrings[:]\n        result = None\n        for i, doclines in enumerate(docstrings):\n            # no lines in docstring, no match\n            if not doclines:\n                continue\n            # match first line of docstring against signature RE\n            match = py_ext_sig_re.match(doclines[0])  # type: ignore\n            if not match:\n                continue\n            exmod, path, base, args, retann = match.groups()\n            # the base name must match ours\n            valid_names = [self.objpath[-1]]  # type: ignore\n            if isinstance(self, ClassDocumenter):\n                valid_names.append('__init__')\n                if hasattr(self.object, '__mro__'):\n                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n            if base not in valid_names:\n                continue\n            # re-prepare docstring to ignore more leading indentation\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]))\n            result = args, retann\n            # don't look any further\n            break\n        return result\n", "docstring": "type: (unicode) -> Tuple[str, str]"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def format_signature(self):\n        # type: () -> unicode\n        if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n            # only act if a signature is not explicitly given already, and if\n            # the feature is enabled\n            result = self._find_signature()\n            if result is not None:\n                self.args, self.retann = result\n        return Documenter.format_signature(self)\n", "docstring": "type: () -> unicode"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def format_signature(self):\n        # type: () -> unicode\n        if self.args is None and self.env.config.autodoc_docstring_signature:\n            # only act if a signature is not explicitly given already, and if\n            # the feature is enabled\n            result = self._find_signature()\n            if result is not None:\n                # Discarding _args is a only difference with\n                # DocstringSignatureMixin.format_signature.\n                # Documenter.format_signature use self.args value to format.\n                _args, self.retann = result\n        return Documenter.format_signature(self)\n", "docstring": "type: () -> unicode"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def can_document_member(cls, member, membername, isattr, parent):\n        # type: (Any, unicode, bool, Any) -> bool\n        # It can be documented if it is a genuine function.\n        # Often, a class instance has the same documentation as its class,\n        # and then we typically want to document the class and not the instance.\n        # However, there is an exception: CachedFunction(f) returns a class instance,\n        # whose doc string coincides with that of f and is thus different from\n        # that of the class CachedFunction. In that situation, we want that f is documented.\n        # This is part of trac #9976.\n        return (inspect.isfunction(member) or inspect.isbuiltin(member)\n                or (isclassinstance(member)\n                    and sage_getdoc_original(member) != sage_getdoc_original(member.__class__)))\n", "docstring": "type: (Any, unicode, bool, Any) -> bool"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def document_members(self, all_members=False):\n        # type: (bool) -> None\n        pass\n", "docstring": "type: (bool) -> None"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def can_document_member(cls, member, membername, isattr, parent):\n        # type: (Any, unicode, bool, Any) -> bool\n        return isinstance(member, type)\n", "docstring": "type: (Any, unicode, bool, Any) -> bool"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def format_args(self):\n        # type: () -> unicode\n        # for classes, the relevant signature is the __init__ method's\n        initmeth = self.get_attr(self.object, '__init__', None)\n        # classes without __init__ method, default __init__ or\n        # __init__ written in C?\n        if initmeth is None or \\\n                is_builtin_class_method(self.object, '__init__') or \\\n                not(inspect.ismethod(initmeth) or inspect.isfunction(initmeth)):\n            return None\n        try:\n            argspec = sage_getargspec(initmeth)\n            if argspec[0] and argspec[0][0] in ('cls', 'self'):\n                del argspec[0][0]\n            return formatargspec(initmeth, *argspec)\n        except TypeError:\n            # still not possible: happens e.g. for old-style classes\n            # with __init__ in C\n            return None\n", "docstring": "type: () -> unicode"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def add_directive_header(self, sig):\n        # type: (unicode) -> None\n        if self.doc_as_attr:\n            self.directivetype = 'attribute'\n        Documenter.add_directive_header(self, sig)\n        # add inheritance info, if wanted\n        if not self.doc_as_attr and self.options.show_inheritance:\n            sourcename = self.get_sourcename()\n            self.add_line(u'', sourcename)\n            if hasattr(self.object, '__bases__') and len(self.object.__bases__):\n                bases = [b.__module__ in ('__builtin__', 'builtins') and\n                         u':class:`%s`' % b.__name__ or\n                         u':class:`%s.%s`' % (b.__module__, b.__name__)\n                         for b in self.object.__bases__]\n                self.add_line(u'   ' + _(u'Bases: %s') % ', '.join(bases),\n                              sourcename)\n", "docstring": "type: (unicode) -> None"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def add_content(self, more_content, no_docstring=False):\n        # type: (Any, bool) -> None\n        if self.doc_as_attr:\n            # We cannot rely on __qualname__ yet for Python 2, because of a\n            # Cython bug: https://github.com/cython/cython/issues/2772. See\n            # trac #27002.\n            classname = safe_getattr(self.object, '__qualname__', None)\n            if not classname:\n                classname = safe_getattr(self.object, '__name__', None)\n            if classname:\n                module = safe_getattr(self.object, '__module__', None)\n                parentmodule = safe_getattr(self.parent, '__module__', None)\n                if module and module != parentmodule:\n                    classname = str(module) + u'.' + str(classname)\n                content = ViewList(\n                    [_('alias of :class:`%s`') % classname], source='')\n                ModuleLevelDocumenter.add_content(self, content,\n                                                  no_docstring=True)\n        else:\n            ModuleLevelDocumenter.add_content(self, more_content)\n", "docstring": "type: (Any, bool) -> None"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def can_document_member(cls, member, membername, isattr, parent):\n        # type: (Any, unicode, bool, Any) -> bool\n        return isinstance(member, type) and issubclass(member, BaseException)\n", "docstring": "type: (Any, unicode, bool, Any) -> bool"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def can_document_member(cls, member, membername, isattr, parent):\n        # type: (Any, unicode, bool, Any) -> bool\n        return isinstance(parent, ModuleDocumenter) and isattr\n", "docstring": "type: (Any, unicode, bool, Any) -> bool"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def document_members(self, all_members=False):\n        # type: (bool) -> None\n        pass\n", "docstring": "type: (bool) -> None"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def can_document_member(cls, member, membername, isattr, parent):\n        # type: (Any, unicode, bool, Any) -> bool\n        return inspect.isroutine(member) and not \\\n                isinstance(parent, ModuleDocumenter)\n", "docstring": "type: (Any, unicode, bool, Any) -> bool"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def document_members(self, all_members=False):\n        # type: (bool) -> None\n        pass\n", "docstring": "type: (bool) -> None"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def can_document_member(cls, member, membername, isattr, parent):\n        # type: (Any, unicode, bool, Any) -> bool\n        non_attr_types = (type, MethodDescriptorType)\n        isdatadesc = isdescriptor(member) and not \\\n                inspect.isroutine(member) and not \\\n                isinstance(member, non_attr_types) and not \\\n                type(member).__name__ == \"instancemethod\"\n        isattribute = isdatadesc or (not isinstance(parent, ModuleDocumenter) and isattr)\n        # Trac #26522: This condition is here just to pass objects of classes\n        # that inherit ClasscallMetaclass as attributes rather than method\n        # descriptors.\n        isattribute = isattribute or isinstance(type(member), ClasscallMetaclass)\n        return isattribute\n        # We ignore the obscure case supported in the following return\n        # statement. The additional check opens a door for attributes without\n        # docstrings to appear in the Sage documentation, and more seriously\n        # effectively prevents certain attributes to get properly documented.\n        # See trac #28698.\n        # That last condition addresses an obscure case of C-defined\n        # methods using a deprecated type in Python 3, that is not otherwise\n        # exported anywhere by Python\n        return isattribute or (not isinstance(parent, ModuleDocumenter) and\n                              not inspect.isroutine(member) and\n                              not isinstance(member, type))\n", "docstring": "type: (Any, unicode, bool, Any) -> bool"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def import_object(self):\n        # type: () -> Any\n        ret = ClassLevelDocumenter.import_object(self)\n        if isenumattribute(self.object):\n            self.object = self.object.value\n        if isdescriptor(self.object) and \\\n                not self.is_function_or_method(self.object):\n            self._datadescriptor = True\n        else:\n            # if it's not a data descriptor\n            self._datadescriptor = False\n        return ret\n", "docstring": "type: () -> Any"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def add_directive_header(self, sig):\n        # type: (unicode) -> None\n        ClassLevelDocumenter.add_directive_header(self, sig)\n        sourcename = self.get_sourcename()\n        if not self.options.annotation:\n            if not self._datadescriptor:\n                try:\n                    objrepr = object_description(self.object)\n                except ValueError:\n                    pass\n                else:\n                    self.add_line(u'   :annotation: = ' + objrepr, sourcename)\n        elif self.options.annotation is SUPPRESS:\n            pass\n        else:\n            self.add_line(u'   :annotation: %s' % self.options.annotation,\n                          sourcename)\n", "docstring": "type: (unicode) -> None"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def can_document_member(cls, member, membername, isattr, parent):\n        # type: (Any, unicode, bool, Any) -> bool\n        \"\"\"This documents only INSTANCEATTR members.\"\"\"\n        return isattr and (member is INSTANCEATTR)\n", "docstring": "type: (Any, unicode, bool, Any) -> bool"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def add_content(self, more_content, no_docstring=False):\n        # type: (Any, bool) -> None\n        \"\"\"Never try to get a docstring from the object.\"\"\"\n        AttributeDocumenter.add_content(self, more_content, no_docstring=True)\n", "docstring": "type: (Any, bool) -> None"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "def autodoc_attrgetter(app, obj, name, *defargs):\n    # type: (Sphinx, Any, unicode, Any) -> Any\n    \"\"\"Alternative getattr() for types\"\"\"\n    for typ, func in app.registry.autodoc_attrgettrs.items():\n        if isinstance(obj, typ):\n            return func(obj, name, *defargs)\n    return safe_getattr(obj, name, *defargs)\n", "docstring": "type: (Sphinx, Any, unicode, Any) -> Any"}
{"repo": "sage-master/src/sage_docbuild/ext/sage_autodoc.py", "original_string": "    def __getattr__(self, x):\n        # type: (Any) -> Any\n        return x\n", "docstring": "type: (Any) -> Any"}
{"repo": "sage-master/src/sage/interfaces/sympy.py", "original_string": "    def __get__(self, ins, typ):\n        import sage.all as sage\n        if ins is None:\n            return lambda: _sympysage_function_by_name(typ.__name__)\n        else:\n            args = [arg._sage_() for arg in ins.args]\n            return lambda : _sympysage_function_by_name(ins.__class__.__name__)(*args)\n", "docstring": "import sage.all as sage"}
{"repo": "sage-master/src/sage/interfaces/matlab.py", "original_string": "    def _install_hints(self):\n        return \"\"\"\n        You must obtain the program MATLAB in order to use MATLAB\n        from Sage.   You can read all about MATLAB at\n                  http://www.mathworks.com/\n        You might have to buy MATLAB or get away with setting up a remote connection to a server running Maple. Type\n", "docstring": "return \n"}
{"repo": "sage-master/src/sage/interfaces/matlab.py", "original_string": "    def __getitem__(self, n):\n        raise RuntimeError(\"Use parenthesis for MATLAB matrices instead.\")\n", "docstring": "raise RuntimeError(\"Use parenthesis for MATLAB matrices instead.\")"}
{"repo": "sage-master/src/sage/interfaces/maxima.py", "original_string": "    def _eval_line(self, line, allow_use_file=False,\n                   wait_for_prompt=True, reformat=True, error_check=True, restart_if_needed=False):\n        \"\"\"\n        Return result of line evaluation.\n        EXAMPLES:\n        We check that errors are correctly checked::\n            sage: maxima._eval_line('1+1;')\n            '2'\n            sage: maxima._eval_line('sage0: x == x;')\n            Traceback (most recent call last):\n            ...\n            TypeError: Error executing code in Maxima...\n        \"\"\"\n        if len(line) == 0:\n            return ''\n        line = line.rstrip()\n        if line[-1] != '$' and line[-1] != ';':\n            line += ';'\n        self._synchronize()\n        if len(line) > self.__eval_using_file_cutoff:\n            # This implicitly uses the set method, then displays\n            # the result of the thing that was set.\n            # This only works when the input line is an expression.\n            # But this is our only choice, since\n            # batchmode doesn't display expressions to screen.\n            a = self(line)\n            return repr(a)\n        else:\n            self._sendline(line)\n        line_echo = self._readline()\n        if not wait_for_prompt:\n            return\n        # line_echo sometimes has randomly inserted terminal echo in front #15811\n        assert line_echo.strip().endswith(line.strip()), 'mismatch:\\n' + line_echo + line\n        self._expect_expr(self._display_prompt)\n        out = self._before()  # input echo + output prompt + output\n        if error_check:\n            self._error_check(line, out)\n        if not reformat:\n            return out\n        self._expect_expr()\n        assert len(self._before()) == 0, \\\n                'Maxima expect interface is confused!'\n        r = self._output_prompt_re\n        m = r.search(out)\n        if m is not None:\n            out = out[m.end():]\n        return re.sub(r'\\s+', '', out)\n", "docstring": "wait_for_prompt=True, reformat=True, error_check=True, restart_if_needed=False):"}
{"repo": "sage-master/src/sage/interfaces/magma.py", "original_string": "    def __init__(self, script_subdirectory=None,\n                 logfile=None, server=None, server_tmpdir=None,\n                 user_config=False, seed=None, command=None):\n        \"\"\"\n        INPUT:\n        -  ``script_subdirectory`` - directory where scripts\n           are read from\n        -  ``logfile`` - output logged to this file\n        -  ``server`` - address of remote server\n        - ``server_tmpdir`` - temporary directory to use in remote server\n        -  ``user_config`` - if True, then local user\n           configuration files will be read by Magma. If False (the default),\n           then Magma is started with the -n option which suppresses user\n           configuration files.\n        - ``seed`` - Seed to use in the random number generator.\n        -  ``command`` - (Default: 'magma') The command to execute to start Magma.\n        EXAMPLES::\n            sage: Magma(logfile=tmp_filename())\n            Magma\n        \"\"\"\n        if command is None:\n            import os\n            command = os.getenv('SAGE_MAGMA_COMMAND') or 'magma'\n        if not user_config:\n            command += ' -n'\n        # Obtain the parameters from the environment, to allow the magma = Magma() phrase\n        # to work with non-default parameters.\n        if seed is None:\n            import os\n            seed = os.getenv('SAGE_MAGMA_SEED')\n        Expect.__init__(self,\n                        name=\"magma\",\n                        prompt=\">>SAGE>>\",\n                        command=command,\n                        server=server,\n                        server_tmpdir=server_tmpdir,\n                        script_subdirectory=script_subdirectory,\n                        restart_on_ctrlc=False,\n                        logfile=logfile,\n                        eval_using_file_cutoff=100)\n        # We use \"-n\" above in the Magma startup command so\n        # local user startup configuration is not read.\n        self.__seq = 0\n        self.__ref = 0\n        self.__available_var = []\n        self.__cache = {}\n        self._preparse_colon_equals = False  # if set to try, all \"=\" become \":=\" (some users really appreciate this)\n        self._seed = seed\n", "docstring": "logfile=None, server=None, server_tmpdir=None,"}
{"repo": "sage-master/src/sage/interfaces/kash.py", "original_string": "    def help_search(self, name):\n        return self._doc(self.eval('?*%s' % name))\n", "docstring": "return self._doc(self.eval('?*%s' % name))"}
{"repo": "sage-master/src/sage/interfaces/kash.py", "original_string": "    def _contains(self, v1, v2):\n        return self.eval('%s in %s' % (v1, v2)) == \"TRUE\"\n", "docstring": "return self.eval('%s in %s' % (v1, v2)) == \"TRUE\""}
{"repo": "sage-master/src/sage/interfaces/kash.py", "original_string": "    def version(self):\n        return kash_version()\n", "docstring": "return kash_version()"}
{"repo": "sage-master/src/sage/interfaces/kash.py", "original_string": "    def __repr__(self):\n        if len(self) == 0:\n            return \"No matches.\"\n        return '\\n'.join(self)\n", "docstring": "if len(self) == 0:"}
{"repo": "sage-master/src/sage/interfaces/axiom.py", "original_string": "    def _eval_line(self, line, reformat=True, allow_use_file=False,\n                   wait_for_prompt=True, restart_if_needed=False):\n        \"\"\"\n        EXAMPLES::\n            sage: print(axiom._eval_line('2+2'))  # optional - axiom\n              4\n                                                       Type: PositiveInteger\n        \"\"\"\n        from sage.misc.verbose import verbose\n        if not wait_for_prompt:\n            return Expect._eval_line(self, line)\n        line = line.rstrip().rstrip(';')\n        if line == '':\n            return ''\n        if len(line) > 3000:\n            raise NotImplementedError(\"evaluation of long input lines (>3000 characters) in Axiom not yet implemented.\")\n        if self._expect is None:\n            self._start()\n        if allow_use_file and self.__eval_using_file_cutoff and \\\n                            len(line) > self.__eval_using_file_cutoff:\n            return self._eval_line_using_file(line)\n        try:\n            E = self._expect\n            # debug\n            # self._synchronize(cmd='1+%s\\n')\n            verbose(\"in = '%s'\"%line,level=3)\n            E.sendline(line)\n            self._expect.expect(self._prompt)\n            out = self._expect.before\n            # debug\n            verbose(\"out = '%s'\"%out,level=3)\n        except EOF:\n          if self._quit_string() in line:\n             return ''\n        except KeyboardInterrupt:\n            self._keyboard_interrupt()\n        if '>> Error detected within library code:' in out or \\\n           'Cannot find a definition or applicable library operation named' in out:\n            raise RuntimeError(out)\n        if not reformat:\n            return out\n        if 'error' in out:\n            return out\n        #out = out.lstrip()\n        i = out.find('\\n')\n        out = out[i+1:]\n        outs = out.split(\"\\n\")\n        i = 0\n        for line in outs:\n            line = line.rstrip()\n            if line[:4] == '   (':\n                i = line.find('(')\n                i += line[i:].find(')')+1\n                if line[i:] == \"\":\n                    i = 0\n                    outs = outs[1:]\n                break;\n        out = \"\\n\".join(line[i:] for line in outs[1:])\n        return out\n", "docstring": "wait_for_prompt=True, restart_if_needed=False):"}
{"repo": "sage-master/src/sage/interfaces/axiom.py", "original_string": "    def _equality_symbol(self):\n        \"\"\"equality symbol\n        EXAMPLES::\n            sage: a = axiom(x==6); a    #optional axiom\n            x= 6\n        \"\"\"\n        return \"=\"\n", "docstring": "equality symbol"}
{"repo": "sage-master/src/sage/interfaces/qsieve.py", "original_string": "    def __init__(self, n, time):\n        self._n = n\n        if time:\n            cmd = 'time QuadraticSieve'\n        else:\n            cmd = 'QuadraticSieve'\n        env = os.environ.copy()\n        env['TMPDIR'] = tmp_dir('qsieve')\n        self._p = SageSpawn(cmd, env=env)\n        cleaner.cleaner(self._p.pid, 'QuadraticSieve')\n        self._p.sendline(str(self._n)+'\\n\\n\\n')\n        self._done = False\n        self._out = ''\n        self._time = ''\n        self._do_time = time\n", "docstring": "self._n = n"}
{"repo": "sage-master/src/sage/interfaces/gnuplot.py", "original_string": "    def plot3d(self, f, xmin=-1, xmax=1, ymin=-1, ymax=1, zmin=-1, zmax=1,\n               title=None,\n               samples=25, isosamples=20, xlabel='x', ylabel='y',\n               interact=True):\n        if title is None:\n            title = str(f)\n        f = f.replace('^','**')\n        cmd=\"\"\"\n        set xlabel \"%s\"\n        set ylabel \"%s\"\n        set key top\n        set border 4095\n        set xrange [%s:%s]\n        set yrange [%s:%s]\n        set samples %s\n        set isosamples %s\n        set title \"%s\"\n        set pm3d; set palette\n        #show pm3d\n        #show palette\n        splot %s\n        \"\"\"%(xlabel, ylabel,\n             xmin, xmax, ymin, ymax, #zmin, zmax,\n             samples, isosamples,\n             title, f)\n        if interact:\n            self.interact(cmd)\n        else:\n            self(cmd)\n", "docstring": "title=None,"}
{"repo": "sage-master/src/sage/interfaces/mathematica.py", "original_string": "    def _eval_line(self, line,  allow_use_file=True, wait_for_prompt=True, restart_if_needed=False):\n        s = Expect._eval_line(self, line,\n             allow_use_file=allow_use_file, wait_for_prompt=wait_for_prompt)\n        return str(s).strip('\\n')\n", "docstring": "s = Expect._eval_line(self, line,"}
{"repo": "sage-master/src/sage/interfaces/mathematica.py", "original_string": "    def _false_symbol(self):\n        return 'False'\n", "docstring": "return 'False'"}
{"repo": "sage-master/src/sage/interfaces/mathematica.py", "original_string": "    def str(self):\n        return str(self)\n", "docstring": "return str(self)"}
{"repo": "sage-master/src/sage/interfaces/r.py", "original_string": "    def __init__(self,\n                 maxread=None,\n                 logfile=None,\n                 init_list_length=1024,\n                 seed=None):\n        \"\"\"\n        An interface to the R interpreter.\n        R is a comprehensive collection of methods for statistics,\n        modelling, bioinformatics, data analysis and much more.\n        For more details, see http://www.r-project.org/about.html\n        Resources:\n        * http://r-project.org/ provides more information about R.\n        * http://rseek.org/ R's own search engine.\n        EXAMPLES::\n             sage: r.summary(r.c(1,2,3,111,2,3,2,3,2,5,4))  # optional - rpy2\n             Min. 1st Qu.  Median    Mean 3rd Qu.    Max.\n             1.00    2.00    3.00   12.55    3.50  111.00\n        TESTS::\n            sage: r == loads(dumps(r))  # optional - rpy2\n            True\n        \"\"\"\n        Interface.__init__(\n                self,\n                name = 'r', # The capitalized version of this is used for printing.\n        )\n        self._seed = seed\n        self._initialized = False # done lazily\n", "docstring": "maxread=None,"}
{"repo": "sage-master/src/sage/interfaces/r.py", "original_string": "    def _loaded_package_pages(self, topic):\n        # for some reason `except` doesn't work with lazy import, so import this here\n        from rpy2.robjects.help import HelpNotFoundError\n        self._lazy_init()\n        res = list()\n        for name in rinterface.baseenv['loadedNamespaces']():\n            pack = Package(name)\n            try:\n                page = pack.fetch(topic)\n                res.append(page)\n            except HelpNotFoundError:\n                pass\n        return tuple(res)\n", "docstring": "for some reason `except` doesn't work with lazy import, so import this here"}
{"repo": "sage-master/src/sage/interfaces/polymake.py", "original_string": "            def convert(y):\n                if isinstance(y, cls):\n                    return y\n                else:\n                    return self(y)\n", "docstring": "if isinstance(y, cls):"}
{"repo": "sage-master/src/sage/interfaces/polymake.py", "original_string": "    def __init__(self, script_subdirectory=None,\n                 logfile=None, server=None, server_tmpdir=None,\n                 seed=None, command=None):\n        \"\"\"\n        TESTS::\n            sage: from sage.interfaces.polymake import PolymakeExpect\n            sage: PolymakeExpect()\n            Polymake\n            sage: PolymakeExpect().is_running()\n            False\n        \"\"\"\n        if command is None:\n            command = \"env TERM=dumb {}\".format(os.getenv('SAGE_POLYMAKE_COMMAND') or 'polymake')\n        PolymakeAbstract.__init__(self, seed=seed)\n        Expect.__init__(self,\n                        name=\"polymake\",\n                        command=command,\n                        prompt=\"polytope > \",\n                        server=server,\n                        server_tmpdir=server_tmpdir,\n                        script_subdirectory=script_subdirectory,\n                        restart_on_ctrlc=False,\n                        logfile=logfile,\n                        eval_using_file_cutoff=1024)   # > 1024 causes hangs\n", "docstring": "logfile=None, server=None, server_tmpdir=None,"}
{"repo": "sage-master/src/sage/interfaces/psage.py", "original_string": "    def _send_nowait(self, x):\n        if x.find('\\n') != -1:\n            raise ValueError(\"x must not have any newlines\")\n        # Now we want the client Python process to execute two things.\n        # The first is x and the second is c.  The effect of c\n        # will be to unlock the lock.\n        if self.is_locked():\n            return \"<<currently executing code>>\"\n        E = self.expect()\n        self._lock()\n        E.write(self.preparse(x) + '\\n')\n        try:\n            E.expect(self._prompt)\n        except ExceptionPexpect:\n            pass\n        E.write(self._unlock_code + '\\n\\n')\n", "docstring": "if x.find('\\n') != -1:"}
{"repo": "sage-master/src/sage/interfaces/lisp.py", "original_string": "    def _synchronize(self):\n        E = self._expect\n        if E is None:\n            self._start()\n            E = self._expect\n        r = random.randrange(2147483647)\n        s = str(r+1)\n        cmd = \"(+ 1 %s)\"%r\n        E.sendline(cmd)\n        E.expect(s)\n        E.expect(self._prompt)\n", "docstring": "E = self._expect"}
{"repo": "sage-master/src/sage/interfaces/interface.py", "original_string": "    def name(self, new_name=None):\n        return self.__name\n", "docstring": "return self.__name"}
{"repo": "sage-master/src/sage/interfaces/interface.py", "original_string": "    def execute(self, *args, **kwds):\n        return self.eval(*args, **kwds)\n", "docstring": "return self.eval(*args, **kwds)"}
{"repo": "sage-master/src/sage/interfaces/interface.py", "original_string": "    def new(self, code):\n        return self(code)\n", "docstring": "return self(code)"}
{"repo": "sage-master/src/sage/interfaces/interface.py", "original_string": "    def _contains(self, v1, v2):\n        raise NotImplementedError\n", "docstring": "raise NotImplementedError"}
{"repo": "sage-master/src/sage/interfaces/interface.py", "original_string": "    def __init__(self, parent, value, is_name=False, name=None):\n        Element.__init__(self, parent)\n        self._create = value\n        if parent is None:\n            return     # means \"invalid element\"\n        # idea: Joe Wetherell -- try to find out if the output\n        # is too long and if so get it using file, otherwise\n        # don't.\n        if is_name:\n            self._name = value\n        else:\n            try:\n                self._name = parent._create(value, name=name)\n            except (TypeError, RuntimeError, ValueError) as x:\n                raise TypeError(x)\n", "docstring": "Element.__init__(self, parent)"}
{"repo": "sage-master/src/sage/interfaces/interface.py", "original_string": "    def __call__(self, *args):\n        self._check_valid()\n        P = self.parent()\n        return getattr(P, self.name())(*args)\n", "docstring": "self._check_valid()"}
{"repo": "sage-master/src/sage/interfaces/interface.py", "original_string": "    def _matrix_(self, R):\n        raise NotImplementedError\n", "docstring": "raise NotImplementedError"}
{"repo": "sage-master/src/sage/interfaces/interface.py", "original_string": "    def gen(self, n):\n        P = self._check_valid()\n        return P.new('%s.%s'%(self._name, int(n)))\n", "docstring": "P = self._check_valid()"}
{"repo": "sage-master/src/sage/interfaces/singular.py", "original_string": "    def _keyboard_interrupt(self):\n        print(\"Interrupting %s...\" % self)\n        try:\n            self._expect.sendline(chr(4))\n        except pexpect.ExceptionPexpect as msg:\n            raise pexpect.ExceptionPexpect(\"THIS IS A BUG -- PLEASE REPORT. This should never happen.\\n\" + msg)\n        self._start()\n        raise KeyboardInterrupt(\"Restarting %s (WARNING: all variables defined in previous session are now invalid)\" % self)\n", "docstring": "print(\"Interrupting %s...\" % self)"}
{"repo": "sage-master/src/sage/interfaces/singular.py", "original_string": "    def wrapper(*args, **kwds):\n        with SingularGBDefaultContext():\n            return func(*args, **kwds)\n", "docstring": "with SingularGBDefaultContext():"}
{"repo": "sage-master/src/sage/interfaces/octave.py", "original_string": "    def _eval_line(self, line, reformat=True, allow_use_file=False,\n                   wait_for_prompt=True, restart_if_needed=False):\n        \"\"\"\n        EXAMPLES::\n            sage: print(octave._eval_line('2+2'))  #optional - octave\n              ans =  4\n        \"\"\"\n        from pexpect.exceptions import EOF\n        if not wait_for_prompt:\n            return Expect._eval_line(self, line)\n        if line == '':\n            return ''\n        if self._expect is None:\n            self._start()\n        if allow_use_file and len(line)>3000:\n            return self._eval_line_using_file(line)\n        try:\n            E = self._expect\n            # debug\n            # self._synchronize(cmd='1+%s\\n')\n            verbose(\"in = '%s'\"%line,level=3)\n            E.sendline(line)\n            E.expect(self._prompt)\n            out = bytes_to_str(E.before)\n            # debug\n            verbose(\"out = '%s'\"%out,level=3)\n        except EOF:\n            if self._quit_string() in line:\n                return ''\n        except KeyboardInterrupt:\n            self._keyboard_interrupt()\n        try:\n            if reformat:\n                if 'syntax error' in out:\n                    raise SyntaxError(out)\n            out = \"\\n\".join(out.splitlines()[1:])\n            return out\n        except NameError:\n            return ''\n", "docstring": "wait_for_prompt=True, restart_if_needed=False):"}
{"repo": "sage-master/src/sage/homology/hochschild_complex.py", "original_string": "        def on_basis(k):\n            p = self._M.monomial(k[0]) * self._A.monomial(k[1])\n            ret = Fd._from_dict({(m,) + k[2:]: c for m,c in p}, remove_zeros=False)\n            for i in range(1, d):\n                p = self._A.monomial(k[i]) * self._A.monomial(k[i+1])\n                ret += mone**i * Fd._from_dict({k[:i] + (m,) + k[i+2:]: c\n                                                   for m,c in p}, remove_zeros=False)\n            p = self._A.monomial(k[-1]) * self._M.monomial(k[0])\n            ret += mone**d * Fd._from_dict({(m,) + k[1:-1]: c for m,c in p},\n                                           remove_zeros=False)\n            return ret\n", "docstring": "p = self._M.monomial(k[0]) * self._A.monomial(k[1])"}
{"repo": "sage-master/src/sage/homology/hochschild_complex.py", "original_string": "            def arrow_art(d):\n                d_str = ['  d_{0}  '.format(d)]\n                arrow = ' <' + '-'*(len(d_str[0])-3) + ' '\n                d_str.append(arrow)\n                return AsciiArt(d_str, baseline=0)\n", "docstring": "d_str = ['  d_{0}  '.format(d)]"}
{"repo": "sage-master/src/sage/categories/euclidean_domains.py", "original_string": "            def refine(a, b):\n                g = a.gcd(b)\n                if g.is_unit():\n                    return (a, set(), b)\n                l1, s1, r1 = refine(a//g, g)\n                l2, s2, r2 = refine(r1, b//g)\n                s1.update(s2)\n                s1.add(l2)\n                return (l1, s1, r2)\n", "docstring": "g = a.gcd(b)"}
{"repo": "sage-master/src/sage/categories/crystals.py", "original_string": "    def __init__(self, parent, cartan_type=None,\n                 virtualization=None, scaling_factors=None):\n        \"\"\"\n        Initialize ``self``.\n        TESTS::\n            sage: B = crystals.Tableaux(['A',2], shape=[2,1])\n            sage: H = Hom(B, B)\n            sage: psi = H.an_element()\n        \"\"\"\n        if cartan_type is None:\n            cartan_type = parent.domain().cartan_type()\n        self._cartan_type = cartan_type\n        index_set = cartan_type.index_set()\n        if scaling_factors is None:\n            scaling_factors = {i: 1 for i in index_set}\n        if virtualization is None:\n            virtualization = {i: (i,) for i in index_set}\n        elif not isinstance(virtualization, dict):\n            try:\n                virtualization = dict(virtualization)\n            except (TypeError, ValueError):\n                virtualization = {i: (virtualization(i),) for i in index_set}\n        from sage.sets.family import Family\n        self._virtualization = Family(virtualization)\n        self._scaling_factors = Family(scaling_factors)\n        Morphism.__init__(self, parent)\n", "docstring": "virtualization=None, scaling_factors=None):"}
{"repo": "sage-master/src/sage/categories/finite_coxeter_groups.py", "original_string": "            def shard_comparison(u, v):\n                Gu, Nu = data[u]\n                Gv, Nv = data[v]\n                return Gu.issubset(Gv) and Nu.issubset(Nv)\n", "docstring": "Gu, Nu = data[u]"}
{"repo": "sage-master/src/sage/categories/finite_coxeter_groups.py", "original_string": "            def degrees_of_irreducible_component(I):\n                \"\"\"Return the degrees for the irreducible component indexed by I\"\"\"\n                # A Coxeter element\n                s = self.simple_reflections()\n                c = self.prod(s[i] for i in I)\n                roots = c.matrix().change_ring(QQbar).charpoly().roots()\n                args = [(z.rational_argument(), m) for z, m in roots]\n                args = [(z if z >=0 else 1 + z, m) for z, m in args]\n                h = max(z.denominator() for z, m in args)\n                return tuple(sorted(ZZ(z * h + 1)\n                                    for z, m in args if z\n                                    for i in range(m)))\n", "docstring": "Return the degrees for the irreducible component indexed by I\n"}
{"repo": "sage-master/src/sage/categories/pushout.py", "original_string": "    def __init__(self, I, names=None, as_field=False, domain=None,\n                 codomain=None, **kwds):\n        \"\"\"\n        INPUT:\n        - ``I``, an ideal (the modulus)\n        - ``names`` (optional string or list of strings), the names for the\n          quotient ring generators\n        - ``as_field`` (optional bool, default false), return the quotient\n          ring as field (if available).\n        - ``domain`` (optional category, default ``Rings()``), the domain of\n          this functor.\n        - ``codomain`` (optional category, default ``Rings()``), the codomain\n          of this functor.\n        - Further named arguments. In particular, an implementation of the\n          quotient can be suggested here.  These named arguments are passed to\n          the quotient construction.\n        TESTS::\n            sage: from sage.categories.pushout import QuotientFunctor\n            sage: P.<t> = ZZ[]\n            sage: F = QuotientFunctor([5+t^2]*P)\n            sage: F(P)\n            Univariate Quotient Polynomial Ring in tbar over Integer Ring with modulus t^2 + 5\n            sage: F(QQ['t'])\n            Univariate Quotient Polynomial Ring in tbar over Rational Field with modulus t^2 + 5\n            sage: F = QuotientFunctor([5+t^2]*P,names='s')\n            sage: F(P)\n            Univariate Quotient Polynomial Ring in s over Integer Ring with modulus t^2 + 5\n            sage: F(QQ['t'])\n            Univariate Quotient Polynomial Ring in s over Rational Field with modulus t^2 + 5\n            sage: F = QuotientFunctor([5]*ZZ,as_field=True)\n            sage: F(ZZ)\n            Finite Field of size 5\n            sage: F = QuotientFunctor([5]*ZZ)\n            sage: F(ZZ)\n            Ring of integers modulo 5\n        \"\"\"\n        if domain is None:\n            domain = Rings()\n        if codomain is None:\n            codomain = Rings()\n        Functor.__init__(self, domain, codomain)\n        \n        self.I = I\n        if names is None:\n            self.names = None\n        elif isinstance(names, str):\n            self.names = (names,)\n        else:\n            self.names = tuple(names)\n        self.as_field = as_field\n        self.kwds = kwds\n", "docstring": "codomain=None, **kwds):"}
{"repo": "sage-master/src/sage/categories/affine_weyl_groups.py", "original_string": "            def select_length(pair):\n                u, length = pair\n                if length == k:\n                    return u\n", "docstring": "u, length = pair"}
{"repo": "sage-master/src/sage/numerical/linear_tensor_constraints.py", "original_string": "        def matrix_art(m):\n            lines = str(m).splitlines()\n            return AsciiArt(lines, baseline=len(lines) // 2)\n", "docstring": "lines = str(m).splitlines()"}
{"repo": "sage-master/src/sage/numerical/backends/logging_backend.py", "original_string": "    def m(self, *args, **kwdargs):\n        funcall = _format_function_call(\"p.\" + attr, *args, **kwdargs)\n        a = getattr(self._backend, attr)\n        if self._printing:\n            print(\"# {}\".format(funcall))\n        if self._doctest:\n            self._doctest.write(\"        sage: {}\\n\".format(funcall))\n        try:\n            result = a(*args, **kwdargs)\n        except Exception as e:\n            if self._printing:\n                print(\"# exception: {}\".format(e))\n            if self._doctest:\n                self._doctest.write(\"        Traceback (most recent call last):\\n\"\n                                    \"        ...\\n\"\n                                    \"        MIPSolverException: {}\\n\".format(e))\n            if self._test_method:\n                self._test_method.write((\"        with tester.assertRaises({}) as cm:\\n\"+\n                                         \"            {}\\n\").format(type(e).__name__, funcall))\n            raise\n        else:\n            if self._printing:\n                print(\"# result: {}\".format(result))\n            if self._doctest:\n                self._doctest.write(\"        {}\\n\".format(result))\n            if self._test_method:\n                if result is None:\n                    self._test_method.write(\"        tester.assertIsNone({})\\n\".format(funcall))\n                elif type(result) is float:\n                    # TODO: by default assertAlmostEqual does 7 decimal places (not significant digits)\n                    # better perhaps to compute an appropriate 'places' or 'delta' parameter from result.\n                    self._test_method.write(\"        tester.assertAlmostEqual({}, {})\\n\".format(funcall, result))\n                else:\n                    self._test_method.write(\"        tester.assertEqual({}, {})\\n\".format(funcall, result))\n        return result\n", "docstring": "funcall = _format_function_call(\"p.\" + attr, *args, **kwdargs)"}
{"repo": "sage-master/src/sage/typeset/character_art.py", "original_string": "            def __init__(self, stack):\n                self._stack = [iter(elems) for elems in stack]\n", "docstring": "self._stack = [iter(elems) for elems in stack]"}
{"repo": "sage-master/src/sage/groups/abelian_gps/abelian_group_morphism.py", "original_string": "    def __init__(self, G, H, genss, imgss):\n        from sage.categories.homset import Hom\n        Morphism.__init__(self, Hom(G, H))\n        if len(genss) != len(imgss):\n            raise TypeError(\"Sorry, the lengths of %s, %s must be equal.\" % (genss, imgss))\n        self._domain = G\n        self._codomain = H\n        if not(G.is_abelian()):\n            raise TypeError(\"Sorry, the groups must be abelian groups.\")\n        if not(H.is_abelian()):\n            raise TypeError(\"Sorry, the groups must be abelian groups.\")\n        G_domain = G.subgroup(genss)\n        if G_domain.order() != G.order():\n            raise TypeError(\"Sorry, the list %s must generate G.\" % genss)\n        # self.domain_invs = G.gens_orders()\n        # self.codomaininvs = H.gens_orders()\n        self.domaingens = genss\n        self.codomaingens = imgss\n        for i in range(len(self.domaingens)):\n            if (self.domaingens[i]).order() != (self.codomaingens[i]).order():\n                raise TypeError(\"Sorry, the orders of the corresponding elements in %s, %s must be equal.\" % (genss, imgss))\n", "docstring": "from sage.categories.homset import Hom"}
{"repo": "sage-master/src/sage/groups/matrix_gps/named_group.py", "original_string": "    def __init__(self, degree, base_ring, special, sage_name, latex_string,\n                 category=None, invariant_form=None):\n        \"\"\"\n        Base class for \"named\" matrix groups\n        INPUT:\n        - ``degree`` -- integer; the degree (number of rows/columns of\n          matrices)\n        - ``base_ring`` -- ring; the base ring of the matrices\n        - ``special`` -- boolean; whether the matrix group is special,\n          that is, elements have determinant one\n        - ``sage_name`` -- string; the name of the group\n        - ``latex_string`` -- string; the latex representation\n        - ``category`` -- (optional) a subcategory of\n          :class:`sage.categories.groups.Groups` passed to\n          the constructor of\n          :class:`sage.groups.matrix_gps.matrix_group.MatrixGroup_generic`\n        - ``invariant_form`` --  (optional) square-matrix of the given\n          degree over the given base_ring describing a bilinear form\n          to be kept invariant by the group\n        EXAMPLES::\n            sage: G = GL(2, QQ)\n            sage: from sage.groups.matrix_gps.named_group import NamedMatrixGroup_generic\n            sage: isinstance(G, NamedMatrixGroup_generic)\n            True\n        .. SEEALSO::\n            See the examples for :func:`GU`, :func:`SU`, :func:`Sp`, etc.\n            as well.\n        \"\"\"\n        MatrixGroup_generic.__init__(self, degree, base_ring, category=category)\n        self._special = special\n        self._name_string = sage_name\n        self._latex_string = latex_string\n        self._invariant_form = invariant_form\n", "docstring": "category=None, invariant_form=None):"}
{"repo": "sage-master/src/sage/groups/matrix_gps/coxeter_group.py", "original_string": "            def val(x):\n                if x == -1:\n                    return 2\n                else:\n                    return E(2 * x) + ~E(2 * x)\n", "docstring": "if x == -1:"}
{"repo": "sage-master/src/sage/groups/matrix_gps/heisenberg.py", "original_string": "        def elementary_matrix(i, j, val, MS):\n            elm = copy(MS.one())\n            elm[i,j] = val\n            elm.set_immutable()\n            return elm\n", "docstring": "elm = copy(MS.one())"}
{"repo": "sage-master/src/sage/media/wav.py", "original_string": "    def _repr_(self):\n        nc = self.getnchannels()\n        return \"Wave file %s with %s channel%s of length %s seconds%s\" % \\\n        (self._name, nc, \"\" if nc == 1 else \"s\", self.getlength(), \"\" if nc == 1 else \" each\")\n", "docstring": "nc = self.getnchannels()"}
{"repo": "sage-master/src/sage/media/wav.py", "original_string": "    def plot_raw(self, npoints=None, channel=0, plotjoined=True, **kwds):\n        npoints = self._normalize_npoints(npoints)\n        seconds = float(self._nframes) / float(self._width)\n        sample_step = seconds / float(npoints)\n        domain = [float(n*sample_step) / float(self._framerate) for n in range(npoints)]\n        frame_skip = self._nframes / npoints\n        values = [self.channel_data(channel)[frame_skip*i] for i in range(npoints)]\n        points = zip(domain, values)\n        return list_plot(points, plotjoined=plotjoined, **kwds)\n", "docstring": "npoints = self._normalize_npoints(npoints)"}
{"repo": "sage-master/src/sage/media/wav.py", "original_string": "    def _copy(self, start, stop):\n        start = start * self._width\n        stop = stop * self._width\n        channels_sliced = [self._channel_data[i][start:stop] for i in range(self._nchannels)]\n        print(stop - start)\n        return Wave(nchannels = self._nchannels,\n                    width = self._width,\n                    framerate = self._framerate,\n                    bytes = self._bytes[start:stop],\n                    nframes = stop - start,\n                    channel_data = channels_sliced,\n                    name = self._name)\n", "docstring": "start = start * self._width"}
{"repo": "sage-master/src/sage/structure/sequence.py", "original_string": "    def __init__(self, x, universe=None, check=True, immutable=False,\n                 cr=False, cr_str=None, use_sage_types=False):\n        \"\"\"\n        Create a sequence.\n        EXAMPLES::\n            sage: Sequence([1..5])\n            [1, 2, 3, 4, 5]\n            sage: a = Sequence([1..3], universe=QQ, check=False, immutable=True, cr=True, cr_str=False, use_sage_types=True)\n            sage: a\n            [\n            1,\n            2,\n            3\n            ]\n            sage: a = Sequence([1..5], universe=QQ, check=False, immutable=True, cr_str=True, use_sage_types=True)\n            sage: a\n            [1, 2, 3, 4, 5]\n            sage: a._Sequence_generic__cr_str\n            True\n            sage: a.__str__()\n            '[\\n1,\\n2,\\n3,\\n4,\\n5\\n]'\n        \"\"\"\n        self.__hash = None\n        self.__cr = cr\n        if cr_str is None:\n            self.__cr_str = cr\n        else:\n            self.__cr_str = cr_str\n        if isinstance(x, Sequence_generic):\n            if universe is None or universe == x.__universe:\n                list.__init__(self, x)\n                self.__universe = x.__universe\n                self._is_immutable = immutable\n                return\n        self.__universe = universe\n        if check:\n            x = list(x)\n            for i in range(len(x)):\n                try:\n                    x[i] = universe(x[i])\n                except TypeError:\n                    raise TypeError(\"unable to convert {} to an element of {}\"\n                                    .format(x[i], universe))\n        list.__init__(self, x)\n        self._is_immutable = immutable\n", "docstring": "cr=False, cr_str=None, use_sage_types=False):"}
{"repo": "sage-master/src/sage/structure/sequence.py", "original_string": "    def __getslice__(self, i, j):\n        return self.__getitem__(slice(i,j))\n", "docstring": "return self.__getitem__(slice(i,j))"}
{"repo": "sage-master/src/sage/structure/graphics_file.py", "original_string": "    def _launch_jmol(self):\n        launch_script = tmp_filename(ext='.spt')\n        with open(launch_script, 'w') as f:\n            f.write('set defaultdirectory \"{0}\"\\n'.format(self.filename()))\n            f.write('script SCRIPT\\n')\n        os.system('jmol {0} 2>/dev/null 1>/dev/null &'\n                  .format(launch_script))\n", "docstring": "launch_script = tmp_filename(ext='.spt')"}
{"repo": "sage-master/src/sage/interacts/library.py", "original_string": "def taylor_polynomial(\n    title = text_control('<h2>Taylor polynomial</h2>'),\n    f=input_box(sin(x)*exp(-x),label=\"$f(x)=$\"), order=slider(range(1,13))):\n    \"\"\"\n    An interact which illustrates the Taylor polynomial approximation\n    of various orders around `x=0`.\n        - ``f`` -- function expression\n        - ```order``` -- integer slider\n    EXAMPLES:\n    Invoked in the notebook, the following command will produce\n    the fully formatted interactive mathlet.  In the command line,\n    it will simply return the underlying HTML and Sage code which\n    creates the mathlet::\n        sage: interacts.calculus.taylor_polynomial()\n        Interactive function <function taylor_polynomial at ...> with 3 widgets\n          title: HTMLText(value=u'<h2>Taylor polynomial</h2>')\n          f: EvalText(value=u'e^(-x)*sin(x)', description=u'$f(x)=$', layout=Layout(max_width=u'81em'))\n          order: SelectionSlider(description=u'order', options=(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), value=1)\n    \"\"\"\n    x0  = 0\n    p   = plot(f,(x,-1,5), thickness=2)\n    dot = point((x0,f(x=x0)),pointsize=80,rgbcolor=(1,0,0))\n    ft = f.taylor(x,x0,order)\n    pt = plot(ft,(-1, 5), color='green', thickness=2)\n    html(r'$f(x)\\;=\\;%s$' % latex(f))\n    html(r'$\\hat{f}(x;%s)\\;=\\;%s+\\mathcal{O}(x^{%s})$' % (x0, latex(ft),\n                                                          order + 1))\n    show(dot + p + pt, ymin = -.5, ymax = 1)\n", "docstring": "title = text_control('<h2>Taylor polynomial</h2>'),"}
{"repo": "sage-master/src/sage/combinat/cluster_complex.py", "original_string": "        def act(F):\n            return self.parent().element_class(sorted([D[i] for i in F]))\n", "docstring": "return self.parent().element_class(sorted([D[i] for i in F]))"}
{"repo": "sage-master/src/sage/combinat/sine_gordon.py", "original_string": "        def vertex_to_angle(v):\n            # v==0 corresponds to pi/2\n            return -2 * pi * RR(v) / self.r() + 5 * pi / 2\n", "docstring": "v==0 corresponds to pi/2"}
{"repo": "sage-master/src/sage/combinat/finite_state_machine_generators.py", "original_string": "        def starts_with(what, pattern):\n            return len(what) >= len(pattern) \\\n                and what[:len(pattern)] == pattern\n", "docstring": "return len(what) >= len(pattern) \\"}
{"repo": "sage-master/src/sage/combinat/finite_state_machine_generators.py", "original_string": "        def transition_function(states2, input):\n            (state_carry, state_level) = states2\n            ((carry, level), output) = recursion_transitions(\n                state_carry, state_level, False)\n            # no more recursion transition is possible,\n            # so this is now a storing transition\n            carry += input * base**level\n            level += 1\n            # We now may proceed along recursion transitions\n            # as long as the carries stay non-negative.\n            ((carry, level), new_output) = recursion_transitions(\n                carry, level, True)\n            return ((carry, level), output + new_output)\n", "docstring": "(state_carry, state_level) = states2"}
{"repo": "sage-master/src/sage/combinat/k_tableau.py", "original_string": "        def chi(x):\n            if x is None:\n                return \"\"\n            if x in ZZ:\n                s = \"%s\"%abs(x)\n                if x<0:\n                    s += \"^\\\\ast\"\n                return s\n            return \"%s\"%x\n", "docstring": "if x is None:"}
{"repo": "sage-master/src/sage/combinat/parking_functions.py", "original_string": "    def parking_permutation(self) -> Permutation:\n        # indices are cars, entries are parking spaces\n        r\"\"\"\n        Return the sequence of parking spots that are taken by cars 1\n        through `n` and corresponding to the parking function.\n        For example, ``parking_permutation(PF) = [6, 1, 5, 2, 3, 4,\n        7]`` means that spot 6 is taken by car 1, spot 1 by car 2,\n        spot 5 by car 3, spot 2 is taken by car 4, spot 3 is taken by\n        car 5, spot 4 is taken by car 6 and spot 7 is taken by car 7.\n        INPUT:\n        - ``self`` -- parking function word\n        OUTPUT:\n        - the permutation of parking spots that corresponds to\n          the parking function and which is the same size as parking\n          function\n        EXAMPLES::\n            sage: PF = ParkingFunction([6, 1, 5, 2, 2, 1, 5])\n            sage: PF.parking_permutation()\n            [6, 1, 5, 2, 3, 4, 7]\n        ::\n            sage: ParkingFunction([3,1,1,4]).parking_permutation()\n            [3, 1, 2, 4]\n            sage: ParkingFunction([4,1,1,1]).parking_permutation()\n            [4, 1, 2, 3]\n            sage: ParkingFunction([2,1,4,1]).parking_permutation()\n            [2, 1, 4, 3]\n        \"\"\"\n        return self.cars_permutation().inverse()\n", "docstring": "indices are cars, entries are parking spaces"}
{"repo": "sage-master/src/sage/combinat/parking_functions.py", "original_string": "    def cars_permutation(self) -> Permutation:\n        # indices are parking spaces, entries are car labels\n        r\"\"\"\n        Return the sequence of cars that take parking spots 1 through `n`\n        and corresponding to the parking function.\n        For example, ``cars_permutation(PF) = [2, 4, 5, 6, 3, 1, 7]``\n        means that car 2 takes spots 1, car 4 takes spot 2, ..., car 1 takes spot 6 and\n        car 7 takes spot 7.\n        INPUT:\n        - ``self`` -- parking function word\n        OUTPUT:\n        - the permutation of cars corresponding to the parking function\n          and which is the same size as parking function\n        EXAMPLES::\n            sage: PF = ParkingFunction([6, 1, 5, 2, 2, 1, 5])\n            sage: PF.cars_permutation()\n            [2, 4, 5, 6, 3, 1, 7]\n        ::\n            sage: ParkingFunction([3,1,1,4]).cars_permutation()\n            [2, 3, 1, 4]\n            sage: ParkingFunction([4,1,1,1]).cars_permutation()\n            [2, 3, 4, 1]\n            sage: ParkingFunction([2,1,4,1]).cars_permutation()\n            [2, 1, 4, 3]\n        \"\"\"\n        out = {}\n        for i in range(len(self)):\n            j = 0\n            while self[i] + j in out:\n                j += 1\n            out[self[i] + j] = i\n        return Permutation([out[i + 1] + 1 for i in range(len(self))])\n", "docstring": "indices are parking spaces, entries are car labels"}
{"repo": "sage-master/src/sage/combinat/set_partition.py", "original_string": "        def re(N, k):\n            if N == 0:\n                return [[]]\n            elif N == 1:\n                return [[0]]\n            elif float(stirling_number2(N-1, k-1))/float(stirling_number2(N, k)) > random():\n                return [[N-1]] + re(N-1, k-1)\n            else:\n                p = re(N-1, k)\n                p[randint(0, len(p)-1)].append(N-1)\n                return p\n", "docstring": "if N == 0:"}
{"repo": "sage-master/src/sage/combinat/sf/witt.py", "original_string": "            def wsum_e(m):     # expansion of e_m in w-basis, for m > 0\n                return self._from_dict({lam: (-1 if (m + len(lam)) % 2 == 1 else 1)\n                                        for lam in Partitions(m, max_slope=-1)})\n", "docstring": "return self._from_dict({lam: (-1 if (m + len(lam)) % 2 == 1 else 1)"}
{"repo": "sage-master/src/sage/combinat/sf/ns_macdonald.py", "original_string": "        def fn(ij):\n            return (-ij[1], -ij[0])\n", "docstring": "return (-ij[1], -ij[0])"}
{"repo": "sage-master/src/sage/combinat/sf/sfa.py", "original_string": "                def component(i, g): # == h_g[L_i]\n                    L_i = p.sum_of_terms([(_Partitions([d] * (i//d)), R(mu(d)))\n                                          for d in squarefree_divisors(i)],\n                                         distinct=True) / i\n                    return p(h[g]).plethysm(L_i)\n", "docstring": "L_i = p.sum_of_terms([(_Partitions([d] * (i//d)), R(mu(d)))"}
{"repo": "sage-master/src/sage/combinat/words/lyndon_word.py", "original_string": "    def standard_unbracketing_rec(w):\n        if not isinstance(w, list):\n            return [w], []\n        if len(w) != 2:\n            raise ValueError(\"not a standard bracketing of a Lyndon word\")\n        x, t = standard_unbracketing_rec(w[0])\n        y, _ = standard_unbracketing_rec(w[1])\n        # If x = st is a standard Lyndon factorization, and y is a Lyndon word\n        # such that y <= t, then xy is standard (but not necessarily Lyndon).\n        if x < y and (len(t) == 0 or y <= t):\n            x += y\n            return x, y\n        else:\n            raise ValueError(\"not a standard bracketing of a Lyndon word\")\n", "docstring": "if not isinstance(w, list):"}
{"repo": "sage-master/src/sage/combinat/cluster_algebra_quiver/quiver_mutation_type.py", "original_string": "    def samples(self, finite=None, affine=None, elliptic=None,\n                mutation_finite=None):\n        \"\"\"\n        Return a sample of the available quiver mutations types.\n        INPUT:\n        - ``finite``\n        - ``affine``\n        - ``elliptic``\n        - ``mutation_finite``\n        All four input keywords default values are ``None``. If\n        set to ``True`` or ``False``, only these samples are returned.\n        EXAMPLES::\n            sage: QuiverMutationType.samples()\n            [['A', 1], ['A', 5], ['B', 2], ['B', 5], ['C', 3],\n             ['C', 5], [ ['A', 1], ['A', 1] ], ['D', 5], ['E', 6],\n             ['E', 7], ['E', 8], ['F', 4], ['G', 2],\n             ['A', [1, 1], 1], ['A', [4, 5], 1], ['D', 4, 1],\n             ['BB', 5, 1], ['E', 6, [1, 1]], ['E', 7, [1, 1]],\n             ['R2', [1, 5]], ['R2', [3, 5]], ['E', 10], ['BE', 5],\n             ['GR', [3, 10]], ['T', [3, 3, 4]]]\n            sage: QuiverMutationType.samples(finite=True)\n            [['A', 1], ['A', 5], ['B', 2], ['B', 5], ['C', 3],\n             ['C', 5], [ ['A', 1], ['A', 1] ], ['D', 5], ['E', 6],\n             ['E', 7], ['E', 8], ['F', 4], ['G', 2]]\n            sage: QuiverMutationType.samples(affine=True)\n            [['A', [1, 1], 1], ['A', [4, 5], 1], ['D', 4, 1], ['BB', 5, 1]]\n            sage: QuiverMutationType.samples(elliptic=True)\n            [['E', 6, [1, 1]], ['E', 7, [1, 1]]]\n            sage: QuiverMutationType.samples(mutation_finite=False)\n            [['R2', [1, 5]], ['R2', [3, 5]], ['E', 10], ['BE', 5],\n             ['GR', [3, 10]], ['T', [3, 3, 4]]]\n        \"\"\"\n        result = self._samples()\n        if finite is not None:\n            result = [t for t in result if t.is_finite() == finite]\n        if affine is not None:\n            result = [t for t in result if t.is_affine() == affine]\n        if elliptic is not None:\n            result = [t for t in result if t.is_elliptic() == elliptic]\n        if mutation_finite is not None:\n            result = [t for t in result\n                      if t.is_mutation_finite() == mutation_finite]\n        return result\n", "docstring": "mutation_finite=None):"}
{"repo": "sage-master/src/sage/combinat/species/generating_series.py", "original_string": "        def multinv_builder(i):\n            return self.coefficient(0)**(-i-1) * (self.coefficient(0) + (-1)*self)**i\n", "docstring": "return self.coefficient(0)**(-i-1) * (self.coefficient(0) + (-1)*self)**i"}
{"repo": "sage-master/src/sage/combinat/species/generating_series.py", "original_string": "        def arith_prod_of_partitions(l1, l2):\n            # Given two partitions `l_1` and `l_2`, we construct a new partition `l_1 \\\\boxtimes l_2` by\n            # the following procedure: each pair of parts `a \\\\in l_1` and `b \\\\in l_2` contributes\n            # `\\\\gcd (a, b)`` parts of size `\\\\lcm (a, b)` to `l_1 \\\\boxtimes l_2`. If `l_1` and `l_2`\n            # are partitions of integers `n` and `m`, respectively, then `l_1 \\\\boxtimes l_2` is a\n            # partition of `nm`.\n            term_iterable = chain.from_iterable(repeat(lcm(pair), gcd(pair))\n                                                for pair in product(l1, l2))\n            return Partition(sorted(term_iterable, reverse=True))\n", "docstring": "Given two partitions `l_1` and `l_2`, we construct a new partition `l_1 \\\\boxtimes l_2` by"}
{"repo": "sage-master/src/sage/combinat/species/generating_series.py", "original_string": "        def arith_prod_sf(x, y):\n            ap_sf_wrapper = lambda l1, l2: p(arith_prod_of_partitions(l1, l2))\n            return p._apply_multi_module_morphism(x, y, ap_sf_wrapper)\n", "docstring": "ap_sf_wrapper = lambda l1, l2: p(arith_prod_of_partitions(l1, l2))"}
{"repo": "sage-master/src/sage/combinat/species/misc.py", "original_string": "    def new_func(*args, **kwds):\n        if 'size' in kwds:\n            if 'min' in kwds or 'max' in kwds:\n                raise ValueError(\"cannot specify both size and (min or max)\")\n            kwds['min'] = kwds['size']\n            kwds['max'] = kwds['size'] + 1\n            del kwds['size']\n        return f(*args, **kwds)\n", "docstring": "if 'size' in kwds:"}
{"repo": "sage-master/src/sage/combinat/species/series.py", "original_string": "    def _approximate_order(self, compute_coefficients, new_order, *series):\n        if self.is_initialized:\n            return\n        ochanged = self.aorder_changed\n        ao = new_order(*[s.aorder for s in series])\n        ao = inf if ao == unk else ao\n        tchanged = self.set_approximate_order(ao)\n        if len(series) == 0:\n            must_initialize_coefficient_stream = True\n            tchanged = ochanged = False\n        elif len(series) == 1 or len(series) == 2:\n            must_initialize_coefficient_stream = ( self.aorder == unk or self.is_initialized is False)\n        else:\n            raise ValueError\n        if ochanged or tchanged:\n            for s in series:\n                s.compute_aorder()\n            ao = new_order(*[s.aorder for s in series])\n            tchanged = self.set_approximate_order(ao)\n        if must_initialize_coefficient_stream:\n            self.initialize_coefficient_stream(compute_coefficients)\n        if hasattr(self, '_reference') and self._reference is not None:\n            self._reference._copy(self)\n", "docstring": "if self.is_initialized:"}
{"repo": "sage-master/src/sage/combinat/crystals/kirillov_reshetikhin.py", "original_string": "    def __init__(self, base, ambient, pdict_inv, index_set,\n                 similarity_factor_domain=None, automorphism=None):\n        \"\"\"\n        Initialize ``self``.\n        EXAMPLES::\n            sage: K = crystals.KirillovReshetikhin(['B',3,1], 3,1)\n            sage: phi = K.from_ambient_crystal()\n            sage: TestSuite(phi).run(skip=['_test_category', '_test_pickling'])\n        \"\"\"\n        from sage.categories.sets_with_partial_maps import SetsWithPartialMaps\n        Map.__init__(self, Hom(ambient, base, SetsWithPartialMaps()))\n        if similarity_factor_domain is None:\n            similarity_factor_domain = {i:1 for i in index_set}\n        if automorphism is None:\n            automorphism = lambda i: i\n        self._pdict_inv = pdict_inv\n        self._automorphism = automorphism\n        self._similarity_factor_domain = similarity_factor_domain\n        self._index_set = index_set\n", "docstring": "similarity_factor_domain=None, automorphism=None):"}
{"repo": "sage-master/src/sage/combinat/crystals/multisegments.py", "original_string": "            def sort_key(mc):\n                x = mc[0]\n                return (-x[0], ZZ(x[1]))\n", "docstring": "x = mc[0]"}
{"repo": "sage-master/src/sage/combinat/designs/steiner_quadruple_systems.py", "original_string": "    def get_label(x):\n        if x in label:\n            return label[x]\n        else:\n            total = len(label)-4\n            label[x] = total\n            return total\n", "docstring": "if x in label:"}
{"repo": "sage-master/src/sage/combinat/root_system/weyl_characters.py", "original_string": "            def next_level(wt):\n                return [wt + la for la in fw if self.level(wt + la) <= k]\n", "docstring": "return [wt + la for la in fw if self.level(wt + la) <= k]"}
{"repo": "sage-master/src/sage/combinat/root_system/weyl_group.py", "original_string": "    def __classcall__(cls, domain, prefix=None):\n        return super(WeylGroup_gens, cls).__classcall__(cls, domain, prefix)\n", "docstring": "return super(WeylGroup_gens, cls).__classcall__(cls, domain, prefix)"}
{"repo": "sage-master/src/sage/combinat/root_system/weyl_group.py", "original_string": "    def morphism_matrix(self, f):\n        return matrix(self.domain().base_ring(), [f(b).to_vector()\n                           for b in self.domain().basis()]).transpose()\n", "docstring": "return matrix(self.domain().base_ring(), [f(b).to_vector()"}
{"repo": "sage-master/src/sage/combinat/root_system/weyl_group.py", "original_string": "        def to_elt(alp):\n            ref = self.domain().reflection(alp)\n            m = Matrix([ref(x).to_vector() for x in self.domain().basis()])\n            return self(m.transpose())\n", "docstring": "ref = self.domain().reflection(alp)"}
{"repo": "sage-master/src/sage/combinat/root_system/weyl_group.py", "original_string": "    def apply_simple_reflection(self, i, side = \"right\"):\n        s = self.parent().simple_reflections()\n        if side == \"right\":\n            return self * s[i]\n        else:\n            return s[i] * self\n", "docstring": "s = self.parent().simple_reflections()"}
{"repo": "sage-master/src/sage/combinat/root_system/branching_rules.py", "original_string": "            def f(x):\n                return other._f(self._f(x))\n", "docstring": "return other._f(self._f(x))"}
{"repo": "sage-master/src/sage/combinat/root_system/braid_move_calculator.py", "original_string": "        def partial_braid_word(length, swap=False, i=i, k=k):\n            if swap:\n                i, k = k, i\n            running_braid_word = [i, k] * (length // 2)\n            if length % 2:\n                running_braid_word.append(i)\n            return tuple(running_braid_word)\n", "docstring": "if swap:"}
{"repo": "sage-master/src/sage/combinat/root_system/weight_space.py", "original_string": "            def sortkey(x):\n                return (1 if isinstance(x, str) else 0, x)\n", "docstring": "return (1 if isinstance(x, str) else 0, x)"}
{"repo": "sage-master/src/sage/monoids/free_monoid.py", "original_string": "    def __classcall_private__(cls, index_set=None, names=None,\n                              commutative=False, **kwds):\n        r\"\"\"\n        Construct a free monoid or a free abelian monoid, depending on the\n        input. Also, normalize the input.\n        EXAMPLES::\n            sage: F.<a,b,c,d,e> = FreeMonoid(); F\n            Free monoid on 5 generators (a, b, c, d, e)\n            sage: FreeMonoid(index_set=ZZ)\n            Free monoid indexed by Integer Ring\n            sage: F.<x,y,z> = FreeMonoid(abelian=True); F\n            Free abelian monoid on 3 generators (x, y, z)\n            sage: FreeMonoid(index_set=ZZ, commutative=True)\n            Free abelian monoid indexed by Integer Ring\n            sage: F = FreeMonoid(index_set=ZZ, names='x,y,z')\n            sage: G = FreeMonoid(index_set=ZZ, names=['x', 'y', 'z'])\n            sage: F == G\n            True\n            sage: F is G\n            True\n            sage: FreeMonoid(2, names='a,b') is FreeMonoid(names=['a','b'])\n            True\n        Fix a bug when ``index_set`` is ``None`` and ``names`` is a\n        string (:trac:`26221`)::\n            sage: FreeMonoid(2, names=['a','b']) is FreeMonoid(names='a,b')\n            True\n        \"\"\"\n        if 'abelian' in kwds:\n            commutative = kwds.pop('abelian')\n        if commutative:\n            from sage.monoids.free_abelian_monoid import FreeAbelianMonoid\n            return FreeAbelianMonoid(index_set, names, **kwds)\n        # Swap args (this works if names is None as well)\n        if isinstance(index_set, str):\n            names, index_set = index_set, names\n        if index_set is None and names is not None:\n            if isinstance(names, str):\n                index_set = names.count(',') + 1\n            else:\n                index_set = len(names)\n        if index_set not in ZZ:\n            if names is not None:\n                names = normalize_names(-1, names)\n            from sage.monoids.indexed_free_monoid import IndexedFreeMonoid\n            return IndexedFreeMonoid(index_set, names=names, **kwds)\n        if names is None:\n            raise ValueError(\"names must be specified\")\n        names = normalize_names(index_set, names)\n        return super(FreeMonoid, cls).__classcall__(cls, index_set, names)\n", "docstring": "commutative=False, **kwds):"}
{"repo": "sage-master/src/sage/tensor/modules/free_module_basis.py", "original_string": "    def __init__(self, basis, symbol, latex_symbol=None, indices=None,\n                 latex_indices=None):\n        r\"\"\"\n        TESTS::\n            sage: from sage.tensor.modules.free_module_basis import FreeModuleCoBasis\n            sage: M = FiniteRankFreeModule(ZZ, 3, name='M')\n            sage: e = M.basis('e')\n            sage: f = FreeModuleCoBasis(e, 'f')\n            sage: TestSuite(f).run()\n        \"\"\"\n        self._basis = basis\n        Basis_abstract.__init__(self, basis._fmodule, symbol, latex_symbol,\n                                indices, latex_indices)\n        # The individual linear forms:\n        vl = list()\n        fmodule = self._fmodule\n        ring_one = fmodule._ring.one()\n        for i in fmodule.irange():\n            v = fmodule.linear_form()\n            v.set_comp(basis)[i] = ring_one\n            vl.append(v)\n        self._vec = tuple(vl)\n        # The names:\n        self.set_name(symbol, latex_symbol=latex_symbol, indices=indices,\n                      latex_indices=latex_indices, index_position='up')\n", "docstring": "latex_indices=None):"}
{"repo": "sage-master/src/sage/matrix/matrix_space.py", "original_string": "def _MatrixSpace_ZZ_2x2():\n    from sage.rings.integer_ring import ZZ\n    return MatrixSpace(ZZ,2)\n", "docstring": "from sage.rings.integer_ring import ZZ"}
{"repo": "sage-master/src/sage/sat/converters/polybori.py", "original_string": "        def to_dimacs_index(v):\n            return v.index() + 1\n", "docstring": "return v.index() + 1"}
{"repo": "sage-master/src/sage/symbolic/expression_conversions.py", "original_string": "    def __init__(self):\n        from sage.interfaces.sympy import sympy_init\n        sympy_init()\n", "docstring": "from sage.interfaces.sympy import sympy_init"}
{"repo": "sage-master/src/sage/symbolic/expression_conversions.py", "original_string": "    def __init__(self):\n        import sage.interfaces.fricas\n        super(FriCASConverter, self).__init__(sage.interfaces.fricas.fricas)\n", "docstring": "import sage.interfaces.fricas"}
{"repo": "sage-master/src/sage/symbolic/constants.py", "original_string": "    def __init__(self, name, conversions=None, latex=None, mathml=\"\",\n                 domain='complex'):\n        \"\"\"\n        EXAMPLES::\n            sage: from sage.symbolic.constants import Constant\n            sage: p = Constant('p')\n            sage: loads(dumps(p))\n            p\n        \"\"\"\n        self._conversions = conversions if conversions is not None else {}\n        self._latex = latex if latex is not None else name\n        self._mathml = mathml\n        self._name = name\n        self._domain = domain\n        for system, value in self._conversions.items():\n            setattr(self, \"_%s_\"%system, partial(self._generic_interface, value))\n            setattr(self, \"_%s_init_\"%system, partial(self._generic_interface_init, value))\n        from sage.libs.pynac.constant import PynacConstant\n        self._pynac = PynacConstant(self._name, self._latex, self._domain)\n        self._serial = self._pynac.serial()\n        constants_table[self._serial] = self\n        constants_name_table[self._name] = self\n        register_symbol(self.expression(), self._conversions)\n", "docstring": "domain='complex'):"}
{"repo": "sage-master/src/sage/schemes/toric/morphism.py", "original_string": "        def projection(ray):\n            ray_L = L.coordinates(ray)\n            return vector(ZZ, L_quotient(ray_L))\n", "docstring": "ray_L = L.coordinates(ray)"}
{"repo": "sage-master/src/sage/schemes/toric/points.py", "original_string": "    def multiplicative_group_order(self):\n        return self.ring.multiplicative_generator().multiplicative_order()\n", "docstring": "return self.ring.multiplicative_generator().multiplicative_order()"}
{"repo": "sage-master/src/sage/schemes/hyperelliptic_curves/jacobian_generic.py", "original_string": "    def _point_homset(self, *args, **kwds):\n        return jacobian_homset.JacobianHomset_divisor_classes(*args, **kwds)\n", "docstring": "return jacobian_homset.JacobianHomset_divisor_classes(*args, **kwds)"}
{"repo": "sage-master/src/sage/schemes/hyperelliptic_curves/hyperelliptic_generic.py", "original_string": "    def __init__(self, PP, f, h=None, names=None, genus=None):\n        x, y, z = PP.gens()\n        df = f.degree()\n        F1 = sum([ f[i]*x**i*z**(df-i) for i in range(df+1) ])\n        if h is None:\n            F = y**2*z**(df-2) - F1\n        else:\n            dh = h.degree()\n            deg = max(df,dh+1)\n            F0 = sum([ h[i]*x**i*z**(dh-i) for i in range(dh+1) ])\n            F = y**2*z**(deg-2) + F0*y*z**(deg-dh-1) - F1*z**(deg-df)\n        plane_curve.ProjectivePlaneCurve.__init__(self,PP,F)\n        R = PP.base_ring()\n        if names is None:\n            names = (\"x\", \"y\")\n        else:\n            names = normalize_names(2, names)\n        self._names = names\n        P1 = PolynomialRing(R, name=names[0])\n        P2 = PolynomialRing(P1, name=names[1])\n        self._PP = PP\n        self._printing_ring = P2\n        self._hyperelliptic_polynomials = (f,h)\n        self._genus = genus\n", "docstring": "x, y, z = PP.gens()"}
{"repo": "sage-master/src/sage/schemes/cyclic_covers/cycliccover_finite_field.py", "original_string": "        def _N0_RH():\n            return ceil(\n                log(2 * binomial(2 * self._genus, self._genus), self._p)\n                + self._genus * self._n / ZZ(2)\n            )\n", "docstring": "return ceil("}
{"repo": "sage-master/src/sage/schemes/cyclic_covers/cycliccover_finite_field.py", "original_string": "        def _extend_frobpow(power):\n            if power < len(self._frobpow_list):\n                pass\n            else:\n                frobpow = self._Zqx(self._frobpow_list[-1])\n                for k in range(len(self._frobpow_list), power + 1):\n                    frobpow *= self._frobf\n                self._frobpow_list.extend([frobpow.list()])\n            assert power < len(self._frobpow_list)\n", "docstring": "if power < len(self._frobpow_list):"}
{"repo": "sage-master/src/sage/schemes/projective/projective_morphism.py", "original_string": "            def self_with_domain(C):\n                return self*C.hom(Amb.gens(), X)\n", "docstring": "return self*C.hom(Amb.gens(), X)"}
{"repo": "sage-master/src/sage/schemes/elliptic_curves/constructor.py", "original_string": "def tangent_at_smooth_point(C,P):\n    \"\"\"Return the tangent at the smooth point `P` of projective curve `C`.\n    INPUT:\n    - ``C`` -- a projective plane curve.\n    - ``P`` -- a 3-tuple `(x,y,z)` defining a projective point on `C`.\n    OUTPUT:\n    The linear form defining the tangent at `P` to `C`.\n    EXAMPLES::\n        sage: R.<x,y,z> = QQ[]\n        sage: from sage.schemes.elliptic_curves.constructor import tangent_at_smooth_point\n        sage: C = Curve(x^3+y^3+60*z^3)\n        sage: tangent_at_smooth_point(C, [1,-1,0])\n        x + y\n        sage: K.<t> = FunctionField(QQ)\n        sage: R.<x,y,z> = K[]\n        sage: C = Curve(x^3+2*y^3+3*z^3)\n        sage: from sage.schemes.elliptic_curves.constructor import tangent_at_smooth_point\n        sage: tangent_at_smooth_point(C,[1,1,-1])\n        3*x + 6*y + 9*z\n    \"\"\"\n    # Over function fields such as QQ(t) an error is raised with the\n    # default (factor=True).  Note that factor=False returns the\n    # product of the tangents in case of a multiple point, while here\n    # `P` is assumed smooth so factorization is unnecessary, but over\n    # QQ (for example) including the factorization gives better\n    # results, for example returning x+y instead of 3x+3y in the\n    # doctest.\n    try:\n        return C.tangents(P)[0]\n    except NotImplementedError:\n        return C.tangents(P,factor=False)[0]\n", "docstring": "Return the tangent at the smooth point `P` of projective curve `C`."}
{"repo": "sage-master/src/sage/schemes/elliptic_curves/heegner.py", "original_string": "    def twist_is_minimal(D):\n        # return True if the quadratic twist E^D has analytic rank <= 1\n        return E.quadratic_twist(D).analytic_rank() <= 1\n", "docstring": "return True if the quadratic twist E^D has analytic rank <= 1"}
{"repo": "sage-master/src/sage/schemes/elliptic_curves/heegner.py", "original_string": "    def best_heegner_D(ell_1, ell_2):\n        # return the first Heegner D satisfy all hypothesis such that\n        # both ell_1 and ell_2 are inert\n        D = -5\n        while True:\n            if number_field.is_fundamental_discriminant(D) and \\\n               D % ell_1 and D % ell_2 and \\\n               E.satisfies_heegner_hypothesis(D) and \\\n               is_inert(D, ell_1) and is_inert(D, ell_2) and \\\n               twist_is_minimal(D):\n                return D\n            D -= 1\n", "docstring": "return the first Heegner D satisfy all hypothesis such that"}
{"repo": "sage-master/src/sage/schemes/elliptic_curves/heegner.py", "original_string": "    def kernel_of_reduction(ell):\n        # return list of reps for the kernel as a subgroup of the map\n        # E(Q) / q E(Q)  ---->  E(F_ell) / q E(F_ell)\n        m = ZZ(E.Np(ell) / q)\n        A = [a*P + b*Q for a in range(q) for b in range(q)]\n        return [z for z in A if red(z,ell) * m == 0]\n", "docstring": "return list of reps for the kernel as a subgroup of the map"}
{"repo": "sage-master/src/sage/schemes/elliptic_curves/gp_simon.py", "original_string": "    def _gp_mod(*args):\n        return args[0]\n", "docstring": "return args[0]"}
{"repo": "sage-master/src/sage/schemes/elliptic_curves/ell_torsion.py", "original_string": "            def red(c):\n                return Fq.sum(Fq(c[j]) * ai**j for j in range(d))\n", "docstring": "return Fq.sum(Fq(c[j]) * ai**j for j in range(d))"}
{"repo": "sage-master/src/sage/schemes/generic/point.py", "original_string": "def is_SchemeTopologicalPoint(x):\n    return isinstance(x, SchemeTopologicalPoint)\n", "docstring": "return isinstance(x, SchemeTopologicalPoint)"}
{"repo": "sage-master/src/sage/schemes/generic/point.py", "original_string": "def is_SchemeRationalPoint(x):\n    return isinstance(x, SchemeRationalPoint)\n", "docstring": "return isinstance(x, SchemeRationalPoint)"}
{"repo": "sage-master/src/sage/dynamics/arithmetic_dynamics/endPN_minimal_model.py", "original_string": "    def insert_item(pts, item, index):\n        # binary insertion to maintain list of points left to consider\n        N = len(pts)\n        if N == 0:\n          return [item]\n        elif N == 1:\n            if item[index] > pts[0][index]:\n                pts.insert(0,item)\n            else:\n                pts.append(item)\n            return pts\n        else: # binary insertion\n            left = 1\n            right = N\n            mid = (left + right) // 2  # these are ints so this is .floor()\n            if item[index] > pts[mid][index]: # item goes into first half\n                return insert_item(pts[:mid], item, index) + pts[mid:N]\n            else: # item goes into second half\n                return pts[:mid] + insert_item(pts[mid:N], item, index)\n", "docstring": "binary insertion to maintain list of points left to consider"}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def __init__(self, x=None):\n        \"\"\"Initialize an instance.\n        Optional argument x controls seeding, as for Random.seed().\n        \"\"\"\n        self.seed(x)\n        self.gauss_next = None\n", "docstring": "Initialize an instance."}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def getstate(self):\n        \"\"\"Return internal state; can be passed to setstate() later.\"\"\"\n        return self.VERSION, super(Random, self).getstate(), self.gauss_next\n", "docstring": "Return internal state; can be passed to setstate() later.\n"}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def jumpahead(self, n):\n        \"\"\"Change the internal state to one that is likely far away\n        from the current state.  This method will not be in Py3.x,\n        so it is better to simply reseed.\n        \"\"\"\n        # The super.jumpahead() method uses shuffling to change state,\n        # so it needs a large and \"interesting\" n to work with.  Here,\n        # we use hashing to create a large n for the shuffle.\n        s = repr(n) + repr(self.getstate())\n        n = int(_hashlib.new('sha512', s).hexdigest(), 16)\n        super(Random, self).jumpahead(n)\n", "docstring": "Change the internal state to one that is likely far away"}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def randrange(self, start, stop=None, step=1, _int=int, _maxwidth=1<<BPF):\n        \"\"\"Choose a random item from range(start, stop[, step]).\n        This fixes the problem with randint() which includes the\n        endpoint; in Python this is usually not what you want.\n        \"\"\"\n        # This code is a bit messy to make it fast for the\n        # common case while still doing adequate error checking.\n        istart = _int(start)\n        if istart != start:\n            raise ValueError(\"non-integer arg 1 for randrange()\")\n        if stop is None:\n            if istart > 0:\n                if istart >= _maxwidth:\n                    return self._randbelow(istart)\n                return _int(self.random() * istart)\n            raise ValueError(\"empty range for randrange()\")\n        # stop argument supplied.\n        istop = _int(stop)\n        if istop != stop:\n            raise ValueError(\"non-integer stop for randrange()\")\n        width = istop - istart\n        if step == 1 and width > 0:\n            # Note that\n            #     int(istart + self.random()*width)\n            # instead would be incorrect.  For example, consider istart\n            # = -2 and istop = 0.  Then the guts would be in\n            # -2.0 to 0.0 exclusive on both ends (ignoring that random()\n            # might return 0.0), and because int() truncates toward 0, the\n            # final result would be -1 or 0 (instead of -2 or -1).\n            #     istart + int(self.random()*width)\n            # would also be incorrect, for a subtler reason:  the RHS\n            # can return a long, and then randrange() would also return\n            # a long, but we're supposed to return an int (for backward\n            # compatibility).\n            if width >= _maxwidth:\n                return _int(istart + self._randbelow(width))\n            return _int(istart + _int(self.random()*width))\n        if step == 1:\n            raise ValueError(\"empty range for randrange() (%d,%d, %d)\" %\n                    (istart, istop, width))\n        # Non-unit step argument supplied.\n        istep = _int(step)\n        if istep != step:\n            raise ValueError(\"non-integer step for randrange()\")\n        if istep > 0:\n            n = (width + istep - 1) // istep\n        elif istep < 0:\n            n = (width + istep + 1) // istep\n        else:\n            raise ValueError(\"zero step for randrange()\")\n        if n <= 0:\n            raise ValueError(\"empty range for randrange()\")\n        if n >= _maxwidth:\n            return istart + istep*self._randbelow(n)\n        return istart + istep*_int(self.random() * n)\n", "docstring": "Choose a random item from range(start, stop[, step])."}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def choice(self, seq):\n        \"\"\"Choose a random element from a non-empty sequence.\"\"\"\n        return seq[int(self.random() * len(seq))]  # raises IndexError if seq is empty\n", "docstring": "Choose a random element from a non-empty sequence.\n"}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def uniform(self, a, b):\n        \"Get a random number in the range [a, b) or [a, b] depending on rounding.\"\n        return a + (b-a) * self.random()\n", "docstring": "\"Get a random number in the range [a, b) or [a, b] depending on rounding.\""}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def triangular(self, low=0.0, high=1.0, mode=None):\n        \"\"\"Triangular distribution.\n        Continuous distribution bounded by given lower and upper limits,\n        and having a given mode value in-between.\n        http://en.wikipedia.org/wiki/Triangular_distribution\n        \"\"\"\n        u = self.random()\n        try:\n            c = 0.5 if mode is None else (mode - low) / (high - low)\n        except ZeroDivisionError:\n            return low\n        if u > c:\n            u = 1.0 - u\n            c = 1.0 - c\n            low, high = high, low\n        return low + (high - low) * (u * c) ** 0.5\n", "docstring": "Triangular distribution."}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def normalvariate(self, mu, sigma):\n        \"\"\"Normal distribution.\n        mu is the mean, and sigma is the standard deviation.\n        \"\"\"\n        # mu = mean, sigma = standard deviation\n        # Uses Kinderman and Monahan method. Reference: Kinderman,\n        # A.J. and Monahan, J.F., \"Computer generation of random\n        # variables using the ratio of uniform deviates\", ACM Trans\n        # Math Software, 3, (1977), pp257-260.\n        random = self.random\n        while 1:\n            u1 = random()\n            u2 = 1.0 - random()\n            z = NV_MAGICCONST*(u1-0.5)/u2\n            zz = z*z/4.0\n            if zz <= -_log(u2):\n                break\n        return mu + z*sigma\n", "docstring": "Normal distribution."}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def lognormvariate(self, mu, sigma):\n        \"\"\"Log normal distribution.\n        If you take the natural logarithm of this distribution, you'll get a\n        normal distribution with mean mu and standard deviation sigma.\n        mu can have any value, and sigma must be greater than zero.\n        \"\"\"\n        return _exp(self.normalvariate(mu, sigma))\n", "docstring": "Log normal distribution."}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def expovariate(self, lambd):\n        \"\"\"Exponential distribution.\n        lambd is 1.0 divided by the desired mean.  It should be\n        nonzero.  (The parameter would be called \"lambda\", but that is\n        a reserved word in Python.)  Returned values range from 0 to\n        positive infinity if lambd is positive, and from negative\n        infinity to 0 if lambd is negative.\n        \"\"\"\n        # lambd: rate lambd = 1/mean\n        # ('lambda' is a Python reserved word)\n        # we use 1-random() instead of random() to preclude the\n        # possibility of taking the log of zero.\n        return -_log(1.0 - self.random())/lambd\n", "docstring": "Exponential distribution."}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def vonmisesvariate(self, mu, kappa):\n        \"\"\"Circular data distribution.\n        mu is the mean angle, expressed in radians between 0 and 2*pi, and\n        kappa is the concentration parameter, which must be greater than or\n        equal to zero.  If kappa is equal to zero, this distribution reduces\n        to a uniform random angle over the range 0 to 2*pi.\n        \"\"\"\n        # mu:    mean angle (in radians between 0 and 2*pi)\n        # kappa: concentration parameter kappa (>= 0)\n        # if kappa = 0 generate uniform random angle\n        # Based upon an algorithm published in: Fisher, N.I.,\n        # \"Statistical Analysis of Circular Data\", Cambridge\n        # University Press, 1993.\n        # Thanks to Magnus Kessler for a correction to the\n        # implementation of step 4.\n        random = self.random\n        if kappa <= 1e-6:\n            return TWOPI * random()\n        s = 0.5 / kappa\n        r = s + _sqrt(1.0 + s * s)\n        while 1:\n            u1 = random()\n            z = _cos(_pi * u1)\n            d = z / (r + z)\n            u2 = random()\n            if u2 < 1.0 - d * d or u2 <= (1.0 - d) * _exp(d):\n                break\n        q = 1.0 / r\n        f = (q + z) / (1.0 + q * z)\n        u3 = random()\n        if u3 > 0.5:\n            theta = (mu + _acos(f)) % TWOPI\n        else:\n            theta = (mu - _acos(f)) % TWOPI\n        return theta\n", "docstring": "Circular data distribution."}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def gammavariate(self, alpha, beta):\n        \"\"\"Gamma distribution.  Not the gamma function!\n        Conditions on the parameters are alpha > 0 and beta > 0.\n        The probability distribution function is:\n                    x ** (alpha - 1) * math.exp(-x / beta)\n          pdf(x) =  --------------------------------------\n                      math.gamma(alpha) * beta ** alpha\n        \"\"\"\n        # alpha > 0, beta > 0, mean is alpha*beta, variance is alpha*beta**2\n        # Warning: a few older sources define the gamma distribution in terms\n        # of alpha > -1.0\n        if alpha <= 0.0 or beta <= 0.0:\n            raise ValueError('gammavariate: alpha and beta must be > 0.0')\n        random = self.random\n        if alpha > 1.0:\n            # Uses R.C.H. Cheng, \"The generation of Gamma\n            # variables with non-integral shape parameters\",\n            # Applied Statistics, (1977), 26, No. 1, p71-74\n            ainv = _sqrt(2.0 * alpha - 1.0)\n            bbb = alpha - LOG4\n            ccc = alpha + ainv\n            while 1:\n                u1 = random()\n                if not 1e-7 < u1 < .9999999:\n                    continue\n                u2 = 1.0 - random()\n                v = _log(u1/(1.0-u1))/ainv\n                x = alpha*_exp(v)\n                z = u1*u1*u2\n                r = bbb+ccc*v-x\n                if r + SG_MAGICCONST - 4.5*z >= 0.0 or r >= _log(z):\n                    return x * beta\n        elif alpha == 1.0:\n            # expovariate(1)\n            u = random()\n            while u <= 1e-7:\n                u = random()\n            return -_log(u) * beta\n        else:   # alpha is between 0 and 1 (exclusive)\n            # Uses ALGORITHM GS of Statistical Computing - Kennedy & Gentle\n            while 1:\n                u = random()\n                b = (_e + alpha)/_e\n                p = b*u\n                if p <= 1.0:\n                    x = p ** (1.0/alpha)\n                else:\n                    x = -_log((b-p)/alpha)\n                u1 = random()\n                if p > 1.0:\n                    if u1 <= x ** (alpha - 1.0):\n                        break\n                elif u1 <= _exp(-x):\n                    break\n            return x * beta\n", "docstring": "Gamma distribution.  Not the gamma function!"}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def gauss(self, mu, sigma):\n        \"\"\"Gaussian distribution.\n        mu is the mean, and sigma is the standard deviation.  This is\n        slightly faster than the normalvariate() function.\n        Not thread-safe without a lock around calls.\n        \"\"\"\n        # When x and y are two variables from [0, 1), uniformly\n        # distributed, then\n        #\n        #    cos(2*pi*x)*sqrt(-2*log(1-y))\n        #    sin(2*pi*x)*sqrt(-2*log(1-y))\n        #\n        # are two *independent* variables with normal distribution\n        # (mu = 0, sigma = 1).\n        # (Lambert Meertens)\n        # (corrected version; bug discovered by Mike Miller, fixed by LM)\n        # Multithreading note: When two threads call this function\n        # simultaneously, it is possible that they will receive the\n        # same return value.  The window is very small though.  To\n        # avoid this, you have to use a lock around all calls.  (I\n        # didn't want to slow this down in the serial case by using a\n        # lock here.)\n        random = self.random\n        z = self.gauss_next\n        self.gauss_next = None\n        if z is None:\n            x2pi = random() * TWOPI\n            g2rad = _sqrt(-2.0 * _log(1.0 - random()))\n            z = _cos(x2pi) * g2rad\n            self.gauss_next = _sin(x2pi) * g2rad\n        return mu + z*sigma\n", "docstring": "Gaussian distribution."}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def betavariate(self, alpha, beta):\n        \"\"\"Beta distribution.\n        Conditions on the parameters are alpha > 0 and beta > 0.\n        Returned values range between 0 and 1.\n        \"\"\"\n        # This version due to Janne Sinkkonen, and matches all the std\n        # texts (e.g., Knuth Vol 2 Ed 3 pg 134 \"the beta distribution\").\n        y = self.gammavariate(alpha, 1.)\n        if y == 0:\n            return 0.0\n        else:\n            return y / (y + self.gammavariate(beta, 1.))\n", "docstring": "Beta distribution."}
{"repo": "sage-master/src/sage/cpython/_py2_random.py", "original_string": "    def paretovariate(self, alpha):\n        \"\"\"Pareto distribution.  alpha is the shape parameter.\"\"\"\n        # Jain, pg. 495\n        u = 1.0 - self.random()\n        return 1.0 / pow(u, 1.0/alpha)\n", "docstring": "Pareto distribution.  alpha is the shape parameter.\n"}
{"repo": "sage-master/src/sage/modular/cusps.py", "original_string": "    def _element_constructor_(self, x):\n        return Cusp(x)\n", "docstring": "return Cusp(x)"}
{"repo": "sage-master/src/sage/modular/modform/constructor.py", "original_string": "def CuspForms(group  = 1,\n              weight = 2,\n              base_ring = None,\n              use_cache = True,\n              prec = defaults.DEFAULT_PRECISION):\n    \"\"\"\n    Create a space of cuspidal modular forms.\n    See the documentation for the ModularForms command for a\n    description of the input parameters.\n    EXAMPLES::\n        sage: CuspForms(11,2)\n        Cuspidal subspace of dimension 1 of Modular Forms space of dimension 2 for Congruence Subgroup Gamma0(11) of weight 2 over Rational Field\n    \"\"\"\n    return ModularForms(group, weight, base_ring,\n                        use_cache=use_cache, prec=prec).cuspidal_submodule()\n", "docstring": "weight = 2,"}
{"repo": "sage-master/src/sage/modular/modsym/boundary.py", "original_string": "    def __init__(self,\n                 group = arithgroup.Gamma0(1),\n                 weight = 2,\n                 sign = 0,\n                 base_ring = rings.QQ,\n                 character = None):\n        \"\"\"\n        Space of boundary symbols for a congruence subgroup of SL_2(Z).\n        This class is an abstract base class, so only derived classes\n        should be instantiated.\n        INPUT:\n        -  ``weight`` - int, the weight\n        -  ``group`` - arithgroup.congroup_generic.CongruenceSubgroup, a congruence\n           subgroup.\n        -  ``sign`` - int, either -1, 0, or 1\n        -  ``base_ring`` - rings.Ring (defaults to the\n           rational numbers)\n        EXAMPLES::\n            sage: B = ModularSymbols(Gamma0(11),2).boundary_space()\n            sage: isinstance(B, sage.modular.modsym.boundary.BoundarySpace)\n            True\n            sage: B == loads(dumps(B))\n            True\n        \"\"\"\n        weight = int(weight)\n        if weight <= 1:\n            raise ArithmeticError(\"weight must be at least 2\")\n        if not arithgroup.is_CongruenceSubgroup(group):\n            raise TypeError(\"group must be a congruence subgroup\")\n        sign = int(sign)\n        if not isinstance(base_ring, rings.Ring) and rings.is_CommutativeRing(base_ring):\n            raise TypeError(\"base_ring must be a commutative ring\")\n        if character is None and arithgroup.is_Gamma0(group):\n            character = dirichlet.TrivialCharacter(group.level(), base_ring)\n        (self.__group, self.__weight, self.__character,\n          self.__sign, self.__base_ring) = (group, weight,\n                                             character, sign, base_ring)\n        self._known_gens = []\n        self._zero_cusps = []\n        hecke.HeckeModule_generic.__init__(self, base_ring, group.level())\n", "docstring": "group = arithgroup.Gamma0(1),"}
{"repo": "sage-master/src/sage/modular/pollack_stevens/distributions.py", "original_string": "    def __init__(self, k, base, character, adjuster, act_on_left, dettwist,\n                 act_padic, implementation):\n        r\"\"\"\n        EXAMPLES::\n            sage: D = sage.modular.pollack_stevens.distributions.Symk(4); D\n            Sym^4 Q^2\n            sage: TestSuite(D).run() # indirect doctest\n        \"\"\"\n        if hasattr(base, 'prime'):\n            p = base.prime()\n        else:\n            p = ZZ(0)\n        OverconvergentDistributions_abstract.__init__(self, k, p, k + 1, base, character,\n                                        adjuster, act_on_left, dettwist,\n                                        act_padic, implementation)\n", "docstring": "act_padic, implementation):"}
{"repo": "sage-master/src/sage/modular/btquotients/btquotient.py", "original_string": "    def __init__(self, p, label, rep, origin, target, links=None,\n                 opposite=None, determinant=None, valuation=None):\n        \"\"\"\n        Representation for edges of quotients of the Bruhat-Tits\n        tree. It is useful to enrich the representation of an edge as\n        a matrix with extra data.\n        EXAMPLES::\n            sage: from sage.modular.btquotients.btquotient import Edge\n            sage: Y = BruhatTitsQuotient(5,11)\n            sage: el = Y.get_edge_list()\n            sage: e1 = el.pop()\n            sage: e2 = Edge(5,e1.label,e1.rep,e1.origin,e1.target)\n            sage: TestSuite(e2).run()\n        \"\"\"\n        if links is None:\n            links = []\n        if determinant is None:\n            determinant = rep.determinant()\n        if valuation is None:\n            valuation = determinant.valuation(p)\n        self.p = p\n        self.label = label\n        self.rep = rep\n        self.rep.set_immutable()\n        self.origin = origin\n        self.target = target\n        self.links = links\n        self.opposite = opposite\n        self.determinant = determinant\n        self.valuation = valuation\n        self.parity = valuation % 2\n", "docstring": "opposite=None, determinant=None, valuation=None):"}
{"repo": "sage-master/src/sage/modular/btquotients/btquotient.py", "original_string": "    def __classcall__(cls, p, Nminus, Nplus=1, character=None,\n                      use_magma=False, seed=None, magma_session=None):\n        \"\"\"\n        Ensure that a canonical BruhatTitsQuotient is created.\n        EXAMPLES::\n            sage: BruhatTitsQuotient(3,17) is BruhatTitsQuotient(3,17,1)\n            True\n        \"\"\"\n        return super(BruhatTitsQuotient, cls).__classcall__(cls, p, Nminus, Nplus,\n               character, use_magma, seed, magma_session)\n", "docstring": "use_magma=False, seed=None, magma_session=None):"}
{"repo": "sage-master/src/sage/geometry/cone.py", "original_string": "    def try_base_extend(ring):\n        # Factor out the \"try this ring...\" code that's repeated four\n        # times.\n        try:\n            return L.base_extend(ring)(data)\n        except TypeError:\n            pass\n        except ValueError as ex:\n            if str(ex).startswith(\"Cannot coerce\"):\n                pass\n", "docstring": "Factor out the \"try this ring...\" code that's repeated four"}
{"repo": "sage-master/src/sage/geometry/lattice_polytope.py", "original_string": "        def index_of_max(iterable):\n            # returns the index of max of any iterable\n            m, x = 0, iterable[0]\n            for k, l in enumerate(iterable):\n                if l > x:\n                    m, x = k, l\n            return m\n", "docstring": "returns the index of max of any iterable"}
{"repo": "sage-master/src/sage/geometry/fan.py", "original_string": "    def result():\n        # \"global\" does not work here...\n        R, V = rays, virtual_rays\n        if V is not None:\n            if normalize:\n                V = normalize_rays(V, lattice)\n            if check:\n                R = PointCollection(V, lattice)\n                V = PointCollection(V, lattice)\n                d = lattice.dimension()\n                if len(V) != d - R.dim() or (R + V).dim() != d:\n                    raise ValueError(\"virtual rays must be linearly \"\n                    \"independent and with other rays span the ambient space.\")\n        return RationalPolyhedralFan(cones, R, lattice, is_complete, V)\n", "docstring": "\"global\" does not work here..."}
{"repo": "sage-master/src/sage/geometry/fan.py", "original_string": "        def sign(x):\n            assert x != 0\n            if x > 0:\n                return +1\n            else:\n                return -1\n", "docstring": "assert x != 0"}
{"repo": "sage-master/src/sage/geometry/polyhedron/double_description_inhomogeneous.py", "original_string": "        def make_matrix(cols):\n            return matrix(self.base_ring, len(cols), self.dim + 1, cols)\n", "docstring": "return matrix(self.base_ring, len(cols), self.dim + 1, cols)"}
{"repo": "sage-master/src/sage/geometry/polyhedron/ppl_lattice_polygon.py", "original_string": "    def _find_cyclic_isomorphism_matching_edge(self, polytope,\n                                               polytope_origin, p_ray_left,\n                                               p_ray_right):\n        r\"\"\"\n        Helper to find an isomorphism of polygons\n        INPUT:\n        - ``polytope`` -- the lattice polytope to compare to.\n        - ``polytope_origin`` -- `\\ZZ`-vector. a vertex of ``polytope``\n        - ``p_ray_left`` - vector. the vector from ``polytope_origin``\n          to one of its neighboring vertices.\n        - ``p_ray_right`` - vector. the vector from\n          ``polytope_origin`` to the other neighboring vertices.\n        OUTPUT:\n        The element of the lattice Euclidean group that maps ``self``\n        to ``polytope`` with given origin and left/right neighboring\n        vertex. A\n        :class:`~sage.geometry.polyhedron.lattice_euclidean_group_element.LatticePolytopesNotIsomorphicError`\n        is raised if no such isomorphism exists.\n        EXAMPLES::\n            sage: from sage.geometry.polyhedron.ppl_lattice_polytope import LatticePolytope_PPL\n            sage: L1 = LatticePolytope_PPL((1,0),(0,1),(0,0))\n            sage: L2 = LatticePolytope_PPL((1,0,3),(0,1,0),(0,0,1))\n            sage: v0, v1, v2 = L2.vertices()\n            sage: L1._find_cyclic_isomorphism_matching_edge(L2, v0, v1-v0, v2-v0)\n            The map A*x+b with A=\n            [ 0  1]\n            [-1 -1]\n            [ 1  3]\n            b =\n            (0, 1, 0)\n        \"\"\"\n        from sage.geometry.polyhedron.lattice_euclidean_group_element import \\\n            LatticePolytopesNotIsomorphicError\n        polytope_matrix = block_matrix(1, 2, [p_ray_left.column(),\n                                              p_ray_right.column()])\n        self_vertices = self.ordered_vertices()\n        for i in range(len(self_vertices)):\n            # three consecutive vertices\n            v_left = self_vertices[(i+0) % len(self_vertices)]\n            v_origin = self_vertices[(i+1) % len(self_vertices)]\n            v_right = self_vertices[(i+2) % len(self_vertices)]\n            r_left = v_left-v_origin\n            r_right = v_right-v_origin\n            self_matrix = block_matrix(1, 2, [r_left.column(),\n                                              r_right.column()])\n            A = self_matrix.solve_left(polytope_matrix)\n            b = polytope_origin - A*v_origin\n            try:\n                A = matrix(ZZ, A)\n                b = vector(ZZ, b)\n            except TypeError:\n                continue\n            if A.elementary_divisors()[0:2] != [1, 1]:\n                continue\n            hom = LatticeEuclideanGroupElement(A, b)\n            if hom(self) == polytope:\n                return hom\n        raise LatticePolytopesNotIsomorphicError('different polygons')\n", "docstring": "polytope_origin, p_ray_left,"}
{"repo": "sage-master/src/sage/geometry/polyhedron/plot.py", "original_string": "        def defining_equation():  # corresponding to a polygon\n            if polyhedron.dim() < 3:\n                yield next(polyhedron.equation_generator())\n            else:\n                for ineq in polyhedron.inequality_generator():\n                    yield ineq\n", "docstring": "if polyhedron.dim() < 3:"}
{"repo": "sage-master/src/sage/geometry/polyhedron/backend_field.py", "original_string": "    def _init_from_Vrepresentation(self, vertices, rays, lines,\n                                   minimize=True, verbose=False):\n        \"\"\"\n        Construct polyhedron from V-representation data.\n        INPUT:\n        - ``vertices`` -- list of points. Each point can be specified\n           as any iterable container of\n           :meth:`~sage.geometry.polyhedron.base.base_ring` elements.\n        - ``rays`` -- list of rays. Each ray can be specified as any\n          iterable container of\n          :meth:`~sage.geometry.polyhedron.base.base_ring` elements.\n        - ``lines`` -- list of lines. Each line can be specified as\n          any iterable container of\n          :meth:`~sage.geometry.polyhedron.base.base_ring` elements.\n        - ``verbose`` -- boolean (default: ``False``). Whether to print\n          verbose output for debugging purposes.\n        EXAMPLES::\n            sage: p = Polyhedron(ambient_dim=2, backend='field')\n            sage: from sage.geometry.polyhedron.backend_field import Polyhedron_field\n            sage: Polyhedron_field._init_from_Vrepresentation(p, [(0,0)], [], [])\n        \"\"\"\n        from sage.geometry.polyhedron.double_description_inhomogeneous import Hrep2Vrep, Vrep2Hrep\n        H = Vrep2Hrep(self.base_ring(), self.ambient_dim(), vertices, rays, lines)\n        V = Hrep2Vrep(self.base_ring(), self.ambient_dim(),\n                      H.inequalities, H.equations)\n        self._init_Vrepresentation_backend(V)\n        self._init_Hrepresentation_backend(H)\n", "docstring": "minimize=True, verbose=False):"}
{"repo": "sage-master/src/sage/geometry/polyhedron/base.py", "original_string": "        def set_adjacent(h1, h2):\n            if h1 is h2:\n                return\n            i = h1.index() - codim\n            j = h2.index() - codim\n            M[i, j] = 1\n            M[j, i] = 1\n", "docstring": "if h1 is h2:"}
{"repo": "sage-master/src/sage/geometry/polyhedron/base.py", "original_string": "        def pad_non_minus(s):\n            if align and shift and not s.startswith('-'):\n                return ' ' + s\n            else:\n                return s\n", "docstring": "if align and shift and not s.startswith('-'):"}
{"repo": "sage-master/src/sage/geometry/polyhedron/ppl_lattice_polytope.py", "original_string": "        def point_combinations_iterator(n, i0=0, saturated=None):\n            for i in range(i0, len(points)):\n                p, ieqs = points[i]\n                if saturated is None:\n                    saturated_ieqs = ieqs\n                else:\n                    saturated_ieqs = saturated.intersection(ieqs)\n                if len(saturated_ieqs)==0:\n                    continue\n                if n == 1:\n                    yield [i]\n                else:\n                    for c in point_combinations_iterator(n-1, i+1, saturated_ieqs):\n                        yield [i] + c\n", "docstring": "for i in range(i0, len(points)):"}
{"repo": "sage-master/src/sage/geometry/polyhedron/parent.py", "original_string": "        def convert_base_ring(lstlst):\n            return [[self.base_ring()(x) for x in lst] for lst in lstlst]\n", "docstring": "return [[self.base_ring()(x) for x in lst] for lst in lstlst]"}
{"repo": "sage-master/src/sage/geometry/hyperplane_arrangement/check_freeness.py", "original_string": "    def next_step(indices, prev, T):\n        for pos,i in enumerate(indices):\n            U = prev * T\n            mu = U * phi[i]\n            mu = mu.stack(matrix.diagonal([B[i]]).dense_matrix())\n            row_syzygy = matrix(S, syz(mu.transpose())).matrix_from_columns(range(r))\n            Y = less_generators(row_syzygy)\n            if not Y.is_square():\n                continue\n            if len(indices) == 1:\n                return [prev, Y]\n            I = list(indices)\n            I.pop(pos)\n            ret = next_step(I, Y, U)\n            if ret is not None:\n                return [prev] + ret\n        return None                \n", "docstring": "for pos,i in enumerate(indices):"}
{"repo": "sage-master/src/sage/doctest/forker.py", "original_string": "            def compiler(example):\n                # Compile mode \"single\" is meant for running a single\n                # statement like on the Python command line. It implies\n                # in particular that the resulting value will be printed.\n                code = compile(example.source, filename, \"single\",\n                               compileflags, 1)\n                # Python 2 ignores everything after the first complete\n                # statement in the source code. To verify that we really\n                # have just a single statement and nothing more, we also\n                # compile in \"exec\" mode and verify that the line\n                # numbers are the same.\n                execcode = compile(example.source, filename, \"exec\",\n                                   compileflags, 1)\n                # findlinestarts() returns pairs (index, lineno) where\n                # \"index\" is the index in the bytecode where the line\n                # number changes to \"lineno\".\n                linenumbers1 = set(lineno for (index, lineno)\n                                   in findlinestarts(code))\n                linenumbers2 = set(lineno for (index, lineno)\n                                   in findlinestarts(execcode))\n                if linenumbers1 != linenumbers2:\n                    raise SyntaxError(\"doctest is not a single statement\")\n                return code\n", "docstring": "Compile mode \"single\" is meant for running a single"}
{"repo": "sage-master/src/sage/doctest/sources.py", "original_string": "        def _update_parens(start,end=None):\n            self.paren_count += line.count(\"(\",start,end) - line.count(\")\",start,end)\n            self.bracket_count += line.count(\"[\",start,end) - line.count(\"]\",start,end)\n            self.curly_count += line.count(\"{\",start,end) - line.count(\"}\",start,end)\n", "docstring": "self.paren_count += line.count(\"(\",start,end) - line.count(\")\",start,end)"}
{"repo": "sage-master/src/sage/doctest/control.py", "original_string": "            def sort_key(source):\n                basename = source.basename\n                return -self.stats.get(basename, default).get('walltime'), basename\n", "docstring": "basename = source.basename"}
{"repo": "sage-master/src/sage/repl/ipython_kernel/widgets_sagenb.py", "original_string": "        def err(v):\n            if v is default:\n                return (-1, 0)\n            try:\n                if v == default:\n                    return (0, 0)\n                return (0, abs(v - default))\n            except Exception:\n                return (1, 0)\n", "docstring": "if v is default:"}
{"repo": "sage-master/src/sage/repl/ipython_kernel/widgets_sagenb.py", "original_string": "    def make_widget(i, j):\n        return input_box(str(default[i][j]), width=width)\n", "docstring": "return input_box(str(default[i][j]), width=width)"}
{"repo": "sage-master/src/sage/repl/rich_output/display_manager.py", "original_string": "    def graphics_from_save(self, save_function, save_kwds,\n                           file_extension, output_container,\n                           figsize=None, dpi=None):\n        r\"\"\"\n        Helper to construct graphics.\n        This method can be used to simplify the implementation of a\n        ``_rich_repr_`` method of a graphics object if there is\n        already a function to save graphics to a file.\n        INPUT:\n        - ``save_function`` -- callable that can save graphics to a file\n          and accepts options like\n          :meth:`sage.plot.graphics.Graphics.save`.\n        - ``save_kwds`` -- dictionary. Keyword arguments that are\n          passed to the save function.\n        - ``file_extension`` -- string starting with ``'.'``. The file\n          extension of the graphics file.\n        - ``output_container`` -- subclass of\n          :class:`sage.repl.rich_output.output_basic.OutputBase`. The\n          output container to use. Must be one of the types in\n          :meth:`supported_output`.\n        - ``figsize`` -- pair of integers (optional). The desired graphics\n          size in pixels. Suggested, but need not be respected by the\n          output.\n        - ``dpi`` -- integer (optional). The desired resolution in dots\n          per inch. Suggested, but need not be respected by the output.\n        OUTPUT:\n        Return an instance of ``output_container``.\n        EXAMPLES::\n            sage: from sage.repl.rich_output import get_display_manager\n            sage: dm = get_display_manager()\n            sage: plt = plot(sin)\n            sage: out = dm.graphics_from_save(plt.save, dict(), '.png', dm.types.OutputImagePng)\n            sage: out\n            OutputImagePng container\n            sage: out.png.get().startswith(b'\\x89PNG')\n            True\n            sage: out.png.filename()   # random\n            '/home/user/.sage/temp/localhost.localdomain/23903/tmp_pu5woK.png'\n        \"\"\"\n        import os\n        if not file_extension.startswith(os.path.extsep):\n            raise ValueError('file_extension must start with a period')\n        if output_container not in self.supported_output():\n            raise OutputTypeException('output_container is not supported by backend')\n        from sage.misc.temporary_file import tmp_filename\n        filename = tmp_filename(ext=file_extension)\n        # Call the save_function with the right arguments\n        kwds = dict(save_kwds)\n        if figsize is not None:\n            kwds['figsize'] = figsize\n        if dpi is not None:\n            kwds['dpi'] = dpi\n        save_function(filename, **kwds)\n        from sage.repl.rich_output.buffer import OutputBuffer\n        buf = OutputBuffer.from_file(filename)\n        return output_container(buf)\n", "docstring": "file_extension, output_container,"}
{"repo": "sage-master/src/sage/functions/log.py", "original_string": "    def __init__(self):\n        BuiltinFunction.__init__(self, \"_swap_harmonic\", nargs=2)\n", "docstring": "BuiltinFunction.__init__(self, \"_swap_harmonic\", nargs=2)"}
{"repo": "sage-master/src/sage/calculus/desolvers.py", "original_string": "            def Dfun(y, t):\n                return [J(y, t)]\n", "docstring": "return [J(y, t)]"}
{"repo": "sage-master/src/sage/crypto/stream.py", "original_string": "    def encoding(self,M):\n        S = self.cipher_domain()\n        try:\n            return S.encoding(M)\n        except Exception:\n            raise TypeError(\"Argument M = %s does not encode in the cipher domain\" % M)\n", "docstring": "S = self.cipher_domain()"}
{"repo": "sage-master/src/sage/crypto/classical_cipher.py", "original_string": "    def __call__(self, M):\n        S = self.domain() # = plaintext_space = ciphertext_space\n        if not isinstance(M, StringMonoidElement) and M.parent() == S:\n            raise TypeError(\"Argument M (= %s) must be a string in the plaintext space.\" % M)\n        m = self.parent().block_length()\n        if len(M) % m != 0:\n            raise TypeError(\"The length of M (= %s) must be a multiple of %s.\" % (M, m ))\n        Alph = list(S.alphabet())\n        A = self.key() # A is an m x m matrix\n        R = A.parent().base_ring()\n        V = FreeModule(R,m)\n        Mstr = str(M)\n        C = []\n        for i in range(len(M)//m):\n            v = V([ Alph.index(Mstr[m*i+j]) for j in range(m) ])\n            C += (v * A).list()\n        return S([ k.lift() for k in C ])\n", "docstring": "S = self.domain() # = plaintext_space = ciphertext_space"}
{"repo": "sage-master/src/sage/crypto/classical_cipher.py", "original_string": "    def __call__(self, M):\n        S = self.domain() # = plaintext_space = ciphertext_space\n        if not isinstance(M, StringMonoidElement) and M.parent() == S:\n            raise TypeError(\"Argument M (= %s) must be a string in the plaintext space.\" % M)\n        A = list(S.alphabet())\n        K = str(self.key()) # K is a string, while we want the indices:\n        I = [ A.index(K[i]) for i in range(len(K)) ]\n        Mstr = str(M)\n        return S([ I[A.index(Mstr[i])] for i in range(len(Mstr)) ])\n", "docstring": "S = self.domain() # = plaintext_space = ciphertext_space"}
{"repo": "sage-master/src/sage/crypto/classical_cipher.py", "original_string": "    def inverse(self):\n        E = self.parent()\n        K = E.inverse_key(self.key())\n        return E(K)\n", "docstring": "E = self.parent()"}
{"repo": "sage-master/src/sage/lfunctions/sympow.py", "original_string": "    def _fix_err(self, err):\n        w = err\n        j = w.rfind('./sympow')\n        if j != -1:\n            w = w[:j - 1] + \"sympow('\" + w[j + 9:] + ')'\n        return w\n", "docstring": "w = err"}
{"repo": "sage-master/src/sage/lfunctions/dokchitser.py", "original_string": "    def __check_init(self):\n        if not self.__init:\n            raise ValueError(\"you must call init_coeffs on the L-function first\")\n", "docstring": "if not self.__init:"}
{"repo": "sage-master/src/sage/algebras/askey_wilson.py", "original_string": "    def __init__(self, domain, on_generators, position=0, codomain=None,\n                 category=None):\n        \"\"\"\n        Given a map on the multiplicative basis of a free algebra, this method\n        returns the algebra morphism that is the linear extension of its image\n        on generators.\n        INPUT:\n        - ``domain`` -- an Askey-Wilson algebra\n        - ``on_generators`` -- a list of length 6 corresponding to\n          the images of the generators\n        - ``codomain`` -- (optional) the codomain\n        - ``position`` -- (default: 0) integer\n        - ``category`` -- (optional) category\n        OUTPUT:\n        - module morphism\n        EXAMPLES::\n            sage: AW = algebras.AskeyWilson(QQ)\n            sage: sigma = AW.sigma()\n            sage: TestSuite(sigma).run()\n        \"\"\"\n        if category is None:\n            category = Algebras(Rings().Commutative()).WithBasis()\n        self._on_generators = tuple(on_generators)\n        ModuleMorphismByLinearity.__init__(self, domain=domain, codomain=codomain,\n                                           position=position, category=category)\n", "docstring": "category=None):"}
{"repo": "sage-master/src/sage/algebras/quantum_matrix_coordinate_algebra.py", "original_string": "            def bar(x):\n                return x.subs(q=~self._q)\n", "docstring": "return x.subs(q=~self._q)"}
{"repo": "sage-master/src/sage/algebras/weyl_algebra.py", "original_string": "        def term(m):\n            ret = ''\n            for i, power in enumerate(m[0] + m[1]):\n                if power == 0:\n                    continue\n                name = self.parent().variable_names()[i]\n                if ret:\n                    ret += '*'\n                if power == 1:\n                    ret += '{}'.format(name)\n                else:\n                    ret += '{}^{}'.format(name, power)\n            return ret\n", "docstring": "ret = ''"}
{"repo": "sage-master/src/sage/algebras/yangian.py", "original_string": "    def __classcall_private__(cls, base_ring, n, level=None,\n                              variable_name='t', filtration='loop'):\n        \"\"\"\n        Return the correct parent based upon input.\n        EXAMPLES::\n            sage: Y = Yangian(QQ, 4)\n            sage: Y2 = Yangian(QQ, 4)\n            sage: Y is Y2\n            True\n            sage: YL = Yangian(QQ, 4, 3)\n            sage: YL2 = Yangian(QQ, 4, 3)\n            sage: YL is YL2\n            True\n        \"\"\"\n        if filtration not in ['natural', 'loop']:\n            raise ValueError(\"invalid filtration\")\n        if level is not None:\n            return YangianLevel(base_ring, n, level, variable_name, filtration)\n        # We need to specify the parameter name for pickling, so it doesn't pass\n        #   ``variable_name`` as ``level``\n        return super(Yangian, cls).__classcall__(cls, base_ring, n,\n                                                 variable_name=variable_name,\n                                                 filtration=filtration)\n", "docstring": "variable_name='t', filtration='loop'):"}
{"repo": "sage-master/src/sage/algebras/yangian.py", "original_string": "        def term(r, i, j, exp):\n            s = prefix + '^{{({})}}_{{{},{}}}'.format(r,i,j)\n            if exp == 1:\n                return s\n            return '\\\\left({}\\\\right)^{{{}}}'.format(s, exp)\n", "docstring": "s = prefix + '^{{({})}}_{{{},{}}}'.format(r,i,j)"}
{"repo": "sage-master/src/sage/algebras/rational_cherednik_algebra.py", "original_string": "        def gen_map(k):\n            if k[0] == 's':\n                i = int(k[1:])\n                return self.monomial( (self._hd.one(),\n                                       self._weyl.group_generators()[i],\n                                       self._h.one()) )\n            if k[1] == 'c':\n                i = int(k[2:])\n                return self.monomial( (self._hd.one(),\n                                       self._weyl.one(),\n                                       self._h.monoid_generators()[i]) )\n            i = int(k[1:])\n            return self.monomial( (self._hd.monoid_generators()[i],\n                                   self._weyl.one(),\n                                   self._h.one()) )\n", "docstring": "if k[0] == 's':"}
{"repo": "sage-master/src/sage/algebras/rational_cherednik_algebra.py", "original_string": "        def commute_w_hd(w, al): # al is given as a dictionary\n            ret = P.one()\n            for k in al:\n                x = sum(c * gens_dict[i] for i,c in alpha[k].weyl_action(w))\n                ret *= x**al[k]\n            ret = ret.dict()\n            for k in ret:\n                yield (self._hd({I[i]: e for i,e in enumerate(k) if e != 0}), ret[k])\n", "docstring": "ret = P.one()"}
{"repo": "sage-master/src/sage/algebras/lie_algebras/structure_coefficients.py", "original_string": "        def to_vector(tuples):\n            vec = [R.zero()]*len(index_set)\n            for k,c in tuples:\n                vec[self._index_to_pos[k]] = c\n            vec = self._M(vec)\n            vec.set_immutable()\n            return vec\n", "docstring": "vec = [R.zero()]*len(index_set)"}
{"repo": "sage-master/src/sage/rings/lazy_laurent_series_ring.py", "original_string": "            def make_series_from(poly):\n                op = LazyLaurentSeriesOperator_polynomial(self, poly)\n                a = poly.valuation()\n                c = (self.base_ring().zero(), poly.degree() + 1)\n                return self.element_class(self, coefficient=op, valuation=a, constant=c)\n", "docstring": "op = LazyLaurentSeriesOperator_polynomial(self, poly)"}
{"repo": "sage-master/src/sage/rings/lazy_laurent_series_ring.py", "original_string": "        def r(s, i):\n            return self.base_ring().an_element()\n", "docstring": "return self.base_ring().an_element()"}
{"repo": "sage-master/src/sage/rings/multi_power_series_ring.py", "original_string": "    def __classcall__(cls, base_ring, num_gens, name_list,\n                 order='negdeglex', default_prec=10, sparse=False):\n        \"\"\"\n        Preprocessing of arguments: The term order can be given as string\n        or as a :class:`~sage.rings.polynomial.term_order.TermOrder` instance.\n        TESTS::\n            sage: P1 = PowerSeriesRing(QQ, ['f0','f1','f2','f3'], order = TermOrder('degrevlex'))\n            sage: P2 = PowerSeriesRing(QQ,4,'f', order='degrevlex')\n            sage: P1 is P2   # indirect doctest\n            True\n        \"\"\"\n        order = TermOrder(order,num_gens)\n        return super(MPowerSeriesRing_generic,cls).__classcall__(cls, base_ring, num_gens, name_list,\n                 order, default_prec, sparse)\n", "docstring": "order='negdeglex', default_prec=10, sparse=False):"}
{"repo": "sage-master/src/sage/rings/pari_ring.py", "original_string": "    def __int__(self):\n        return int(self.__x)\n", "docstring": "return int(self.__x)"}
{"repo": "sage-master/src/sage/rings/function_field/order.py", "original_string": "        def from_R(e):\n            return F(_from_R(e))\n", "docstring": "return F(_from_R(e))"}
{"repo": "sage-master/src/sage/rings/number_field/S_unit_solver.py", "original_string": "    def hprime(SUK, alpha, v):\n        # [Sma1998]_ p. 225\n        return R(max(alpha.global_height(), 1/SUK.number_field().degree(), abs( v(alpha).log() ) / SUK.number_field().degree()))\n", "docstring": "[Sma1998]_ p. 225"}
{"repo": "sage-master/src/sage/rings/number_field/S_unit_solver.py", "original_string": "        def epsilon_q(a, i):\n            # a is an exponent vector\n            # i is an index for one of the primes over q\n            # returns the value of rho_j^a_j inside the\n            # residue field of Qi. (Necessarily isomorphic to F_q.)\n            # rho_images[i][j] == rho[j] modulo Q[i]\n            eps_value = rho_images[i][0]**a[0]\n            for j in range(1, rho_length):\n                eps_value *= rho_images[i][j]**a[j]\n            return eps_value\n", "docstring": "a is an exponent vector"}
{"repo": "sage-master/src/sage/rings/invariants/invariant_theory.py", "original_string": "        def diff(j):\n            df = f.form().derivative(x,j).derivative(y,h-j)\n            dg = g.form().derivative(x,h-j).derivative(y,j)\n            return (-1)**j * binomial(h,j) * df * dg\n", "docstring": "df = f.form().derivative(x,j).derivative(y,h-j)"}
{"repo": "sage-master/src/sage/rings/invariants/invariant_theory.py", "original_string": "            def diff(p, d):\n                return [p.derivative(x) for x in self._variables]\n", "docstring": "return [p.derivative(x) for x in self._variables]"}
{"repo": "sage-master/src/sage/rings/invariants/invariant_theory.py", "original_string": "            def mono_to_tuple(mono):\n                return (R(mono).exponents()[0],)\n", "docstring": "return (R(mono).exponents()[0],)"}
{"repo": "sage-master/src/sage/rings/invariants/invariant_theory.py", "original_string": "            def mono_to_tuple(mono):\n                # mono is any monomial in the ring R\n                # keep only the exponents of true variables\n                mono = R(mono).exponents()[0]\n                return tuple(mono[i] for i in indices)\n", "docstring": "mono is any monomial in the ring R"}
{"repo": "sage-master/src/sage/rings/finite_rings/conway_polynomials.py", "original_string": "    def find_leveller(qindex, level, x, xleveled, searched, i):\n        searched[i] = True\n        crt_possibles = []\n        for j in range(1,len(qlist)):\n            if i==j: continue\n            if crt[(i,j)][qindex][1] >= level:\n                if xleveled[j]:\n                    return [j]\n                elif j not in searched:\n                    crt_possibles.append(j)\n        for j in crt_possibles:\n            path = find_leveller(qindex, level, x, xleveled, searched, j)\n            if path is not None:\n                path.append(j)\n                return path\n        return None\n", "docstring": "searched[i] = True"}
{"repo": "sage-master/src/sage/rings/polynomial/multi_polynomial_element.py", "original_string": "    def _add_(self, right):\n        #return self.parent()(self.__element + right.__element)\n        return self.__class__(self.parent(),self.__element + right.__element)\n", "docstring": "return self.parent()(self.__element + right.__element)"}
{"repo": "sage-master/src/sage/rings/polynomial/multi_polynomial_element.py", "original_string": "    def _mul_(self, right):\n        #return self.parent()(self.__element * right.__element)\n        return self.__class__(self.parent(),self.__element * right.__element)\n", "docstring": "return self.parent()(self.__element * right.__element)"}
{"repo": "sage-master/src/sage/rings/polynomial/multi_polynomial_element.py", "original_string": "    def __rpow__(self, n):\n        if not isinstance(n, (int, sage.rings.integer.Integer)):\n            raise TypeError(\"The exponent must be an integer.\")\n        return self.parent()(self.__element**n)\n", "docstring": "if not isinstance(n, (int, sage.rings.integer.Integer)):"}
{"repo": "sage-master/src/sage/rings/polynomial/multi_polynomial_element.py", "original_string": "    def __eq__(self,right):\n        if not isinstance(right, MPolynomial_polydict):\n            # we want comparison with zero to be fast\n            if not right:\n                return not self._MPolynomial_element__element.dict()\n            return CommutativeRingElement.__eq__(self, right)\n        return self._MPolynomial_element__element == right._MPolynomial_element__element\n", "docstring": "we want comparison with zero to be fast"}
{"repo": "sage-master/src/sage/rings/polynomial/multi_polynomial_ring.py", "original_string": "    def __init__(self, base_ring, n, names, order):\n        from sage.rings.polynomial.polynomial_singular_interface import can_convert_to_singular\n        order = TermOrder(order,n)\n        # MPolynomialRing_base.__init__() normally initialises the base ring,\n        # but it also needs the generators to construct a coercion map from the\n        # base ring, and the base ring must be set to initialise the generators.\n        # We set the base ring manually to break this circular dependency.\n        self._base = base_ring\n        # Construct the generators\n        v = [0] * n\n        one = base_ring(1);\n        self._gens = []\n        C = self._poly_class()\n        for i in range(n):\n            v[i] = 1  # int's!\n            self._gens.append(C(self, {tuple(v):one}))\n            v[i] = 0\n        self._gens = tuple(self._gens)\n        self._zero_tuple = tuple(v)\n        MPolynomialRing_base.__init__(self, base_ring, n, names, order)\n        self._has_singular = can_convert_to_singular(self)\n", "docstring": "from sage.rings.polynomial.polynomial_singular_interface import can_convert_to_singular"}
{"repo": "sage-master/src/sage/rings/polynomial/groebner_fan.py", "original_string": "    def __init__(self, gfan_polyhedral_fan, polynomial_system, poly_ring,\n                 parameters=None):\n        \"\"\"\n        This class is a subclass of the PolyhedralFan class,\n        with some additional methods for tropical prevarieties.\n        INPUT:\n        - ``gfan_polyhedral_fan`` -- output from ``gfan`` of a\n          polyhedral fan.\n        - ``polynomial_system`` -- a list of polynomials\n        - ``poly_ring`` -- the polynomial ring of the list of polynomials\n        - ``parameters`` (optional) -- a list of variables to be considered\n           as parameters\n        EXAMPLES::\n            sage: R.<x,y,z> = QQ[]\n            sage: I = R.ideal([(x+y+z)^2-1,(x+y+z)-x,(x+y+z)-3])\n            sage: GF = I.groebner_fan()\n            sage: TI = GF.tropical_intersection()\n            sage: TI._polynomial_system\n            [x^2 + 2*x*y + y^2 + 2*x*z + 2*y*z + z^2 - 1, y + z, x + y + z - 3]\n        \"\"\"\n        parameter_indices = []\n        if parameters is not None:\n            allvars = poly_ring.gens()\n            parameter_indices = [allvars.index(q) for q in parameters]\n        PolyhedralFan.__init__(self, gfan_polyhedral_fan,\n                               parameter_indices=parameter_indices)\n        self._polynomial_system = polynomial_system\n        self._parameters = parameters\n", "docstring": "parameters=None):"}
{"repo": "sage-master/src/sage/rings/polynomial/groebner_fan.py", "original_string": "    def interactive(self, latex=False, flippable=False, wall=False,\n                    inequalities=False, weight=False):\n        \"\"\"\n        Do an interactive walk of the Groebner fan starting at this reduced\n        Groebner basis.\n        EXAMPLES::\n            sage: R.<x,y> = PolynomialRing(QQ,2)\n            sage: G = R.ideal([y^3 - x^2, y^2 - 13*x]).groebner_fan()\n            sage: G[0].interactive()      # not tested\n            Initializing gfan interactive mode\n            *********************************************\n            *     Press control-C to return to Sage     *\n            *********************************************\n            ....\n        \"\"\"\n        cmd = 'gfan_interactive'\n        if latex:\n            cmd += ' -L'\n        if flippable:\n            cmd += ' -f'\n        if wall:\n            cmd += ' -w'\n        if inequalities:\n            cmd += ' -i'\n        if weight:\n            cmd += ' -W'\n        cmd += self.__groebner_fan._gfan_mod()\n        E = pexpect.spawn(cmd)\n        print(\"Initializing gfan interactive mode\")\n        # E.sendline(self._gfan_ideal())\n        E.sendline(self.__gfan_gens)\n        print(\"*\" * 45)\n        print(\"*     Press control-C to return to Sage     *\")\n        print(\"*\" * 45)\n        try:\n            E.interact()\n        except OSError:\n            print(\"Returning to Sage.\")\n", "docstring": "inequalities=False, weight=False):"}
{"repo": "sage-master/src/sage/rings/polynomial/toy_d_basis.py", "original_string": "def LM(f):\n    return f.lm()\n", "docstring": "return f.lm()"}
{"repo": "sage-master/src/sage/rings/polynomial/polynomial_element_generic.py", "original_string": "    def __init__(self, parent, is_gen=False, construct=False):\n        Polynomial.__init__(self, parent, is_gen=is_gen)\n", "docstring": "Polynomial.__init__(self, parent, is_gen=is_gen)"}
{"repo": "sage-master/src/sage/rings/polynomial/polynomial_element_generic.py", "original_string": "    def __init__(self, parent, x=None, check=True, is_gen = False, construct=False):\n        Polynomial_generic_sparse.__init__(self, parent, x, check, is_gen)\n", "docstring": "Polynomial_generic_sparse.__init__(self, parent, x, check, is_gen)"}
{"repo": "sage-master/src/sage/rings/polynomial/polynomial_quotient_ring_element.py", "original_string": "    def __hash__(self):\n        return hash(self._polynomial)\n", "docstring": "return hash(self._polynomial)"}
{"repo": "sage-master/src/sage/rings/polynomial/polynomial_quotient_ring_element.py", "original_string": "    def __neg__(self):\n        return self.__class__(self.parent(), -self._polynomial)\n", "docstring": "return self.__class__(self.parent(), -self._polynomial)"}
{"repo": "sage-master/src/sage/rings/polynomial/complex_roots.py", "original_string": "    def column_disjoint():\n        column.sort()\n        row = []\n        prev_imag = None\n        def row_disjoint():\n            for a in range(len(row)):\n                for b in range(a+1, len(row)):\n                    if row[a].overlaps(row[b]):\n                        return False\n            return True\n        for (y_imag, y) in column:\n            if prev_imag is not None and y_imag > prev_imag:\n                if not row_disjoint(): return False\n                row = []\n            prev_imag = y_imag\n            row.append(y)\n        if not row_disjoint(): return False\n        return True\n", "docstring": "column.sort()"}
{"repo": "sage-master/src/sage/rings/polynomial/polynomial_singular_interface.py", "original_string": "    def _singular_(self, singular=singular, have_ring=False):\n        return _singular_func(self, singular, have_ring)\n", "docstring": "return _singular_func(self, singular, have_ring)"}
{"repo": "sage-master/src/sage/rings/polynomial/padics/polynomial_padic_capped_relative_dense.py", "original_string": "    def _normalize(self):\n        # Currently slow: need to optimize\n        if not self._normalized:\n            if self._valaddeds is None:\n                self._comp_valaddeds()\n            val = sage.rings.padics.misc.min(self._valaddeds)\n            prime_pow = self.base_ring().prime_pow\n            selflist = self._poly.list()\n            if val is infinity:\n                pass\n            elif val != 0:\n                self._relprecs = [max(prec - val,0) for prec in self._relprecs]\n                v = [Integer(0) if (e is infinity) else ((c // prime_pow(val)) % prime_pow(e)) for (c,e) in zip(selflist, self._relprecs)]\n                self._poly = self._poly.parent()(v, check=False)\n                self._valbase += val\n                self._valaddeds = [c - val for c in self._valaddeds]\n            else:\n                self._poly = self._poly.parent()([Integer(0) if (e is infinity) else (c % prime_pow(e)) for (c,e) in zip(selflist, self._relprecs)], check=False)\n            self._normalized = True\n", "docstring": "Currently slow: need to optimize"}
{"repo": "sage-master/src/sage/rings/polynomial/padics/polynomial_padic_capped_relative_dense.py", "original_string": "    def _comp_valaddeds(self):\n        self._valaddeds = []\n        for i in range(self._poly.degree() + 1):\n            tmp = self._poly.list()[i].valuation(self.parent().base_ring().prime())\n            if tmp is infinity or tmp > self._relprecs[i]:\n                self._valaddeds.append(self._relprecs[i])\n            else:\n                self._valaddeds.append(tmp)\n        for i in range(self._poly.degree() + 1, len(self._relprecs)):\n            self._valaddeds.append(self._relprecs[i])\n", "docstring": "self._valaddeds = []"}
{"repo": "sage-master/src/sage/rings/polynomial/padics/polynomial_padic_capped_relative_dense.py", "original_string": "    def _lmul_(self, right):\n        return self._rmul_(right)\n", "docstring": "return self._rmul_(right)"}
{"repo": "sage-master/src/sage/rings/polynomial/padics/polynomial_padic_capped_relative_dense.py", "original_string": "    def disc(self):\n        return self.discriminant()\n", "docstring": "return self.discriminant()"}
{"repo": "sage-master/src/sage/rings/polynomial/padics/polynomial_padic_capped_relative_dense.py", "original_string": "def _extend_by_infinity(L, n):\n    return L + [infinity] * (n - len(L))\n", "docstring": "return L + [infinity] * (n - len(L))"}
{"repo": "sage-master/src/sage/rings/polynomial/pbori/gbcore.py", "original_string": "def gauss_on_linear_pre(I, prot):\n    return (gauss_on_linear(I), None)\n", "docstring": "return (gauss_on_linear(I), None)"}
{"repo": "sage-master/src/sage/docs/conf.py", "original_string": "    def apply(self):\n        for node in self.document.traverse(nodes.literal_block):\n            if node.get('language') is None and node.astext().startswith('sage:'):\n                node['language'] = 'ipycon'\n                source = node.rawsource\n                source = blankline_re.sub('', source)\n                node.rawsource = source\n                node[:] = [nodes.Text(source)]\n", "docstring": "for node in self.document.traverse(nodes.literal_block):"}
{"repo": "sage-master/src/sage/graphs/tutte_polynomial.py", "original_string": "    def wrapper(G, *args, **kwds):\n        cache = kwds.setdefault('cache', {})\n        key = _cache_key(G)\n        if key in cache:\n            return cache[key]\n        result = func(G, *args, **kwds)\n        cache[key] = result\n        return result\n", "docstring": "cache = kwds.setdefault('cache', {})"}
{"repo": "sage-master/src/sage/graphs/graph_decompositions/modular_decomposition.py", "original_string": "def compute_mu_for_component(graph, component_index, source_index,\n                             root, vertices_in_component):\n    \"\"\"\n    Compute the mu value for component\n    INPUT:\n    - ``graph`` -- Graph whose MD tree needs to be computed\n    - ``component_index`` -- index of the component\n    - ``source_index`` -- index of the source in the forest\n    - ``root`` -- the forest which needs to be assembled into a MD tree\n    - ``vertices_in_component`` -- dictionary which maps index i to list of\n      vertices in the tree at the index i in the forest\n    OUTPUT:\n    The mu value (co-component in the forest) for the component\n    EXAMPLES::\n        sage: from sage.graphs.graph_decompositions.modular_decomposition import *\n        sage: g = Graph()\n        sage: g.add_vertices([1, 2, 3, 4, 5, 6, 7])\n        sage: g.add_edge(2, 3)\n        sage: g.add_edge(4, 3)\n        sage: g.add_edge(5, 3)\n        sage: g.add_edge(2, 6)\n        sage: g.add_edge(2, 7)\n        sage: g.add_edge(6, 1)\n        sage: forest = Node(NodeType.FOREST)\n        sage: forest.children = [create_normal_node(2),\n        ....:                    create_normal_node(3), create_normal_node(1)]\n        sage: series_node = Node(NodeType.SERIES)\n        sage: series_node.children = [create_normal_node(4),\n        ....:                         create_normal_node(5)]\n        sage: parallel_node = Node(NodeType.PARALLEL)\n        sage: parallel_node.children = [create_normal_node(6),\n        ....:                           create_normal_node(7)]\n        sage: forest.children.insert(1, series_node)\n        sage: forest.children.insert(3, parallel_node)\n        sage: vertices_in_component = {}\n        sage: for index, component in enumerate(forest.children):\n        ....:     vertices_in_component[index] = get_vertices(component)\n        sage: compute_mu_for_component(g, 3, 2, forest,\n        ....:                          vertices_in_component)\n        SERIES [NORMAL [4], NORMAL [5]]\n        sage: compute_mu_for_component(g, 4, 2, forest,\n        ....:                          vertices_in_component)\n        NORMAL [2]\n    \"\"\"\n    # default mu value for a component\n    mu_for_component = root.children[0]\n    for index in range(source_index):\n        if (mu_for_component == root.children[index] and\n            is_component_connected(graph, component_index,\n                                   index, vertices_in_component)):\n            mu_for_component = root.children[index + 1]\n    # return the default value\n    return mu_for_component\n", "docstring": "root, vertices_in_component):"}
{"repo": "sage-master/src/sage/libs/gap/operations.py", "original_string": "        def mfi(o):\n            filts = GET_OPER_FLAGS(o)\n            return any(all(IS_SUBSET_FLAGS(self.flags, fl) for fl in fls)\n                       for fls in filts)\n", "docstring": "filts = GET_OPER_FLAGS(o)"}
{"repo": "sage-master/src/sage/libs/pari/__init__.py", "original_string": "def _get_pari_instance():\n    # There are two constraints for the virtual stack size:\n    # 1) on 32-bit systems, even virtual memory can be a scarce\n    #    resource since it is limited by 4GB (of which the kernel\n    #    needs a significant part)\n    # 2) the system should actually be able to handle a stack size\n    #    as large as the complete virtual stack.\n    # As a simple heuristic, we set the virtual stack to 1/4 of the\n    # virtual memory.\n    from sage.misc.getusage import virtual_memory_limit\n    sizemax = virtual_memory_limit() // 4\n    from sage.env import CYGWIN_VERSION\n    if CYGWIN_VERSION and CYGWIN_VERSION < (2, 5, 2):\n        # Cygwin's mmap is broken for large NORESERVE mmaps (>~ 4GB) See\n        # http://trac.sagemath.org/ticket/20463 So we set the max stack\n        # size to a little below 4GB (putting it right on the margin proves\n        # too fragile)\n        #\n        # The underlying issue is fixed in Cygwin v2.5.2\n        sizemax = min(sizemax, 0xf0000000)\n    from cypari2 import Pari\n    P = Pari(1000000, sizemax)\n    # pari_init_opts() overrides MPIR's memory allocation functions,\n    # so we need to reset them.\n    from sage.ext.memory import init_memory_functions\n    init_memory_functions()\n    # PARI sets debugmem=1 by default but we do not want those warning\n    # messages in Sage.\n    P.default(\"debugmem\", 0)\n    # Make sure pari doesn't use threads, regardless of how it was compiled.\n    # Threads cause some doctest failures (memory issues). Those could probably\n    # be solved without disabling threads. But that would require figuring out\n    # some sensible values for `threadsizemax`. See\n    # https://pari.math.u-bordeaux.fr/dochtml/html/GP_defaults.html\n    P.default(\"nbthreads\", 1)\n    return P\n", "docstring": "There are two constraints for the virtual stack size:"}
{"repo": "sage-master/src/sage/databases/jones.py", "original_string": "    def __init__(self):\n        self.root = None\n", "docstring": "self.root = None"}
{"repo": "sage-master/src/sage/databases/db_class_polynomials.py", "original_string": "    def __repr__(self):\n        return \"Hilbert class polynomial database\"\n", "docstring": "return \"Hilbert class polynomial database\""}
{"repo": "sage-master/src/sage/databases/symbolic_data.py", "original_string": "        def _getTextFromNode(node):\n            t = \"\"\n            for n in node.childNodes:\n                if n.nodeType == n.TEXT_NODE:\n                    t += str(n.nodeValue)\n                else:\n                    raise TypeError('not a text node')\n            return t\n", "docstring": "t = \"\""}
{"repo": "sage-master/src/sage/databases/stein_watkins.py", "original_string": "    def __init__(self, num):\n        num = int(num)\n        self.num = num\n        if num < 0:\n            raise RuntimeError(\"num (=%s) must be a nonnegative integer\"%num)\n        name = str(num)\n        name = '0'*(2-len(name)) + name\n        self._file = os.path.join(SAGE_SHARE,'stein_watkins', 'p.%s.bz2'%name)\n        self._iter = iter(self)\n", "docstring": "num = int(num)"}
{"repo": "sage-master/src/sage/databases/cremona.py", "original_string": "    def _init_from_ftpdata(self, ftpdata, largest_conductor=0):\n        \"\"\"Create the SQL Cremona Database from the Cremona elliptic curve\n        data repository ecdata, which is available from\n        https://github.com/JohnCremona/ecdata.\n        To create the large database from Cremona's text files, see\n        sage.databases.cremona.build.  Alternatively:\n        If the Cremona database has already been installed, remove\n        `SAGE_DATA/cremona/cremona.db`. Then run::\n            sage: C = sage.databases.cremona.LargeCremonaDatabase('cremona',False, True)  # not tested\n            sage: C._init_from_ftpdata('path/to/ecdata/',0)                               # not tested\n        EXAMPLES::\n            sage: d = sage.databases.cremona.MiniCremonaDatabase(name='cremona', read_only=False, rebuild=True)   # not tested\n            sage: d._init_from_ftpdata('/home/jec/ecdata')                                                        # not tested\n        \"\"\"\n        if self.__read_only__:\n            raise RuntimeError(\"The database must not be read_only.\")\n        if not os.path.exists(ftpdata):\n            raise RuntimeError(\"The cremona ftpdata directory '\" + ftpdata\n                + \"' does not exist.\")\n        if largest_conductor:\n            print(\"largest conductor =\", largest_conductor)\n            self.__largest_conductor__ =  largest_conductor\n        # Since July 2014 the data files have been arranged in\n        # subdirectories (see trac #16903).\n        allcurves_dir = os.path.join(ftpdata,'allcurves')\n        allbsd_dir = os.path.join(ftpdata,'allbsd')\n        allgens_dir = os.path.join(ftpdata,'allgens')\n        degphi_dir = os.path.join(ftpdata,'degphi')\n        num_curves, num_iso_classes = self._init_allcurves(allcurves_dir, largest_conductor)\n        self.__number_of_curves__ = num_curves\n        self.__number_of_isogeny_classes__ = num_iso_classes\n        if hasattr(self, 'degphi'):\n            self._init_degphi(degphi_dir, largest_conductor)\n        if hasattr(self, 'allbsd'):\n            self._init_allbsd(allbsd_dir, largest_conductor)\n        if hasattr(self, 'allgens'):\n            self._init_allgens(allgens_dir, largest_conductor)\n        self.vacuum()\n", "docstring": "Create the SQL Cremona Database from the Cremona elliptic curve"}
{"repo": "sage-master/src/sage/databases/sloane.py", "original_string": "    def install(self, oeis_url=\"http://oeis.org/stripped.gz\",\n                names_url=\"http://oeis.org/names.gz\", overwrite=False):\n        \"\"\"\n        Download and install the online encyclopedia, raising an IOError if\n        either step fails.\n        INPUT:\n        - ``oeis_url`` - string (default: \"http://oeis.org...\")\n          The URL of the stripped.gz encyclopedia file.\n        - ``names_url`` - string (default: \"http://oeis.org...\")\n          The URL of the names.gz encyclopedia file.  If you do not want to\n          download this file, set names_url=None.\n        - ``overwrite`` - boolean (default: False) If the encyclopedia is\n          already installed and overwrite=True, download and install the latest\n          version over the installed one.\n        \"\"\"\n        # See if the encyclopedia already exists\n        if not overwrite and os.path.exists(self.__file__):\n            raise IOError(\"Sloane encyclopedia is already installed\")\n        tm = verbose(\"Downloading stripped version of Sloane encyclopedia\")\n        try:\n            fname, _ = urlretrieve(oeis_url)\n        except IOError as msg:\n            raise IOError(\"%s\\nError fetching the following website:\\n    %s\\nTry checking your internet connection.\" % (msg, oeis_url))\n        if names_url is not None:\n            try:\n                nname, _ = urlretrieve(names_url)\n            except IOError as msg:\n                raise IOError(\"%s\\nError fetching the following website:\\n    %s\\nTry checking your internet connection.\" % (msg, names_url))\n        else:\n            nname = None\n        verbose(\"Finished downloading\", tm)\n        self.install_from_gz(fname, nname, overwrite)\n        # Delete the temporary downloaded files\n        os.remove(fname)\n        if nname is not None:\n            os.remove(nname)\n", "docstring": "names_url=\"http://oeis.org/names.gz\", overwrite=False):"}
{"repo": "sage-master/src/sage/modules/free_module.py", "original_string": "    def __init__(self, base_ring, rank, degree, sparse=False,\n                 coordinate_ring=None, category=None):\n        \"\"\"\n        Create the free module of given rank ``rank`` over the given base\n        ring ``base_ring``.\n        INPUT:\n        - ``base_ring`` -- a commutative ring\n        - ``rank`` -- a non-negative integer\n        - ``degree`` -- a non-negative integer\n        - ``sparse`` -- bool (default: False)\n        - ``coordinate_ring`` -- a ring containing ``base_ring``\n          (default: equal to ``base_ring``)\n        - ``category`` -- category (default: None)\n        If ``base_ring`` is a field, then the default category is the\n        category of finite-dimensional vector spaces over that field;\n        otherwise it is the category of finite-dimensional free modules\n        over that ring.  In addition, the category is intersected with the\n        category of finite enumerated sets if the ring is finite or the\n        rank is 0.\n        EXAMPLES::\n            sage: PolynomialRing(QQ,3,'x')^3\n            Ambient free module of rank 3 over the integral domain Multivariate Polynomial Ring in x0, x1, x2 over Rational Field\n            sage: FreeModule(GF(7),3).category()\n            Category of enumerated finite dimensional vector spaces with basis over\n             (finite enumerated fields and subquotients of monoids and quotients of semigroups)\n            sage: V = QQ^4; V.category()\n            Category of finite dimensional vector spaces with basis over\n             (number fields and quotient fields and metric spaces)\n            sage: V = GF(5)**20; V.category()\n            Category of enumerated finite dimensional vector spaces with basis over (finite enumerated fields and subquotients of monoids and quotients of semigroups)\n            sage: FreeModule(ZZ,3).category()\n            Category of finite dimensional modules with basis over\n             (euclidean domains and infinite enumerated sets\n              and metric spaces)\n            sage: (QQ^0).category()\n            Category of finite enumerated finite dimensional vector spaces with basis\n             over (number fields and quotient fields and metric spaces)\n        TESTS::\n            sage: M = FreeModule(ZZ,20,sparse=False)\n            sage: x = M.random_element()\n            sage: type(x)\n            <type 'sage.modules.vector_integer_dense.Vector_integer_dense'>\n            sage: M.element_class\n            <type 'sage.modules.vector_integer_dense.Vector_integer_dense'>\n            sage: N = FreeModule(ZZ,20,sparse=True)\n            sage: y = N.random_element()\n            sage: type(y)\n            <type 'sage.modules.free_module_element.FreeModuleElement_generic_sparse'>\n            sage: N.element_class\n            <type 'sage.modules.free_module_element.FreeModuleElement_generic_sparse'>\n        \"\"\"\n        if not base_ring.is_commutative():\n            warn(\"\"\"You are constructing a free module\n", "docstring": "coordinate_ring=None, category=None):"}
{"repo": "sage-master/src/sage/modules/free_module.py", "original_string": "    def _Hom_(self, Y, category):\n        from .free_module_homspace import FreeModuleHomspace\n        return FreeModuleHomspace(self, Y, category)\n", "docstring": "from .free_module_homspace import FreeModuleHomspace"}
{"repo": "sage-master/src/sage/modules/free_module.py", "original_string": "    def __init__(self, ambient, basis, check=True,\n        echelonize=False, echelonized_basis=None, already_echelonized=False):\n        r\"\"\"\n        See :class:`FreeModule_submodule_with_basis_pid` for documentation.\n        TESTS::\n            sage: M = ZZ^3\n            sage: W = M.span_of_basis([[1,2,3],[4,5,6]])\n            sage: TestSuite(W).run()\n        We test that the issue at :trac:`9502` is solved::\n            sage: parent(W.basis()[0])\n            Free module of degree 3 and rank 2 over Integer Ring\n            User basis matrix:\n            [1 2 3]\n            [4 5 6]\n            sage: parent(W.echelonized_basis()[0])\n            Free module of degree 3 and rank 2 over Integer Ring\n            User basis matrix:\n            [1 2 3]\n            [4 5 6]\n        Now we test that the issue introduced at :trac:`9502` and reported at\n        :trac:`10250` is solved as well::\n            sage: V = (QQ^2).span_of_basis([[1,1]])\n            sage: w = sqrt(2) * V([1,1])\n            sage: 3 * w\n            (3*sqrt(2), 3*sqrt(2))\n        \"\"\"\n        if not isinstance(ambient, FreeModule_ambient_pid):\n            raise TypeError(\"ambient (=%s) must be ambient.\" % ambient)\n        self.__ambient_module = ambient\n        R = ambient.base_ring()\n        R_coord = R\n        # Convert all basis elements to the ambient module\n        try:\n            basis = [ambient(x) for x in basis]\n        except TypeError:\n            # That failed, try the ambient vector space instead\n            V = ambient.ambient_vector_space()\n            R_coord = V.base_ring()\n            try:\n                basis = [V(x) for x in basis]\n            except TypeError:\n                raise TypeError(\"each element of basis must be in \"\n                                \"the ambient vector space\")\n        if echelonize and not already_echelonized:\n            basis = self._echelonized_basis(ambient, basis)\n        # The following is WRONG - we should call __init__ of\n        # FreeModule_generic_pid. However, it leads to a bunch of errors.\n        FreeModule_generic.__init__(self, base_ring=R, coordinate_ring=R_coord,\n                                    rank=len(basis), degree=ambient.degree(),\n                                    sparse=ambient.is_sparse())\n        C = self.element_class\n        w = [C(self, x.list(), coerce=False, copy=False) for x in basis]\n        self.__basis = basis_seq(self, w)\n        if echelonize or already_echelonized:\n            self.__echelonized_basis = self.__basis\n        else:\n            if echelonized_basis is None:\n                echelonized_basis = self._echelonized_basis(ambient, basis)\n            w = [C(self, x.list(), coerce=False, copy=True)\n                 for x in echelonized_basis]\n            self.__echelonized_basis = basis_seq(self, w)\n        if check and len(basis) != len(self.__echelonized_basis):\n            raise ValueError(\"The given basis vectors must be linearly \"\n                             \"independent.\")\n", "docstring": "echelonize=False, echelonized_basis=None, already_echelonized=False):"}
{"repo": "sage-master/src/sage/modules/free_module.py", "original_string": "    def __init__(self, ambient, basis, check=True,\n        echelonize=False, echelonized_basis=None, already_echelonized=False):\n        \"\"\"\n        Create a vector space with given basis.\n        EXAMPLES::\n            sage: V = QQ^3\n            sage: W = V.span_of_basis([[1,2,3],[4,5,6]])\n            sage: W\n            Vector space of degree 3 and dimension 2 over Rational Field\n            User basis matrix:\n            [1 2 3]\n            [4 5 6]\n        \"\"\"\n        FreeModule_submodule_with_basis_pid.__init__(\n            self, ambient, basis=basis, check=check, echelonize=echelonize,\n            echelonized_basis=echelonized_basis, already_echelonized=already_echelonized)\n", "docstring": "echelonize=False, echelonized_basis=None, already_echelonized=False):"}
{"repo": "sage-master/src/sage/modules/free_module.py", "original_string": "    def __init__(self,n):\n        FreeModule_ambient_field.__init__(self,sage.rings.real_double.RDF,n)\n", "docstring": "FreeModule_ambient_field.__init__(self,sage.rings.real_double.RDF,n)"}
{"repo": "sage-master/src/sage/modules/free_quadratic_module.py", "original_string": "    def __init__(self, ambient, basis, inner_product_matrix,\n        check=True, echelonize=False, echelonized_basis=None, already_echelonized=False):\n        \"\"\"\n        Create a free module with basis over a PID.\n        EXAMPLES::\n            sage: A = diagonal_matrix([1,2,2])\n            sage: M = FreeQuadraticModule(ZZ,3,inner_product_matrix=A)\n            sage: W = M.span_of_basis([[1,2,3],[4,5,6]]); W\n            Free quadratic module of degree 3 and rank 2 over Integer Ring\n            Basis matrix:\n            [1 2 3]\n            [4 5 6]\n            Inner product matrix:\n            [1 0 0]\n            [0 2 0]\n            [0 0 2]\n            sage: W = M.span_of_basis([[1,2,3/2],[4,5,6]]); W\n            Free quadratic module of degree 3 and rank 2 over Integer Ring\n            Basis matrix:\n            [  1   2 3/2]\n            [  4   5   6]\n            Inner product matrix:\n            [1 0 0]\n            [0 2 0]\n            [0 0 2]\n        TESTS:\n        We test that :trac:`23703` is fixed::\n            sage: A=FreeQuadraticModule(ZZ,1,matrix.identity(1))\n            sage: B=A.span([[1/2]])\n            sage: C=B.span([[1]])\n            sage: B.intersection(C)==C.intersection(B)\n            True\n        \"\"\"\n        free_module.FreeModule_submodule_with_basis_pid.__init__(\n            self, ambient=ambient, basis=basis, check=check,\n            echelonize=echelonize, echelonized_basis=echelonized_basis, already_echelonized=already_echelonized)\n        #self._FreeQuadraticModule_generic_inner_product_matrix = inner_product_matrix\n        self._inner_product_matrix = inner_product_matrix\n", "docstring": "check=True, echelonize=False, echelonized_basis=None, already_echelonized=False):"}
{"repo": "sage-master/src/sage/modules/free_quadratic_module.py", "original_string": "    def __init__(self, ambient, basis, inner_product_matrix,\n                 check=True, echelonize=False, echelonized_basis=None, already_echelonized=False):\n        \"\"\"\n        Create a vector space with given basis.\n        EXAMPLES::\n            sage: V = QQ^3\n            sage: W = V.span_of_basis([[1,2,3],[4,5,6]])\n            sage: W\n            Vector space of degree 3 and dimension 2 over Rational Field\n            User basis matrix:\n            [1 2 3]\n            [4 5 6]\n            sage: V = VectorSpace(QQ, 3, inner_product_matrix=1)\n            sage: V.span_of_basis([[1,2,3],[4,5,6]])\n            Quadratic space of degree 3 and dimension 2 over Rational Field\n            Basis matrix:\n            [1 2 3]\n            [4 5 6]\n            Inner product matrix:\n            [1 0 0]\n            [0 1 0]\n            [0 0 1]\n        \"\"\"\n        free_module.FreeModule_submodule_with_basis_field.__init__(\n            self, ambient=ambient, basis=basis, check=check,\n            echelonize=echelonize, echelonized_basis=echelonized_basis, already_echelonized=already_echelonized)\n        #self._FreeQuadraticModule_generic_inner_product_matrix = inner_product_matrix\n        self._inner_product_matrix = inner_product_matrix\n", "docstring": "check=True, echelonize=False, echelonized_basis=None, already_echelonized=False):"}
{"repo": "sage-master/src/sage/modules/with_basis/morphism.py", "original_string": "    def __init__(self, domain, on_basis=None, codomain=None, category=None,\n                 position=0, zero=None):\n        \"\"\"\n        TESTS::\n            sage: X = CombinatorialFreeModule(ZZ, [-2, -1, 1, 2])\n            sage: Y = CombinatorialFreeModule(ZZ, [1, 2])\n            sage: from sage.modules.with_basis.morphism import ModuleMorphismByLinearity\n            sage: phi = ModuleMorphismByLinearity(X, on_basis=Y.monomial * abs)\n            sage: TestSuite(phi).run()\n        \"\"\"\n        # Might want to assert that domain is a module with basis\n        base_ring = domain.base_ring()\n        if codomain is None and hasattr(on_basis, 'codomain'):\n            codomain = on_basis.codomain()\n        if zero is None:\n            zero = codomain.zero()\n        self._zero = zero\n        self._position = position\n        if on_basis is not None:\n            self._on_basis = on_basis\n        self._is_module_with_basis_over_same_base_ring = \\\n            codomain in ModulesWithBasis( base_ring ) and zero == codomain.zero()\n        ModuleMorphism.__init__(self, domain, codomain,\n                                category=category,\n                                affine=(zero != codomain.zero()))\n", "docstring": "position=0, zero=None):"}
{"repo": "sage-master/src/sage/coding/guruswami_sudan/interpolation.py", "original_string": "def _interpolation_max_weighted_deg(n, tau, s):\n    \"\"\"Return the maximal weighted degree allowed for an interpolation\n    polynomial over `n` points, correcting `tau` errors and with multiplicity\n    `s`\n    EXAMPLES::\n        sage: from sage.coding.guruswami_sudan.interpolation import _interpolation_max_weighted_deg\n        sage: _interpolation_max_weighted_deg(10, 3, 5)\n        35\n    \"\"\"\n    return (n-tau) * s\n", "docstring": "Return the maximal weighted degree allowed for an interpolation"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, n, R):\n        self.__n = n\n        self.__R = R\n        self.repr_str = 'Square a polynomial of degree %s over %s'%(self.__n, self.__R)\n", "docstring": "self.__n = n"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, nvars=2, exp=10, base=QQ, allow_singular=True):\n        self.nvars = nvars\n        self.exp = exp\n        self.base = base\n        self.allow_singular = allow_singular\n        s = 'Compute (x_0 + ... + x_%s)^%s over %s'%(\n            self.nvars - 1, self.exp, self.base)\n        if self.allow_singular:\n            s += ' (use singular for Sage mult.)'\n        self.repr_str = s\n", "docstring": "self.nvars = nvars"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, nvars=2, base=QQ, allow_singular=True):\n        if nvars%2:\n            nvars += 1\n        self.nvars = nvars\n        self.base = base\n        self.allow_singular = allow_singular\n        s =  'Compute (x_0 + ... + x_%s) * (x_%s + ... + x_%s) over %s'%(\n            self.nvars/2 - 1, self.nvars/2, self.nvars, self.base)\n        if self.allow_singular:\n            s += ' (use singular for Sage mult.)'\n        self.repr_str = s\n", "docstring": "if nvars%2:"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, nvars=2, base=QQ, allow_singular=True):\n        if nvars%2:\n            nvars += 1\n        self.nvars = nvars\n        self.base = base\n        self.allow_singular = allow_singular\n        s =  'Compute (x_1 + 2*x_2 + 3*x_3 + ... + %s*x_%s) * (%s * x_%s + ... + %s*x_%s) over %s'%(\n            self.nvars/2, self.nvars/2, self.nvars/2+1, self.nvars/2+1,\n            self.nvars+1, self.nvars+1, self.base)\n        if self.allow_singular:\n            s += ' (use singular for Sage mult.)'\n        self.repr_str = s\n", "docstring": "if nvars%2:"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, N=37,k=2,p=2,sign=1):\n        self.N = N\n        self.k = k\n        self.p = p\n        self.sign = sign\n        self.repr_str = \"Compute the charpoly (given the matrix) of T_%s on S_%s(Gamma_0(%s)) with sign %s.\"%(self.p, self.k, self.N, self.sign)\n", "docstring": "self.N = N"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, n, R):\n        self.__n = n\n        self.__R = R\n        self.repr_str = \"Factor a product of 2 polynomials of degree %s over %s.\"%(self.__n, self.__R)\n", "docstring": "self.__n = n"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, base=10, ndigits=10**5):\n        self.__ndigits = ndigits\n        self.base =base\n        self.repr_str = \"Square the integer %s^%s\"%(self.base, self.__ndigits)\n", "docstring": "self.__ndigits = ndigits"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, n, R):\n        self.__n = n\n        self.__R = R\n        self.repr_str = 'Square a matrix of degree %s over %s'%(self.__n, self.__R)\n", "docstring": "self.__n = n"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, n):\n        self.__n = n\n        self.repr_str = \"Compute the factorial of %s\"%self.__n\n", "docstring": "self.__n = n"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, n):\n        self.__n = n\n        self.repr_str = \"Compute the %s-th Fibonacci number\"%self.__n\n", "docstring": "self.__n = n"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, p):\n        self.__p = p\n        self.repr_str = \"Do SEA on an elliptic curve over GF(%s)\"%self.__p\n", "docstring": "self.__p = p"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, n, R):\n        self.__n = n\n        self.__R = R\n        self.repr_str = 'Kernel of a matrix of degree %s over %s'%(self.__n, self.__R)\n", "docstring": "self.__n = n"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, bits_prec, times):\n        self.__bits_prec = bits_prec\n        self.__times = times\n        self.repr_str = \"List of multiplies of two complex numbers with %s bits of precision %s times\"%(self.__bits_prec, self.__times)\n", "docstring": "self.__bits_prec = bits_prec"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, N, k=2):\n        self.__N = N\n        self.__k = k\n        self.repr_str = 'Presentation for modular symbols on Gamma_0(%s) of weight %s'%(self.__N, self.__k)\n", "docstring": "self.__N = N"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, N, k=2, sign=1, bnd=10):\n        self.N = N\n        self.k = k\n        self.sign = sign\n        self.bnd = bnd\n        self.repr_str = 'Decomposition of modular symbols on Gamma_0(%s) of weight %s and sign %s'%(self.N, self.k, self.sign)\n", "docstring": "self.N = N"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, B):\n        self.B = B\n        self.repr_str = \"Compute all a_p for the elliptic curve [1,2,3,4,5], for p < %s\"%self.B\n", "docstring": "self.B = B"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, n):\n        self.n = n\n        self.repr_str = \"Compute %s*(0,0) on the elliptic curve [0, 0, 1, -1, 0] over QQ\"%self.n\n", "docstring": "self.n = n"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, ainvs):\n        self.ainvs = ainvs\n        self.repr_str = \"Compute generators for the Mordell-Weil group of the elliptic curve %s over QQ\"%self.ainvs\n", "docstring": "self.ainvs = ainvs"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self,field,times):\n        self.__times = times\n        self.field = field\n        self.e = field.gen()**(field.cardinality()/3)\n        self.f = field.gen()**(2*field.cardinality()/3)\n        self.repr_str = \"Multiply a^(#K/3) with a^(2*#K/3) where a == K.gen()\"\n", "docstring": "self.__times = times"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "    def __init__(self, field, times):\n        self.__times = times\n        self.field = field\n        self.e = field.gen()**(field.cardinality()/3)\n        self.f = field.gen()**(2*field.cardinality()/3)\n        self.repr_str = \"Add a^(#K/3) to a^(2*#K/3) where a == K.gen()\"\n", "docstring": "self.__times = times"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "def suite1():\n    PolySquare(10000,QQ).run()\n    PolySquare(20000,ZZ).run()\n    PolySquare(50000,GF(5)).run()\n    PolySquare(20000,Integers(8)).run()\n    SquareInts(10,2000000).run()\n    MatrixSquare(200,QQ).run()\n    MatrixSquare(50,ZZ).run()\n    SquareInts(10,150000).run()\n    Factorial(2*10**6).run(systems = ['sage', 'magma'])\n    Fibonacci(10**6).run()\n    Fibonacci(2*10^7).run(systems=[\"sage\", \"magma\", \"mathematica\"])\n    MatrixKernel(150,QQ).run()\n    ComplexMultiply(100000,1000)\n    ComplexMultiply(100,100000)\n    ComplexMultiply(53,100000)\n    PolyFactor(300,ZZ)\n    PolyFactor(300,GF(19))\n    PolyFactor(700,GF(19))\n    PolyFactor(500,GF(49,'a'))\n    PolyFactor(100,GF(10007^3,'a'))\n    CharPolyTp(54,4).run()\n    CharPolyTp(389,2).run()\n    CharPolyTp(389,2,sign=0,p=3).run()\n    CharPolyTp(1000,2,sign=1,p=2).run(systems=['sage','magma'])\n    CharPolyTp(1,100,sign=1,p=5).run(systems=['sage','magma'])   # Sage's multimodular really sucks here! (GP is way better, even)\n    CharPolyTp(512,sign=1,p=3).run(systems=['sage','magma','gp'])\n    CharPolyTp(512,sign=0,p=3).run(systems=['sage','magma','gp'])\n    CharPolyTp(1024,sign=1,p=3).run(systems=['sage','magma','gp'])\n    CharPolyTp(2006,sign=1,p=2).run(systems=['sage','magma','gp'])\n    CharPolyTp(2006,sign=1,p=2).run(systems=['sage','magma'])    # gp takes > 1 minute.\n", "docstring": "PolySquare(10000,QQ).run()"}
{"repo": "sage-master/src/sage/tests/benchmark.py", "original_string": "def modsym_decomp():\n    ModularSymbolsDecomp1(1,24).run()\n    ModularSymbolsDecomp1(125,2).run()\n    ModularSymbolsDecomp1(389,2).run()\n    ModularSymbolsDecomp1(1,100).run()\n    ModularSymbolsDecomp1(54,4).run()\n", "docstring": "ModularSymbolsDecomp1(1,24).run()"}
{"repo": "sage-master/src/sage/plot/plot.py", "original_string": "        def golden_rainbow(i,lightness=0.4):\n            # note: sage's \"blue\" has hue-saturation-lightness values (2/3, 1, 1/2).\n            g = 0.61803398875\n            return Color((0.66666666666666 + i*g) % 1, 1, lightness, space='hsl')\n", "docstring": "note: sage's \"blue\" has hue-saturation-lightness values (2/3, 1, 1/2)."}
{"repo": "sage-master/src/sage/plot/arc.py", "original_string": "            def is_cyclic_ordered(x1, x2, x3):\n                return ((x1 < x2 and x2 < x3) or\n                        (x2 < x3 and x3 < x1) or\n                        (x3 < x1 and x1 < x2))\n", "docstring": "return ((x1 < x2 and x2 < x3) or"}
{"repo": "sage-master/src/sage/plot/plot3d/tri_plot.py", "original_string": "            def fcn(x,y):\n                return [self._f(x,y)]\n", "docstring": "return [self._f(x,y)]"}
{"repo": "sage-master/src/sage/plot/plot3d/shapes2.py", "original_string": "    def __init__(self, points, thickness=5, corner_cutoff=0.5,\n                 arrow_head=False, **kwds):\n        \"\"\"\n        Create the graphics primitive :class:`Line` in 3-D.\n        See the docstring of this class for full documentation.\n        EXAMPLES::\n            sage: from sage.plot.plot3d.shapes2 import Line\n            sage: P = Line([(1,2,3),(1,2,2),(-1,2,2),(-1,3,2)],thickness=6,corner_cutoff=.2)\n            sage: P.points, P.arrow_head\n            ([(1, 2, 3), (1, 2, 2), (-1, 2, 2), (-1, 3, 2)], False)\n        \"\"\"\n        if len(points) < 2:\n            raise ValueError(\"there must be at least 2 points\")\n        PrimitiveObject.__init__(self, **kwds)\n        self.points = points\n        self.thickness = thickness\n        self.corner_cutoff = corner_cutoff\n        self.arrow_head = arrow_head\n", "docstring": "arrow_head=False, **kwds):"}
{"repo": "sage-master/src/sage/plot/plot3d/list_plot3d.py", "original_string": "        def g(x, y):\n            z = f(x, y)\n            return (x, y, z)\n", "docstring": "z = f(x, y)"}
{"repo": "sage-master/src/sage/misc/all.py", "original_string": "    def __repr__(self):\n        return self\n", "docstring": "return self"}
{"repo": "sage-master/src/sage/misc/latex.py", "original_string": "    def __init__(self, bb=False, delimiters=[\"(\", \")\"],\n                 matrix_column_alignment=\"r\"):\n        \"\"\"\n        Define an object that holds LaTeX global preferences.\n        EXAMPLES::\n            sage: from sage.misc.latex import _Latex_prefs_object\n            sage: latex_prefs = _Latex_prefs_object()\n            sage: TestSuite(latex_prefs).run(skip =\"_test_pickling\")\n        \"\"\"\n        self._option = {}\n        self._option[\"blackboard_bold\"] = bb\n        self._option[\"matrix_delimiters\"] = list(delimiters)\n        self._option[\"vector_delimiters\"] = list(delimiters)\n        self._option[\"matrix_column_alignment\"] = matrix_column_alignment\n        self._option[\"macros\"] = \"\"\n        self._option[\"preamble\"] = \"\"\n        self._option[\"engine\"] = \"pdflatex\"\n        self._option[\"engine_name\"] = \"LaTeX\"\n", "docstring": "matrix_column_alignment=\"r\"):"}
{"repo": "sage-master/src/sage/misc/latex.py", "original_string": "    def extra_macros(self, macros=None):\n        r\"\"\"nodetex\n        String containing extra LaTeX macros to use with %latex and %html.\n        INPUT:\n        - ``macros`` -- string (default: ``None``)\n        If ``macros`` is ``None``, return the current string.  Otherwise,\n        set it to ``macros``.  If you want to *append* to the string\n        of macros instead of replacing it, use\n        :meth:`latex.add_macro <Latex.add_macro>`.\n        EXAMPLES::\n            sage: latex.extra_macros(\"\\\\newcommand{\\\\foo}{bar}\")\n            sage: latex.extra_macros()\n            '\\\\newcommand{\\\\foo}{bar}'\n            sage: latex.extra_macros(\"\")\n            sage: latex.extra_macros()\n            ''\n        \"\"\"\n        if macros is None:\n            return _Latex_prefs._option['macros']\n        else:\n            _Latex_prefs._option['macros'] = macros\n", "docstring": "r\"\"\"nodetex"}
{"repo": "sage-master/src/sage/misc/profiler.py", "original_string": "    def __call__(self, message=None):\n        \"\"\" Adds a checkpoint. \"\"\"\n        entry_times = [fn() for fn in self._cputime_functions ]\n        frame = inspect.currentframe().f_back\n        try:\n            frame_info = inspect.getframeinfo(frame, 9)\n            line_number = frame_info[1]\n            context = frame_info[3]\n        finally:\n            # This is here to prevent reference cycles\n            # (according to the warning in the python documentation:\n            # http://docs.python.org/lib/inspect-stack.html):\n            del frame_info\n            del frame\n        if self._active_details is not None:\n            _time = sum([entry_times[i]-self._last_cputime[i] for i in range(len(entry_times))])\n            self._checkpoints.append((self._active_details, _time))\n        self._active_details = (line_number, context, message)\n        self._last_cputime = [fn() for fn in self._cputime_functions ]\n        if self._verbose:\n            print(self.print_last())\n            sys.stdout.flush()\n", "docstring": "Adds a checkpoint. \n"}
{"repo": "sage-master/src/sage/misc/inline_fortran.py", "original_string": "    def __init__(self, globals=None):\n        # globals=None means: use user globals from REPL\n        self.globs = globals\n        self.library_paths=[]\n        self.libraries=[]\n        self.verbose = False\n", "docstring": "globals=None means: use user globals from REPL"}
{"repo": "sage-master/src/sage/misc/inline_fortran.py", "original_string": "    def __call__(self, *args, **kwds):\n        return self.eval(*args, **kwds)\n", "docstring": "return self.eval(*args, **kwds)"}
{"repo": "sage-master/src/sage/misc/superseded.py", "original_string": "        def wrapper(*args, **kwds):\n            if not wrapper._already_issued:\n                experimental_warning(self.trac_number,\n                            'This class/method/function is marked as '\n                            'experimental. It, its functionality or its '\n                            'interface might change without a '\n                            'formal deprecation.',\n                            self.stacklevel)\n                wrapper._already_issued = True\n            return func(*args, **kwds)\n", "docstring": "if not wrapper._already_issued:"}
{"repo": "sage-master/src/sage/misc/test_class_pickling.py", "original_string": "    def __eq__(self, other):\n        print(\"calling __eq__ defined in Metaclass\")\n        return (type(self) is type(other)) and (self.reduce_args == other.reduce_args)\n", "docstring": "print(\"calling __eq__ defined in Metaclass\")"}
{"repo": "sage-master/src/sage/misc/mrange.py", "original_string": "    def __init__(self, iter_list, typ=list):\n        self.iter_list = iter_list\n        self.typ = typ\n", "docstring": "self.iter_list = iter_list"}
{"repo": "sage-master/src/sage/misc/mrange.py", "original_string": "    def __init__(self, sizes, typ=list):\n        self.sizes = [int(x) for x in sizes]\n        self.typ = typ\n", "docstring": "self.sizes = [int(x) for x in sizes]"}
{"repo": "sage-master/src/sage/misc/misc.py", "original_string": "def word_wrap(s, ncols=85):\n    t = []\n    if ncols == 0:\n        return s\n    for x in s.split('\\n'):\n        if not x or x.lstrip()[:5] == 'sage:':\n            t.append(x)\n            continue\n        while len(x) > ncols:\n            k = ncols\n            while k > 0 and x[k] != ' ':\n                k -= 1\n            if k == 0:\n                k = ncols\n                end = '\\\\'\n            else:\n                end = ''\n            t.append(x[:k] + end)\n            x = x[k:]\n            k = 0\n            while k < len(x) and x[k] == ' ':\n                k += 1\n            x = x[k:]\n        t.append(x)\n    return '\\n'.join(t)\n", "docstring": "t = []"}
{"repo": "sage-master/src/sage/misc/misc.py", "original_string": "    def in_quote():\n        return in_single_quote or in_double_quote or in_triple_quote\n", "docstring": "return in_single_quote or in_double_quote or in_triple_quote"}
{"repo": "sage-master/src/sage/misc/decorators.py", "original_string": "    def _left(self, right):\n        \"\"\"The function for the operation on the left (e.g., __add__).\"\"\"\n        if self.left is None:\n            if self.right is None:\n                new = copy(self)\n                new.right = right\n                return new\n            else:\n                raise SyntaxError(\"Infix operator already has its \"\n                                  \"right argument\")\n        else:\n            return self.function(self.left, right)\n", "docstring": "The function for the operation on the left (e.g., __add__).\n"}
{"repo": "sage-master/src/sage/misc/decorators.py", "original_string": "        def wrapper(*args, **kwds):\n            suboptions = copy(self.options)\n            suboptions.update(kwds.pop(self.name+\"options\", {}))\n            # Collect all the relevant keywords in kwds\n            # and put them in suboptions\n            for key, value in list(kwds.items()):\n                if key.startswith(self.name):\n                    suboptions[key[len(self.name):]] = value\n                    del kwds[key]\n            kwds[self.name + \"options\"] = suboptions\n            return func(*args, **kwds)\n", "docstring": "suboptions = copy(self.options)"}
{"repo": "sage-master/src/sage/misc/decorators.py", "original_string": "        def wrapper(*args, **kwds):\n            options = copy(wrapper.options)\n            if self.original_opts:\n                options['__original_opts'] = kwds\n            options.update(kwds)\n            return func(*args, **options)\n", "docstring": "options = copy(wrapper.options)"}
{"repo": "sage-master/src/sage/misc/decorators.py", "original_string": "        def wrapper(*args, **kwds):\n            for old_name, new_name in self.renames.items():\n                if old_name in kwds and new_name not in kwds:\n                    if self.deprecation is not None:\n                        from sage.misc.superseded import deprecation\n                        deprecation(self.deprecation, \"use the option \"\n                                    \"%r instead of %r\" % (new_name, old_name))\n                    kwds[new_name] = kwds[old_name]\n                    del kwds[old_name]\n            return func(*args, **kwds)\n", "docstring": "for old_name, new_name in self.renames.items():"}
{"repo": "sage-master/src/sage/misc/bindable_class.py", "original_string": "    def __init__(self, *args):\n        super(BoundClass, self).__init__()\n        self.__doc__ = self.func.__doc__\n", "docstring": "super(BoundClass, self).__init__()"}
{"repo": "sage-master/src/sage/misc/sageinspect.py", "original_string": "    def split_string(s, quot):\n        escaped = False\n        l = len(quot)\n        for i in range(len(s)):\n            if s[i] == '\\\\':\n                escaped = not escaped\n                continue\n            if not escaped and s[i:i+l] == quot:\n                return s[:i], s[i+l:]\n            escaped = False\n        raise SyntaxError(\"EOF while scanning string literal\")\n", "docstring": "escaped = False"}
{"repo": "sage-master/src/sage/misc/sageinspect.py", "original_string": "    def formatargandannotation(arg):\n        result = formatarg(arg)\n        if arg in annotations:\n            result += ': ' + formatannotation(annotations[arg])\n        return result\n", "docstring": "result = formatarg(arg)"}
{"repo": "sage-master/src/sage/misc/sagedoc.py", "original_string": "def detex(s, embedded=False):\n    r\"\"\"nodetex\n    This strips LaTeX commands from a string; it is used by the\n    ``format`` function to process docstrings for display from the\n    command line interface.\n    INPUT:\n    - ``s`` - string\n    - ``embedded`` - boolean (optional, default False)\n    If ``embedded`` is False, then do the replacements in both\n    ``math_substitutes`` and ``nonmath_substitutes``.  If True, then\n    only do ``nonmath_substitutes``.\n    OUTPUT:\n    string\n    EXAMPLES::\n        sage: from sage.misc.sagedoc import detex\n        sage: detex(r'Some math: `n \\geq k`.  A website: \\url{sagemath.org}.')\n        'Some math: n >= k.  A website: sagemath.org.\\n'\n        sage: detex(r'More math: `x \\mapsto y`.  {\\bf Bold face}.')\n        'More math: x  |-->  y.  { Bold face}.\\n'\n        sage: detex(r'`a, b, c, \\ldots, z`')\n        'a, b, c, ..., z\\n'\n        sage: detex(r'`a, b, c, \\ldots, z`', embedded=True)\n        '`a, b, c, \\\\ldots, z`'\n        sage: detex(r'`\\left(\\lvert x\\ast y \\rvert\\right]`')\n        '(| x * y |]\\n'\n        sage: detex(r'`\\left(\\leq\\le\\leftarrow \\rightarrow\\unknownmacro\\to`')\n        '(<=<=<-- -->\\\\unknownmacro-->\\n'\n    \"\"\"\n    s = _rmcmd(s, 'url')\n    s = _rmcmd(s, 'code')\n    s = _rmcmd(s, 'class')\n    s = _rmcmd(s, 'mbox')\n    s = _rmcmd(s, 'text')\n    s = _rmcmd(s, 'section')\n    s = _rmcmd(s, 'subsection')\n    s = _rmcmd(s, 'subsubsection')\n    s = _rmcmd(s, 'note', 'NOTE: ', '')\n    s = _rmcmd(s, 'emph', '*', '*')\n    s = _rmcmd(s, 'textbf', '*', '*')\n    s = re.sub(itempattern, itemreplace, s)\n    for a,b in nonmath_substitutes:\n        s = s.replace(a,b)\n    if not embedded: # not in the notebook\n        s = _rmcmd(s, 'mathop')\n        s = _rmcmd(s, 'mathrm')\n        s = sphinxify(s, format='text')\n        # Do math substitutions. The strings to be replaced should be\n        # TeX commands like \"\\\\blah\". Do a regular expression\n        # replacement to replace \"\\\\blah\" but not \"\\\\blahxyz\", etc.:\n        # test to make sure the next character is not a letter.\n        for a,b in math_substitutes:\n            s = re.sub(a+'([^a-zA-Z])', b+'\\\\1', s)\n    return s\n", "docstring": "r\"\"\"nodetex"}
{"repo": "sage-master/src/sage/misc/cython.py", "original_string": "    def __init__(self):\n        from sage.repl.user_globals import get_globals\n        self.globals = get_globals()\n", "docstring": "from sage.repl.user_globals import get_globals"}
{"repo": "sage-master/src/sage/misc/sage_unittest.py", "original_string": "    def __init__(self, instance, elements=None, verbose=False, prefix=\"\",\n                 max_runs=4096, max_samples=None, **options):\n        \"\"\"\n        A gadget attached to an instance providing it with testing utilities.\n        EXAMPLES::\n            sage: from sage.misc.sage_unittest import InstanceTester\n            sage: InstanceTester(instance = ZZ, verbose = True, elements = [1,2,3])\n            Testing utilities for Integer Ring\n        This is used by ``SageObject._tester``, for example::\n            sage: QQ._tester()\n            Testing utilities for Rational Field\n        \"\"\"\n        unittest.TestCase.__init__(self)\n        self._instance = instance\n        self._verbose = verbose\n        self._elements = elements\n        self._prefix = prefix\n        self._max_runs = max_runs\n        self._max_samples = max_samples\n", "docstring": "max_runs=4096, max_samples=None, **options):"}
{"repo": "sage-master/src/sage/parallel/decorate.py", "original_string": "        def h(*args, **kwds):\n            return list(g([(args, kwds)]))[0][1]\n", "docstring": "return list(g([(args, kwds)]))[0][1]"}
{"repo": "sage-master/src/sage_setup/find.py", "original_string": "                def is_in_distributions(filename):\n                    if distributions is None:\n                        return True\n                    distribution = read_distribution(os.path.join(dirpath, filename))\n                    return distribution in distributions\n", "docstring": "if distributions is None:"}
{"repo": "sage-master/src/sage_setup/find.py", "original_string": "    def add(module, filename, dirpath):\n        # Find the longest extension that matches the filename\n        best_ext = ''\n        for ext in module_exts:\n            if filename.endswith(ext) and len(ext) > len(best_ext):\n                best_ext = ext\n        if not best_ext:\n            return\n        base = filename[:-len(best_ext)]\n        filename = os.path.join(dirpath, filename)\n        if base != '__init__':\n            module += '.' + base\n        module_files[module].add(filename)\n        cache_filename = importlib.util.cache_from_source(filename)\n        if os.path.exists(cache_filename):\n            module_files[module].add(cache_filename)\n", "docstring": "Find the longest extension that matches the filename"}
{"repo": "sage-master/src/sage_setup/command/sage_build_ext.py", "original_string": "    def prepare_extension(self, ext):\n        sources = ext.sources\n        if sources is None or not isinstance(sources, (list, tuple)):\n            raise DistutilsSetupError((\"in 'ext_modules' option (extension '%s'), \" +\n                   \"'sources' must be present and must be \" +\n                   \"a list of source filenames\") % ext.name)\n        sources = list(sources)\n        fullname = self.get_ext_fullname(ext.name)\n        if self.inplace:\n            # ignore build-lib -- put the compiled extension into\n            # the source tree along with pure Python modules\n            modpath = fullname.split('.')\n            package = '.'.join(modpath[0:-1])\n            base = modpath[-1]\n            build_py = self.get_finalized_command('build_py')\n            package_dir = build_py.get_package_dir(package)\n            ext_filename = os.path.join(package_dir,\n                                        self.get_ext_filename(base))\n            relative_ext_filename = self.get_ext_filename(base)\n        else:\n            ext_filename = os.path.join(self.build_lib,\n                                        self.get_ext_filename(fullname))\n            relative_ext_filename = self.get_ext_filename(fullname)\n        # while dispatching the calls to gcc in parallel, we sometimes\n        # hit a race condition where two separate build_ext objects\n        # try to create a given directory at the same time; whoever\n        # loses the race then seems to throw an error, saying that\n        # the directory already exists. so, instead of fighting to\n        # fix the race condition, we simply make sure the entire\n        # directory tree exists now, while we're processing the\n        # extensions in serial.\n        relative_ext_dir = os.path.split(relative_ext_filename)[0]\n        prefixes = ['', self.build_lib, self.build_temp]\n        for prefix in prefixes:\n            path = os.path.join(prefix, relative_ext_dir)\n            try:\n                os.makedirs(path)\n            except OSError as e:\n                assert e.errno==errno.EEXIST, 'Cannot create %s.' % path\n        depends = sources + ext.depends\n        if not (self.force or newer_group(depends, ext_filename, 'newer')):\n            log.debug(\"skipping '%s' extension (up-to-date)\", ext.name)\n            need_to_compile = False\n        else:\n            log.info(\"building '%s' extension\", ext.name)\n            need_to_compile = True\n        return need_to_compile, (sources, ext, ext_filename)\n", "docstring": "sources = ext.sources"}
{"repo": "sage-master/src/bin/sage-startuptime.py", "original_string": "def print_separator():\n    print('=' * 72)\n", "docstring": "print('=' * 72)"}
{"repo": "makesite-master/makesite.py", "original_string": "def fread(filename):\n    \"\"\"Read file and close the file.\"\"\"\n    with open(filename, 'r') as f:\n        return f.read()\n", "docstring": "Read file and close the file.\n"}
{"repo": "makesite-master/makesite.py", "original_string": "def log(msg, *args):\n    \"\"\"Log message with specified arguments.\"\"\"\n    sys.stderr.write(msg.format(*args) + '\\n')\n", "docstring": "Log message with specified arguments.\n"}
{"repo": "makesite-master/makesite.py", "original_string": "def read_headers(text):\n    \"\"\"Parse headers in text and yield (key, value, end-index) tuples.\"\"\"\n    for match in re.finditer(r'\\s*<!--\\s*(.+?)\\s*:\\s*(.+?)\\s*-->\\s*|.+', text):\n        if not match.group(1):\n            break\n        yield match.group(1), match.group(2), match.end()\n", "docstring": "Parse headers in text and yield (key, value, end-index) tuples.\n"}
{"repo": "makesite-master/makesite.py", "original_string": "def read_content(filename):\n    \"\"\"Read content and metadata from file into a dictionary.\"\"\"\n    # Read file content.\n    text = fread(filename)\n    # Read metadata and save it in a dictionary.\n    date_slug = os.path.basename(filename).split('.')[0]\n    match = re.search(r'^(?:(\\d\\d\\d\\d-\\d\\d-\\d\\d)-)?(.+)$', date_slug)\n    content = {\n        'date': match.group(1) or '1970-01-01',\n        'slug': match.group(2),\n    }\n    # Read headers.\n    end = 0\n    for key, val, end in read_headers(text):\n        content[key] = val\n    # Separate content from headers.\n    text = text[end:]\n    # Convert Markdown content to HTML.\n    if filename.endswith(('.md', '.mkd', '.mkdn', '.mdown', '.markdown')):\n        try:\n            if _test == 'ImportError':\n                raise ImportError('Error forced by test')\n            import commonmark\n            text = commonmark.commonmark(text)\n        except ImportError as e:\n            log('WARNING: Cannot render Markdown in {}: {}', filename, str(e))\n    # Update the dictionary with content and RFC 2822 date.\n    content.update({\n        'content': text,\n        'rfc_2822_date': rfc_2822_format(content['date'])\n    })\n    return content\n", "docstring": "Read content and metadata from file into a dictionary.\n"}
{"repo": "makesite-master/makesite.py", "original_string": "def make_pages(src, dst, layout, **params):\n    \"\"\"Generate pages from page content.\"\"\"\n    items = []\n    for src_path in glob.glob(src):\n        content = read_content(src_path)\n        page_params = dict(params, **content)\n        # Populate placeholders in content if content-rendering is enabled.\n        if page_params.get('render') == 'yes':\n            rendered_content = render(page_params['content'], **page_params)\n            page_params['content'] = rendered_content\n            content['content'] = rendered_content\n        items.append(content)\n        dst_path = render(dst, **page_params)\n        output = render(layout, **page_params)\n        log('Rendering {} => {} ...', src_path, dst_path)\n        fwrite(dst_path, output)\n    return sorted(items, key=lambda x: x['date'], reverse=True)\n", "docstring": "Generate pages from page content.\n"}
{"repo": "makesite-master/makesite.py", "original_string": "def main():\n    # Create a new _site directory from scratch.\n    if os.path.isdir('_site'):\n        shutil.rmtree('_site')\n    shutil.copytree('static', '_site')\n    # Default parameters.\n    params = {\n        'base_path': '',\n        'subtitle': 'Lorem Ipsum',\n        'author': 'Admin',\n        'site_url': 'http://localhost:8000',\n        'current_year': datetime.datetime.now().year\n    }\n    # If params.json exists, load it.\n    if os.path.isfile('params.json'):\n        params.update(json.loads(fread('params.json')))\n    # Load layouts.\n    page_layout = fread('layout/page.html')\n    post_layout = fread('layout/post.html')\n    list_layout = fread('layout/list.html')\n    item_layout = fread('layout/item.html')\n    feed_xml = fread('layout/feed.xml')\n    item_xml = fread('layout/item.xml')\n    # Combine layouts to form final layouts.\n    post_layout = render(page_layout, content=post_layout)\n    list_layout = render(page_layout, content=list_layout)\n    # Create site pages.\n    make_pages('content/_index.html', '_site/index.html',\n               page_layout, **params)\n    make_pages('content/[!_]*.html', '_site/{{ slug }}/index.html',\n               page_layout, **params)\n    # Create blogs.\n    blog_posts = make_pages('content/blog/*.md',\n                            '_site/blog/{{ slug }}/index.html',\n                            post_layout, blog='blog', **params)\n    news_posts = make_pages('content/news/*.html',\n                            '_site/news/{{ slug }}/index.html',\n                            post_layout, blog='news', **params)\n    # Create blog list pages.\n    make_list(blog_posts, '_site/blog/index.html',\n              list_layout, item_layout, blog='blog', title='Blog', **params)\n    make_list(news_posts, '_site/news/index.html',\n              list_layout, item_layout, blog='news', title='News', **params)\n    # Create RSS feeds.\n    make_list(blog_posts, '_site/blog/rss.xml',\n              feed_xml, item_xml, blog='blog', title='Blog', **params)\n    make_list(news_posts, '_site/news/rss.xml',\n              feed_xml, item_xml, blog='news', title='News', **params)\n", "docstring": "Create a new _site directory from scratch."}
{"repo": "makesite-master/test/test_pages.py", "original_string": "    def test_content_header_params(self):\n        # Test that header params from one post is not used in another\n        # post.\n        src = os.path.join(self.blog_path, 'header*.txt')\n        dst = os.path.join(self.site_path, '{{ slug }}.txt')\n        tpl = '{{ title }}:{{ tag }}:{{ content }}'\n        makesite.make_pages(src, dst, tpl)\n        with open(os.path.join(self.site_path, 'header-foo.txt')) as f:\n            self.assertEqual(f.read(), '{{ title }}:foo:Foo')\n        with open(os.path.join(self.site_path, 'header-bar.txt')) as f:\n            self.assertEqual(f.read(), 'bar:{{ tag }}:Bar')\n", "docstring": "Test that header params from one post is not used in another"}
{"repo": "makesite-master/test/test_pages.py", "original_string": "    def test_content_rendering_via_kwargs(self):\n        # Test that placeholders are populated in content rendering when\n        # requested in make_pages.\n        src = os.path.join(self.blog_path, 'placeholder-foo.txt')\n        dst = os.path.join(self.site_path, '{{ slug }}.txt')\n        tpl = '<div>{{ content }}</div>'\n        makesite.make_pages(src, dst, tpl, author='Admin', render='yes')\n        with open(os.path.join(self.site_path, 'placeholder-foo.txt')) as f:\n            self.assertEqual(f.read(), '<div>foo:Admin:Foo</div>')\n", "docstring": "Test that placeholders are populated in content rendering when"}
{"repo": "pyafipws-master/nsis.py", "original_string": "    def run(self):\n        # Clean up\n        os.system(\"del /S /Q dist\")\n        # First, let py2exe do it's work.\n        py2exe.run(self)\n        lib_dir = self.lib_dir\n        dist_dir = self.dist_dir\n        comserver_files = self.comserver_files\n        metadata = self.distribution.metadata\n        # create the Installer, using the files py2exe has created.\n        script = NSISScript(metadata,\n                            lib_dir,\n                            dist_dir,\n                            self.windows_exe_files,\n                            self.lib_files,\n                            comserver_files)\n        print \"*** creating the nsis script***\"\n        script.create()\n        print \"*** compiling the nsis script***\"\n        script.compile()\n        # Note: By default the final setup.exe will be in an Output subdirectory.\n", "docstring": "Clean up"}
{"repo": "Yamale-master/yamale/yamale.py", "original_string": "def make_schema(path=None, parser='PyYAML', validators=None, content=None):\n    # validators = None means use default.\n    # Import readers here so we can get version information in setup.py.\n    from . import readers\n    raw_schemas = readers.parse_yaml(path, parser, content=content)\n    if not raw_schemas:\n        raise ValueError('{} is an empty file!'.format(path))\n    # First document is the base schema\n    try:\n        s = Schema(raw_schemas[0], path, validators=validators)\n        # Additional documents contain Includes.\n        for raw_schema in raw_schemas[1:]:\n            s.add_include(raw_schema)\n    except (TypeError, SyntaxError) as e:\n        error = 'Schema error in file %s\\n' % path\n        error += str(e)\n        raise SyntaxError(error)\n    return s\n", "docstring": "validators = None means use default."}
{"repo": "Yamale-master/yamale/schema/schema.py", "original_string": "    def validate(self, data, data_name, strict):\n        path = DataPath()\n        errors = self._validate(self._schema, data, path, strict)\n        return ValidationResult(data_name, self.name, errors)\n", "docstring": "path = DataPath()"}
{"repo": "Yamale-master/yamale/schema/schema.py", "original_string": "    def _validate_map_list(self, validator, data, path, strict):\n        errors = []\n        if not validator.validators:\n            return errors  # No validators, user just wanted a map.\n        for key in util.get_keys(data):\n            sub_errors = []\n            for v in validator.validators:\n                err = self._validate_item(v, data, path, strict, key)\n                if err:\n                    sub_errors.append(err)\n            if len(sub_errors) == len(validator.validators):\n                # All validators failed, add to errors\n                for err in sub_errors:\n                    errors += err\n        return errors\n", "docstring": "errors = []"}
{"repo": "Yamale-master/yamale/validators/base.py", "original_string": "    def can_be_none(self):\n        \"\"\"Check if value for optional field can be None.\"\"\"\n        return self._value_can_be_none\n", "docstring": "Check if value for optional field can be None.\n"}
{"repo": "Yamale-master/yamale/validators/validators.py", "original_string": "    def fail(self, value):\n        # Called in case `_is_valid` returns False\n        return '\\'%s\\' may not be an empty set.' % self.get_name()\n", "docstring": "Called in case `_is_valid` returns False"}
{"repo": "Yamale-master/yamale/validators/tests/test_validate.py", "original_string": "def test_integer():\n    v = val.Integer()\n    assert v.is_valid(1)\n    assert not v.is_valid('1')\n    assert not v.is_valid(1.34)\n", "docstring": "v = val.Integer()"}
{"repo": "Yamale-master/yamale/tests/test_functional.py", "original_string": "def test_tests():\n    \"\"\" Make sure the test runner is working.\"\"\"\n    assert 1 + 1 == 2\n", "docstring": "Make sure the test runner is working.\n"}
{"repo": "parsedmarc-master/tests.py", "original_string": "    def testBase64Decoding(self):\n        \"\"\"Test base64 decoding\"\"\"\n        # Example from Wikipedia Base64 article\n        b64_str = \"YW55IGNhcm5hbCBwbGVhcw\"\n        decoded_str = parsedmarc.utils.decode_base64(b64_str)\n        assert decoded_str == b\"any carnal pleas\"\n", "docstring": "Test base64 decoding\n"}
{"repo": "parsedmarc-master/tests.py", "original_string": "    def testAggregateSamples(self):\n        \"\"\"Test sample aggregate/rua DMARC reports\"\"\"\n        sample_paths = glob(\"samples/aggregate/*\")\n        for sample_path in sample_paths:\n            print(\"Testing {0}...\\n\".format(sample_path))\n            parsed_report = parsedmarc.parse_report_file(\n                sample_path)[\"report\"]\n            print(json.dumps(parsed_report, ensure_ascii=False, indent=2))\n            print(\"\\n\")\n            print(parsedmarc.parsed_aggregate_reports_to_csv(parsed_report))\n", "docstring": "Test sample aggregate/rua DMARC reports\n"}
{"repo": "parsedmarc-master/parsedmarc/s3.py", "original_string": "    def save_forensic_report_to_s3(self, report):\n        self.save_report_to_s3(report, 'forensic')\n", "docstring": "self.save_report_to_s3(report, 'forensic')"}
{"repo": "parsedmarc-master/parsedmarc/utils.py", "original_string": "def _cleanup():\n    \"\"\"Remove temporary files\"\"\"\n    shutil.rmtree(tempdir)\n", "docstring": "Remove temporary files\n"}
{"repo": "parsedmarc-master/parsedmarc/utils.py", "original_string": "    def download_psl():\n        url = \"https://publicsuffix.org/list/public_suffix_list.dat\"\n        # Use a browser-like user agent string to bypass some proxy blocks\n        headers = {\"User-Agent\": USER_AGENT}\n        try:\n            fresh_psl = requests.get(url, headers=headers).text\n            with open(psl_path, \"w\", encoding=\"utf-8\") as fresh_psl_file:\n                fresh_psl_file.write(fresh_psl)\n        except Exception as error:\n            raise DownloadError(\n                \"Failed to download an updated PSL {0}\".format(error))\n", "docstring": "Use a browser-like user agent string to bypass some proxy blocks"}
{"repo": "parsedmarc-master/parsedmarc/utils.py", "original_string": "def parse_email_address(original_address):\n    if original_address[0] == \"\":\n        display_name = None\n    else:\n        display_name = original_address[0]\n    address = original_address[1]\n    address_parts = address.split(\"@\")\n    local = None\n    domain = None\n    if len(address_parts) > 1:\n        local = address_parts[0].lower()\n        domain = address_parts[-1].lower()\n    return OrderedDict([(\"display_name\", display_name),\n                        (\"address\", address),\n                        (\"local\", local),\n                        (\"domain\", domain)])\n", "docstring": "if original_address[0] == \"\":"}
{"repo": "parsedmarc-master/parsedmarc/cli.py", "original_string": "def _str_to_list(s):\n    \"\"\"Converts a comma separated string to a list\"\"\"\n    _list = s.split(\",\")\n    return list(map(lambda i: i.lstrip(), _list))\n", "docstring": "Converts a comma separated string to a list\n"}
{"repo": "parsedmarc-master/parsedmarc/__init__.py", "original_string": "def parse_report_file(input_, nameservers=None, dns_timeout=2.0,\n                      strip_attachment_payloads=False,\n                      offline=False, parallel=False, server=None):\n    \"\"\"Parses a DMARC aggregate or forensic file at the given path, a\n    file-like object. or bytes\n    Args:\n        input_: A path to a file, a file like object, or bytes\n        nameservers (list): A list of one or more nameservers to use\n        (Cloudflare's public DNS resolvers by default)\n        dns_timeout (float): Sets the DNS timeout in seconds\n        strip_attachment_payloads (bool): Remove attachment payloads from\n        forensic report results\n        offline (bool): Do not make online queries for geolocation or DNS\n        parallel (bool): Parallel processing\n        server (IMAPClient): Connection object\n    Returns:\n        OrderedDict: The parsed DMARC report\n    \"\"\"\n    if type(input_) == str:\n        logger.debug(\"Parsing {0}\".format(input_))\n        file_object = open(input_, \"rb\")\n    elif type(input_) == bytes:\n        file_object = BytesIO(input_)\n    else:\n        file_object = input_\n    content = file_object.read()\n    file_object.close()\n    try:\n        report = parse_aggregate_report_file(content,\n                                             offline=offline,\n                                             nameservers=nameservers,\n                                             dns_timeout=dns_timeout,\n                                             parallel=parallel,\n                                             server=server)\n        results = OrderedDict([(\"report_type\", \"aggregate\"),\n                               (\"report\", report)])\n    except InvalidAggregateReport:\n        try:\n            sa = strip_attachment_payloads\n            results = parse_report_email(content,\n                                         offline=offline,\n                                         nameservers=nameservers,\n                                         dns_timeout=dns_timeout,\n                                         strip_attachment_payloads=sa,\n                                         parallel=parallel,\n                                         server=server)\n        except InvalidDMARCReport:\n            raise InvalidDMARCReport(\"Not a valid aggregate or forensic \"\n                                     \"report\")\n    return results\n", "docstring": "strip_attachment_payloads=False,"}
{"repo": "parsedmarc-master/parsedmarc/__init__.py", "original_string": "def watch_inbox(host, username, password, callback, port=None, ssl=True,\n                verify=True, reports_folder=\"INBOX\",\n                archive_folder=\"Archive\", delete=False, test=False,\n                idle_timeout=30, offline=False, nameservers=None,\n                dns_timeout=6.0, strip_attachment_payloads=False,\n                batch_size=None):\n    \"\"\"\n    Use an IDLE IMAP connection to parse incoming emails, and pass the results\n    to a callback function\n    Args:\n        host: The mail server hostname or IP address\n        username: The mail server username\n        password: The mail server password\n        callback: The callback function to receive the parsing results\n        port: The mail server port\n        ssl (bool): Use SSL/TLS\n        verify (bool): Verify the TLS/SSL certificate\n        reports_folder: The IMAP folder where reports can be found\n        archive_folder: The folder to move processed mail to\n        delete (bool): Delete  messages after processing them\n        test (bool): Do not move or delete messages after processing them\n        idle_timeout (int): Number of seconds to wait for a IMAP IDLE response\n        offline (bool): Do not query online for geolocation or DNS\n        nameservers (list): A list of one or more nameservers to use\n        (Cloudflare's public DNS resolvers by default)\n        dns_timeout (float): Set the DNS query timeout\n        strip_attachment_payloads (bool): Replace attachment payloads in\n        forensic report samples with None\n        batch_size (int): Number of messages to read and process before saving\n    \"\"\"\n    sa = strip_attachment_payloads\n    def idle_callback(connection):\n        res = get_dmarc_reports_from_inbox(connection=connection,\n                                           reports_folder=reports_folder,\n                                           archive_folder=archive_folder,\n                                           delete=delete,\n                                           test=test,\n                                           offline=offline,\n                                           nameservers=nameservers,\n                                           dns_timeout=dns_timeout,\n                                           strip_attachment_payloads=sa,\n                                           batch_size=batch_size)\n        callback(res)\n    while True:\n        try:\n            IMAPClient(host=host, username=username, password=password,\n                       port=port, ssl=ssl, verify=verify,\n                       initial_folder=reports_folder,\n                       idle_callback=idle_callback,\n                       idle_timeout=idle_timeout)\n        except (timeout, IMAPClientError):\n            logger.warning(\"IMAP connection timeout. Reconnecting...\")\n            sleep(5)\n        except Exception as e:\n            logger.warning(\"IMAP connection error. {0}. \"\n                           \"Reconnecting...\".format(e))\n            sleep(5)\n", "docstring": "verify=True, reports_folder=\"INBOX\","}
{"repo": "mimicdb-master/mimicdb/s3/bucket.py", "original_string": "    def __init__(self, *args, **kwargs):\n        \"\"\"Set the class for key objects created in the bucket to the MimicDB\n        key class.\n        \"\"\"\n        kwargs['key_class'] = Key\n        super(Bucket, self).__init__(*args, **kwargs)\n", "docstring": "Set the class for key objects created in the bucket to the MimicDB"}
{"repo": "mimicdb-master/mimicdb/s3/bucket.py", "original_string": "    def get_key(self, *args, **kwargs):\n        \"\"\"Return the key from MimicDB.\n        :param boolean force: If true, API call is forced to S3\n        \"\"\"\n        if kwargs.pop('force', None):\n            headers = kwargs.get('headers', {})\n            headers['force'] = True\n            kwargs['headers'] = headers\n        return super(Bucket, self).get_key(*args, **kwargs)\n", "docstring": "Return the key from MimicDB."}
{"repo": "mimicdb-master/mimicdb/s3/bucket.py", "original_string": "    def get_all_keys(self, *args, **kwargs):\n        \"\"\"Return a list of keys from MimicDB.\n        :param boolean force: If true, API call is forced to S3\n        \"\"\"\n        if kwargs.pop('force', None):\n            headers = kwargs.get('headers', args[0] if len(args) else None) or dict()\n            headers['force'] = True\n            kwargs['headers'] = headers\n        return super(Bucket, self).get_all_keys(*args, **kwargs)\n", "docstring": "Return a list of keys from MimicDB."}
{"repo": "mimicdb-master/mimicdb/s3/bucket.py", "original_string": "    def _delete_key_internal(self, *args, **kwargs):\n        \"\"\"Remove key name from bucket set.\n        \"\"\"\n        mimicdb.backend.srem(tpl.bucket % self.name, args[0])\n        mimicdb.backend.delete(tpl.key % (self.name, args[0]))\n        return super(Bucket, self)._delete_key_internal(*args, **kwargs)\n", "docstring": "Remove key name from bucket set."}
{"repo": "mimicdb-master/mimicdb/s3/bucket.py", "original_string": "    def _get_all(self, *args, **kwargs):\n        \"\"\"If 'force' is in the headers, retrieve the list of keys from S3.\n        Otherwise, use the list() function to retrieve the keys from MimicDB.\n        \"\"\"\n        headers = kwargs.get('headers', args[2] if len(args) > 2 else None) or dict()\n        if 'force' in headers:\n            keys = super(Bucket, self)._get_all(*args, **kwargs)\n            for key in keys:\n                mimicdb.backend.sadd(tpl.bucket % self.name, key.name)\n                mimicdb.backend.hmset(tpl.key % (self.name, key.name), dict(size=key.size, md5=key.etag.strip('\"')))\n                key.name = key.name\n            return keys\n        prefix = kwargs.get('prefix', '')\n        return list(self.list(prefix=prefix))\n", "docstring": "If 'force' is in the headers, retrieve the list of keys from S3."}
{"repo": "mimicdb-master/mimicdb/s3/connection.py", "original_string": "    def __init__(self, *args, **kwargs):\n        \"\"\"Set the base class for bucket objects created in the connection to\n        the MimicDB bucket class.\n        \"\"\"\n        kwargs['bucket_class'] = Bucket\n        super(S3Connection, self).__init__(*args, **kwargs)\n", "docstring": "Set the base class for bucket objects created in the connection to"}
{"repo": "mimicdb-master/mimicdb/s3/connection.py", "original_string": "    def get_bucket(self, bucket_name, validate=True, headers=None, force=None):\n        \"\"\"Return a bucket from MimicDB if it exists. Return a\n        S3ResponseError if the bucket does not exist and validate is passed.\n        :param boolean force: If true, API call is forced to S3\n        \"\"\"\n        if force:\n            bucket = super(S3Connection, self).get_bucket(bucket_name, validate, headers)\n            mimicdb.backend.sadd(tpl.connection, bucket.name)\n            return bucket\n        if mimicdb.backend.sismember(tpl.connection, bucket_name):\n            return Bucket(self, bucket_name)\n        else:\n            if validate:\n                raise S3ResponseError(404, 'NoSuchBucket')\n            else:\n                return Bucket(self, bucket_name)\n", "docstring": "Return a bucket from MimicDB if it exists. Return a"}
{"repo": "mimicdb-master/mimicdb/s3/connection.py", "original_string": "    def delete_bucket(self, *args, **kwargs):\n        \"\"\"Delete the bucket on S3 before removing it from MimicDB.\n        If the delete fails (usually because the bucket is not empty), do\n        not remove the bucket from the set.\n        \"\"\"\n        super(S3Connection, self).delete_bucket(*args, **kwargs)\n        bucket = kwargs.get('bucket_name', args[0] if args else None)\n        if bucket:\n            mimicdb.backend.srem(tpl.connection, bucket)\n", "docstring": "Delete the bucket on S3 before removing it from MimicDB."}
{"repo": "mimicdb-master/mimicdb/s3/key.py", "original_string": "    def __init__(self, *args, **kwargs):\n        \"\"\"Add the key to the bucket set if the key name is set and metadata is\n        available for it, otherwise wait until uploaded or downloaded.\n        \"\"\"\n        bucket = kwargs.get('bucket', args[0] if args else None)\n        name = kwargs.get('name', args[1] if len(args) > 1 else None)\n        self._name = name\n        if name and bucket:\n            meta = mimicdb.backend.hgetall(tpl.key % (bucket.name, name))\n            if meta:\n                mimicdb.backend.sadd(tpl.bucket % bucket.name, name)\n                self._load_meta(meta['size'], meta['md5'])\n        super(Key, self).__init__(*args, **kwargs)\n", "docstring": "Add the key to the bucket set if the key name is set and metadata is"}
{"repo": "mimicdb-master/mimicdb/s3/key.py", "original_string": "    def name(self, value):\n        \"\"\"Key name can be set by Key.key or Key.name. Key.key sets Key.name\n        internally, so just handle this property. When changing the key\n        name, try to load it's metadata from MimicDB. If it's not available,\n        the key hasn't been uploaded, downloaded or synced so don't add it to\n        the bucket set (it also might have just been deleted,\n        see boto.s3.bucket.py#785)\n        \"\"\"\n        self._name = value\n        if value:\n            meta = mimicdb.backend.hgetall(tpl.key % (self.bucket.name, value))\n            if meta:\n                mimicdb.backend.sadd(tpl.bucket % self.bucket.name, value)\n                self._load_meta(meta['size'], meta['md5'])\n", "docstring": "Key name can be set by Key.key or Key.name. Key.key sets Key.name"}
{"repo": "Traffic-Rule-Violation-Detection-System-master/openalpr_api/rest.py", "original_string": "    def __init__(self, pools_size=4):\n        # urllib3.PoolManager will pass all kw parameters to connectionpool\n        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75\n        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680\n        # ca_certs vs cert_file vs key_file\n        # http://stackoverflow.com/a/23957365/2985775\n        # cert_reqs\n        if Configuration().verify_ssl:\n            cert_reqs = ssl.CERT_REQUIRED\n        else:\n            cert_reqs = ssl.CERT_NONE\n        # ca_certs\n        if Configuration().ssl_ca_cert:\n            ca_certs = Configuration().ssl_ca_cert\n        else:\n            # if not set certificate file, use Mozilla's root certificates.\n            ca_certs = certifi.where()\n        # cert_file\n        cert_file = Configuration().cert_file\n        # key file\n        key_file = Configuration().key_file\n        # https pool manager\n        self.pool_manager = urllib3.PoolManager(\n            num_pools=pools_size,\n            cert_reqs=cert_reqs,\n            ca_certs=ca_certs,\n            cert_file=cert_file,\n            key_file=key_file\n        )\n", "docstring": "urllib3.PoolManager will pass all kw parameters to connectionpool"}
{"repo": "Traffic-Rule-Violation-Detection-System-master/openalpr_api/rest.py", "original_string": "    def GET(self, url, headers=None, query_params=None):\n        return self.request(\"GET\", url,\n                            headers=headers,\n                            query_params=query_params)\n", "docstring": "return self.request(\"GET\", url,"}
{"repo": "Traffic-Rule-Violation-Detection-System-master/openalpr_api/api_client.py", "original_string": "    def __call_api(self, resource_path, method,\n                   path_params=None, query_params=None, header_params=None,\n                   body=None, post_params=None, files=None,\n                   response_type=None, auth_settings=None, callback=None, _return_http_data_only=None):\n        # headers parameters\n        header_params = header_params or {}\n        header_params.update(self.default_headers)\n        if self.cookie:\n            header_params['Cookie'] = self.cookie\n        if header_params:\n            header_params = self.sanitize_for_serialization(header_params)\n        # path parameters\n        if path_params:\n            path_params = self.sanitize_for_serialization(path_params)\n            for k, v in iteritems(path_params):\n                replacement = quote(str(self.to_path_value(v)))\n                resource_path = resource_path.\\\n                    replace('{' + k + '}', replacement)\n        # query parameters\n        if query_params:\n            query_params = self.sanitize_for_serialization(query_params)\n            query_params = {k: self.to_path_value(v)\n                            for k, v in iteritems(query_params)}\n        # post parameters\n        if post_params or files:\n            post_params = self.prepare_post_parameters(post_params, files)\n            post_params = self.sanitize_for_serialization(post_params)\n        # auth setting\n        self.update_params_for_auth(header_params, query_params, auth_settings)\n        # body\n        if body:\n            body = self.sanitize_for_serialization(body)\n        # request url\n        url = self.host + resource_path\n        # perform request and return response\n        response_data = self.request(method, url,\n                                     query_params=query_params,\n                                     headers=header_params,\n                                     post_params=post_params, body=body)\n        self.last_response = response_data\n        # deserialize response data\n        if response_type:\n            deserialized_data = self.deserialize(response_data, response_type)\n        else:\n            deserialized_data = None\n        if callback:\n            callback(deserialized_data) if _return_http_data_only else callback((deserialized_data, response_data.status, response_data.getheaders()))\n        elif _return_http_data_only:\n            return ( deserialized_data );\n        else:\n            return (deserialized_data, response_data.status, response_data.getheaders())\n        \n", "docstring": "path_params=None, query_params=None, header_params=None,"}
{"repo": "Traffic-Rule-Violation-Detection-System-master/openalpr_api/api_client.py", "original_string": "    def request(self, method, url, query_params=None, headers=None,\n                post_params=None, body=None):\n        \"\"\"\n        Makes the HTTP request using RESTClient.\n        \"\"\"\n        if method == \"GET\":\n            return self.rest_client.GET(url,\n                                        query_params=query_params,\n                                        headers=headers)\n        elif method == \"HEAD\":\n            return self.rest_client.HEAD(url,\n                                         query_params=query_params,\n                                         headers=headers)\n        elif method == \"OPTIONS\":\n            return self.rest_client.OPTIONS(url,\n                                            query_params=query_params,\n                                            headers=headers,\n                                            post_params=post_params,\n                                            body=body)\n        elif method == \"POST\":\n            return self.rest_client.POST(url,\n                                         query_params=query_params,\n                                         headers=headers,\n                                         post_params=post_params,\n                                         body=body)\n        elif method == \"PUT\":\n            return self.rest_client.PUT(url,\n                                        query_params=query_params,\n                                        headers=headers,\n                                        post_params=post_params,\n                                        body=body)\n        elif method == \"PATCH\":\n            return self.rest_client.PATCH(url,\n                                          query_params=query_params,\n                                          headers=headers,\n                                          post_params=post_params,\n                                          body=body)\n        elif method == \"DELETE\":\n            return self.rest_client.DELETE(url,\n                                           query_params=query_params,\n                                           headers=headers,\n                                           body=body)\n        else:\n            raise ValueError(\n                \"http method must be `GET`, `HEAD`,\"\n                \" `POST`, `PATCH`, `PUT` or `DELETE`.\"\n            )\n", "docstring": "post_params=None, body=None):"}
{"repo": "RPA-Python-master/tagui.py", "original_string": "def _python2_env():\n    \"\"\"function to check python version for compatibility handling\"\"\"\n    if sys.version_info[0] < 3: return True\n    else: return False\n", "docstring": "function to check python version for compatibility handling\n"}
{"repo": "RPA-Python-master/tagui.py", "original_string": "def _py23_decode(input_variable = None):\n    \"\"\"function for python 2 and 3 str-byte compatibility handling\"\"\"\n    if input_variable is None: return None\n    elif _python2_env(): return input_variable\n    else: return input_variable.decode('utf-8')\n", "docstring": "function for python 2 and 3 str-byte compatibility handling\n"}
{"repo": "RPA-Python-master/tagui.py", "original_string": "def _py23_open(target_filename, target_mode = 'r'):\n    \"\"\"function for python 2 and 3 open utf-8 compatibility handling\"\"\"\n    if _python2_env():\n        return io.open(target_filename, target_mode, encoding = 'utf-8')\n    else:\n        return open(target_filename, target_mode, encoding = 'utf-8') \n", "docstring": "function for python 2 and 3 open utf-8 compatibility handling\n"}
{"repo": "RPA-Python-master/tagui.py", "original_string": "def _py23_write(input_text = None):\n    \"\"\"function for python 2 and 3 write utf-8 compatibility handling\"\"\"\n    if input_text is None: return None\n    if _python2_env(): return input_text.decode('utf-8')\n    else: return input_text\n", "docstring": "function for python 2 and 3 write utf-8 compatibility handling\n"}
{"repo": "RPA-Python-master/tagui.py", "original_string": "def _tagui_write(input_text = ''):\n    \"\"\"function to write to tagui process live mode interface\"\"\"\n    global _process; _process.stdin.write(_py23_encode(input_text))\n    _process.stdin.flush(); # flush to ensure immediate delivery\n", "docstring": "function to write to tagui process live mode interface\n"}
{"repo": "RPA-Python-master/tagui.py", "original_string": "def _esq(input_text = ''):\n    \"\"\"function for selective escape of single quote ' for tagui\"\"\"\n    # [BACKSLASH_QUOTE] marker to work together with send()\n    return input_text.replace(\"'\",'[BACKSLASH_QUOTE]')\n", "docstring": "function for selective escape of single quote ' for tagui\n"}
{"repo": "RPA-Python-master/tagui.py", "original_string": "def _visual_flow():\n    \"\"\"function to create entry tagui flow with visual automation\"\"\"\n    flow_text = '// VISUAL ENTRY FLOW FOR RPA FOR PYTHON ~ TEBEL.ORG\\r\\n' + \\\n                '// mouse_xy() - dummy trigger for SikuliX integration\\r\\n\\r\\nlive'\n    flow_file = _py23_open('rpa_python', 'w')\n    flow_file.write(_py23_write(flow_text))\n    flow_file.close()\n", "docstring": "function to create entry tagui flow with visual automation\n"}
{"repo": "RPA-Python-master/tagui.py", "original_string": "def _tagui_delta(base_directory = None):\n    \"\"\"function to download stable delta files from tagui cutting edge version\"\"\"\n    global __version__\n    if base_directory is None or base_directory == '': return False\n    # skip downloading if it is already done before for current release\n    if os.path.isfile(base_directory + '/' + 'rpa_python_' + __version__): return True\n    # define list of key tagui files to be downloaded and synced locally\n    delta_list = ['tagui', 'tagui.cmd', 'end_processes', 'end_processes.cmd', \n                    'tagui_header.js', 'tagui_parse.php', 'tagui.sikuli/tagui.py']\n    for delta_file in delta_list:\n        tagui_delta_url = 'https://raw.githubusercontent.com/tebelorg/Tump/master/TagUI-Python/' + delta_file\n        tagui_delta_file = base_directory + '/' + 'src' + '/' + delta_file\n        if not download(tagui_delta_url, tagui_delta_file): return False\n    # make sure execute permission is there for .tagui/src/tagui and end_processes\n    if platform.system() in ['Linux', 'Darwin']:\n        os.system('chmod -R 755 \"' + base_directory + '/' + 'src' + '/' + 'tagui\" > /dev/null 2>&1')\n        os.system('chmod -R 755 \"' + base_directory + '/' + 'src' + '/' + 'end_processes\" > /dev/null 2>&1')\n    # create marker file to skip syncing delta files next time for current release\n    delta_done_file = _py23_open(base_directory + '/' + 'rpa_python_' + __version__, 'w')\n    delta_done_file.write(_py23_write('TagUI installation files used by RPA for Python'))\n    delta_done_file.close()\n    return True\n", "docstring": "function to download stable delta files from tagui cutting edge version\n"}
{"repo": "RPA-Python-master/tagui.py", "original_string": "def coord(x_coordinate = 0, y_coordinate = 0):\n    \"\"\"function to form a coordinate string from x and y integers\"\"\"\n    return '(' + str(x_coordinate) + ',' + str(y_coordinate) + ')'\n", "docstring": "function to form a coordinate string from x and y integers\n"}
{"repo": "RPA-Python-master/tagui.py", "original_string": "def tagui_location(location = None):\n    \"\"\"function to set location of TagUI installation\"\"\"\n    global _tagui_location\n    if location is not None: _tagui_location = location\n    return _tagui_location\n", "docstring": "function to set location of TagUI installation\n"}
{"repo": "RPA-Python-master/tagui.py", "original_string": "def pack():\n    \"\"\"function to pack TagUI files for installation on an air-gapped computer without internet\"\"\"\n    print('[RPA][INFO] - pack() is to deploy RPA for Python to a computer without internet')\n    print('[RPA][INFO] - update() is to update an existing installation deployed from pack()')\n    print('[RPA][INFO] - detecting and zipping your TagUI installation to rpa_python.zip ...')\n    # first make sure TagUI files have been downloaded and synced to latest stable delta files\n    global _tagui_started\n    if _tagui_started:\n        if not close():\n            return False\n    if not init(False, False):\n        return False\n    if not close():\n        return False\n    # next download jython to tagui/src/sikulix folder (after init() it can be moved away)\n    if platform.system() == 'Windows':\n        tagui_directory = tagui_location() + '/' + 'tagui'\n        # pack in Visual C++ MSVCR110.dll dependency from PHP for offline installation \n        vcredist_x86_url = 'https://raw.githubusercontent.com/tebelorg/Tump/master/vcredist_x86.exe'\n        if not download(vcredist_x86_url, tagui_directory + '/vcredist_x86.exe'):\n            return False\n    else:\n        tagui_directory = tagui_location() + '/' + '.tagui'\n    sikulix_directory = tagui_directory + '/' + 'src' + '/' + 'sikulix'\n    sikulix_jython_url = 'https://github.com/tebelorg/Tump/releases/download/v1.0.0/jython-standalone-2.7.1.jar'\n    if not download(sikulix_jython_url, sikulix_directory + '/' + 'jython-standalone-2.7.1.jar'):\n        return False\n    # finally zip entire TagUI installation and save a copy of tagui.py to current folder\n    import shutil\n    shutil.make_archive('rpa_python', 'zip', tagui_directory)\n    shutil.copyfile(os.path.dirname(__file__) + '/tagui.py', 'rpa.py')\n    print('[RPA][INFO] - done. copy rpa_python.zip and rpa.py to your target computer.')\n    print('[RPA][INFO] - then install and use with import rpa as r followed by r.init()')\n    return True\n", "docstring": "function to pack TagUI files for installation on an air-gapped computer without internet\n"}
{"repo": "RPA-Python-master/tagui.py", "original_string": "def _ready():\n    \"\"\"internal function to check if tagui is ready to receive instructions after init() is called\"\"\"\n    global _process, _tagui_started, _tagui_id, _tagui_visual, _tagui_chrome\n    if not _tagui_started:\n        # print output error in calling parent function instead\n        return False\n    try:\n        # failsafe exit if tagui process gets killed for whatever reason\n        if _process.poll() is not None:\n            # print output error in calling parent function instead\n            _tagui_visual = False\n            _tagui_chrome = False\n            _tagui_started = False\n            return False\n        # read next line of output from tagui process live mode interface\n        tagui_out = _tagui_read()\n        # print to screen debug output that is saved to rpa_python.log\n        if debug():\n            sys.stdout.write(tagui_out); sys.stdout.flush()\n        # check if tagui live mode is listening for inputs and return result\n        if tagui_out.strip().startswith('[RPA][') and tagui_out.strip().endswith('] - listening for inputs'):\n            return True\n        else:\n            return False\n    except Exception as e:\n        print('[RPA][ERROR] - ' + str(e))\n        return False\n", "docstring": "internal function to check if tagui is ready to receive instructions after init() is called\n"}
{"repo": "RPA-Python-master/tagui.py", "original_string": "def close():\n    \"\"\"disconnect from tagui process by sending 'done' trigger instruction\"\"\"\n    global _process, _tagui_started, _tagui_id, _tagui_visual, _tagui_chrome, _tagui_init_directory\n    if not _tagui_started:\n        print('[RPA][ERROR] - use init() before using close()')\n        return False\n    try:\n        # failsafe exit if tagui process gets killed for whatever reason\n        if _process.poll() is not None:\n            print('[RPA][ERROR] - no active TagUI process to close()')\n            _tagui_visual = False\n            _tagui_chrome = False\n            _tagui_started = False\n            return False\n        # send 'done' instruction to terminate live mode and exit tagui\n        _tagui_write('echo \"[RPA][FINISHED]\"\\n')\n        _tagui_write('done\\n')\n        # loop until tagui process has closed before returning control\n        while _process.poll() is None: pass\n        # remove again generated tagui flow, js code and custom functions files\n        if os.path.isfile('rpa_python'): os.remove('rpa_python')\n        if os.path.isfile('rpa_python.js'): os.remove('rpa_python.js')\n        if os.path.isfile('rpa_python.raw'): os.remove('rpa_python.raw')\n        if os.path.isfile('tagui_local.js'): os.remove('tagui_local.js')\n        # to handle user changing current directory after init() is called\n        if os.path.isfile(os.path.join(_tagui_init_directory, 'rpa_python')):\n            os.remove(os.path.join(_tagui_init_directory, 'rpa_python'))\n        if os.path.isfile(os.path.join(_tagui_init_directory, 'rpa_python.js')):\n            os.remove(os.path.join(_tagui_init_directory, 'rpa_python.js'))\n        if os.path.isfile(os.path.join(_tagui_init_directory, 'rpa_python.raw')):\n            os.remove(os.path.join(_tagui_init_directory, 'rpa_python.raw'))\n        if os.path.isfile(os.path.join(_tagui_init_directory, 'tagui_local.js')):\n            os.remove(os.path.join(_tagui_init_directory, 'tagui_local.js'))   \n        # remove generated tagui log and data files if not in debug mode\n        if not debug():\n            if os.path.isfile('rpa_python.log'): os.remove('rpa_python.log')\n            if os.path.isfile('rpa_python.txt'): os.remove('rpa_python.txt')\n        \n            # to handle user changing current directory after init() is called\n            if os.path.isfile(os.path.join(_tagui_init_directory, 'rpa_python.log')):\n                os.remove(os.path.join(_tagui_init_directory, 'rpa_python.log'))\n            if os.path.isfile(os.path.join(_tagui_init_directory, 'rpa_python.txt')):\n                os.remove(os.path.join(_tagui_init_directory, 'rpa_python.txt'))\n        _tagui_visual = False\n        _tagui_chrome = False\n        _tagui_started = False\n        return True\n    except Exception as e:\n        print('[RPA][ERROR] - ' + str(e))\n        _tagui_visual = False\n        _tagui_chrome = False\n        _tagui_started = False\n        return False\n", "docstring": "disconnect from tagui process by sending 'done' trigger instruction\n"}
{"repo": "cocos-master/tools/change_license.py", "original_string": "def process_file(filename):\n    '''Open a Python source file and check if exactly begins with the\n    text provided in the global old_license; if yes, replace that text with\n    the one in the global new_license.\n    Side effect: if the global report_not_changed is True will print the filename\n    if the file dont begins with the old_license text    \n    '''\n    global target_license, new_license, change_files, report_match, reported\n    f = open(filename, 'rU')\n    text = f.read()\n    f.close()\n    match = text.startswith(target_license)\n    if change_files and match:\n        text = new_license + text[len(target_license):]\n        f = open(filename, 'w')\n        f.write(text)\n        f.close()\n    if report_match == match:\n        reported.append(filename)\n    \n", "docstring": "Open a Python source file and check if exactly begins with the"}
{"repo": "cocos-master/tools/uniform_snippet.py", "original_string": "def get_start_line(iter_enumerated_lines, target):\n    \"\"\"-> line number where the target string matches the start of line\n    Consumes the iterator until a line with a match is found or untilt the\n    iterator is exhausted.\n    \n    Returns the line number where the match was found or None if no match.\n    After the return, a call to the iterator 'next' method would yield\n    the (lineno, line) for the line following the matching line.\n    \n    It discards whitespace in the lines provided by the iterator before\n    comparison.\n    \"\"\"\n    try:\n        while 1:\n            lineno, line = six.next(iter_enumerated_lines)\n            line = line.strip()\n            line = line.replace(' ', '')\n            if line.startswith(target):\n                start_line = lineno\n                break\n    except StopIteration:\n        # target not present\n        start_line = None\n    return start_line\n", "docstring": "-> line number where the target string matches the start of line"}
{"repo": "cocos-master/tools/primitives.py", "original_string": "    def intersects(self, x,y):\n        if x==self.x and y==self.y : return True\n", "docstring": "if x==self.x and y==self.y : return True"}
{"repo": "cocos-master/tools/primitives.py", "original_string": "    def render(self):\n        \"\"\" Draw Circle\n            x, y, z, width in pixel, rotation, color and line width in px\n            style choices are : GLU_LINE, GLU_FILL, GLU_SILHOUETTE, GLU_POINT\n            TO DO : textured circles\n        \"\"\"\n        \n        glColor4f(*self.color)\n        glPushMatrix()\n        glTranslatef(self.x, self.y, -self.z)\n        glRotatef(self.rotation, 0, 0, 0.1)\n        if self.radius < 1 : self.radius = 1\n        if self.stroke :\n            inner = self.radius - self.stroke # outline width\n            if inner < 0: inner=0\n        else :\n             inner = 0 # filled\n        \n        gluQuadricDrawStyle(self.q, self.style)\n        gluDisk(self.q, inner, self.radius, self.circleresolution, 1) # gluDisk(quad, inner, outer, slices, loops)\n            \n        glPopMatrix()\n", "docstring": "Draw Circle"}
{"repo": "cocos-master/tools/primitives.py", "original_string": "    def __init__(self, v, z=0, color=(0,0,0,1), stroke=0, rotation=0.0, style=0):\n        \"\"\" polygon class\n            Polygon(vertexarray=[(0, 0), (29, 100), (30, 200)], z=100, color=(0,0.3,0.1,1), stroke=0, rotation=23)\n            overwrites few methods from superclass as polygons are more complex, needs to update everyvertex.\n        \"\"\"\n        self.v = v\n        l, t, r, b = calcPolygonRect(v) # get the bounding rect\n        self.rect = Rect(l+(r-l)*0.5, t+(b-t)*0.5, r-l, b-t)\n        self.v2 = [(i[0] - self.rect.x, i[1] - self.rect.y) for i in v] #relative polygon\n        self.style = style\n        \n        Base.__init__(self, self.rect.x, self.rect.y, z,color,stroke,rotation)\n", "docstring": "polygon class"}
{"repo": "cocos-master/tools/primitives.py", "original_string": "    def render(self):\n        \"\"\" Draw Polygon\n            v is an array with tuple points like [(x, y), (x2, y2), (x3, y3)]\n            min vertex number to draw a polygon is 3\n            stroke=0 to fil with color the inside of the shape or stroke=N just to draw N-px thick outline.\n            Note. It doesnt work with non convex polygons, need to implement tesselation yet\n        \"\"\"\n        l,t,r,b = calcPolygonRect(self.v)\n        x,y = calcRectCenter(l,t,r,b)\n        self.drawVertex(x, y, self.z, [(i[0] - x, i[1] - y) for i in self.v], self.color, self.stroke, self.rotation, self.style)\n", "docstring": "Draw Polygon"}
{"repo": "cocos-master/tools/primitives.py", "original_string": "    def __init__(self, x,y, a=(0,0), b=(0,0), z=0, color=(0,0,0,1), stroke=0, rotation=0.0, style=0):\n        \"\"\" Draws a basic line given the begining and end point (tuples), color (tuple) and stroke\n            (thickness of line)\n            Line( x,y, a=(1,1), b=(100,100), z=0, color=(0.2,0,0,1), stroke=10, rotation=45)\n        \"\"\"\n        w = (b[0] - a[0]) \n        h = (b[1] - a[1]) \n        x = abs(a[0] + w*0.5)\n        y = abs(a[1] + h*0.5)\n        self.a2 = abs(a[0]) - x, abs(a[1]) - y\n        self.b2 = abs(b[0]) - x, abs(b[1]) - y\n        self.a = x - w*0.5, y - w*0.5\n        self.b = x + w*0.5, y + w*0.5\n        self.rect = Rect(x, y, w, h)\n        self.style = style\n        Base.__init__(self, x, y, z,color,stroke,rotation)\n", "docstring": "Draws a basic line given the begining and end point (tuples), color (tuple) and stroke"}
{"repo": "cocos-master/tools/primitives.py", "original_string": "    def __init__(self, a=(0,0), b=(0,0), z=0, color=(0,0,0,1), stroke=0, rotation=0.0, style=0):\n        \"\"\" Draws a basic line given the begining and end point (tuples), color (tuple) and stroke\n            (thickness of line)\n            Line( a=(1,1), b=(100,100), z=20, color=(0.2,0,0,1), stroke=10, rotation=45)\n        \"\"\"\n        w = (b[0] - a[0]) \n        h = (b[1] - a[1]) \n        x = abs(a[0] + w*0.5) # abs x,y\n        y = abs(a[1] + h*0.5)\n        a = x-w*0.5, y-h*0.5 # relative a,b\n        b = x+w*0.5, y+h*0.5\n        LineRel.__init__(self, x, y, a, b, z, color, stroke, rotation, style)\n        \n", "docstring": "Draws a basic line given the begining and end point (tuples), color (tuple) and stroke"}
{"repo": "cocos-master/tools/primitives.py", "original_string": "    def __init__(self, x=0,y=0,w=0,h=0):\n        \"\"\" rect(self, x=0,y=0,w=0,h=0)\n            x,y,loc, width, height\n            left,top,right,bottom\n            quad ->\n            --------------------\n            topleft = quad[0]\n            topright = quad[1]\n            bottomright = quad[2]\n            bottomleft = quad[3]\n        \"\"\"\n        self.rect = x,y,w,h\n", "docstring": "rect(self, x=0,y=0,w=0,h=0)"}
{"repo": "cocos-master/tools/primitives.py", "original_string": "def calcPolygonRect(pointArray):\n    \"\"\" receives a point list and returns the rect that contains them as a tupple -> tuple left, top, right, bottom\n    \"\"\"\n    # init to ridiculously big values. not very elegant or eficient\n    l, t, r, b = 10000000, 10000000, -10000000, -10000000\n", "docstring": "receives a point list and returns the rect that contains them as a tupple -> tuple left, top, right, bottom"}
{"repo": "cocos-master/tools/primitives.py", "original_string": "def calcRectCenter(l,t,r,b):#,v=()):\n    \"\"\" returns rect center point -> x,y\n        calcRectCenter(l,t,r,b)\n    \"\"\"\n", "docstring": "returns rect center point -> x,y"}
{"repo": "cocos-master/utest/test_p_ba_Spawn_IntervalAction.py", "original_string": "    def test_update_crossing_min_not_max_at_1st_step(self, duration1, duration2):\n        # min< next_elapsed < max\n        global rec\n        # expect start, [xxx,]update(1), stop for shortest action\n        # only applies if min<max\n        need_test = (duration1 < duration2)\n        if not need_test:\n            return\n        \n        node = CocosNode()\n        name1 = '1'\n        name2 = '2'\n        a1 = UIntervalAction(name1, duration1)\n        a2 = UIntervalAction(name2, duration2)\n        composite = ac.spawn(a1, a2)\n        rec = []\n        node.do(composite)\n        elapsed = 0.0\n        # between duration1 and duration2\n        next_elapsed = (duration1 + duration2)/2.0\n        dt = next_elapsed - elapsed\n        node._step(dt)\n        \n        print('rec:', rec)\n        rec = [ e for e in rec if e[1]!='step' ]\n        if duration1 < duration2:\n            oname1 = name1\n            oduration1 = duration1\n            oname2 = name2\n            oduration2 = duration2\n        else:\n            oname1 = name2\n            oduration1 = duration2\n            oname2 = name1\n            oduration2 = duration1\n        orec1 = [ e for e in rec if e[0]==oname1 ]\n        print(orec1)\n        assert orec1[0]==(oname1, 'start')\n        assert orec1[1]==(oname1, 'update', 1.0)\n        assert orec1[2]==(oname1, 'stop')\n        assert len(orec1)==3\n        \n        orec2 = [ e for e in rec if e[0]==oname2 ]\n        print(orec2)\n        assert len(orec2)==2\n        assert orec2[0]==(oname2, 'start')\n        assert orec2[1][1]=='update'\n        assert abs(orec2[1][2] - next_elapsed/oduration2)<fe\n", "docstring": "min< next_elapsed < max"}
{"repo": "cocos-master/utest/test_p_ba_Spawn_IntervalAction.py", "original_string": "    def test_update_crossing_max_at_1st_step(self, duration1, duration2):\n        # next_elapsed > max(duration1, duration2)\n        global rec\n        node = CocosNode()\n        name1 = '1'\n        name2 = '2'\n        a1 = UIntervalAction(name1, duration1)\n        a2 = UIntervalAction(name2, duration2)\n        composite = ac.spawn(a1, a2)\n        rec = []\n        node.do(composite)\n        elapsed = 0.0\n        next_elapsed = max(duration1, duration2)*1.1 # above max\n        dt = next_elapsed - elapsed\n        node._step(dt)\n        recx = [ e for e in rec if e[1]!='step' ]\n        rec = [ e for e in recx if e[0]==name1]\n        print('rec', rec)\n        assert rec[0][1]=='start'\n        assert rec[1][1]=='update' and rec[1][2]==1.0\n        assert rec[2][1]=='stop'\n        assert len(rec)==3\n        rec = [ e for e in recx if e[0]==name2]\n        print ('rec:', rec)\n        assert rec[0][1]=='start'\n        assert rec[1][1]=='update' and rec[1][2]==1.0\n        assert rec[2][1]=='stop'\n        assert len(rec)==3\n", "docstring": "next_elapsed > max(duration1, duration2)"}
{"repo": "cocos-master/utest/test_p_ba_Spawn_IntervalAction.py", "original_string": "    def test_update_crossing_max_from_above_min(self, duration1, duration2):\n        # min < elapsed < max < next_elapsed\n        global rec\n        \n        need_test = (duration1!=duration2)\n        if not need_test:\n            return\n        node = CocosNode()\n        name1 = '1'\n        name2 = '2'\n        a1 = UIntervalAction(name1, duration1)\n        a2 = UIntervalAction(name2, duration2)\n        composite = ac.spawn(a1, a2)\n        node.do(composite)\n        elapsed = 0.0\n        next_elapsed = (duration1 + duration2)/2.0 # above min, below max\n        dt = next_elapsed - elapsed\n        node._step(dt)\n        elapsed = next_elapsed\n        next_elapsed = max(duration1, duration2)*1.1 # above max\n        dt = next_elapsed - elapsed\n        rec = []\n        node._step(dt)\n        # expected: no call from action with min duration, two calls from the\n        # action with max duration: .update(1) and .stop() in that order\n        if duration1 < duration2:\n            oname1 = name1\n            oname2 = name2\n        else:\n            oname1 = name2\n            oname2 = name1\n        rec_lo = [ e for e in rec if e[0]==oname1]\n        print('rec_lo:', rec_lo)\n        assert len(rec_lo)==0\n        rec = [ e for e in rec if e[0]==oname2]\n        rec = [ e for e in rec if e[1]!='step' ]\n        print('rec hi:', rec)\n        assert rec[0][1]=='update' and rec[0][2]==1.0\n        assert rec[1][1]=='stop'\n        assert len(rec)==2\n", "docstring": "min < elapsed < max < next_elapsed"}
{"repo": "cocos-master/utest/_parametric_test_t_demo.py", "original_string": "    def test3_demo(self, duration1, duration2):\n        # can we skip test on certain params conditions ?\n        if duration1>4.0:\n            return\n        assert duration1>=0.0\n        # yes, the test listed as PASS in the case with duration1 == 5.0\n", "docstring": "can we skip test on certain params conditions ?"}
{"repo": "cocos-master/utest/test_p_ba_cocosnode_actions.py", "original_string": "    def test_do_inmediate_effects2(self):\n        # do called with an explicit target\n        global rec, next_done\n        next_done = 0\n        node = CocosNode()\n        name1 = '1'\n        action = UAction(name1)\n        my_target = 'zptx'\n        rec = []\n        a_copy = node.do(action, target=my_target)\n        assert a_copy.target == my_target\n        assert a_copy in node.actions\n        assert len(node.actions)==1\n        assert rec[0]==(name1, 'start')\n        assert len(rec)==1\n", "docstring": "do called with an explicit target"}
{"repo": "cocos-master/utest/test_p_ba_Sequence_IntervalAction.py", "original_string": "    def test_test_receiving_stop_async_before_duration1(self, duration1, duration2):\n        #0<duration1\n        global rec\n        if duration1==0.0:\n            return\n        \n        node = CocosNode()\n        name1 = '1'\n        name2 = '2'\n        a1 = UIntervalAction(name1, duration1)\n        a2 = UIntervalAction(name2, duration2)\n        elapsed = 0.0\n        rec = []\n        composite = ac.sequence(a1, a2)\n        a_copy = node.do(composite)\n        rec = []\n        a_copy.stop()\n        assert rec[0]==(name1, 'stop')\n        assert len(rec)==1\n", "docstring": "0<duration1"}
{"repo": "cocos-master/utest/aux_RectMapCollider__no_stuck.py", "original_string": "def calc_base_rect_and_expect_dxdy(dx, dy, cell_start, delta_start, sizes):\n    # sanity \n    assert (abs(delta_start[0]), abs(delta_start[1])) in ((0, 1), (1, 0))\n    assert dx != 0 and dy != 0\n    # calc in which corner want to align cell_start_rect and player_rect\n    if delta_start[0] == 0:\n        # moving vertical\n        first = 'top' if delta_start[1] == 1 else 'bottom'\n        second = 'left' if dx < 0 else 'right'\n        expect_dxdy = (0, dy)\n    else:\n        # moving horizontal\n        second = 'left' if delta_start[0] == -1 else 'right' \n        first = 'top' if dy > 0 else 'bottom'\n        expect_dxdy = (dx, 0)\n    # build base_rect_start\n    cell_width, cell_height, actor_width, actor_height = sizes\n    cell_start_rect = Rect(cell_start[0]*cell_width, cell_start[1]*cell_height,\n                           cell_width, cell_height)\n    base_rect_start = Rect(0, 0, actor_width, actor_height)\n    align_corner(base_rect_start, cell_start_rect, first + second)\n    return base_rect_start, expect_dxdy\n", "docstring": "sanity"}
{"repo": "cocos-master/utest/test_collision_model_details.py", "original_string": "def test_ops_near_boundaries():\n    # applies only to CollisionManagerGrid, boundaries are the grid boundaries\n    w_width = 200.0\n    w_height = 100.0\n    cell_side = 20.00\n    collman = cm.CollisionManagerGrid(0.0, w_width, 0.0, w_height, cell_side,\n                                      cell_side)\n    # adding object near boundaries should not fail\n    radius = 5.0\n    \n    lo_lo = create_obj_with_circle('lo-lo',\n                        eu.Vector2(radius+fe, radius+fe), radius)\n    collman.add(lo_lo) #must not fail\n    assert collman.knows(lo_lo)\n    lo_hi = create_obj_with_circle('lo-hi',\n                        eu.Vector2(radius+fe, w_height - (radius+fe)), radius)\n    collman.add(lo_hi) #must not fail\n    assert collman.knows(lo_hi)\n    \n    hi_lo = create_obj_with_circle('hi-lo',\n                        eu.Vector2(w_width - (radius+fe), radius+fe), radius)\n    collman.add(hi_lo) #must not fail\n    assert collman.knows(hi_lo)\n    \n    hi_hi = create_obj_with_circle('hi-hi',\n                        eu.Vector2(w_width - (radius+fe), w_height - (radius+fe)),\n                        radius)\n    collman.add(hi_hi) #must not fail\n    assert collman.knows(hi_hi)\n    # asking for others near obj should not fail if the near capsule goes out\n    # of world boundaries\n    \n    near_distance = w_width\n    nears = collman.objs_near(lo_lo, near_distance) #must not fail\n    li = collman.objs_near_wdistance(lo_lo, near_distance) #must not fail\n    ranked = collman.ranked_objs_near(lo_lo, near_distance) #must not fail\n    \n    nears = collman.objs_near(lo_hi, near_distance) #must not fail\n    li = collman.objs_near_wdistance(lo_hi, near_distance) #must not fail\n    ranked = collman.ranked_objs_near(lo_hi, near_distance) #must not fail\n    \n    nears = collman.objs_near(hi_lo, near_distance) #must not fail\n    li = collman.objs_near_wdistance(hi_lo, near_distance) #must not fail\n    ranked = collman.ranked_objs_near(hi_lo, near_distance) #must not fail\n    nears = collman.objs_near(hi_hi, near_distance) #must not fail\n    li = collman.objs_near_wdistance(hi_hi, near_distance) #must not fail\n    ranked = collman.ranked_objs_near(hi_hi, near_distance) #must not fail\n    nears = collman.objs_near(lo_lo, w_width + w_height)\n    assert set(nears) == set([lo_hi, hi_lo, hi_hi])\n", "docstring": "applies only to CollisionManagerGrid, boundaries are the grid boundaries"}
{"repo": "cocos-master/utest/test_tiles.py", "original_string": "    def test_rect_neighbor(self):\n        # test rectangular tile map\n        #    +---+---+---+\n        #    | d | e | f |\n        #    +---+---+---+\n        #    | a | b | c |\n        #    +---+---+---+\n        m = gen_rect_map(rmd, 10, 16)\n        t = m.get_cell(0,0)\n        self.assertEqual((t.x, t.y), (0, 0))\n        self.assertEqual(t.properties['meta'], 'a')\n        assert m.get_neighbor(t, m.DOWN) is None\n        self.assertEqual(m.get_neighbor(t, m.UP).properties['meta'], 'd')\n        assert m.get_neighbor(t, m.LEFT) is None\n        self.assertEqual(m.get_neighbor(t, m.RIGHT).properties['meta'], 'b')\n        t = m.get_neighbor(t, m.UP)\n        self.assertEqual((t.i, t.j), (0, 1))\n        self.assertEqual((t.x, t.y), (0, 16))\n        self.assertEqual(t.properties['meta'], 'd')\n        self.assertEqual(m.get_neighbor(t, m.DOWN).properties['meta'], 'a')\n        assert m.get_neighbor(t, m.UP) is None\n        assert m.get_neighbor(t, m.LEFT) is None\n        self.assertEqual(m.get_neighbor(t, m.RIGHT).properties['meta'], 'e')\n        t = m.get_neighbor(t, m.RIGHT)\n        self.assertEqual((t.i, t.j), (1, 1))\n        self.assertEqual((t.x, t.y), (10, 16))\n        self.assertEqual(t.properties['meta'], 'e')\n        self.assertEqual(m.get_neighbor(t, m.DOWN).properties['meta'], 'b')\n        assert m.get_neighbor(t, m.UP) is None\n        self.assertEqual(m.get_neighbor(t, m.RIGHT).properties['meta'], 'f')\n        self.assertEqual(m.get_neighbor(t, m.LEFT).properties['meta'], 'd')\n        t = m.get_neighbor(t, m.RIGHT)\n        self.assertEqual((t.i, t.j), (2, 1))\n        self.assertEqual((t.x, t.y), (20, 16))\n        self.assertEqual(t.properties['meta'], 'f')\n        self.assertEqual(m.get_neighbor(t, m.DOWN).properties['meta'], 'c')\n        assert m.get_neighbor(t, m.UP) is None\n        assert m.get_neighbor(t, m.RIGHT) is None\n        self.assertEqual(m.get_neighbor(t, m.LEFT).properties['meta'], 'e')\n        t = m.get_neighbor(t, m.DOWN)\n        self.assertEqual((t.i, t.j), (2, 0))\n        self.assertEqual((t.x, t.y), (20, 0))\n        self.assertEqual(t.properties['meta'], 'c')\n        assert m.get_neighbor(t, m.DOWN) is None\n        self.assertEqual(m.get_neighbor(t, m.UP).properties['meta'], 'f')\n        assert m.get_neighbor(t, m.RIGHT) is None\n        self.assertEqual(m.get_neighbor(t, m.LEFT).properties['meta'], 'b')\n", "docstring": "test rectangular tile map"}
{"repo": "cocos-master/utest/test_tiles.py", "original_string": "    def test_rect_region(self):\n        # test rectangular tile map\n        #    +---+---+---+\n        #    | d | e | f |\n        #    +---+---+---+\n        #    | a | b | c |\n        #    +---+---+---+\n        m = gen_rect_map(rmd, 64, 64)\n        t = m.get_in_region(0, 0, 63, 63)\n        self.assertEqual(len(t), 1)\n        self.assertEqual(t[0].properties['meta'], 'a')\n        t = m.get_in_region(64, 64, 127, 127)\n        self.assertEqual(len(t), 1)\n        self.assertEqual(t[0].properties['meta'], 'e')\n        t = m.get_in_region(32, 32, 96, 96)\n        self.assertEqual(len(t), 4)\n", "docstring": "test rectangular tile map"}
{"repo": "cocos-master/utest/test_tiles.py", "original_string": "    def test_rect_region_alt__rect_is_a_segment_not_in_cells_boundary(self):\n        # this is emergent behavior , not planed one\n        tile_width = tile_height_h = 2\n        nrows = 7\n        ncols = 6\n        cells = [ [ 'col_%d_row_%d'%(yy, xx) for xx in range(ncols)]\n                                                      for yy in range(nrows)]        \n        m = RectMap(42, tile_width, tile_height_h, cells, origin=(0, 0, 0))\n        x1, y1 = 5, 8\n        x2, y2 = 5, 12\n        overlaps = m.get_in_region(x1, y1, x2, y2)\n        print('rect is a segment not overlapping cells boundary:', overlaps)\n        assert set(overlaps) == set( ['col_2_row_4', 'col_2_row_5'] )\n", "docstring": "this is emergent behavior , not planed one"}
{"repo": "cocos-master/utest/test_tiles.py", "original_string": "    def test_rect_region_alt__rect_is_a_point(self):\n        # this is emergent behavior , not planed one\n        tile_width = tile_height_h = 2\n        nrows = 7\n        ncols = 6\n        cells = [ [ 'col_%d_row_%d'%(yy, xx) for xx in range(ncols)]\n                                                      for yy in range(nrows)]        \n        m = RectMap(42, tile_width, tile_height_h, cells, origin=(0, 0, 0))\n        x1, y1 = 5, 8\n        x2, y2 = 5, 8\n        overlaps = m.get_in_region(x1, y1, x2, y2)\n        print('rect is point:', overlaps)\n        assert set(overlaps) == set( [] )\n", "docstring": "this is emergent behavior , not planed one"}
{"repo": "cocos-master/utest/test_tiles.py", "original_string": "    def test_hex_coords(self):\n        # test hexagonal tile map\n        # tiles = [['a', 'b'], ['c', 'd'], ['e', 'f'], ['g', 'h']]\n        #   /d\\ /h\\\n        # /b\\_/f\\_/\n        # \\_/c\\_/g\\\n        # /a\\_/e\\_/\n        # \\_/ \\_/ \n        m = gen_hex_map(hmd, 32)\n        # test tile sides / corners\n        t00 = m.get_cell(0, 0)\n        self.assertEqual(t00.top, 32)\n        self.assertEqual(t00.bottom, 0)\n        self.assertEqual(t00.left, (0, 16))\n        self.assertEqual(t00.right, (36, 16))\n        self.assertEqual(t00.center, (18, 16))\n        self.assertEqual(t00.topleft, (9, 32))\n        self.assertEqual(t00.topright, (27, 32))\n        self.assertEqual(t00.bottomleft, (9, 0))\n        self.assertEqual(t00.bottomright, (27, 0))\n        self.assertEqual(t00.midtop, (18, 32))\n        self.assertEqual(t00.midbottom, (18, 0))\n        self.assertEqual(t00.midtopleft, (4, 24))\n        self.assertEqual(t00.midtopright, (31, 24))\n        self.assertEqual(t00.midbottomleft, (4, 8))\n        self.assertEqual(t00.midbottomright, (31, 8))\n        t10 = m.get_cell(1, 0)\n        self.assertEqual(t10.top, 48)\n        self.assertEqual(t10.bottom, 16)\n        self.assertEqual(t10.left, t00.topright)\n        self.assertEqual(t10.right, (63, 32))\n        self.assertEqual(t10.center, (45, 32))\n        self.assertEqual(t10.topleft, (36, 48))\n        self.assertEqual(t10.topright, (54, 48))\n        self.assertEqual(t10.bottomleft, t00.right)\n        self.assertEqual(t10.bottomright, (54, 16))\n        self.assertEqual(t10.midtop, (45, 48))\n        self.assertEqual(t10.midbottom, (45, 16))\n        self.assertEqual(t10.midtopleft, (31, 40))\n        self.assertEqual(t10.midtopright, (58, 40))\n        self.assertEqual(t10.midbottomleft, t00.midtopright)\n        self.assertEqual(t10.midbottomright, (58, 24))\n        t = m.get_cell(2, 0)\n        self.assertEqual(t.top, 32)\n        self.assertEqual(t.bottom, 0)\n        self.assertEqual(t.left, t10.bottomright)\n        self.assertEqual(t.right, (90, 16))\n        self.assertEqual(t.center, (72, 16))\n        self.assertEqual(t.topleft, t10.right)\n        self.assertEqual(t.midtopleft, t10.midbottomright)\n", "docstring": "test hexagonal tile map"}
{"repo": "cocos-master/samples/hello_world_actions.py", "original_string": "    def __init__(self):\n        # blueish color\n        super(HelloWorld, self).__init__(64, 64, 224, 255)\n        # a cocos.text.Label is a wrapper of pyglet.text.Label\n        # with the benefit of being a CocosNode\n        label = cocos.text.Label('Hello, World!',\n                                 font_name='Times New Roman',\n                                 font_size=32,\n                                 anchor_x='center', anchor_y='center')\n        # set the label in the center of the screen\n        label.position = 320, 240\n        self.add(label)\n        # similar to cocos.text.Label, a cocos.sprite.Sprite\n        # is a subclass of pyglet.sprite.Sprite with the befits of\n        # being a CocosNode.\n        sprite = cocos.sprite.Sprite('grossini.png')\n        # sprite in the center of the screen (default is 0,0)\n        sprite.position = 320, 240\n        # sprite scale attribute starts with 3 (default 1 )\n        sprite.scale = 3\n        # add the sprite as a child, but with z=1 (default is z=0).\n        # this means that the sprite will be drawn on top of the label\n        self.add(sprite, z=1)\n        # create a ScaleBy action that lasts 2 seconds\n        scale = ScaleBy(3, duration=2)\n        # tell the label to scale and scale back and repeat these 2 actions forever\n        label.do(Repeat(scale + Reverse(scale)))\n        # tell the sprite to scaleback and then scale, and repeat these 2 actions forever\n        sprite.do(Repeat(Reverse(scale) + scale))\n", "docstring": "blueish color"}
{"repo": "cocos-master/samples/jumping_lens.py", "original_string": "    def __init__(self):\n        # always call super()\n        super(BackgroundLayer, self).__init__()\n        # load the image form file\n        self.image = pyglet.resource.image('flag.png')\n", "docstring": "always call super()"}
{"repo": "cocos-master/samples/demo_grid_effects.py", "original_string": "    def __init__(self):\n        # call superclass with the title\n        super(MainMenu, self).__init__(\"GROSSINI'S SISTERS\")\n        pyglet.font.add_directory('.')\n        # you can override the font that will be used for the title and the items\n        self.font_title['font_name'] = 'You Are Loved'\n        self.font_title['font_size'] = 72\n        self.font_item['font_name'] = 'You Are Loved'\n        self.font_item_selected['font_name'] = 'You Are Loved'\n        # you can also override the font size and the colors. see menu.py for\n        # more info\n        # example: menus can be vertical aligned and horizontal aligned\n        self.menu_valign = CENTER\n        self.menu_halign = CENTER\n        items = []\n        items.append(MenuItem('New Game', self.on_new_game))\n        items.append(MenuItem('Options', self.on_options))\n        items.append(MenuItem('Scores', self.on_scores))\n        items.append(MenuItem('Quit', self.on_quit))\n        self.create_menu(items, zoom_in(), zoom_out())\n", "docstring": "call superclass with the title"}
{"repo": "cocos-master/samples/mouse_elastic_box_selection.py", "original_string": "    def on_mouse_release(self, sx, sy, button, modifiers):\n        # should we handle here mod_restricted_mov ?\n        wx, wy = screen_to_world(sx, sy)\n        modify_selection = modifiers & self.mod_modify_selection\n        if self.dragging:\n            # ignore all buttons except left button\n            if button != mouse.LEFT:\n                return\n            if self.drag_selecting:\n                self.end_drag_selection(wx, wy, modify_selection)\n            elif self.drag_moving:\n                self.end_drag_move(wx, wy)\n            self.dragging = False\n        else:\n            if button == mouse.LEFT:\n                self.end_click_selection(wx, wy, modify_selection)\n", "docstring": "should we handle here mod_restricted_mov ?"}
{"repo": "cocos-master/samples/mouse_elastic_box_selection.py", "original_string": "    def adjust_elastic_box(self):\n        # when elastic_box visible this method needs to be called any time\n        # world_mouse changes or screen_to_world results changes (scroll, etc)\n        wx0, wy0 = self.wdrag_start_point\n        wx1, wy1 = self.world_mouse\n        wminx = min(wx0, wx1)\n        wmaxx = max(wx0, wx1)\n        wminy = min(wy0, wy1)\n        wmaxy = max(wy0, wy1)\n        self.elastic_box_wminmax = wminx, wmaxx, wminy, wmaxy\n        self.elastic_box.adjust_from_w_minmax(*self.elastic_box_wminmax)\n", "docstring": "when elastic_box visible this method needs to be called any time"}
{"repo": "cocos-master/samples/mouse_elastic_box_selection.py", "original_string": "    def begin_drag_move(self):\n        # begin drag move\n        self.drag_moving = True\n        # how-to update collman: remove/add vs clear/add all\n        # when total number of actors is low anyone will be fine,\n        # with high numbers, most probably we move only a small fraction\n        # For simplicity I choose remove/add, albeit a hybrid approach\n        # can be implemented later\n        self.set_selection_in_collman(False)\n", "docstring": "begin drag move"}
{"repo": "cocos-master/samples/demo_flag3d.py", "original_string": "    def on_cocos_resize(self, width, height):\n        # change to our custom projection\n        glViewport(0, 0, int(0.9*width) , height)\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        gluPerspective(90, 1.0 * width / height, 0.1, 400.0)\n        glMatrixMode(GL_MODELVIEW)\n", "docstring": "change to our custom projection"}
{"repo": "cocos-master/samples/demo_flag3d.py", "original_string": "    def step(self, dt):\n        # move the z vertices with the sin(x+y) function\n        # to simulate a 3D flag effect\n        self.elapsed += dt\n        amplitud = 32\n        for i in range(0, self.grid_size.x + 1):\n            for j in range(0, self.grid_size.y + 1):\n                x, y, z = self.get_vertex(i, j)\n                z = (math.sin(self.elapsed * math.pi * 2 + (y + x) * .01) * amplitud)\n                self.set_vertex(i, j, (x, y, z))\n", "docstring": "move the z vertices with the sin(x+y) function"}
{"repo": "cocos-master/samples/demo_flag3d.py", "original_string": "    def set_vertex(self, x, y, v):\n        '''Set a vertex point is a certain value\n        :Parameters:\n            `x` : int\n               x-vertex\n            `y` : int\n               y-vertex\n            `v` : (int, int, int)\n                tuple value for the vertex\n        '''\n        idx = (x * (self.grid_size.y+1) + y) * 3\n        self.vertex_list.vertices[idx] = v[0]\n        self.vertex_list.vertices[idx+1] = v[1]\n        self.vertex_list.vertices[idx+2] = v[2]\n", "docstring": "Set a vertex point is a certain value"}
{"repo": "cocos-master/samples/handling_events.py", "original_string": "    def on_key_press(self, key, modifiers):\n        \"\"\"This function is called when a key is pressed.\n        \n        'key' is a constant indicating which key was pressed.\n        'modifiers' is a bitwise or of several constants indicating which\n           modifiers are active at the time of the press (ctrl, shift, capslock, etc.)\n        See also on_key_release situations when a key press does not fire an\n         'on_key_press' event.\n        \"\"\"\n        self.keys_pressed.add(key)\n        self.update_text()\n", "docstring": "This function is called when a key is pressed."}
{"repo": "cocos-master/samples/handling_events.py", "original_string": "    def on_mouse_motion(self, x, y, dx, dy):\n        \"\"\"Called when the mouse moves over the app window with no button pressed\n        \n        (x, y) are the physical coordinates of the mouse\n        (dx, dy) is the distance vector covered by the mouse pointer since the\n          last call.\n        \"\"\"\n        self.update_text(x, y)\n", "docstring": "Called when the mouse moves over the app window with no button pressed"}
{"repo": "cocos-master/samples/handling_events.py", "original_string": "    def on_mouse_press(self, x, y, buttons, modifiers):\n        \"\"\"This function is called when any mouse button is pressed\n        (x, y) are the physical coordinates of the mouse\n        'buttons' is a bitwise or of pyglet.window.mouse constants LEFT, MIDDLE, RIGHT\n        'modifiers' is a bitwise or of pyglet.window.key modifier constants\n           (values like 'SHIFT', 'OPTION', 'ALT')\n        \"\"\"\n        self.posx, self.posy = director.get_virtual_coordinates(x, y)\n        self.update_text(x, y)\n", "docstring": "This function is called when any mouse button is pressed"}
{"repo": "cocos-master/samples/tetrico/gameview.py", "original_string": "    def draw( self ):\n        '''draw the map and the block'''\n        glPushMatrix()\n        self.transform()\n        for i in range( COLUMNS ):\n            for j in range( ROWS ):\n                color = self.model.map.get( (i,j) )\n                if color:\n                    Colors.images[color].blit( i * SQUARE_SIZE, j* SQUARE_SIZE)\n        if self.model.block:\n            self.model.block.draw()\n        glPopMatrix()\n", "docstring": "draw the map and the block'''"}
{"repo": "cocos-master/samples/tetrico/gamemodel.py", "original_string": "    def check_line(self):\n        '''checks if the line is complete'''\n        lines = []\n        for j in range( ROWS ):\n            for i in range( COLUMNS ):\n                c = self.map.get( (i,j) )\n                if not c:\n                    break\n                if i == COLUMNS-1:\n                    lines.append(j)\n        lines.reverse()\n        effects = []\n        for j in lines:\n            for i in range(COLUMNS):\n                e = self.map[ (i,j) ]\n                if e in Colors.specials:\n                    effects.append( e )\n        if effects:\n            self.process_effects( effects )\n        for l in lines:\n            for j in range(l, ROWS-1 ):\n                for i in range(COLUMNS):\n                    self.map[ (i,j) ] = self.map[ (i,j+1) ]\n        if lines:\n            status.score += pow(2, len(lines)) -1\n            status.lines += len(lines)\n            self.dispatch_event(\"on_line_complete\", lines )\n            if status.lines >= status.level.lines:\n                self.ctrl().pause_controller()\n                if status.level_idx + 1 >= len( levels.levels):\n                    self.dispatch_event(\"on_win\")\n                else:\n                    self.dispatch_event(\"on_level_complete\")\n", "docstring": "checks if the line is complete'''"}
{"repo": "cocos-master/samples/tetrico/gamemodel.py", "original_string": "    def merge_block( self ):\n        '''merges a block in the map'''\n        for i in range( self.block.x ):\n            for j in range( self.block.x ):\n                c= self.block.get(i,j)\n                if c:\n                    self.map[ (i+self.block.pos.x, j+self.block.pos.y) ] = c\n", "docstring": "merges a block in the map'''"}
{"repo": "cocos-master/samples/tetrico/gamemodel.py", "original_string": "    def block_right( self ):\n        '''moves right the block 1 square'''\n        self.block.backup()\n        self.block.pos.x += 1\n        if not self.is_valid_block():\n            self.block.restore()\n        else:\n            self.dispatch_event(\"on_move_block\")\n", "docstring": "moves right the block 1 square'''"}
{"repo": "cocos-master/samples/tetrico/gamemodel.py", "original_string": "    def block_down( self, sound=True ):\n        '''moves down the block 1 square'''\n        self.block.backup()\n        self.block.pos.y -= 1\n        if not self.is_valid_block():\n            self.block.restore()\n            self.next_block()\n        else:\n            if sound:\n                self.dispatch_event(\"on_move_block\")\n", "docstring": "moves down the block 1 square'''"}
{"repo": "cocos-master/samples/tetrico/gamemodel.py", "original_string": "    def block_rotate( self ):\n        '''rotates the block'''\n        self.block.backup()\n        self.block.rotate()\n        if not self.is_valid_block():\n            self.block.restore()\n        else:\n            self.dispatch_event(\"on_move_block\")\n", "docstring": "rotates the block'''"}
{"repo": "cocos-master/samples/tetrico/gamemodel.py", "original_string": "    def random_block( self ):\n        '''puts the next block in stage'''\n        self.block = status.next_piece\n        block = random.choice( (\n            Block_L,\n            Block_L2,\n            Block_O,\n            Block_I,\n            Block_Z,\n            Block_Z2,\n            Block_A\n            ) )\n        status.next_piece = block()\n        if not self.block:\n            self.random_block()\n", "docstring": "puts the next block in stage'''"}
{"repo": "cocos-master/samples/tetrico/gamemodel.py", "original_string": "    def rotate( self ):\n        '''rotate the block'''\n        self.rot = (self.rot + 1) % self.mod\n", "docstring": "rotate the block'''"}
{"repo": "cocos-master/samples/tetrico/gamemodel.py", "original_string": "    def restore( self ):\n        '''restore a copy of the block'''\n        self.pos = self.save_pos\n        self.rot = self.save_rot\n", "docstring": "restore a copy of the block'''"}
{"repo": "cocos-master/samples/tetrico/status.py", "original_string": "    def __init__( self ):\n        # current score\n        self.score = 0\n        # next piece\n        self.next_piece = None\n        # current level\n        self.level = None\n        # current level idx\n        self.level_idx = None\n        # level lines completed\n        self.lines = 0\n        # total lines completed\n        self.tot_lines = 0\n", "docstring": "current score"}
{"repo": "cocos-master/samples/tetrico/gamectrl.py", "original_string": "    def resume_controller( self ):\n        '''schedules  the timer and handles the keys'''\n        self.paused = False\n        self.schedule( self.step )\n", "docstring": "schedules  the timer and handles the keys'''"}
{"repo": "cocos-master/samples/balldrive_toy_game/balldrive_toy_game.py", "original_string": "def world_to_view(v):\n    \"\"\"world coords to view coords; v an eu.Vector2, returns (float, float)\"\"\"\n    return v.x * scale_x, v.y * scale_y\n", "docstring": "world coords to view coords; v an eu.Vector2, returns (float, float)\n"}
{"repo": "cocos-master/samples/balldrive_toy_game/balldrive_toy_game.py", "original_string": "    def generate_random_level(self):\n        # hardcoded params:\n        food_num = 5\n        food_scale = 1.0  # relative to player\n        wall_num = 10\n        gate_scale = 1.5  # relative to player\n        min_separation_rel = 3.0  # as fraction of player diameter\n        # build !\n        width = self.width\n        height = self.height\n        rPlayer = self.rPlayer\n        min_separation = min_separation_rel * rPlayer\n        wall_scale_min = self.wall_scale_min\n        wall_scale_max = self.wall_scale_max\n        pics = self.pics\n        z = 0\n        # add player\n        cx, cy = (0.5 * width, 0.5 * height)\n        self.player = Actor(cx, cy, rPlayer, 'player', pics['player'])\n        self.collman.add(self.player)\n        minSeparation = min_separation * 2. * rPlayer\n        # add gate\n        rGate = gate_scale * rPlayer\n        self.gate = Actor(cx, cy, rGate, 'gate', pics['wall'])\n        self.gate.color = Actor.palette['wall']\n        cntTrys = 0\n        while cntTrys < 100:\n            cx = rGate + random.random() * (width - 2.0 * rGate)\n            cy = rGate + random.random() * (height - 2.0 * rGate)\n            self.gate.update_center(eu.Vector2(cx, cy))\n            if not self.collman.they_collide(self.player, self.gate):\n                break\n            cntTrys += 1\n        self.add(self.gate, z=z)\n        z += 1\n        self.collman.add(self.gate)\n        # add food\n        rFood = food_scale * rPlayer\n        self.cnt_food = 0\n        for i in range(food_num):\n            food = Actor(cx, cy, rFood, 'food', pics['food'])\n            cntTrys = 0\n            while cntTrys < 100:\n                cx = rFood + random.random() * (width - 2.0 * rFood)\n                cy = rFood + random.random() * (height - 2.0 * rFood)\n                food.update_center(eu.Vector2(cx, cy))\n                if self.collman.any_near(food, min_separation) is None:\n                    self.cnt_food += 1\n                    self.add(food, z=z)\n                    z += 1\n                    self.collman.add(food)\n                    break\n                cntTrys += 1\n        # add walls\n        for i in range(wall_num):\n            s = random.random()\n            r = rPlayer * (wall_scale_min * s + wall_scale_max * (1.0 - s))  # lerp\n            wall = Actor(cx, cy, r, 'wall', pics['wall'])\n            cntTrys = 0\n            while cntTrys < 100:\n                cx = r + random.random() * (width - 2.0 * r)\n                cy = r + random.random() * (height - 2.0 * r)\n                wall.update_center(eu.Vector2(cx, cy))\n                if self.collman.any_near(wall, min_separation) is None:\n                    self.add(wall, z=z)\n                    z += 1\n                    self.collman.add(wall)\n                    break\n                cntTrys += 1\n        self.add(self.player, z=z)\n        z += 1\n", "docstring": "hardcoded params:"}
{"repo": "cocos-master/test/test_bezier_direct.py", "original_string": "def direct_bezier(p0, p1, p2, p3):\n    '''Given four points, returns a bezier path that go through them.\n    It starts in p0, finish in p3, and pass through p1 and p2 in t=0.4 and\n    t=0.6 respectively.\n    '''\n    def _one_dim(p0xy, B1xy, B2xy, p3xy):\n        '''Calculates the p1 and p2 to draw through B1 and B2 given p0 and p3.\n        p0: P sub 0 of bezier, it's also B(0)\n        B1: B(0.4)\n        B2: B(0.6)\n        p3: P sub 3 of bezier, it's also B(1)\n        '''\n        p2xy = (1.5 * B2xy - B1xy + 0.12 * p0xy - 0.26 * p3xy) / 0.36\n        p1xy = (B2xy - 0.064 * p0xy - 0.432 * p2xy - 0.216 * p3xy) / 0.288\n        return p1xy, p2xy\n    bp1x, bp2x = _one_dim(p0[0], p1[0], p2[0], p3[0])\n    bp1y, bp2y = _one_dim(p0[1], p1[1], p2[1], p3[1])\n    bp1 = bp1x, bp1y\n    bp2 = bp2x, bp2y\n    bezier_path = path.Bezier(p0, p3, bp1, bp2)\n    return bezier_path\n", "docstring": "Given four points, returns a bezier path that go through them."}
{"repo": "cocos-master/test/test_scrolling_manager_without_tiles_autoscale.py", "original_string": "    def on_mouse_press(self,x,y,button,modifiers):\n        # test from screen coords\n        print('on_mouse_press:')\n        vx, vy = self.scroller.screen_to_world(x,y)\n        print('\\tscreen_to_world(x, y):', vx, vy)\n", "docstring": "test from screen coords"}
{"repo": "cocos-master/test/test_tmx.py", "original_string": "    def step(self, dt):\n        # handle input and move the car\n        self.target.rotation += (keyboard[key.RIGHT] - keyboard[key.LEFT]) * 150 * dt\n        self.target.acceleration = (keyboard[key.UP] - keyboard[key.DOWN]) * 400\n        if keyboard[key.SPACE]: self.target.speed = 0\n        super(DriveCar, self).step(dt)\n        scroller.set_focus(self.target.x, self.target.y)\n", "docstring": "handle input and move the car"}
{"repo": "cocos-master/test/test_custom_on_resize.py", "original_string": "    def on_exit(self):\n        # if a handler is explicitly attaching at on_enter, it should detach\n        # at on_exit, else two bad things happens:\n        #   The event dispatcher will continue calling the listener even if the\n        # node is not in the active scene\n        #   The event dispatcher retains a reference to the registered function,\n        # thus preventing garbage collection\n        director.remove_handlers(self.on_cocos_resize)\n        super(AutocenteredBackgroundLayer,self).on_exit()\n        # we want auto center to hold even when added to an active scene, or\n        # when the scene containing the layer is director.pushed and then popped,\n        # so we do here a direct call to on_cocos_resize\n        self.on_cocos_resize(director._usable_width, director._usable_height)\n", "docstring": "if a handler is explicitly attaching at on_enter, it should detach"}
{"repo": "cocos-master/test/test_custom_on_resize.py", "original_string": "    def on_cocos_resize(self, usable_width, usable_height):\n        # assumes  scene.scale==1.0\n        x = (usable_width - self.img.width * self.scale) // 2\n        y = (usable_height - self.img.height * self.scale) // 2\n        self.position = (x, y)\n", "docstring": "assumes  scene.scale==1.0"}
{"repo": "cocos-master/test/test_tmx_hexmap.py", "original_string": "    def step(self, dt):\n        # handle input and move the car\n        self.target.rotation += (keyboard[key.RIGHT] - keyboard[key.LEFT]) * 150 * dt\n        self.target.acceleration = (keyboard[key.UP] - keyboard[key.DOWN]) * 400\n        if keyboard[key.SPACE]: self.target.speed = 0\n        super(DriveCar, self).step(dt)\n        scroller.set_focus(self.target.x, self.target.y)\n", "docstring": "handle input and move the car"}
{"repo": "cocos-master/test/test_action_non_interval.py", "original_string": "    def init(self, fastness):\n        #self.chasee = chasee\n        self.fastness = fastness\n", "docstring": "self.chasee = chasee"}
{"repo": "cocos-master/test/test_multiplex_layer.py", "original_string": "    def __init__( self ):\n        # call superclass with the title\n        super( MainMenu, self ).__init__(\"MultiplexLayer\")\n        l = []\n        l.append( MenuItem('Options', self.on_new_game ) )\n        l.append( MenuItem('Quit', self.on_quit ) )\n        self.create_menu( l )\n        if autotest:\n            self.do( Delay(1) + CallFunc(self.on_new_game))\n", "docstring": "call superclass with the title"}
{"repo": "cocos-master/test/test_all_collisions.py", "original_string": "    def __init__(self, *args, **kwargs):\n        \"\"\"same params as Sprite plus kwargs\n                'rx', 'ry' for collision cshape\n                'desired_width' \"\"\"\n        rx = kwargs.pop('rx', None)\n        ry = kwargs.pop('ry', None)\n        desired_width = kwargs.pop('desired_width', None)\n        super(Actor, self).__init__(*args, **kwargs)\n        if desired_width is None:\n            desired_width = self.image.width\n        desired_width = float(desired_width)\n        self.scale =  desired_width / self.width\n        if rx is None:\n            rx = 0.8 * desired_width / 2.0\n        if ry is None:\n            ry = 0.8 * self.image.height / self.image.width * desired_width / 2.0\n        #self.cshape = cm.AARectShape(eu.Vector2(0.0, 0.0), rx, ry)\n        self.cshape = cm.CircleShape(eu.Vector2(0.0, 0.0), rx)#, ry)\n", "docstring": "same params as Sprite plus kwargs"}
{"repo": "cocos-master/test/test_all_collisions.py", "original_string": "    def generate_travel(self):\n        #ix,iy : ints, street crossing; 0,0 is bottom left (out of view)\n        #ix, iy maps to x,y = ix*crossing_point_separation + iy*crossing_point_separation\n        # iz refers to the starting crossing, jz to the final crossing\n        # generate starting crossing\n        if random.random()>0.5:\n            # start from left - right side\n            ix = 0\n            if random.random()>0.5:\n                ix = streets_per_side - 1\n            iy = random.randint(1, streets_per_side - 2)\n        else:\n            # start from bottom - top side\n            iy = 0\n            if random.random()>0.5:\n                iy = streets_per_side - 1\n            ix = random.randint(1, streets_per_side-2);\n        # generate final crossing by simetry of initial\n        jx = streets_per_side - 1 - ix; jy = streets_per_side - 1 - iy\n        initial_crossing = (ix, iy)\n        final_crossing = (jx, jy)\n        return initial_crossing, final_crossing\n", "docstring": "ix,iy : ints, street crossing; 0,0 is bottom left (out of view)"}
{"repo": "cocos-master/test/test_scrolling_manager_without_tiles.py", "original_string": "    def on_mouse_press(self,x,y,button,modifiers):\n        # test from screen coords\n        print('on_mouse_press:')\n        vx, vy = self.scroller.screen_to_world(x,y)\n        print('\\tscreen_to_world(x, y):', vx, vy)\n", "docstring": "test from screen coords"}
{"repo": "cocos-master/test/test_tiles.py", "original_string": "    def step(self, dt):\n        # handle input and move the car\n        self.target.rotation += (keyboard[key.RIGHT] - keyboard[key.LEFT]) * 150 * dt\n        self.target.acceleration = (keyboard[key.UP] - keyboard[key.DOWN]) * 400\n        if keyboard[key.SPACE]: self.target.speed = 0\n        super(DriveCar, self).step(dt)\n        scroller.set_focus(self.target.x, self.target.y)\n", "docstring": "handle input and move the car"}
{"repo": "cocos-master/cocos/framegrabber.py", "original_string": "def TextureGrabber():\n    \"\"\"Returns an instance of the best texture grabbing class\"\"\"\n    # Why this isn't done on module import? Because we need an initialized\n    # GL Context to query availability of extensions\n    global _best_grabber\n    if _best_grabber is not None:\n        return _best_grabber()\n    # Preferred method: framebuffer object\n    try:\n        # TEST XXX\n        # _best_grabber = GenericGrabber\n        _best_grabber = FBOGrabber\n        return _best_grabber()\n    except:\n        import traceback\n        traceback.print_exc()\n    # Fallback: GL generic grabber\n    raise Exception(\"ERROR: GPU doesn't support Frame Buffers Objects. Can't continue\")\n", "docstring": "Returns an instance of the best texture grabbing class\n"}
{"repo": "cocos-master/cocos/framegrabber.py", "original_string": "    def __init__(self):\n        \"\"\"Create a texture grabber.\"\"\"\n", "docstring": "Create a texture grabber.\n"}
{"repo": "cocos-master/cocos/framegrabber.py", "original_string": "    def before_render(self, texture):\n        \"\"\"Setup call before rendering begins.\"\"\"\n", "docstring": "Setup call before rendering begins.\n"}
{"repo": "cocos-master/cocos/framegrabber.py", "original_string": "    def __init__(self):\n        # This code is on init to make creation fail if FBOs are not available\n        self.fbuf = FramebufferObject()\n        self.fbuf.check_status()\n", "docstring": "This code is on init to make creation fail if FBOs are not available"}
{"repo": "cocos-master/cocos/fps.py", "original_string": "    def init(self):\n        \"\"\"Called once before any other method; performs initialization.\n        The window and the associated OpenGL context is guaranteed to exist\n        at the time of calling.\n        Usually used to create the Label to display fps stats.\n        \"\"\"\n        pass\n", "docstring": "Called once before any other method; performs initialization."}
{"repo": "cocos-master/cocos/fps.py", "original_string": "    def tick(self):\n        \"\"\"Called each time the active scene has been draw; updates the stats\n        If there is a view its data can be eventually updated.\n        \"\"\"\n        pass\n", "docstring": "Called each time the active scene has been draw; updates the stats"}
{"repo": "cocos-master/cocos/fps.py", "original_string": "    def draw(self):\n        \"\"\"Opportunity to draw stats on top of the active scene, called after tick.\n        Normally it draws itself in the window, but can be implemented with a\n        'pass' if the object is designed to gather stats and not display them.\n        \"\"\"\n        pass\n", "docstring": "Opportunity to draw stats on top of the active scene, called after tick."}
{"repo": "cocos-master/cocos/fps.py", "original_string": "    def terminate(self):\n        \"\"\"last call to this object, opportunity to cleanup / store data.\"\"\"\n        pass\n", "docstring": "last call to this object, opportunity to cleanup / store data.\n"}
{"repo": "cocos-master/cocos/fps.py", "original_string": "    def tick(self):\n        \"\"\"Called after the active scene was drawn. Updates stats.\"\"\"\n        t = self.fn_time()\n        dt = t - self.prev_time\n        self.prev_time = t\n        self.cnt_frames += 1\n        if self.max_dt < dt:\n            self.max_dt = dt\n        if t > self.next_refresh_time:\n            self.fps = int(self.cnt_frames / (t - self.start_refresh_time))\n            self.min_fps = int(1.0 / self.max_dt)\n            self.complete_refresh(t)\n            self.label.update_info(self.fps, self.min_fps)\n", "docstring": "Called after the active scene was drawn. Updates stats.\n"}
{"repo": "cocos-master/cocos/fps.py", "original_string": "    def draw(self):\n        \"\"\"Draws the fps view.\"\"\"\n        self.label.draw()\n", "docstring": "Draws the fps view.\n"}
{"repo": "cocos-master/cocos/fps.py", "original_string": "    def tick(self):\n        \"\"\"Called after the active scene was drawn. Updates stats\"\"\"\n        t = self.fn_time()\n        if t > self.next_refresh_time:\n            self.fps = int(self.cnt_frames / (t - self.start_refresh_time))\n            self.complete_refresh(t)\n            self.label.update_info(self.fps)\n        else:\n            self.cnt_frames += 1\n", "docstring": "Called after the active scene was drawn. Updates stats\n"}
{"repo": "cocos-master/cocos/fps.py", "original_string": "    def draw(self):\n        \"\"\"Draws the fps view\"\"\"\n        self.label.draw()\n", "docstring": "Draws the fps view\n"}
{"repo": "cocos-master/cocos/fps.py", "original_string": "    def __init__(self, template, font_name=None, font_size= 36, color=(128, 128, 128, 128)):\n        # changes for compatibility with pyglet 1.4 forced an incompatible API change in this call,\n        # so try to detect and give a clean diagnostic\n        if (font_name is not None and not isinstance(font_name, six.string_types)\n            or not isinstance(font_size, int)\n            or not isinstance(color, tuple)\n            or not isinstance(color[0], int)\n            ):\n            # incompatible old style\n            raise TypeError(\"Bad type(s) in call to cocos.fps.InfoLabel, correct caller code or use cocos version <= 0.6.5 and pyglet version <= 1.3.2 \")\n        self.template = template\n        self.label = pyglet.text.Label(\"\", font_name=font_name,font_size=font_size, color=color, x=10, y=10)\n", "docstring": "changes for compatibility with pyglet 1.4 forced an incompatible API change in this call,"}
{"repo": "cocos-master/cocos/gl_framebuffer_object.py", "original_string": "    def __init__(self):\n        \"\"\"Create a new framebuffer object\"\"\"\n        id = gl.GLuint(0)\n        gl.glGenFramebuffersEXT(1, ct.byref(id))\n        self._id = id.value\n", "docstring": "Create a new framebuffer object\n"}
{"repo": "cocos-master/cocos/gl_framebuffer_object.py", "original_string": "    def unbind(self):\n        \"\"\"Set default framebuffer as current rendering target\"\"\"\n        gl.glBindFramebufferEXT(gl.GL_FRAMEBUFFER_EXT, 0)\n", "docstring": "Set default framebuffer as current rendering target\n"}
{"repo": "cocos-master/cocos/gl_framebuffer_object.py", "original_string": "    def check_status(self):\n        \"\"\"Check that currently set framebuffer is ready for rendering\"\"\"\n        status = gl.glCheckFramebufferStatusEXT(gl.GL_FRAMEBUFFER_EXT)\n        if status != gl.GL_FRAMEBUFFER_COMPLETE_EXT:\n            raise Exception(\"Frambuffer not complete: %d\" % status)\n", "docstring": "Check that currently set framebuffer is ready for rendering\n"}
{"repo": "cocos-master/cocos/scene.py", "original_string": "    def on_exit(self):\n        \"\"\"Called every time the :class:`Scene` exits the stage.\"\"\"\n        super(Scene, self).on_exit()\n        # _apply_music after super, because is_running must be already False\n        if self.music_playing:\n            cocos.audio.music.control.stop()\n", "docstring": "Called every time the :class:`Scene` exits the stage.\n"}
{"repo": "cocos-master/cocos/scene.py", "original_string": "    def load_music(self, filename):\n        \"\"\"This prepares a streamed music file to be played in this scene.\n        Music will be stopped after calling this (even if it was playing before).\n        Arguments:\n            filename (str): Filename of music to load.\n                Depending on installed libraries, supported formats may be\n                WAV, MP3, OGG, MOD. You can also use ``None`` to unset music.\n        \"\"\"\n        self.music = filename\n        self.music_playing = False\n        if self.is_running:\n            if filename is not None:\n                cocos.audio.music.control.load(filename)\n            else:\n                cocos.audio.music.control.stop()\n", "docstring": "This prepares a streamed music file to be played in this scene."}
{"repo": "cocos-master/cocos/sprite.py", "original_string": "    def rotation(self, a):\n        super(Sprite, Sprite).rotation.__set__(self, a)\n        pyglet.sprite.Sprite.rotation.__set__(self, a)\n", "docstring": "super(Sprite, Sprite).rotation.__set__(self, a)"}
{"repo": "cocos-master/cocos/sprite.py", "original_string": "    def width(self):\n        \"\"\"Scaled width of the sprite.\n        Read-only.  Invariant under rotation.\n        :type: int\n        \"\"\"\n        return int(self._texture.width * self._scale * self._scale_x)\n", "docstring": "Scaled width of the sprite."}
{"repo": "cocos-master/cocos/sprite.py", "original_string": "    def height(self):\n        \"\"\"Scaled height of the sprite.\n        Read-only.  Invariant under rotation.\n        Returns: \n            int\n        \"\"\"\n        return int(self._texture.height * self._scale * self._scale_y)\n", "docstring": "Scaled height of the sprite."}
{"repo": "cocos-master/cocos/sprite.py", "original_string": "    def image_anchor_x(self):\n        \"\"\"float: x coordinate from where the image will be positioned, \n        rotated and scaled in pixels.\n        \"\"\"\n        return self._image_anchor_x\n", "docstring": "float: x coordinate from where the image will be positioned,"}
{"repo": "cocos-master/cocos/sprite.py", "original_string": "    def image_anchor_y(self):\n        \"\"\"float: y coordinate from where the image will be positioned, \n        rotated and scaled in pixels.\n        \"\"\"\n        return self._image_anchor_y\n", "docstring": "float: y coordinate from where the image will be positioned,"}
{"repo": "cocos-master/cocos/sprite.py", "original_string": "    def image_anchor(self):\n        \"\"\"tuple[float]: Point from where the image will be positioned, \n        rotated and scaled in pixels.\n        \"\"\"\n        return self._image_anchor_x, self._image_anchor_y\n", "docstring": "tuple[float]: Point from where the image will be positioned,"}
{"repo": "cocos-master/cocos/sprite.py", "original_string": "    def _update_position(self):\n        \"\"\"Updates the vertex list\"\"\"\n        if not self._visible:\n            self._vertex_list.vertices[:] = [0, 0, 0, 0, 0, 0, 0, 0]\n            return\n        img = self._texture\n        if self.transform_anchor_x == self.transform_anchor_y == 0:\n            if self._rotation:\n                x1 = -self._image_anchor_x * self._scale * self._scale_x\n                y1 = -self._image_anchor_y * self._scale * self._scale_y\n                x2 = x1 + img.width*self._scale*self._scale_x\n                y2 = y1 + img.height*self._scale*self._scale_y\n                x = self._x\n                y = self._y\n                r = -math.radians(self._rotation)\n                cr = math.cos(r)\n                sr = math.sin(r)\n                ax = int(x1*cr - y1*sr + x)\n                ay = int(x1*sr + y1*cr + y)\n                bx = int(x2*cr - y1*sr + x)\n                by = int(x2*sr + y1*cr + y)\n                cx = int(x2*cr - y2*sr + x)\n                cy = int(x2*sr + y2*cr + y)\n                dx = int(x1*cr - y2*sr + x)\n                dy = int(x1*sr + y2*cr + y)\n                self._vertex_list.vertices[:] = [ax, ay, bx, by, cx, cy, dx, dy]\n            elif self._scale != 1.0 or self._scale_x != 1.0 or self._scale_y != 1.0:\n                x1 = int(self._x - self._image_anchor_x*self._scale*self._scale_x)\n                y1 = int(self._y - self._image_anchor_y*self._scale*self._scale_y)\n                x2 = int(x1 + img.width*self._scale*self._scale_x)\n                y2 = int(y1 + img.height*self._scale*self._scale_y)\n                self._vertex_list.vertices[:] = [x1, y1, x2, y1, x2, y2, x1, y2]\n            else:\n                x1 = int(self._x - self._image_anchor_x)\n                y1 = int(self._y - self._image_anchor_y)\n                x2 = x1 + img.width\n                y2 = y1 + img.height\n                self._vertex_list.vertices[:] = [x1, y1, x2, y1, x2, y2, x1, y2]\n        else:\n            x1 = int(-self._image_anchor_x)\n            y1 = int(-self._image_anchor_y)\n            x2 = x1 + img.width\n            y2 = y1 + img.height\n            m = self.get_local_transform()\n            p1 = m * euclid.Point2(x1, y1)\n            p2 = m * euclid.Point2(x2, y1)\n            p3 = m * euclid.Point2(x2, y2)\n            p4 = m * euclid.Point2(x1, y2)\n            self._vertex_list.vertices[:] = [\n                int(p1.x), int(p1.y), int(p2.x), int(p2.y),\n                int(p3.x), int(p3.y), int(p4.x), int(p4.y)]\n", "docstring": "Updates the vertex list\n"}
{"repo": "cocos-master/cocos/mapcolliders.py", "original_string": "    def collide_bottom(self, obj):\n        \"\"\"placeholder, called when collision with obj's bottom side detected\"\"\"\n        pass\n", "docstring": "placeholder, called when collision with obj's bottom side detected\n"}
{"repo": "cocos-master/cocos/mapcolliders.py", "original_string": "    def collide_right(self, obj):\n        \"\"\"placeholder, called when collision with obj's right side detected\"\"\"\n        pass\n", "docstring": "placeholder, called when collision with obj's right side detected\n"}
{"repo": "cocos-master/cocos/mapcolliders.py", "original_string": "    def on_bump_bounce(self, vx, vy):\n        \"\"\"Bounces when a wall is touched.\n        Example use case: bouncing projectiles.\n        \"\"\"\n        if self.bumped_x:\n            vx = -vx\n        if self.bumped_y:\n            vy = -vy\n        return vx, vy\n", "docstring": "Bounces when a wall is touched."}
{"repo": "cocos-master/cocos/mapcolliders.py", "original_string": "    def on_bump_slide(self, vx, vy):\n        \"\"\"Blocks movement only in the axis that touched a wall.\n        Example use case: player in a platformer game.\n        \"\"\"\n        if self.bumped_x:\n            vx = 0.0\n        if self.bumped_y:\n            vy = 0.0\n        return vx, vy\n", "docstring": "Blocks movement only in the axis that touched a wall."}
{"repo": "cocos-master/cocos/mapcolliders.py", "original_string": "    def on_bump_handler(self, vx, vy):\n        \"\"\"Returns velocity after all collisions considered by collide_map\n        Arguments:\n            vx (float) : velocity in x-axis before collision\n            vy (float) : velocity in y-axis before collision\n        Returns:\n            (vx, vx) : velocity after all collisions considered in collide_map\n        This is a placeholder, either define a custom one or replace with one\n        of the stock on_bump_<bump_style> methods\n        \"\"\"\n        raise ValueError(self.__class__.__name__ +\n                '.on_bump_handler must be set to a real handler before calling.')\n        # real code modifies vx, vy and\n        return vx, vy\n", "docstring": "Returns velocity after all collisions considered by collide_map"}
{"repo": "cocos-master/cocos/mapcolliders.py", "original_string": "    def detect_collision(self, obj, last, new):\n        \"\"\"returns minimal correction in each axis to not collide with obj\n        Arguments:\n            obj : object in a MapLayer\n            last (Rect) : starting rect for the actor step\n            new (Rect) : tentative actor's rect after step\n        Decides if there is a collision with obj when moving ``last`` -> ``new``\n        and then returns the minimal correction in each axis as to not collide.\n        \n        It can be overridden to be more selective about when a collision exists\n        (see the matching method in :class:`RectMapWithPropsCollider` for example).\n        \"\"\"\n        dx_correction = dy_correction = 0.0\n        if last.bottom >= obj.top > new.bottom:\n            dy_correction = obj.top - new.bottom\n        elif last.top <= obj.bottom < new.top:\n            dy_correction = obj.bottom - new.top\n        if last.right <= obj.left < new.right:\n            dx_correction = obj.left - new.right\n        elif last.left >= obj.right > new.left:\n            dx_correction = obj.right - new.left\n        return dx_correction, dy_correction\n", "docstring": "returns minimal correction in each axis to not collide with obj"}
{"repo": "cocos-master/cocos/mapcolliders.py", "original_string": "    def detect_collision(self, obj, last, new):\n        \"\"\"Returns minimal correction in each axis to not collide with obj\n        Collision happens only on objects sides with prop <side> set.\n        \"\"\"\n        # shorthand for getting a prop from obj\n        g = obj.get\n        dx_correction = dy_correction = 0.0\n        if g('top') and last.bottom >= obj.top > new.bottom:\n            dy_correction = obj.top - new.bottom\n        elif g('bottom') and last.top <= obj.bottom < new.top:\n            dy_correction = obj.bottom - new.top\n        if g('left') and last.right <= obj.left < new.right:\n            dx_correction = obj.left - new.right\n        elif g('right') and last.left >= obj.right > new.left:\n            dx_correction = obj.right - new.left\n        return dx_correction, dy_correction\n", "docstring": "Returns minimal correction in each axis to not collide with obj"}
{"repo": "cocos-master/cocos/mapcolliders.py", "original_string": "    def collide_map(self, maplayer, last, new, vx, vy):\n        \"\"\"Constrains a movement ``last`` -> ``new`` by considering collisions\n        Arguments:\n            maplayer (RectMapLayer) : layer with solid objects to collide with.\n            last (Rect) : actor rect before step.\n            new (Rect): tentative rect after the stepm will be adjusted.\n            vx (float) : velocity in x-axis used to calculate 'last' -> 'new'\n            vy (float) : velocity in y-axis used to calculate 'last' -> 'new'\n        Returns:\n            vx, vy (float, float) : the possibly modified (vx, vy).\n        See :meth:`RectMapCollider.collide_map` for side effects and details\n        \"\"\"\n        self.bumped_x = False\n        self.bumped_y = False\n        objects = maplayer.get_in_region(*(new.bottomleft + new.topright))\n        # first pass, adjust for collisions in only one axis\n        collide_later = set()\n        for obj in objects:\n            # the if is not superfluous in the loop because 'new' can change\n            if not obj.intersects(new):\n                continue\n            dx_correction, dy_correction = self.detect_collision(obj, last, new)\n            if dx_correction == 0.0 or dy_correction == 0.0:\n                self.resolve_collision(obj, new, dx_correction, dy_correction)\n            else:\n                collide_later.add(obj)\n        # second pass, for objs that initially collided in both axis\n        for obj in collide_later:\n            if obj.intersects(new):\n                dx_correction, dy_correction = self.detect_collision(obj, last, new)\n                if abs(dx_correction) < abs(dy_correction):\n                    # do correction only on X (below)\n                    dy_correction = 0.0\n                elif abs(dy_correction) < abs(dx_correction):\n                    # do correction only on Y (below)\n                    dx_correction = 0.0\n                self.resolve_collision(obj, new, dx_correction, dy_correction)\n        vx, vy = self.on_bump_handler(vx, vy)\n        return vx, vy\n", "docstring": "Constrains a movement ``last`` -> ``new`` by considering collisions"}
{"repo": "cocos-master/cocos/director.py", "original_string": "    def set_show_FPS(self, value):\n        if value and self.fps_display is None:\n            self.fps_display = self.fps_display_provider()\n            self.fps_display.init()\n        elif not value and self.fps_display:\n            self.fps_display.terminate()\n            self.fps_display = None\n", "docstring": "if value and self.fps_display is None:"}
{"repo": "cocos-master/cocos/director.py", "original_string": "    def run(self, scene):\n        \"\"\"Runs a scene, entering in the Director's main loop.\n        :Parameters:\n            `scene` : `Scene`\n                The scene that will be run.\n        \"\"\"\n        self._set_scene(scene)\n        # workaround pyglet 1.3 not calling on_draw if nothing scheduled (at least in Windows)\n        # also does a defered close, outside of on_draw and on_key_.. to not\n        # emit spureous exception on console, see issue #334\n        pyglet.clock.schedule_interval(self.handle_closing, 0.1)\n        event_loop.run()\n", "docstring": "Runs a scene, entering in the Director's main loop."}
{"repo": "cocos-master/cocos/director.py", "original_string": "    def set_recorder(self, framerate, template=\"frame-%d.png\", duration=None):\n        \"\"\"Will replace the app clock so that now we can ensure a steady\n        frame rate and save one image per frame\n        :Parameters\n            `framerate`: int\n                the number of frames per second\n            `template`: str\n                the template that will be completed with an in for the name of the files\n            `duration`: float\n                the amount of seconds to record, or 0 for infinite\n        \"\"\"\n        clock = cocos.custom_clocks.get_recorder_clock(framerate, template, duration)\n        cocos.custom_clocks.set_app_clock(clock)\n", "docstring": "Will replace the app clock so that now we can ensure a steady"}
{"repo": "cocos-master/cocos/director.py", "original_string": "    def push(self, scene):\n        \"\"\"Suspends the execution of the running scene, pushing it\n        on the stack of suspended scenes. The new scene will be executed.\n        :Parameters:\n            `scene` : `Scene`\n                It is the scene that will be run.\n           \"\"\"\n        self.dispatch_event(\"on_push\", scene)\n", "docstring": "Suspends the execution of the running scene, pushing it"}
{"repo": "cocos-master/cocos/director.py", "original_string": "    def pop(self):\n        \"\"\"If the scene stack is empty the appication is terminated.\n            Else pops out a scene from the stack and sets as the running one.\n        \"\"\"\n        self.dispatch_event(\"on_pop\")\n", "docstring": "If the scene stack is empty the appication is terminated."}
{"repo": "cocos-master/cocos/director.py", "original_string": "    def replace(self, scene):\n        \"\"\"Replaces the running scene with a new one. The running scene is terminated.\n        :Parameters:\n            `scene` : `Scene`\n                It is the scene that will be run.\n        \"\"\"\n        self.next_scene = scene\n", "docstring": "Replaces the running scene with a new one. The running scene is terminated."}
{"repo": "cocos-master/cocos/director.py", "original_string": "    def get_window_size(self):\n        \"\"\"Returns the size of the window\n        If director.init(...) was called with autoscale=True it will return\n        a virtuel size, the same as the size set in director.init(...)\n        If director.init(...) was called with autoscale=Fakse it will return\n        the physical size of the window.\n        \n        Usually you don't want to know the current window size, because the\n        Director() hides the complexity of rescaling your objects when\n        the Window is resized or if the window is made fullscreen.\n        If you created a window of 640x480, the you should continue to place\n        your objects in a 640x480 world, no matter if your window is resized or not.\n        Director will do the magic for you.\n        :rtype: (x,y)\n        :returns: The size of the window when it was created\n        \"\"\"\n        # this method will be replaced by _get_window_size_autoscale or\n        # _get_window_size_no_autoscale when director.init(...) is called\n        raise NotImplemented\n", "docstring": "Returns the size of the window"}
{"repo": "cocos-master/cocos/director.py", "original_string": "    def get_virtual_coordinates_autoscale(self, x, y):\n        \"\"\"Transforms coordinates that belongs the *real* window size, to the\n        coordinates that belongs to the *virtual* window.\n        For example, if you created a window of 640x480, and it was resized\n        to 640x1000, then if you move your mouse over that window,\n        it will return the coordinates that belongs to the newly resized window.\n        Probably you are not interested in those coordinates, but in the coordinates\n        that belongs to your *virtual* window.\n        :rtype: (x,y)\n        :returns: Transformed coordinates from the *real* window to the *virtual* window\n        \"\"\"\n        x_diff = self._window_virtual_width / float(self.window.width - self._offset_x * 2)\n        y_diff = self._window_virtual_height / float(self.window.height - self._offset_y * 2)\n        adjust_x = (self.window.width * x_diff - self._window_virtual_width) / 2\n        adjust_y = (self.window.height * y_diff - self._window_virtual_height) / 2\n        return int(x_diff * x) - adjust_x, int(y_diff * y) - adjust_y\n", "docstring": "Transforms coordinates that belongs the *real* window size, to the"}
{"repo": "cocos-master/cocos/director.py", "original_string": "    def scaled_resize_window(self, width, height):\n        \"\"\"One of two possible methods that are called when the main window is resized.\n        This implementation scales the display such that the initial resolution\n        requested by the programmer (the \"logical\" resolution) is always retained\n        and the content scaled to fit the physical display.\n        This implementation also sets up a 3D projection for compatibility with the\n        largest set of Cocos transforms.\n        The other implementation is `unscaled_resize_window`.\n        :Parameters:\n            `width` : Integer\n                New width\n            `height` : Integer\n                New height\n        \"\"\"\n        # physical view size\n        pw, ph = width, height\n        # virtual (desired) view size\n        vw, vh = self.get_window_size()\n        # desired aspect ratio\n        v_ar = vw / float(vh)\n        # usable width, heigh\n        uw = int(min(pw, ph * v_ar))\n        uh = int(min(ph, pw / v_ar))\n        ox = (pw-uw) // 2\n        oy = (ph-uh) // 2\n        self._offset_x = ox\n        self._offset_y = oy\n        self._usable_width = uw\n        self._usable_height = uh\n        self.set_projection()\n        if self._resize_no_events:\n            # setting viewport geometry, not handling an event\n            return\n        self.dispatch_event(\"on_cocos_resize\", self._usable_width, self._usable_height)\n        # eliminate ugly padding bands used to keep the aspect ratio truogh resizes\n        if self.resizable and (ox > 1 or oy > 1):\n            pyglet.clock.schedule(self.post_resize_adjust)\n        # dismiss the pyglet BaseWindow default 'on_resize' handler\n        return pyglet.event.EVENT_HANDLED\n", "docstring": "One of two possible methods that are called when the main window is resized."}
{"repo": "cocos-master/cocos/director.py", "original_string": "    def unscaled_resize_window(self, width, height):\n        \"\"\"One of two possible methods that are called when the main window is resized.\n        This implementation does not scale the display but rather forces the logical\n        resolution to match the physical one.\n        This implementation sets up a 2D projection, resulting in the best pixel\n        alignment possible. This is good for text and other detailed 2d graphics\n        rendering.\n        The other implementation is `scaled_resize_window`.\n        :Parameters:\n            `width` : Integer\n                New width\n            `height` : Integer\n                New height\n        \"\"\"\n        self._usable_width = width\n        self._usable_height = height\n        if self._resize_no_events:\n            # setting viewport geometry, not handling an event\n            return\n        self.dispatch_event(\"on_cocos_resize\", self._usable_width, self._usable_height)\n", "docstring": "One of two possible methods that are called when the main window is resized."}
{"repo": "cocos-master/cocos/director.py", "original_string": "    def set_projection3D(self):\n        \"\"\"Sets a 3D projection mantaining the aspect ratio of the original window size\"\"\"\n        # virtual (desired) view size\n        vw, vh = self.get_window_size()\n        gl.glViewport(self._offset_x, self._offset_y, self._usable_width, self._usable_height)\n        gl.glMatrixMode(gl.GL_PROJECTION)\n        gl.glLoadIdentity()\n        gl.gluPerspective(60, self._usable_width / float(self._usable_height), 0.1, 3000.0)\n        gl.glMatrixMode(gl.GL_MODELVIEW)\n        gl.glLoadIdentity()\n        gl.gluLookAt(vw / 2.0, vh / 2.0, vh / 1.1566,   # eye\n                  vw / 2.0, vh / 2.0, 0,             # center\n                  0.0, 1.0, 0.0                      # up vector\n                  )\n", "docstring": "Sets a 3D projection mantaining the aspect ratio of the original window size\n"}
{"repo": "cocos-master/cocos/camera.py", "original_string": "    def get_z_eye(cls):\n        \"\"\"Returns the best distance for the camera for the current window size\n        cocos2d uses a Filed Of View (fov) of 60\n        \"\"\"\n        width, height = director.get_window_size()\n        eye_z = height / 1.1566\n        return eye_z\n", "docstring": "Returns the best distance for the camera for the current window size"}
{"repo": "cocos-master/cocos/camera.py", "original_string": "    def locate(self, force=False):\n        \"\"\"Sets the camera using gluLookAt using its eye, center and up_vector\n        :Parameters:\n            `force` : bool\n                whether or not the camera will be located even if it is not dirty\n        \"\"\"\n        if force or self.dirty or self.once:\n            gl.glLoadIdentity()\n            gl.gluLookAt(self._eye.x, self._eye.y, self._eye.z,             # camera eye\n                      self._center.x, self._center.y, self._center.z,    # camera center\n                      self._up_vector.x, self._up_vector.y, self._up_vector.z  # camera up vector\n                      )\n            self.once = False\n", "docstring": "Sets the camera using gluLookAt using its eye, center and up_vector"}
{"repo": "cocos-master/cocos/euclid.py", "original_string": "    def reflect(self, normal):\n        # assume normal is normalized\n        assert isinstance(normal, Vector2)\n        d = 2 * (self.x * normal.x + self.y * normal.y)\n        return Vector2(self.x - d * normal.x,\n                       self.y - d * normal.y)\n", "docstring": "assume normal is normalized"}
{"repo": "cocos-master/cocos/euclid.py", "original_string": "    def angle(self, other):\n        \"\"\"canonical angle between vectors, ``angle(u, v) = u dot v / (|u|*|v|)``\n        Is the angle between the lines generated by self and other.\n        Range is [0, pi]\n        v.angle(w) == w.angle(v)\n        \"\"\"\n        return abs(self.angle_oriented(other))\n", "docstring": "canonical angle between vectors, ``angle(u, v) = u dot v / (|u|*|v|)``"}
{"repo": "cocos-master/cocos/euclid.py", "original_string": "    def project(self, other):\n        \"\"\"Return one vector projected on the vector other\"\"\"\n        n = other.normalized()\n        return self.dot(n)*n\n", "docstring": "Return one vector projected on the vector other\n"}
{"repo": "cocos-master/cocos/euclid.py", "original_string": "    def rotate_around(self, axis, theta):\n        \"\"\"Return the vector rotated around axis through angle theta. Right hand rule applies\"\"\"\n        # Adapted from equations published by Glenn Murray.\n        # http://inside.mines.edu/~gmurray/ArbitraryAxisRotation/ArbitraryAxisRotation.html\n        x, y, z = self.x, self.y,self.z\n        u, v, w = axis.x, axis.y, axis.z\n        # Extracted common factors for simplicity and efficiency\n        r2 = u**2 + v**2 + w**2\n        r = math.sqrt(r2)\n        ct = math.cos(theta)\n        st = math.sin(theta) / r\n        dt = (u*x + v*y + w*z) * (1 - ct) / r2\n        return Vector3((u * dt + x * ct + (-w * y + v * z) * st),\n                       (v * dt + y * ct + ( w * x - u * z) * st),\n                       (w * dt + z * ct + (-v * x + u * y) * st))\n", "docstring": "Return the vector rotated around axis through angle theta. Right hand rule applies\n"}
{"repo": "cocos-master/cocos/euclid.py", "original_string": "    def project(self, other):\n        \"\"\"Return one vector projected on the vector other\"\"\"\n        n = other.normalized()\n        return self.dot(n)*n\n", "docstring": "Return one vector projected on the vector other\n"}
{"repo": "cocos-master/cocos/euclid.py", "original_string": "    def new_rotate_euler(cls, heading, attitude, bank):\n        # from http://www.euclideanspace.com/\n        ch = math.cos(heading)\n        sh = math.sin(heading)\n        ca = math.cos(attitude)\n        sa = math.sin(attitude)\n        cb = math.cos(bank)\n        sb = math.sin(bank)\n        self = cls()\n        self.a = ch * ca\n        self.b = sh * sb - ch * sa * cb\n        self.c = ch * sa * sb + sh * cb\n        self.e = sa\n        self.f = ca * cb\n        self.g = -ca * sb\n        self.i = -sh * ca\n        self.j = sh * sa * cb + ch * sb\n        self.k = -sh * sa * sb + ch * cb\n        return self\n", "docstring": "from http://www.euclideanspace.com/"}
{"repo": "cocos-master/cocos/euclid.py", "original_string": "    def new_perspective(cls, fov_y, aspect, near, far):\n        # from the gluPerspective man page\n        f = 1 / math.tan(fov_y / 2)\n        self = cls()\n        assert near != 0.0 and near != far\n        self.a = f / aspect\n        self.f = f\n        self.k = (far + near) / (near - far)\n        self.l = 2 * far * near / (near - far)\n        self.o = -1\n        self.p = 0\n        return self\n", "docstring": "from the gluPerspective man page"}
{"repo": "cocos-master/cocos/euclid.py", "original_string": "    def _swap(self):\n        # used by connect methods to switch order of points\n        self.p = self.p2\n        self.v *= -1\n        return self\n", "docstring": "used by connect methods to switch order of points"}
{"repo": "cocos-master/cocos/euclid.py", "original_string": "    def _swap(self):\n        # used by connect methods to switch order of points\n        self.p = self.p2\n        self.v *= -1\n        return self\n", "docstring": "used by connect methods to switch order of points"}
{"repo": "cocos-master/cocos/shader.py", "original_string": "    def simple_program(cls, name, vertex_code, fragment_code):\n        \"\"\"Intended to cut boilerplate when doing simple shaders\n           name : string with program name\n           vertex_code : None or string with the vertex shader code\n           fragment_code : None or string with the fragment shader code\n        \"\"\"\n        shader_p = cls()\n        if vertex_code:\n            shader_p.setShader(VertexShader(name + '_vp', vertex_code))\n        if fragment_code:\n            shader_p.setShader(FragmentShader(name + '_fp', fragment_code))\n        # link now to allow fail early\n        shader_p.prog()\n        return shader_p\n", "docstring": "Intended to cut boilerplate when doing simple shaders"}
{"repo": "cocos-master/cocos/custom_clocks.py", "original_string": "    def __init__(self, framerate, template, duration):\n        super(ScreenReaderClock, self).__init__()\n        self.framerate = float(framerate)\n        self.template = template\n        self.duration = duration\n        self.frameno = 0\n        self.fake_time = 0\n", "docstring": "super(ScreenReaderClock, self).__init__()"}
{"repo": "cocos-master/cocos/custom_clocks.py", "original_string": "    def _screenshot_logic(self):\n        \"\"\"takes screenshots, handles end of screenshot session\"\"\"\n        # take screenshot\n        pyglet.image.get_buffer_manager().get_color_buffer().save(self.template % self.frameno)\n        self.frameno += 1\n        # end?\n        if self.duration:\n            if self.fake_time > self.duration:\n                raise SystemExit()\n", "docstring": "takes screenshots, handles end of screenshot session\n"}
{"repo": "cocos-master/cocos/custom_clocks.py", "original_string": "    def get_sleep_time(self, sleep_idle):\n        \"\"\"sleep time between frames; 0.0 as as we want to run as fast as possible\"\"\"\n        return 0.0\n", "docstring": "sleep time between frames; 0.0 as as we want to run as fast as possible\n"}
{"repo": "cocos-master/cocos/custom_clocks.py", "original_string": "    def _get_ts(self):\n        \"\"\"handles the time progression\"\"\"\n        ts = self.fake_time\n        self.fake_time = self.frameno/self.framerate\n        return ts\n", "docstring": "handles the time progression\n"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def find(self, cls):\n        \"\"\"Find all elements of the given class in this resource.\n        \"\"\"\n        for k in self.contents:\n            if isinstance(self.contents[k], cls):\n                yield (k, self.contents[k])\n", "docstring": "Find all elements of the given class in this resource."}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def save_xml(self, filename):\n        \"\"\"Save this resource's XML to the indicated file.\n        \"\"\"\n        # generate the XML\n        root = ElementTree.Element('resource')\n        root.tail = '\\n'\n        for namespace, res in self.requires:\n            r = ElementTree.SubElement(root, 'requires', file=res.filename)\n            r.tail = '\\n'\n            if namespace:\n                r.set('namespace', namespace)\n        for element in self.contents.values():\n            element._as_xml(root)\n        tree = ElementTree.ElementTree(root)\n        tree.write(filename)\n", "docstring": "Save this resource's XML to the indicated file."}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "def load(filename):\n    \"\"\"Load resource(s) defined in the indicated XML file.\n    \"\"\"\n    # make sure we can find files relative to this one\n    dirname = os.path.dirname(filename)\n    if dirname and dirname not in pyglet.resource.path:\n        if os.sep == '\\\\':\n            # pyglet resource does not accept '\\' in relative paths\n            dirname = dirname.replace(os.sep, '/')\n        pyglet.resource.path.append(dirname)\n        pyglet.resource.reindex()\n    if filename in _cache:\n        if _cache[filename] is _NOT_LOADED:\n            raise ResourceError('Loop in tile map files loading \"%s\"' % filename)\n        return _cache[filename]\n    _cache[filename] = _NOT_LOADED\n    if filename.endswith('.tmx'):\n        obj = load_tmx(filename)\n    else:\n        obj = load_tiles(filename)\n    _cache[filename] = obj\n    return obj\n", "docstring": "Load resource(s) defined in the indicated XML file."}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "def decode_base64(s):\n    \"\"\"returns a bytes object\"\"\"\n    if six.PY2:\n        return s.decode('base64')\n    else:\n        import base64\n        b = s.encode('utf-8')\n        return base64.b64decode(b)\n", "docstring": "returns a bytes object\n"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "def decompress_gzip(in_bytes):\n    \"\"\"decompress the input array of bytes to an array of bytes using gzip\"\"\"\n    import gzip\n    inp = six.BytesIO(in_bytes)\n    f = gzip.GzipFile(fileobj=inp)\n    out_bytes = f.read()\n    f.close()\n    inp.close()\n    return out_bytes\n", "docstring": "decompress the input array of bytes to an array of bytes using gzip\n"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "def capture_tileset(map_path, tileset_tag, tileset_path, firstgid, tile_width, tile_height): \n    name = tileset_tag.attrib['name']\n    image_tag = tileset_tag.find(\"image\")\n    uses_spritesheet = (image_tag is not None)\n    if uses_spritesheet:\n        # create a tileset from the image atlas\n        spacing = int(tileset_tag.attrib.get('spacing', 0))\n        if 'source' in image_tag.attrib:\n            image_path = tmx_get_path(tileset_path, image_tag.attrib['source'])\n        else:\n            # malformed file missing \"source\" or very old file which\n            # embeds the image content in a <data> child node.\n            # unsuported in modern Tiled editor, cocos will not support it\n            raise(TmxUnsupportedVariant(\"<image> missing 'source' attrib\"))\n        # create a tileset from the image atlas\n        tileset_tile_height = int(tileset_tag.attrib.get('tileheight', tile_height))\n        tileset_tile_width = int(tileset_tag.attrib.get('tilewidth', tile_width))\n        tileset = TileSet.from_atlas(name, firstgid, image_path, tileset_tile_width,\n                                     tileset_tile_height, row_padding=spacing,\n                                     column_padding=spacing)\n    else:\n        # tileset with individual images, each tile has its own image\n        texture_bin = pyglet.image.atlas.TextureBin()\n        tileset = TileSet(name, {})\n    # TODO consider adding the individual tiles to the resource?\n    for c in tileset_tag.findall(\"tile\"):\n        local_id = int(c.attrib[\"id\"])\n        gid = firstgid + local_id\n        if not uses_spritesheet:\n            image_tag = c.find(\"image\")\n            if image_tag is None:\n                fmt = \"In tileset '%s', <tile> with id=%d don't have <image> child\"\n                msg = fmt % (name, local_id)\n                raise(TmxUnsupportedVariant(msg))\n            if 'source' in image_tag.attrib:\n                image_path = tmx_get_path(tileset_path, image_tag.attrib['source'])\n                image = pyglet.image.load(image_path)\n            else:\n                # malformed file missing \"source\" or very old file which\n                # embeds the image content in a <data> child node.\n                # unsuported in modern Tiled editor, cocos will not support it\n                fmt = \"In tileset '%s', <tile> with id=%d has <image> missing 'source' attrib\"\n                msg = fmt % (name, local_id)\n                raise(TmxUnsupportedVariant(msg))\n            tile_image = texture_bin.add(image)\n            tileset[gid] = tileset.get_tile(gid, tile_image)\n        \n        # add properties to tiles in the tileset\n        tile = tileset[gid]\n        property_values, property_types = tmx_get_properties(c, map_path)\n        tile.properties = property_values\n        tile.property_types = property_types\n    return tileset\n", "docstring": "name = tileset_tag.attrib['name']"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "def _handle_properties(tag):\n    \"\"\"returns the properties dict reading from the etree node tag\n    :Parameters:\n        `tag` : xml.etree.ElementTree\n            node from which the properties are obtained\n    \"\"\"\n    properties = {}\n    for node in tag.findall('./property'):\n        name = node.get('name')\n        type = node.get('type') or 'unicode'\n        value = node.get('value')\n        if name is None:\n            raise TilesPropertyWithoutName(\"\\nnode:\\n%s\" % ElementTree.tostring(node))\n        if value is None:\n            raise TilesPropertyWithoutValue(\"\\nnode:\\n%s\" % ElementTree.tostring(node))\n        properties[name] = _xml_to_python[type](value)\n    return properties\n", "docstring": "returns the properties dict reading from the etree node tag"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def set_view(self, x, y, w, h, viewport_x=0, viewport_y=0):\n        # invoked by ScrollingManager.set_focus()\n        super(MapLayer, self).set_view(x, y, w, h, viewport_x, viewport_y)\n        self._update_sprite_set()\n", "docstring": "invoked by ScrollingManager.set_focus()"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def is_visible(self, rect):\n        \"\"\"Determine whether the indicated rect (with .x, .y, .width and\n        .height attributes) located in this Layer is visible.\n        \"\"\"\n        x, y = rect.x, rect.y\n        if x + rect.width < self.view_x:\n            return False\n        if y + rect.height < self.view_y:\n            return False\n        if x > self.view_x + self.view_w:\n            return False\n        if y > self.view_y + self.view_h:\n            return False\n        return True\n", "docstring": "Determine whether the indicated rect (with .x, .y, .width and"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def find_cells(self, **requirements):\n        \"\"\"Find all cells that match the properties specified.\n        For example:\n           map.find_cells(player_start=True)\n        Return a list of Cell instances.\n        \"\"\"\n        r = []\n        for col in self.cells:\n            for cell in col:\n                for k in requirements:\n                    if cell.get(k) != requirements[k]:\n                        break\n                else:\n                    r.append(cell)\n        return r\n", "docstring": "Find all cells that match the properties specified."}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def get_cell(self, i, j):\n        \"\"\" Return Cell at cell pos=(i, j).\n        Return None if out of bounds.\"\"\"\n        if i < 0 or j < 0:\n            return None\n        try:\n            return self.cells[i][j]\n        except IndexError:\n            return None\n", "docstring": "Return Cell at cell pos=(i, j)."}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def get_key_at_pixel(self, x, y):\n        \"\"\"returns the grid coordinates for the hex that covers the point (x, y)\"\"\"\n        return (int((x - self.origin_x) // self.tw),\n                int((y - self.origin_y) // self.th))\n", "docstring": "returns the grid coordinates for the hex that covers the point (x, y)\n"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def get_neighbor(self, cell, direction):\n        \"\"\"Get the neighbor Cell in the given direction (dx, dy) which\n        is one of self.UP, self.DOWN, self.LEFT or self.RIGHT.\n        Returns None if out of bounds.\n        \"\"\"\n        dx, dy = direction\n        return self.get_cell(cell.i + dx, cell.j + dy)\n", "docstring": "Get the neighbor Cell in the given direction (dx, dy) which"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def _as_xml(self, root):\n        \"\"\"stores a XML representation of itself as child of root with type rectmap\n        \"\"\"\n        m = ElementTree.SubElement(root, 'rectmap', id=self.id,\n                                   tile_size='%dx%d' % (self.tw, self.th),\n                                   origin='%s,%s,%s' % (self.origin_x, self.origin_y, self.origin_z))\n        m.tail = '\\n'\n        # map properties\n        for k in self.properties:\n            v = self.properties[k]\n            t = type(v)\n            v = _python_to_xml[t](v)\n            p = ElementTree.SubElement(m, 'property', name=k, value=v,\n                                       type=_xml_type[t])\n            p.tail = '\\n'\n        # columns / cells\n        for column in self.cells:\n            c = ElementTree.SubElement(m, 'column')\n            c.tail = '\\n'\n            for cell in column:\n                cell._as_xml(c)\n", "docstring": "stores a XML representation of itself as child of root with type rectmap"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def __init__(self, id, tw, th, cells, origin=None, properties=None):\n        RectMap.__init__(self, id, tw, th, cells, origin, properties)\n        MapLayer.__init__(self, properties)\n", "docstring": "RectMap.__init__(self, id, tw, th, cells, origin, properties)"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def get_key_at_pixel(self, x, y):\n        \"\"\"returns the grid coordinates for the hex that covers the point (x, y)\n        Reference:\n            Hexagonal grid math, by Ruslan Shestopalyuk\n            http://blog.ruslans.com/2011/02/hexagonal-grid-math.html\n        \"\"\"\n        radius = self.edge_length\n        side = (self.tw * 3) // 4\n        height = self.th\n        ci = int(floor(x / side))\n        cx = int(x - side * ci)\n        ty = int(y - (ci % 2) * height / 2.0)\n        cj = int(floor(1.0 * ty / height))\n        cy = ty - height * cj\n        if cx <= abs(radius / 2.0 - radius * cy / height):\n            cj = cj + (ci % 2) - (1 if (cy < height / 2.0) else 0)\n            ci = ci - 1\n        return ci, cj\n", "docstring": "returns the grid coordinates for the hex that covers the point (x, y)"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def get_neighbor(self, cell, direction):\n        \"\"\"Get the neighbor HexCell in the given direction which\n        is one of self.UP, self.DOWN, self.UP_LEFT, self.UP_RIGHT,\n        self.DOWN_LEFT or self.DOWN_RIGHT.\n        Return None if out of bounds.\n        \"\"\"\n        if direction is self.UP:\n            return self.get_cell(cell.i, cell.j + 1)\n        elif direction is self.DOWN:\n            return self.get_cell(cell.i, cell.j - 1)\n        elif direction is self.UP_LEFT:\n            if cell.i % 2:\n                return self.get_cell(cell.i - 1, cell.j + 1)\n            else:\n                return self.get_cell(cell.i - 1, cell.j)\n        elif direction is self.UP_RIGHT:\n            if cell.i % 2:\n                return self.get_cell(cell.i + 1, cell.j + 1)\n            else:\n                return self.get_cell(cell.i + 1, cell.j)\n        elif direction is self.DOWN_LEFT:\n            if cell.i % 2:\n                return self.get_cell(cell.i - 1, cell.j)\n            else:\n                return self.get_cell(cell.i - 1, cell.j - 1)\n        elif direction is self.DOWN_RIGHT:\n            if cell.i % 2:\n                return self.get_cell(cell.i + 1, cell.j)\n            else:\n                return self.get_cell(cell.i + 1, cell.j - 1)\n        else:\n            raise ValueError('Unknown direction %r' % direction)\n", "docstring": "Get the neighbor HexCell in the given direction which"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "def parse_tmx_points(tag, obj_x, obj_y):\n    \"\"\"parses tmx tag points into left, bottom, right, top, points\n    :Parameters:\n        `tag` : xml tag\n            assumed an object tag\n        `obj_x` :\n            object x position in gl coordinates\n        `obj_y` :\n            object y position in gl coordinates\n    :Returns: tuple (left, bottom, width, height, points)\n        left: leftmost x-position in points, gl coordinates system\n        bottom: bottommost y-position in points, gl coordinates system\n        width: width of point's enclosing box\n        height: height of point's enclosing box\n        points: list of points in a gl coordinates system relative to (left, bottom)\n    \"\"\"\n    points_string = tag.attrib['points']\n    points_parts = points_string.split(' ')\n    # points, absolute position\n    pa = []\n    for pair in points_parts:\n        coords = pair.split(',')\n        pa.append((float(coords[0]) + obj_x, -float(coords[1]) + obj_y))\n    left = min([x for x, y in pa])\n    bottom = min([y for x, y in pa])\n    right = max([x for x, y in pa])\n    top = max([y for x, y in pa])\n    width = right - left + 1\n    height = top - bottom + 1\n    # points, relative to (bottom, left)\n    points = [(x - left, y - bottom) for x, y in pa]\n    return left, bottom, width, height, points\n", "docstring": "parses tmx tag points into left, bottom, right, top, points"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def __init__(self, name, color, objects, opacity=1,\n                 visible=1, position=(0, 0)):\n        MapLayer.__init__(self, {})\n        self.name = name\n        self.color = color\n        self.objects = objects\n        self.opacity = opacity\n        self.visible = visible\n        self.position = position\n", "docstring": "visible=1, position=(0, 0)):"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def find_cells(self, **requirements):\n        \"\"\"Find all objects with the given properties set.\n        Called \"find_cells\" for compatibility with existing cocos tile API.\n        \"\"\"\n        r = []\n        for propname in requirements:\n            for obj in self.objects:\n                if obj and propname in obj or propname in self.properties:\n                    r.append(obj)\n        return r\n", "docstring": "Find all objects with the given properties set."}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def collide(self, rect, propname):\n        \"\"\"Find all objects the rect is touching that have the indicated\n        property name set.\n        \"\"\"\n        r = []\n        for obj in self.get_in_region(rect.left, rect.bottom, rect.right,\n                                      rect.top):\n            if propname in obj or propname in self.properties:\n                r.append(obj)\n        return r\n", "docstring": "Find all objects the rect is touching that have the indicated"}
{"repo": "cocos-master/cocos/tiles.py", "original_string": "    def get_at(self, x, y):\n        \"\"\"Return the first object found at the nominated (x, y) coordinate.\n        Return an TmxObject instance or None.\n        \"\"\"\n        for obj in self.objects:\n            if obj.contains(x, y):\n                return obj\n", "docstring": "Return the first object found at the nominated (x, y) coordinate."}
{"repo": "cocos-master/cocos/collision_model.py", "original_string": "    def known_objs(self):\n        \"\"\"Returns a set with all the objects known by the CollisionManager\n        Used for debug and testing.\n        \"\"\"\n        raise NotImplementedError(msg_abstract)\n", "docstring": "Returns a set with all the objects known by the CollisionManager"}
{"repo": "cocos-master/cocos/collision_model.py", "original_string": "    def objs_into_box(self, minx, maxx, miny, maxy):\n        \"\"\"Returns a container with know objects that fully fits into the axis\n        aligned rectangle defined by params\n        Useful for elastic box selection\n        \"\"\"\n        raise NotImplementedError(msg_abstract)\n", "docstring": "Returns a container with know objects that fully fits into the axis"}
{"repo": "cocos-master/cocos/collision_model.py", "original_string": "    def distance(self, other):\n        if isinstance(other, CircleShape):\n            return circle_distance_circle(self, other)\n        elif isinstance(other, AARectShape):\n            return aa_rect_distance_circle(other, self)\n        raise NotImplementedError(\n            \"Distance between CircleShape and {0} is not implemented\".format(other.__class__.__name__))\n", "docstring": "if isinstance(other, CircleShape):"}
{"repo": "cocos-master/cocos/collision_model.py", "original_string": "    def distance(self, other):\n        if isinstance(other, AARectShape):\n            return aa_rect_distance_aa_rect(self, other)\n        elif isinstance(other, CircleShape):\n            return aa_rect_distance_circle(self, other)\n        raise NotImplementedError(\n            \"Distance between AARectShape and {0} is not implemented\".format(other.__class__.__name__))\n", "docstring": "if isinstance(other, AARectShape):"}
{"repo": "cocos-master/cocos/collision_model.py", "original_string": "    def __init__(self):\n        self.objs = set()\n", "docstring": "self.objs = set()"}
{"repo": "cocos-master/cocos/collision_model.py", "original_string": "    def remove_tricky(self, obj):\n        for cell_idx in self._iter_cells_for_aabb(obj.cshape.minmax()):\n            self.buckets[cell_idx].remove(obj)\n", "docstring": "for cell_idx in self._iter_cells_for_aabb(obj.cshape.minmax()):"}
{"repo": "cocos-master/cocos/menu.py", "original_string": "    def __init__(self, callback_func, *args, **kwargs):\n        \"\"\"Creates a new menu item\n        :Parameters:\n            `callback_func` : function\n                The callback function\n        \"\"\"\n        super(BaseMenuItem, self).__init__()\n        self.callback_func = callback_func\n        self.callback_args = args\n        self.callback_kwargs = kwargs\n        self.is_selected = False\n        self.item_halign = None\n        self.item_valign = None\n        self.item = None\n        self.item_selected = None\n", "docstring": "Creates a new menu item"}
{"repo": "cocos-master/cocos/menu.py", "original_string": "    def get_item_height(self):\n        \"\"\" Returns the width of the item.\n            This method should be implemented by descendents.\n            :rtype: int\n        \"\"\"\n        return self.item.height\n", "docstring": "Returns the width of the item."}
{"repo": "cocos-master/cocos/menu.py", "original_string": "    def get_item_x(self):\n        \"\"\" Return the x position of the item.\n            This method should be implemented by descendents.\n            :rtype: int\n        \"\"\"\n        return self.item.x\n", "docstring": "Return the x position of the item."}
{"repo": "cocos-master/cocos/menu.py", "original_string": "    def get_box(self):\n        \"\"\"Returns the box that contains the menu item.\n        :rtype: (x1,x2,y1,y2)\n        \"\"\"\n        width = self.get_item_width()\n        height = self.get_item_height()\n        if self.item_halign == CENTER:\n            x_diff = - width / 2\n        elif self.item_halign == RIGHT:\n            x_diff = - width\n        elif self.item_halign == LEFT:\n            x_diff = 0\n        else:\n            raise Exception(\"Invalid halign: %s\" % str(self.item_halign))\n        y_diff = - height / 2\n        x1 = self.get_item_x() + x_diff\n        y1 = self.get_item_y() + y_diff\n        # x1 += self.parent.x\n        # y1 += self.parent.y\n        # x2 = x1 + width\n        # y2 = y1 + height\n        # return x1, y1, x2, y2\n        return rect.Rect(x1, y1, width, height)\n", "docstring": "Returns the box that contains the menu item."}
{"repo": "cocos-master/cocos/menu.py", "original_string": "    def is_inside_box(self, x, y):\n        \"\"\"Returns whether the point (x,y) is inside the menu item.\n        :rtype: bool\n        \"\"\"\n", "docstring": "Returns whether the point (x,y) is inside the menu item."}
{"repo": "cocos-master/cocos/menu.py", "original_string": "    def __init__(self, label, callback_func, *args, **kwargs):\n        \"\"\"Creates a new menu item\n        :Parameters:\n            `label` : string\n                The label the of the menu item\n            `callback_func` : function\n                The callback function\n        \"\"\"\n        self.label = label\n        super(MenuItem, self).__init__(callback_func, *args, **kwargs)\n", "docstring": "Creates a new menu item"}
{"repo": "cocos-master/cocos/menu.py", "original_string": "    def __init__(self, label, callback_func, items, default_item=0):\n        \"\"\"Creates a Multiple Menu Item\n        :Parameters:\n            `label` : string\n                Item's label\n            `callback_func` : function\n                Callback function\n            `items` : list\n                List of strings containing the values\n            `default_item` : integer\n                Default item of the list. It is an index of the list. Default: 0\n        \"\"\"\n        self.my_label = label\n        self.items = items\n        self.idx = default_item\n        if self.idx < 0 or self.idx >= len(self.items):\n            raise Exception(\"Index out of bounds\")\n        super(MultipleMenuItem, self).__init__(self._get_label(), callback_func)\n", "docstring": "Creates a Multiple Menu Item"}
{"repo": "cocos-master/cocos/menu.py", "original_string": "    def __init__(self, label, callback_func, value=False):\n        \"\"\"Creates a Toggle Menu Item\n        :Parameters:\n            `label` : string\n                Item's label\n            `callback_func` : function\n                Callback function\n            `value` : bool\n                Default value of the item: False is 'OFF', True is 'ON'. Default:False\n        \"\"\"\n        super(ToggleMenuItem, self).__init__(label, callback_func, ['OFF', 'ON'],  int(value))\n", "docstring": "Creates a Toggle Menu Item"}
{"repo": "cocos-master/cocos/menu.py", "original_string": "    def __init__(self, label, callback_func, value, max_length=0):\n        \"\"\"Creates an Entry Menu Item\n        :Parameters:\n            `label` : string\n                Item's label\n            `callback_func` : function\n                Callback function taking one argument.\n            `value` : String\n                Default value: any string\n            `max_length` : integer\n                Maximum value length (Defaults to 0 for unbound length)\n        \"\"\"\n        self._value = list(value)\n        self._label = label\n        super(EntryMenuItem, self).__init__(\"%s %s\" % (label, value), callback_func)\n        self.max_length = max_length\n", "docstring": "Creates an Entry Menu Item"}
{"repo": "cocos-master/cocos/menu.py", "original_string": "    def __init__(self, label, callback_func, items, default_item=0):\n        \"\"\"Creates a Color Menu Item\n        :Parameters:\n            `label` : string\n                Item's label\n            `callback_func` : function\n                Callback function\n            `items` : list\n                List of thre-element tuples describing the color choices\n            `default_item` : integer\n                Default item of the list. It is an index of the list. Default: 0\n        \"\"\"\n        self.my_label = label\n        self.items = items\n        self.idx = default_item\n        if self.idx < 0 or self.idx >= len(self.items):\n            raise Exception(\"Index out of bounds\")\n        super(ColorMenuItem, self).__init__(self._get_label(), callback_func)\n", "docstring": "Creates a Color Menu Item"}
{"repo": "cocos-master/cocos/menu.py", "original_string": "def shake_back():\n    \"\"\"Predefined action that rotates to 0 degrees in 0.1 seconds\"\"\"\n    return ac.RotateTo(0, 0.1)\n", "docstring": "Predefined action that rotates to 0 degrees in 0.1 seconds\n"}
{"repo": "cocos-master/cocos/particle.py", "original_string": "def PointerToNumpy(a, ptype=ctypes.c_float):\n    \"\"\"PointerToNumpy(a, ptype=ctypes.c_float)\n    Provides a ctype pointer to a Numpy array.\n    Arguments:\n        a (numpy.array): The Numpy array.\n        ptype (ctypes): The ctypes type contained in the array.\n    Returns:\n        Pointer to the Numpy array.\n    \"\"\"\n    a = numpy.ascontiguousarray(a)           # Probably a NO-OP, but perhaps not\n    return a.ctypes.data_as(ctypes.POINTER(ptype))  # Ugly and undocumented!\n", "docstring": "PointerToNumpy(a, ptype=ctypes.c_float)"}
{"repo": "cocos-master/cocos/particle.py", "original_string": "    def __init__(self, r, g, b, a):\n        self.r = r\n        self.g = g\n        self.b = b\n        self.a = a\n", "docstring": "self.r = r"}
{"repo": "cocos-master/cocos/particle.py", "original_string": "    def load_texture(self):\n        \"\"\"Sets the default texture used by all instances of this particles system.\n        Override this method to change the default texture.\n        Note:\n            By `issue #168 <https://github.com/los-cocos/cocos/issues/168>`_ \n            the texture should hold only one image, so don't use::\n                texture = pyglet.resource.image('z.png').texture # (produces an atlas, ie multiple images in a texture)\n            You can use instead::\n                texture = pyglet.image.load(...).get_texture()\n                # Or using pyglet resource mechanism\n                texture = pyglet.image.load('filename.png', file=pyglet.resource.file('filename.png')).get_texture()\n        \"\"\"\n        pic = pyglet.image.load('fire.png', file=pyglet.resource.file('fire.png'))\n        self.__class__.texture = pic.get_texture()\n", "docstring": "Sets the default texture used by all instances of this particles system."}
{"repo": "cocos-master/cocos/particle.py", "original_string": "    def on_exit(self):\n        \"\"\"Called everytime the Particle system exits the stage.\"\"\"\n        super(ParticleSystem, self).on_exit()\n        director.remove_handlers(self)\n", "docstring": "Called everytime the Particle system exits the stage.\n"}
{"repo": "cocos-master/cocos/particle.py", "original_string": "    def scale(self, s):\n        # Extend CocosNode scale setter property\n        # The use of super(CocosNode, CocosNode).name.__set__(self, s) in the setter function is no mistake.\n        # To delegate to the previous implementation of the setter, control needs to pass\n        # through the __set__() method of the previously defined name property. However, the\n        # only way to get to this method is to access it as a class variable instead of an instance\n        # variable. This is what happens with the super(CocosNode, CocosNode) operation.\n        super(ParticleSystem, ParticleSystem).scale.__set__(self, s)\n        self._scale_particle_size()\n", "docstring": "Extend CocosNode scale setter property"}
{"repo": "cocos-master/cocos/particle.py", "original_string": "    def draw(self):\n        \"\"\"Draw the particles system\"\"\"\n        gl.glPushMatrix()\n        self.transform()\n        # color preserve - at least nvidia 6150SE needs that\n        gl.glPushAttrib(gl.GL_CURRENT_BIT)\n        # glPointSize(self.get_scaled_particle_size())\n        gl.glEnable(gl.GL_TEXTURE_2D)\n        gl.glEnable(gl.GL_PROGRAM_POINT_SIZE)\n        # glBindTexture(GL_TEXTURE_2D, self.texture.id)\n        gl.glEnable(gl.GL_POINT_SPRITE)\n        gl.glTexEnvi(gl.GL_POINT_SPRITE, gl.GL_COORD_REPLACE, gl.GL_TRUE)\n        gl.glEnableClientState(gl.GL_VERTEX_ARRAY)\n        vertex_ptr = PointerToNumpy(self.particle_pos)\n        gl.glVertexPointer(2, gl.GL_FLOAT, 0, vertex_ptr)\n        gl.glEnableClientState(gl.GL_COLOR_ARRAY)\n        color_ptr = PointerToNumpy(self.particle_color)\n        gl.glColorPointer(4, gl.GL_FLOAT, 0, color_ptr)\n        gl.glEnableVertexAttribArray(self.particle_size_idx)\n        size_ptr = PointerToNumpy(self.particle_size_scaled)\n        gl.glVertexAttribPointer(self.particle_size_idx, 1, gl.GL_FLOAT,\n                                 False, 0, size_ptr)\n        gl.glPushAttrib(gl.GL_COLOR_BUFFER_BIT)\n        gl.glEnable(gl.GL_BLEND)\n        if self.blend_additive:\n            gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE)\n        else:\n            gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\n        # mode = GLint()\n        # glTexEnviv( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, mode )\n        #\n        # if self.color_modulate:\n        #   glTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE )\n        # else:\n        #   glTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE )\n        self.sprite_shader.install()\n        self.sprite_shader.usetTex('sprite_texture', 0,\n                                   gl.GL_TEXTURE_2D, self.texture.id)\n        gl.glDrawArrays(gl.GL_POINTS, 0, self.total_particles)\n        self.sprite_shader.uninstall()\n        # un -blend\n        gl.glPopAttrib()\n        # color restore\n        gl.glPopAttrib()\n        # restore env mode\n        # glTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, mode)\n        # disable states\n        gl.glDisableVertexAttribArray(self.particle_size_idx)\n        gl.glDisableClientState(gl.GL_COLOR_ARRAY)\n        gl.glDisableClientState(gl.GL_VERTEX_ARRAY)\n        gl.glDisable(gl.GL_POINT_SPRITE)\n        gl.glDisable(gl.GL_PROGRAM_POINT_SIZE)\n        gl.glDisable(gl.GL_TEXTURE_2D)\n        gl.glPopMatrix()\n", "docstring": "Draw the particles system\n"}
{"repo": "cocos-master/cocos/particle.py", "original_string": "    def reset_system(self):\n        \"\"\"Resets the particle system.\"\"\"\n        self.elapsed = self.duration\n        self.emit_counter = 0\n", "docstring": "Resets the particle system.\n"}
{"repo": "cocos-master/cocos/particle.py", "original_string": "    def init_particle(self):\n        \"\"\"Set initial particles state.\"\"\"\n        # position\n        # p=self.particles[idx]\n        a = self.particle_life < 0\n        idxs = a.nonzero()\n        idx = -1\n        if len(idxs[0]) > 0:\n            idx = idxs[0][0]\n        else:\n            raise ExceptionNoEmptyParticle()\n        # position\n        self.particle_pos[idx][0] = self.pos_var.x * rand()\n        self.particle_pos[idx][1] = self.pos_var.y * rand()\n        # start position\n        self.start_pos[idx][0] = self.x\n        self.start_pos[idx][1] = self.y\n        a = math.radians(self.angle + self.angle_var * rand())\n        v = Point2(math.cos(a), math.sin(a))\n        s = self.speed + self.speed_var * rand()\n        dir = v * s\n        # direction\n        self.particle_dir[idx][0] = dir.x\n        self.particle_dir[idx][1] = dir.y\n        # radial accel\n        self.particle_rad[idx] = self.radial_accel + self.radial_accel_var * rand()\n        # tangential accel\n        self.particle_tan[idx] = self.tangential_accel + self.tangential_accel_var * rand()\n        # life\n        life = self.particle_life[idx] = self.life + self.life_var * rand()\n        # Color\n        # start\n        sr = self.start_color.r + self.start_color_var.r * rand()\n        sg = self.start_color.g + self.start_color_var.g * rand()\n        sb = self.start_color.b + self.start_color_var.b * rand()\n        sa = self.start_color.a + self.start_color_var.a * rand()\n        self.particle_color[idx][0] = sr\n        self.particle_color[idx][1] = sg\n        self.particle_color[idx][2] = sb\n        self.particle_color[idx][3] = sa\n        # end\n        er = self.end_color.r + self.end_color_var.r * rand()\n        eg = self.end_color.g + self.end_color_var.g * rand()\n        eb = self.end_color.b + self.end_color_var.b * rand()\n        ea = self.end_color.a + self.end_color_var.a * rand()\n        delta_color_r = (er - sr) / life\n        delta_color_g = (eg - sg) / life\n        delta_color_b = (eb - sb) / life\n        delta_color_a = (ea - sa) / life\n        self.particle_delta_color[idx][0] = delta_color_r\n        self.particle_delta_color[idx][1] = delta_color_g\n        self.particle_delta_color[idx][2] = delta_color_b\n        self.particle_delta_color[idx][3] = delta_color_a\n        # size\n        self.particle_size[idx] = self.size + self.size_var * rand()\n        self._scale_particle_size()\n        # gravity\n        self.particle_grav[idx][0] = self.gravity.x\n        self.particle_grav[idx][1] = self.gravity.y\n", "docstring": "Set initial particles state.\n"}
{"repo": "cocos-master/cocos/particle.py", "original_string": "    def _fallback_init(self):\n        self.vertexs = numpy.zeros((self.total_particles, 4, 2), numpy.float32)\n        tex_coords_for_quad = numpy.array([[0.0, 1.0], [0.0, 0.0], [1.0, 0.0], [1.0, 1.0]], numpy.float32)\n        self.tex_coords = numpy.zeros((self.total_particles, 4, 2), numpy.float32)\n        self.tex_coords[:] = tex_coords_for_quad[numpy.newaxis, :, :]\n        self.per_vertex_colors = numpy.zeros((self.total_particles, 4, 4), numpy.float32)\n        self.delta_pos_to_vertex = numpy.zeros((self.total_particles, 4, 2), numpy.float32)\n", "docstring": "self.vertexs = numpy.zeros((self.total_particles, 4, 2), numpy.float32)"}
{"repo": "cocos-master/cocos/particle.py", "original_string": "    def update_vertexs_from_pos(self):\n        \"\"\"Helper function to update particle quad vertices based\n        on particle position.\n        \"\"\"\n        vertexs = self.vertexs\n        delta = self.delta_pos_to_vertex\n        pos = self.particle_pos\n        vertexs[:] = delta + pos[:, numpy.newaxis, :]\n", "docstring": "Helper function to update particle quad vertices based"}
{"repo": "cocos-master/cocos/batch.py", "original_string": "    def visit(self):\n        \"\"\" All children are placed in to self.batch, so nothing to visit \"\"\"\n        if not self.visible:\n            return\n        gl.glPushMatrix()\n        self.transform()\n        self.batch.draw()\n        gl.glPopMatrix()\n", "docstring": "All children are placed in to self.batch, so nothing to visit \n"}
{"repo": "cocos-master/cocos/grid.py", "original_string": "    def before_draw(self):\n        \"\"\"Binds the framebuffer to a texture\n        and set a 2d projection before binding\n        to prevent calculating a new texture\n        \"\"\"\n        self._set_2d_projection()\n        # capture before drawing\n        self.grabber.before_render(self.texture)\n", "docstring": "Binds the framebuffer to a texture"}
{"repo": "cocos-master/cocos/grid.py", "original_string": "    def _set_2d_projection(cls):\n        # director.set_2d_projection()\n        width, height = director.get_window_size()\n        gl.glLoadIdentity()\n        gl.glViewport(0, 0, width, height)\n        gl.glMatrixMode(gl.GL_PROJECTION)\n        gl.glLoadIdentity()\n        gl.glOrtho(0, width, 0, height, -100, 100)\n        gl.glMatrixMode(gl.GL_MODELVIEW)\n", "docstring": "director.set_2d_projection()"}
{"repo": "cocos-master/cocos/grid.py", "original_string": "    def _init(self):\n        # calculate vertex, textures depending on screen size\n        idx_pts, ver_pts_idx, tex_pts_idx = self._calculate_vertex_points()\n        #: indexed vertex array that can be transformed.\n        #: it has these attributes:\n        #:\n        #:    - vertices\n        #:    - colors\n        #:    - tex_coords\n        #:\n        #: for more information refer to pyglet's documentation: pyglet.graphics.vertex_list_indexed\n        self.vertex_list = pyglet.graphics.vertex_list_indexed((self.grid.x + 1) * (self.grid.y + 1),\n                                                               idx_pts, \"t2f\", \"v3f/stream\", \"c4B\")\n        #: original vertex array of the grid. (read-only)\n        self.vertex_points = ver_pts_idx[:]\n        self.vertex_list.vertices = ver_pts_idx\n        self.vertex_list.tex_coords = tex_pts_idx\n        self.vertex_list.colors = (255, 255, 255, 255) * (self.grid.x + 1) * (self.grid.y + 1)\n", "docstring": "calculate vertex, textures depending on screen size"}
{"repo": "cocos-master/cocos/grid.py", "original_string": "    def get_original_vertex(self, x, y):\n        \"\"\"Get the original vertex coordinate.\n        The original vertices are the ones weren't modified by the current action.\n        :Parameters:\n            `x` : int\n               x-vertex\n            `y` : int\n               y-vertex\n        :rtype: (float, float, float)\n        \"\"\"\n        idx = (x * (self.grid.y + 1) + y) * 3\n        x = self.vertex_points[idx]\n        y = self.vertex_points[idx + 1]\n        z = self.vertex_points[idx + 2]\n        return x, y, z\n", "docstring": "Get the original vertex coordinate."}
{"repo": "cocos-master/cocos/grid.py", "original_string": "    def _init(self):\n        # calculate vertex, textures depending on screen size\n        ver_pts, tex_pts = self._calculate_vertex_points()\n        #: vertex array that can be transformed.\n        #: it has these attributes:\n        #:\n        #:    - vertices\n        #:    - colors\n        #:    - tex_coords\n        #:\n        #: for more information refer to pyglet's documentation: pyglet.graphics.vertex_list\n        self.vertex_list = pyglet.graphics.vertex_list(self.grid.x * self.grid.y * 4,\n                                                       \"t2f\", \"v3f/stream\", \"c4B\")\n        #: original vertex array of the grid. (read-only)\n        self.vertex_points = ver_pts[:]\n        self.vertex_list.vertices = ver_pts\n        self.vertex_list.tex_coords = tex_pts\n        self.vertex_list.colors = (255, 255, 255, 255) * self.grid.x * self.grid.y * 4\n", "docstring": "calculate vertex, textures depending on screen size"}
{"repo": "cocos-master/cocos/grid.py", "original_string": "    def get_original_tile(self, x, y):\n        \"\"\"Get the 4-original tile coordinates.\n        Coordinates positions::\n            3 <-- 2\n                  ^\n                  |\n            0 --> 1\n        :Parameters:\n            `x` : int\n                x coordinate of the tile\n            `y` : int\n                y coordinate of the tile\n        :rtype: [ float, float, float, float, float, float, float, float, float, float, float, float ]\n        :returns: The 4 coordinates with the following order: x0, y0, z0, x1, y1, z1,...,x3, y3, z3\n        \"\"\"\n        idx = (self.grid.y * x + y) * 4 * 3\n        return self.vertex_points[idx:idx + 12]\n", "docstring": "Get the 4-original tile coordinates."}
{"repo": "cocos-master/cocos/cocosnode.py", "original_string": "    def _set_parent(self, parent):\n        if parent is None:\n            self._parent = None\n        else:\n            self._parent = weakref.ref(parent)\n", "docstring": "if parent is None:"}
{"repo": "cocos-master/cocos/cocosnode.py", "original_string": "    def _get_x(self):\n        return self._x\n", "docstring": "return self._x"}
{"repo": "cocos-master/cocos/cocosnode.py", "original_string": "    def add(self, child, z=0, name=None):\n        \"\"\"Adds a child and if it becomes part of the active scene, it calls\n        its :meth:`on_enter` method.\n        Arguments:\n            child (CocosNode):\n                object to be added\n            z (Optional[float]):\n                the child z index. Defaults to 0.\n            name (Optional[str]):\n                Name of the child. Defaults to ``None``\n        Returns:\n            CocosNode: self\n        \"\"\"\n        # child must be a subclass of supported_classes\n        # if not isinstance( child, self.supported_classes ):\n        #    raise TypeError(\"%s is not instance of: %s\" % (type(child), self.supported_classes) )\n        if name:\n            if name in self.children_names:\n                raise Exception(\"Name already exists: %s\" % name)\n            self.children_names[name] = child\n        child.parent = self\n        elem = z, child\n        # inlined and customized bisect.insort_right, the stock one fails in py3\n        lo = 0\n        hi = len(self.children)\n        a = self.children\n        while lo < hi:\n            mid = (lo+hi) // 2\n            if z < a[mid][0]:\n                hi = mid\n            else:\n                lo = mid + 1\n        self.children.insert(lo, elem)\n        if self.is_running:\n            child.on_enter()\n        return self\n", "docstring": "Adds a child and if it becomes part of the active scene, it calls"}
{"repo": "cocos-master/cocos/cocosnode.py", "original_string": "    def remove(self, obj):\n        \"\"\"Removes a child given its name or object\n        If the node was added with name, it is better to remove by name, else\n        the name will be unavailable for further adds (and will raise an \n        Exception if add with this same name is attempted)\n        If the node was part of the active scene, its :meth:`on_exit` method \n        will be called.\n        Arguments:\n            obj (str or object):\n                Name of the reference to be removed or object to be removed.\n        \"\"\"\n        if isinstance(obj, string_types):\n            if obj in self.children_names:\n                child = self.children_names.pop(obj)\n                self._remove(child)\n            else:\n                raise Exception(\"Child not found: %s\" % obj)\n        else:\n            self._remove(obj)\n", "docstring": "Removes a child given its name or object"}
{"repo": "cocos-master/cocos/cocosnode.py", "original_string": "    def get_children(self):\n        \"\"\"Return a list with the node's children, order is back to front.\n        Returns:\n            list[CocosNode]: children of this node, ordered back to front.\n        \"\"\"\n        return [c for (z, c) in self.children]\n", "docstring": "Return a list with the node's children, order is back to front."}
{"repo": "cocos-master/cocos/cocosnode.py", "original_string": "    def get(self, name):\n        \"\"\"Gets a child given its name.\n        Arguments:\n            name (str):\n                name of the reference to retrieve.\n        Returns:\n            CocosNode: The child named 'name'. Will raise an ``Exception`` if \n            not present.\n        Warning:\n            If a node is added with name, then removing it differently\n            than by name will prevent the name to be recycled: attempting to add \n            another node with this name will produce an Exception.\n        \"\"\"\n        if name in self.children_names:\n            return self.children_names[name]\n        else:\n            raise Exception(\"Child not found: %s\" % name)\n", "docstring": "Gets a child given its name."}
{"repo": "cocos-master/cocos/cocosnode.py", "original_string": "    def remove_action(self, action):\n        \"\"\"Removes an action from the node actions container, potentially \n        calling ``action.stop()``.\n        If action was running, :meth:`.Action.stop` is called.\n        Mandatory interface to remove actions in the node actions container.\n        When skipping this there is the posibility to double call the \n        ``action.stop``\n        Arguments:\n            action (Action):\n                Action to be removed.\n                Must be the return value for a :meth:`do` call\n        \"\"\"\n        assert action in self.actions\n        if not action.scheduled_to_remove:\n            action.scheduled_to_remove = True\n            action.stop()\n            action.target = None\n            self.to_remove.append(action)\n", "docstring": "Removes an action from the node actions container, potentially"}
{"repo": "cocos-master/cocos/cocosnode.py", "original_string": "    def get_local_transform(self):\n        \"\"\"Returns an :class:`.euclid.Matrix3` with the local transformation matrix\n        Returns:\n            euclid.Matrix3\n        \"\"\"\n        if self.is_transform_dirty:\n            matrix = euclid.Matrix3().identity()\n            matrix.translate(self._x, self._y)\n            matrix.translate(self.transform_anchor_x, self.transform_anchor_y)\n            matrix.rotate(math.radians(-self.rotation))\n            matrix.scale(self._scale * self._scale_x, self._scale * self._scale_y)\n            matrix.translate(-self.transform_anchor_x, -self.transform_anchor_y)\n            self.is_transform_dirty = False\n            self.transform_matrix = matrix\n        return self.transform_matrix\n", "docstring": "Returns an :class:`.euclid.Matrix3` with the local transformation matrix"}
{"repo": "cocos-master/cocos/cocosnode.py", "original_string": "    def point_to_world(self, p):\n        \"\"\"Returns an :class:`.euclid.Vector2` converted to world space.\n        Arguments:\n            p (Vector2): Vector to convert\n        Returns:\n            Vector2: ``p`` vector converted to world coordinates.\n        \"\"\"\n        v = euclid.Point2(p[0], p[1])\n        matrix = self.get_world_transform()\n        return matrix * v\n", "docstring": "Returns an :class:`.euclid.Vector2` converted to world space."}
{"repo": "cocos-master/cocos/cocosnode.py", "original_string": "    def get_world_inverse(self):\n        \"\"\"returns an :class:`.euclid.Matrix3` with the world inverse \n        transformation matrix.\n        Returns:\n            euclid.Matrix3\n        \"\"\"\n        matrix = self.get_local_inverse()\n        p = self.parent\n        while p is not None:\n            matrix = matrix * p.get_local_inverse()\n            p = p.parent\n        return matrix\n", "docstring": "returns an :class:`.euclid.Matrix3` with the world inverse"}
{"repo": "cocos-master/cocos/rect.py", "original_string": "    def __init__(self, x, y, width, height):\n        \"\"\"Create a Rect with the bottom-left corner at (x, y) and\n        dimensions (width, height).\n        \"\"\"\n        self._x, self._y = x, y\n        self._width, self._height = width, height\n", "docstring": "Create a Rect with the bottom-left corner at (x, y) and"}
{"repo": "cocos-master/cocos/rect.py", "original_string": "    def __ne__(self, other):\n        \"\"\"Compare the two rects.\n        >>> r1 = Rect(0, 0, 10, 10)\n        >>> r1 != Rect(0, 0, 10, 10)\n        False\n        >>> r1 != Rect(1, 0, 10, 10)\n        True\n        >>> r1 != Rect(0, 1, 10, 10)\n        True\n        >>> r1 != Rect(0, 0, 11, 10)\n        True\n        >>> r1 != Rect(0, 0, 10, 11)\n        True\n        \"\"\"\n        return not (self == other)\n", "docstring": "Compare the two rects."}
{"repo": "cocos-master/cocos/rect.py", "original_string": "    def contains(self, x, y):\n        \"\"\"Return boolean whether the point defined by x, y is inside the\n        rect area.\n        \"\"\"\n        if x < self.x or x > self.x + self.width:\n            return False\n        if y < self.y or y > self.y + self.height:\n            return False\n        return True\n", "docstring": "Return boolean whether the point defined by x, y is inside the"}
{"repo": "cocos-master/cocos/rect.py", "original_string": "    def clippedBy(self, other):\n        \"\"\"bool. True iif intersection with other is smaller than self.\n        Equivalent: True if self doesn't fit entirely into other\n        >>> r1 = Rect(0, 0, 10, 10)\n        >>> r2 = Rect(1, 1, 9, 9)\n        >>> r2.clippedBy(r1)    # r2 fits inside r1\n        False\n        >>> r1.clippedBy(r2)    # r1 is clipped by r2\n        True\n        >>> r2 = Rect(1, 1, 11, 11)\n        >>> r1.intersect(r2)\n        Rect(xy=1,1; wh=9,9)\n        >>> r1.clippedBy(r2)\n        True\n        >>> r2.intersect(r1)\n        Rect(xy=1,1; wh=9,9)\n        >>> r2.clippedBy(r1)\n        True\n        >>> r2 = Rect(11, 11, 1, 1)\n        >>> r1.clippedBy(r2)\n        True\n        \"\"\"\n        intersection = self.intersect(other)\n        if intersection is None:\n            return True\n        return intersection != self\n", "docstring": "bool. True iif intersection with other is smaller than self."}
{"repo": "cocos-master/cocos/audio/effect.py", "original_string": "    def __init__(self, filename):\n        \"\"\"Initialize the effect\n        :Parameters:\n            `filename` : fullpath\n                path of a WAV or Ogg audio file\n        \"\"\"\n        if audio._working:\n            self.sound = Sound(filename)\n        else:\n            self.sound = None\n        self.action = actions.PlayAction(self.sound)\n", "docstring": "Initialize the effect"}
{"repo": "cocos-master/cocos/audio/SDL/array.py", "original_string": "    def __init__(self, ptr, count, ctype):\n        \"\"\"Construct an array at memory location `ptr` with `count` elements\n        of type `ctype`.\n        :Parameters:\n            `ptr` : ctypes.Array, POINTER(ctype) or POINTER(ctypes.Array)\n                Starting point of the array space.  Don't use c_void_p; this\n                will not cast correctly.  If `ptr` is None, the array\n                will be created (filled with random data).\n            `count` : int\n                Number of elements in the array.\n            `ctype` : type\n                ctypes type if each element, e.g., c_ubyte, c_int, etc.\n        \"\"\"\n        count = int(count)\n        assert count >= 0\n        if not ptr:\n            ptr = (ctype * count)()\n        self.ptr = ptr\n        self.count = count\n        self.ctype = ctype\n        self._ctypes_array = None\n", "docstring": "Construct an array at memory location `ptr` with `count` elements"}
{"repo": "cocos-master/cocos/audio/SDL/array.py", "original_string": "    def as_bytes(self):\n        \"\"\"Access the array as raw bytes, regardless of the underlying\n        data type.\n        This can be useful, for example, in accessing a 32-bit colour\n        buffer by individual components rather than the encoded pixel.\n        :rtype: SDL_array\n        \"\"\"\n        return SDL_array(self.ptr, (self.count * sizeof(self.ctype)), c_ubyte)\n", "docstring": "Access the array as raw bytes, regardless of the underlying"}
{"repo": "cocos-master/cocos/audio/SDL/array.py", "original_string": "    def as_int32(self):\n        \"\"\"Access the array as 32-bit integers, regardless of the underlying\n        data type.\n        :rtype: SDL_array\n        \"\"\"\n        return SDL_array(self.ptr,\n                         self.count * sizeof(self.ctype) / 4,\n                         c_uint)\n", "docstring": "Access the array as 32-bit integers, regardless of the underlying"}
{"repo": "cocos-master/cocos/audio/SDL/array.py", "original_string": "    def have_numpy(cls):\n        \"\"\"Determine if the numpy array module is available.\n        :rtype: bool\n        \"\"\"\n        return _have_numpy\n", "docstring": "Determine if the numpy array module is available."}
{"repo": "cocos-master/cocos/audio/SDL/array.py", "original_string": "    def to_string(self):\n        \"\"\"Return a string with the contents of this array.\n        :rtype: string\n        \"\"\"\n        count = sizeof(self.ctype) * self.count\n        s = create_string_buffer(count)\n        memmove(s, self.ptr, count)\n        return s.raw\n", "docstring": "Return a string with the contents of this array."}
{"repo": "cocos-master/cocos/audio/SDL/version.py", "original_string": "def SDL_VERSIONNUM(major, minor, patch):\n    \"\"\"Turn the version numbers into a numeric value.\n    For example::\n        >>> SDL_VERSIONNUM(1, 2, 3)\n        1203\n    :Parameters:\n     - `major`: int\n     - `minor`: int\n     - `patch`: int\n    :rtype: int\n    \"\"\"\n    return x*1000 + y*100 + z\n", "docstring": "Turn the version numbers into a numeric value."}
{"repo": "cocos-master/cocos/audio/SDL/version.py", "original_string": "def SDL_VERSION_ATLEAST(major, minor, patch):\n    \"\"\"Determine if the SDL library is at least the given version.\n    :Parameters:\n     - `major`: int\n     - `minor`: int\n     - `patch`: int\n    :rtype: bool\n    \"\"\"\n    v = SDL_Linked_Version()\n    return SDL_VERSIONNUM(v.major, v.minor, v.patch) >= \\\n        SDL_VERSIONNUM(major, minor, patch)\n", "docstring": "Determine if the SDL library is at least the given version."}
{"repo": "cocos-master/cocos/audio/SDL/dll.py", "original_string": "    def assert_version_compatible(self, name, since):\n        \"\"\"Raises an exception if `since` is later than the loaded library.\"\"\"\n        if not version_compatible(since):\n            import cocos.audio.SDL.error\n            raise cocos.audio.SDL.error.SDL_NotImplementedError(\n                '%s requires SDL version %s; currently using version %s' %\n                (name, _version_string(since), _version_string(self._version)))\n", "docstring": "Raises an exception if `since` is later than the loaded library.\n"}
{"repo": "cocos-master/cocos/audio/SDL/rwops.py", "original_string": "def SDL_RWFromObject(obj):\n    \"\"\"Construct an SDL_RWops structure from a Python file-like object.\n    The object must support the following methods in the same fashion as\n    the builtin file object:\n        - ``read(len) -> data``\n        - ``write(data)``\n        - ``seek(offset, whence)``\n        - ``close()``\n    :Parameters:\n     - `obj`: Python file-like object to wrap\n    :rtype: `SDL_RWops`\n    \"\"\"\n    ctx = SDL_RWops()\n    def _seek(context, offset, whence):\n        obj.seek(offset, whence)\n        return obj.tell()\n    ctx.seek = _seek_fn(_seek)\n    def _read(context, ptr, size, maximum):\n        try:\n            r = obj.read(maximum * size)\n            memmove(ptr, r, len(r))\n            return len(r) / size\n        except:\n            return -1\n    ctx.read = _read_fn(_read)\n    def _write(context, ptr, size, num):\n        try:\n            obj.write(string_at(ptr, size*num))\n            return num\n        except:\n            return -1\n    ctx.write = _write_fn(_write)\n    def _close(context):\n        obj.close()\n    ctx.close = _close_fn(_close)\n    return ctx\n", "docstring": "Construct an SDL_RWops structure from a Python file-like object."}
{"repo": "cocos-master/cocos/audio/SDL/mixer.py", "original_string": "def Mix_QuerySpec():\n    \"\"\"Find out what the actual audio device parameters are.\n    The function returns a tuple giving each parameter value.  The first\n    value is 1 if the audio has been opened, 0 otherwise.\n    :rtype: (int, int, int, int)\n    :return: (opened, frequency, format, channels)\n    \"\"\"\n    frequency, format, channels = c_int(), c_ushort(), c_int()\n    opened = _Mix_QuerySpec(byref(frequency), byref(format), byref(channels))\n    return opened, frequency.value, format.value, channels.value\n", "docstring": "Find out what the actual audio device parameters are."}
{"repo": "cocos-master/cocos/audio/SDL/mixer.py", "original_string": "def Mix_LoadWAV(file):\n    \"\"\"Load a WAV, RIFF, AIFF, OGG or VOC file.\n    :Parameters:\n        `file` : string\n            Filename to load.\n    :rtype: `Mix_Chunk`\n    \"\"\"\n    filename = cocos.compat.asciibytes(file)\n    return Mix_LoadWAV_RW(rwops.SDL_RWFromFile(filename, b'rb'), 1)\n", "docstring": "Load a WAV, RIFF, AIFF, OGG or VOC file."}
{"repo": "cocos-master/cocos/audio/SDL/mixer.py", "original_string": "def Mix_QuickLoad_WAV(mem):\n    \"\"\"Load a wave file of the mixer format from a sequence or SDL_array.\n    :Parameters:\n     - `mem`: sequence or `SDL_array`\n    :rtype: `Mix_Chunk`\n    \"\"\"\n    ref, mem = array.to_ctypes(mem, len(mem), c_ubyte)\n    return _Mix_QuickLoad_WAV(mem)\n", "docstring": "Load a wave file of the mixer format from a sequence or SDL_array."}
{"repo": "cocos-master/cocos/audio/SDL/mixer.py", "original_string": "def Mix_QuickLoad_RAW(mem):\n    \"\"\"Load raw audio data of the mixer format from a sequence or SDL_array.\n    :Parameters:\n     - `mem`: sequence or `SDL_array`\n    :rtype: `Mix_Chunk`\n    \"\"\"\n    l = len(mem)\n    ref, mem = SDL.array.to_ctypes(mem, len(mem), c_ubyte)\n    return _Mix_QuickLoad_RAW(mem, l)\n", "docstring": "Load raw audio data of the mixer format from a sequence or SDL_array."}
{"repo": "cocos-master/cocos/audio/SDL/mixer.py", "original_string": "def Mix_SetPostMix(mix_func, udata):\n    \"\"\"Set a function that is called after all mixing is performed.\n    This can be used to provide real-time visual display of the audio\n    stream or add a custom mixer filter for the stream data.\n    :Parameters\n        `mix_func` : function\n            The function must have the signature\n            (stream: `SDL_array`, udata: any) -> None.  The first argument\n            is the array of audio data that may be modified in place.\n            `udata` is the value passed in this function.\n        `udata` : any\n            A variable that is passed to the `mix_func` function each\n            call.\n    \"\"\"\n    global _mix_postmix_ref\n    _mix_postmix_ref = _make_filter(mix_func, udata)\n    _Mix_SetPostMix(_mix_postmix_ref, None)\n", "docstring": "Set a function that is called after all mixing is performed."}
{"repo": "cocos-master/cocos/audio/SDL/mixer.py", "original_string": "def Mix_HookMusic(mix_func, udata):\n    \"\"\"Add your own music player or additional mixer function.\n    If `mix_func` is None, the default music player is re-enabled.\n    :Parameters\n        `mix_func` : function\n            The function must have the signature\n            (stream: `SDL_array`, udata: any) -> None.  The first argument\n            is the array of audio data that may be modified in place.\n            `udata` is the value passed in this function.\n        `udata` : any\n            A variable that is passed to the `mix_func` function each\n            call.\n    \"\"\"\n    global _hookmusic_ref\n    _hookmusic_ref = _make_filter(mix_func, udata)\n    _Mix_HookMusic(_hookmusic_ref, None)\n", "docstring": "Add your own music player or additional mixer function."}
{"repo": "cocos-master/cocos/audio/SDL/mixer.py", "original_string": "def Mix_HookMusicFinished(music_finished):\n    \"\"\"Add your own callback when the music has finished playing.\n    This callback is only called if the music finishes naturally.\n    :Parameters:\n        `music_finished` : function\n            The callback takes no arguments and returns no value.\n    \"\"\"\n    if music_finished:\n        _Mix_HookMusicFinished(_Mix_HookMusicFinishedFunc(music_finished))\n    else:\n        _Mix_HookMusicFinished(_Mix_HookMusicFinishedFunc())\n", "docstring": "Add your own callback when the music has finished playing."}
{"repo": "cocos-master/cocos/audio/SDL/mixer.py", "original_string": "def Mix_ChannelFinished(channel_finished):\n    \"\"\"Add your own callback when a channel has finished playing.\n    The callback may be called from the mixer's audio callback or it\n    could be called as a result of `Mix_HaltChannel`, etc.\n    Do not call `SDL_LockAudio` from this callback; you will either be\n    inside the audio callback, or SDL_mixer will explicitly lock the\n    audio before calling your callback.\n    :Parameters:\n        `channel_finished` : function\n            The function takes the channel number as its only argument,\n            and returns None.  Pass None here to disable the callback.\n    \"\"\"\n    global _channelfinished_ref\n    if channel_finished:\n        _channelfinished_ref = _Mix_ChannelFinishedFunc(channel_finished)\n    else:\n        _channelfinished_ref = _Mix_ChannelFinishedFunc()\n    _Mix_ChannelFinished(_channelfinished_ref)\n", "docstring": "Add your own callback when a channel has finished playing."}
{"repo": "cocos-master/cocos/audio/SDL/mixer.py", "original_string": "def Mix_PlayChannel(channel, chunk, loops):\n    \"\"\"Play an audio chunk on a specific channel.\n    :Parameters:\n        `channel` : int\n            If -1, play on the first free channel.\n        `chunk` : `Mix_Chunk`\n            Chunk to play\n        `loops` : int\n            If greater than zero, the number of times to play the sound;\n            if -1, loop infinitely.\n    :rtype: int\n    :return: the channel that was used to play the sound.\n    \"\"\"\n    return Mix_PlayChannelTimed(channel, chunk, loops, -1)\n", "docstring": "Play an audio chunk on a specific channel."}
{"repo": "cocos-master/cocos/audio/SDL/mixer.py", "original_string": "def Mix_FadeInChannel(channel, chunk, loops, ms):\n    \"\"\"Fade in a channel.\n    :Parameters:\n        `channel` : int\n            If -1, play on the first free channel.\n        `chunk` : `Mix_Chunk`\n            Chunk to play\n        `loops` : int\n            If greater than zero, the number of times to play the sound;\n            if -1, loop infinitely.\n        `ms` : int\n            Number of milliseconds to fade up over.\n    \"\"\"\n    Mix_FadeInChannelTimed(channel, chunk, loops, -1)\n", "docstring": "Fade in a channel."}
{"repo": "cocos-master/cocos/audio/SDL/constants.py", "original_string": "def SDL_EVENTMASK(x):\n    \"\"\"Used for predefining event masks.\"\"\"\n    return 1 << x\n", "docstring": "Used for predefining event masks.\n"}
{"repo": "cocos-master/cocos/audio/SDL/__init__.py", "original_string": "def SDL_Init(flags):\n    \"\"\"Initialise the SDL library.\n    This function loads the SDL dynamically linked library and initializes\n    the subsystems specified by `flags` (and those satisfying dependencies)\n    Unless the `SDL_INIT_NOPARACHUTE` flag is set, it will install cleanup\n    signal handlers for some commonly ignored fatal signals (like SIGSEGV).\n    The following flags are recognised:\n        - `SDL_INIT_TIMER`\n        - `SDL_INIT_AUDIO`\n        - `SDL_INIT_VIDEO`\n        - `SDL_INIT_CDROM`\n        - `SDL_INIT_JOYSTICK`\n        - `SDL_INIT_NOPARACHUTE`\n        - `SDL_INIT_EVENTTHREAD`\n        - `SDL_INIT_EVERYTHING`\n    :Parameters:\n     - `flags`: int\n    :rtype: int\n    :return: undocumented (FIXME)\n    :see: `SDL_Quit`\n    \"\"\"\n    if sys.platform == 'darwin' and flags & SDL_INIT_VIDEO:\n        import cocos.audio.SDL.darwin\n        cocos.audio.SDL.darwin.init()\n    return _SDL_Init(flags)\n", "docstring": "Initialise the SDL library."}
{"repo": "cocos-master/cocos/audio/SDL/__init__.py", "original_string": "def SDL_InitSubSystem(flags):\n    \"\"\"Initialize specific SDL subsystems.\n    :Parameters:\n     - `flags`: int\n    :rtype: int\n    :return: undocumented (FIXME)\n    :see: `SDL_Init`, `SDL_QuitSubSystem`\n    \"\"\"\n    if sys.platform == 'darwin' and flags & SDL_INIT_VIDEO:\n        import cocos.audio.SDL.darwin\n        cocos.audio.SDL.darwin.init()\n    return _SDL_InitSubSystem(flags)\n", "docstring": "Initialize specific SDL subsystems."}
{"repo": "cocos-master/cocos/audio/SDL/sound.py", "original_string": "def Sound_GetLinkedVersion():\n    \"\"\"Get the version of the dynamically linked SDL_sound library\n    :rtype: `Sound_Version`\n    \"\"\"\n    version = Sound_Version()\n    _Sound_GetLinkedVersion(byref(version))\n    return version\n", "docstring": "Get the version of the dynamically linked SDL_sound library"}
{"repo": "cocos-master/cocos/audio/SDL/sound.py", "original_string": "def Sound_AvailableDecoders():\n    \"\"\"Get a list of sound formats supported by this version of SDL_sound.\n    This is for informational purposes only. Note that the extension listed\n    is merely convention: if we list \"MP3\", you can open an MPEG-1 Layer 3\n    audio file with an extension of \"XYZ\", if you like. The file extensions\n    are informational, and only required as a hint to choosing the correct\n    decoder, since the sound data may not be coming from a file at all,\n    thanks to the abstraction that an SDL_RWops provides.\n    :rtype: list of `Sound_DecoderInfo`\n    \"\"\"\n    decoders = []\n    decoder_p = _Sound_AvailableDecoders()\n    i = 0\n    while decoder_p[i]:\n        decoders.append(decoder_p[i].contents)\n        i += 1\n    return decoders\n", "docstring": "Get a list of sound formats supported by this version of SDL_sound."}
{"repo": "cocos-master/cocos/audio/SDL/sound.py", "original_string": "def Sound_NewSampleFromMem(data, ext, desired, bufferSize):\n    \"\"\"Start decoding a new sound sample from a buffer.\n    This is identical to `Sound_NewSample`, but it creates an `SDL_RWops`\n    for you from the buffer.\n    :Parameters:\n        `data` : `SDL_array` or sequence\n            Buffer holding encoded byte sound data\n        `ext` : str\n            File extension normally associated with a data format.  Can\n            usually be None.\n        `desired` : `Sound_AudioInfo`\n            Format to convert sound data into.  Can usually be None if you\n            don't need conversion.\n        `bufferSize` : int\n            Size, in bytes, to allocate for the decoding buffer\n    :rtype: `Sound_Sample`\n    :since: Not yet released in SDL_sound\n    \"\"\"\n    ref, data = SDL.array.to_ctypes(data, len(data), c_ubyte)\n    return _Sound_NewSampleFromMem(data, len(data), ext, desired, bufferSize)\n", "docstring": "Start decoding a new sound sample from a buffer."}
{"repo": "cocos-master/cocos/audio/SDL/audio.py", "original_string": "def SDL_LoadWAV_RW(src, freesrc):\n    \"\"\"Load a WAVE from the data source.\n    The source is automatically freed if `freesrc` is non-zero.  For\n    example, to load a WAVE file, you could do::\n        SDL_LoadWAV_RW(SDL_RWFromFile('sample.wav', 'rb'), 1)\n    You need to free the returned buffer with `SDL_FreeWAV` when you\n    are done with it.\n    :Parameters:\n     - `src`: `SDL_RWops`\n     - `freesrc`: int\n    :rtype: (`SDL_AudioSpec`, `SDL_array`)\n    :return: a tuple (`spec`, `audio_buf`) where `spec` describes the data\n        format and `audio_buf` is the buffer containing audio data.\n    \"\"\"\n    spec = SDL_AudioSpec()\n    audio_buf = POINTER(c_ubyte)()\n    audio_len = c_uint()\n    _SDL_LoadWAV_RW(src, freesrc, spec, byref(audio_buf), byref(audio_len))\n    ctype = _ctype_audio_format(spec.format)\n    return (spec,\n            array.SDL_array(audio_buf, audio_len.value/sizeof(ctype), ctype))\n", "docstring": "Load a WAVE from the data source."}
{"repo": "cocos-master/cocos/audio/SDL/audio.py", "original_string": "def SDL_FreeWAV(audio_buf):\n    \"\"\"Free a buffer previously allocated with `SDL_LoadWAV_RW` or\n    `SDL_LoadWAV`.\n    :Parameters:\n     - `audio_buf`: `SDL_array`\n    \"\"\"\n    _SDL_FreeWAV(audio_buf.as_bytes().as_ctypes())\n", "docstring": "Free a buffer previously allocated with `SDL_LoadWAV_RW` or"}
{"repo": "cocos-master/cocos/audio/SDL/audio.py", "original_string": "def SDL_BuildAudioCVT(src_format, src_channels, src_rate,\n                      dst_format, dst_channels, dst_rate):\n    \"\"\"Take a source format and rate and a destination format and rate,\n    and return a `SDL_AudioCVT` structure.\n    The `SDL_AudioCVT` structure is used by `SDL_ConvertAudio` to convert\n    a buffer of audio data from one format to the other.\n    :Parameters:\n     - `src_format`: int\n     - `src_channels`: int\n     - `src_rate`: int\n     - `dst_format`: int\n     - `dst_channels`: int\n     - `dst_rate`: int\n    :rtype: `SDL_AudioCVT`\n    \"\"\"\n    cvt = SDL_AudioCVT()\n    _SDL_BuildAudioCVT(cvt, src_format, src_channels, src_rate,\n                       dst_format, dst_channels, dst_rate)\n    return cvt\n", "docstring": "Take a source format and rate and a destination format and rate,"}
{"repo": "cocos-master/cocos/audio/SDL/audio.py", "original_string": "def SDL_MixAudio(dst, src, length, volume):\n    \"\"\"Mix two audio buffers.\n    This takes two audio buffers of the playing audio format and mixes\n    them, performing addition, volume adjustment, and overflow clipping.\n    The volume ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME\n    for full audio volume.  Note this does not change hardware volume.\n    This is provided for convenience -- you can mix your own audio data.\n    :note: SDL-ctypes doesn't know the current play format, so you must\n        always pass in byte buffers (SDL_array or sequence) to this function,\n        rather than of the native data type.\n    :Parameters:\n     - `dst`: `SDL_array`\n     - `src`: `SDL_array`\n     - `length`: int\n     - `volume`: int\n    \"\"\"\n    dstref, dst = array.to_ctypes(dst, len(dst), c_ubyte)\n    srcref, src = array.to_ctypes(src, len(src), c_ubyte)\n    if len(dst) < length:\n        raise TypeError('Destination buffer too small')\n    elif len(src) < length:\n        raise TypeError('Source buffer too small')\n    _SDL_MixAudio(dst, src, length, volume)\n", "docstring": "Mix two audio buffers."}
{"repo": "cocos-master/cocos/audio/SDL/timer.py", "original_string": "def SDL_SetTimer(interval, callback):\n    \"\"\"Set a callback to run after the specified number of milliseconds has\n    elapsed.\n    The callback function is passed the current timer interval\n    and returns the next timer interval.  If the returned value is the\n    same as the one passed in, the periodic alarm continues, otherwise a\n    new alarm is scheduled.  If the callback returns 0, the periodic alarm\n    is cancelled.\n    To cancel a currently running timer, call ``SDL_SetTimer(0, None)``.\n    The timer callback function may run in a different thread than your\n    main code, and so shouldn't call any functions from within itself.\n    The maximum resolution of this timer is 10 ms, which means that if\n    you request a 16 ms timer, your callback will run approximately 20 ms\n    later on an unloaded system.  If you wanted to set a flag signaling\n    a frame update at 30 frames per second (every 33 ms), you might set a\n    timer for 30 ms::\n          SDL_SetTimer((33/10)*10, flag_update)\n    If you use this function, you need to pass `SDL_INIT_TIMER` to\n    `SDL_Init`.\n    Under UNIX, you should not use raise or use SIGALRM and this function\n    in the same program, as it is implemented using ``setitimer``.  You\n    also should not use this function in multi-threaded applications as\n    signals to multi-threaded apps have undefined behavior in some\n    implementations.\n    :Parameters:\n        `interval` : int\n            Interval before callback, in milliseconds.\n        `callback` : function\n            Callback function should accept one argument, the number of\n            milliseconds elapsed, and return the next timer interval,\n            in milliseconds.\n    \"\"\"\n    # Note SDL_SetTimer actually returns 1 on success, not 0 as documented\n    # in SDL_timer.h.\n    global _timercallback_ref\n    if callback:\n        _timercallback_ref = _SDL_TimerCallback(callback)\n    else:\n        _timercallback_ref = _SDL_TimerCallback()\n    # XXX if this fails the global ref is incorrect and old one will\n    # possibly be collected early.\n    if _SDL_SetTimer(interval, _timercallback_ref) == -1:\n        raise SDL.error.SDL_Exception(SDL.error.SDL_GetError())\n", "docstring": "Set a callback to run after the specified number of milliseconds has"}
{"repo": "cocos-master/cocos/audio/SDL/timer.py", "original_string": "def SDL_AddTimer(interval, callback, param):\n    \"\"\"Add a new timer to the pool of timers already running.\n    :Parameters:\n        `interval` : int\n            The interval before calling the callback, in milliseconds.\n        `callback` : function\n            The callback function.  It is passed the current timer\n            interval, in millseconds, and returns the next timer interval,\n            in milliseconds.  If the returned value is the same as the one\n            passed in, the periodic alarm continues, otherwise a new alarm\n            is scheduled.  If the callback returns 0, the periodic alarm is\n            cancelled.  An example callback function is::\n                def timer_callback(interval, param):\n                    print('timer called after %d ms.' % interval)\n                    return 1000     # call again in 1 second\n        `param` : any\n            A value passed to the callback function.\n    :rtype: int\n    :return: the timer ID\n    \"\"\"\n    def _callback(interval, _ignored_param):\n        return callback(interval, param)\n    func = _SDL_NewTimerCallback(_callback)\n    result = _SDL_AddTimer(interval, func, None)\n    if not result:\n        raise SDL.error.SDL_Exception(SDL.error.SDL_GetError())\n    _timer_refs[result] = func\n    return result\n", "docstring": "Add a new timer to the pool of timers already running."}
{"repo": "cocos-master/cocos/audio/pygame/base.py", "original_string": "def init():\n    \"\"\"Autoinitialize all imported pygame modules.\n    Initialize all imported pygame modules. Includes pygame modules\n    that are not part of the base modules (like font and image).\n    It does not raise exceptions, but instead silently counts which\n    modules have failed to init. The return argument contains a count\n    of the number of modules initialized, and the number of modules\n    that failed to initialize.\n    You can always initialize the modules you want by hand. The\n    modules that need it have an `init` and `quit` routine built in,\n    which you can call directly. They also have a `get_init` routine\n    which you can use to doublecheck the initialization. Note that\n    the manual `init` routines will raise an exception on error. Be\n    aware that most platforms require the display module to be\n    initialized before others. This `init` will handle that for you,\n    but if you initialize by hand, be aware of this constraint.\n    As with the manual `init` routines. It is safe to call this\n    `init` as often as you like.\n    :rtype: int, int\n    :return: (count_passed, count_failed)\n    \"\"\"\n    success = 0\n    fail = 0\n    SDL.SDL_Init(SDL.SDL_INIT_EVENTTHREAD |\n                 SDL.SDL_INIT_TIMER |\n                 SDL.SDL_INIT_NOPARACHUTE)\n    if _video_autoinit():\n        success += 1\n    else:\n        fail += 1\n    for mod in list(sys.modules.values()):\n        if (hasattr(mod, '__PYGAMEinit__') and isinstance(mod.__PYGAMEinit__,\n                                                          collections.Callable)):\n            try:\n                mod.__PYGAMEinit__()\n                success += 1\n            except:\n                fail += 1\n    return success, fail\n", "docstring": "Autoinitialize all imported pygame modules."}
{"repo": "cocos-master/cocos/audio/pygame/base.py", "original_string": "def quit():\n    \"\"\"Uninitialize all pygame modules.\n    Uninitialize all pygame modules that have been initialized. Even\n    if you initialized the module by hand, this `quit` will\n    uninitialize it for you.\n    All the pygame modules are uninitialized automatically when your\n    program exits, so you will usually not need this routine. If you\n    program plans to keep running after it is done with pygame, then\n    would be a good time to make this call.\n    \"\"\"\n    _atexit_quit()\n", "docstring": "Uninitialize all pygame modules."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "def pre_init(frequency=0, size=0, stereo=0, buffer=0):\n    \"\"\"Preset the mixer init arguments.\n    Any nonzero arguments change the default values used when the real\n    pygame.mixer.init() is called. The best way to set custom mixer playback\n    values is to call pygame.mixer.pre_init() before calling the top level\n    pygame.init().\n    :Parameters:\n        `frequency` : int\n            Sample rate, in Hertz\n        `size` : int\n            Bits per sample per channel.  Positive values for unsigned\n            values, negative for signed.\n        `stereo` : bool\n            Number of mixdown channels: False for 1, True for 2.\n        `buffer` : int\n            Bytes for mixdown buffer size; a power of two.\n    \"\"\"\n    global _request_frequency\n    global _request_size\n    global _request_stereo\n    global _request_buffer\n    if frequency:\n        _request_frequency = frequency\n    if size:\n        _request_size = size\n    if stereo:\n        _request_stereo = stereo\n    if buffer:\n        _request_buffer = buffer\n", "docstring": "Preset the mixer init arguments."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "def get_init():\n    \"\"\"Determine if the mixer is initialized.\n    If the mixer is initialized, this returns the playback arguments it\n    is using. If the mixer has not been initialized this returns None\n    The value of `size` follows the same conventions as in `init`.\n    :rtype: (int, int, bool) or None\n    :return: (frequency, size, stereo)\n    \"\"\"\n    if not SDL_WasInit(SDL_INIT_AUDIO):\n        return\n    opened, frequency, format, channels = Mix_QuerySpec()\n    if format & ~0xff:\n        format = -(format & 0xff)\n    return frequency, format, channels > 1\n", "docstring": "Determine if the mixer is initialized."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "def stop():\n    \"\"\"Stop playback of all sound channels.\n    This will stop all playback of all active mixer channels.\n    \"\"\"\n    _mixer_init_check()\n    Mix_HaltChannel(-1)\n", "docstring": "Stop playback of all sound channels."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "def unpause():\n    \"\"\"Resume paused playback of sound channels.\n    This will resume all active sound channels after they have been paused.\n    \"\"\"\n    _mixer_init_check()\n    Mix_Resume(-1)\n", "docstring": "Resume paused playback of sound channels."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "def set_num_channels(channels):\n    \"\"\"Set the total number of playback channels.\n    Sets the number of available channels for the mixer. The default value is\n    8. The value can be increased or decreased. If the value is decreased,\n    sounds playing on the truncated channels are stopped.\n    :Parameters:\n        `channels` : int\n            Number of channels\n    \"\"\"\n    _mixer_init_check()\n    Mix_AllocateChannels(channels)\n    for i in list(_channels.keys()[:]):\n        if i >= channels:\n            del channels[i]\n", "docstring": "Set the total number of playback channels."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "def set_reserved(channels):\n    \"\"\"Reserve channels from being automatically used.\n    The mixer can reserve any number of channels that will not be automatically\n    selected for playback by Sounds. If sounds are currently playing on the\n    reserved channels they will not be stopped.\n    This allows the application to reserve a specific number of channels for\n    important sounds that must not be dropped or have a guaranteed channel to\n    play on.\n    :Parameters:\n        `channels` : int\n            Number of channels to reserve.\n    \"\"\"\n    _mixer_init_check()\n    Mix_ReserveChannels(channels)\n", "docstring": "Reserve channels from being automatically used."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "def get_busy():\n    \"\"\"Test if any sound is being mixed.\n    Returns True if the mixer is busy mixing any channels. If the mixer is\n    idle then this return False.\n    :rtype: bool\n    \"\"\"\n    if not SDL_WasInit(SDL_INIT_AUDIO):\n        return False\n    return bool(Mix_Playing(-1))\n", "docstring": "Test if any sound is being mixed."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "    def __init__(self, file, _chunk=None):\n        \"\"\"Create a new Sound object from a file.\n        Load a new sound buffer from a filename or from a python file object.\n        Limited resampling will be performed to help the sample match the\n        initialize arguments for the mixer.\n        The Sound can be loaded from an OGG audio file or from an uncompressed\n        WAV.\n        :Parameters:\n            `file` : string encoded in ascii or file-like object\n                The filename or file to load.\n            `_chunk` : None\n                Internal use only.\n        \"\"\"\n        if _chunk:\n            self._chunk = _chunk\n            return\n        _mixer_init_check()\n        if hasattr(file, 'read'):\n            rw = SDL_RWFromObject(file)\n            # differ from Pygame, no freesrc here.\n            self._chunk = Mix_LoadWAV_RW(rw, 0)\n        else:\n            self._chunk = Mix_LoadWAV(file)\n", "docstring": "Create a new Sound object from a file."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "    def play(self, loops=0, maxtime=-1):\n        \"\"\"Begin sound playback.\n        Begin playback of the Sound (i.e., on the computer's speakers) on an\n        available Channel. This will forcibly select a Channel, so playback\n        may cut off a currently playing sound if necessary.\n        The loops argument controls how many times the sample will be repeated\n        after being played the first time. A value of 5 means that the sound\n        will be played once, then repeated five times, and so is played a\n        total of six times. The default value (zero) means the Sound is not\n        repeated, and so is only played once. If loops is set to -1 the Sound\n        will loop indefinitely (though you can still call stop() to stop it).\n        The maxtime argument can be used to stop playback after a given number\n        of milliseconds.\n        :Parameters:\n            `loops` : int\n                Number of times to repeat the sound after the first play.\n            `maxtime` : int\n                Maximum number of milliseconds to play for.\n        :rtype: `Channel`\n        :return: The Channel object for the channel that was selected.\n        \"\"\"\n        channelnum = Mix_PlayChannelTimed(-1, self._chunk, loops, maxtime)\n        if channelnum == -1:\n            return\n        Mix_Volume(channelnum, 128)\n        Mix_GroupChannel(channelnum, id(self))\n        channel = Channel(channelnum)\n        channel._queue = None\n        channel._sound = self\n        return channel\n", "docstring": "Begin sound playback."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "    def fadeout(self, time):\n        \"\"\"Stop sound playback after fading out.\n        This will stop playback of the sound after fading it out over the\n        time argument in milliseconds. The Sound will fade and stop on all\n        actively playing channels.\n        :Parameters:\n            `time` : int\n                Time to fade out, in milliseconds.\n        \"\"\"\n        _mixer_init_check()\n        Mix_FadeOutGroup(id(self), time)\n", "docstring": "Stop sound playback after fading out."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "    def get_volume(self):\n        \"\"\"Get the playback volume.\n        Return a value from 0.0 to 1.0 representing the volume for this Sound.\n        :rtype: float\n        \"\"\"\n        _mixer_init_check()\n        return Mix_VolumeChunk(self._chunk, -1) / 128.0\n", "docstring": "Get the playback volume."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "    def get_length(self):\n        \"\"\"Get the length of the Sound.\n        Return the length of this Sound in seconds.\n        :rtype: float\n        \"\"\"\n        _mixer_init_check()\n        opened, freq, format, channels = Mix_QuerySpec()\n        if format == AUDIO_S8 or format == AUDIO_U8:\n            mixerbytes = 1\n        else:\n            mixerbytes = 2\n        numsamples = self._chunk.alen / mixerbytes / channels\n        return numsamples / float(freq)\n", "docstring": "Get the length of the Sound."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "    def play(self, sound, loops=0, time=-1):\n        \"\"\"Play a Sound on a specific Channel.\n        This will begin playback of a Sound on a specific Channel. If the\n        Channel is currently playing any other Sound it will be stopped.\n        The loops argument has the same meaning as in Sound.play(): it is the\n        number of times to repeat the sound after the first time. If it is 3,\n        the sound will be played 4 times (the first time, then three more).\n        If loops is -1 then the playback will repeat indefinitely.\n        As in Sound.play(), the time argument can be used to\n        stop playback of the Sound after a given number of milliseconds.\n        :Parameters:\n            `sound` : `Sound`\n                Sound data to play.\n            `loops` : int\n                Number of times to repeat the sound after the first play.\n            `time` : int\n                Maximum number of milliseconds to play for.\n        \"\"\"\n        channelnum = Mix_PlayChannelTimed(self._id, sound._chunk, loops, time)\n        if channelnum != -1:\n            Mix_GroupChannel(channelnum, id(sound))\n        self._sound = sound\n        self._queue = None\n", "docstring": "Play a Sound on a specific Channel."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "    def pause(self):\n        \"\"\"Temporarily stop playback of a channel.\n        Temporarily stop the playback of sound on a channel. It can be resumed\n        at a later time with Channel.unpause()\n        \"\"\"\n        _mixer_init_check()\n        Mix_Pause(self._id)\n", "docstring": "Temporarily stop playback of a channel."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "    def fadeout(self, time):\n        \"\"\"Stop playback after fading channel out.\n        Stop playback of a channel after fading out the sound over the given\n        time argument in milliseconds.\n        :Parameters:\n            `time` : int\n                Time to fade out, in milliseconds.\n        \"\"\"\n        _mixer_init_check()\n        Mix_FadeOutChannel(self._id, time)\n", "docstring": "Stop playback after fading channel out."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "    def get_volume(self):\n        \"\"\"Get the volume of the playing channel.\n        Return the volume of the channel for the current playing sound. This\n        does not take into account stereo separation used by\n        Channel.set_volume.  The Sound object also has its own volume which is\n        mixed with the channel.\n        :rtype: float\n        \"\"\"\n        _mixer_init_check()\n        return Mix_Volume(self._id, -1) / 128.0\n", "docstring": "Get the volume of the playing channel."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "    def get_sound(self):\n        \"\"\"Get the currently playing Sound.\n        Return the actual Sound object currently playing on this channel. If\n        the channel is idle None is returned.\n        :rtype: `Sound`\n        \"\"\"\n        return self._sound\n", "docstring": "Get the currently playing Sound."}
{"repo": "cocos-master/cocos/audio/pygame/mixer.py", "original_string": "    def get_queue(self):\n        \"\"\"Return any Sound that is queued.\n        If a Sound is already queued on this channel it will be returned. Once\n        the queued sound begins playback it will no longer be on the queue.\n        :rtype: `Sound`\n        \"\"\"\n        return self._queue\n", "docstring": "Return any Sound that is queued."}
{"repo": "cocos-master/cocos/audio/pygame/music.py", "original_string": "def play(loops=0, start=0.0):\n    \"\"\"Start the playback of the music stream.\n    This will play the loaded music stream. If the music is already playing it\n    will be restarted.\n    The `loops` argument controls the number of repeats a music will play.\n    play(5) will cause the music to played once, then repeated five times, for\n    a total of six. If `loops` is -1 then the music will repeat until stopped.\n    The `start` argument controls where in the music the song starts playing.\n    The starting position is dependent on the format of music playing.\n    MP3 and OGG use the position as time (in seconds). MOD music it is the\n    pattern order number. Passing a value to `start` will raise a\n    NotImplementedError if it cannot set the start position\n    :Parameters:\n        `loops` : int\n            Number of times to repeat music after initial play through.\n        `start` : float\n            Starting time within music track to play from, in seconds.\n    \"\"\"\n    global _frequency, _format, _channels\n    mixer._mixer_init_check()\n    if not _current_music:\n        raise base.error('music not loaded')\n    Mix_HookMusicFinished(_endmusic_callback)\n    Mix_SetPostMix(_mixmusic_callback, None)\n    ready, _frequency, _format, _channels = Mix_QuerySpec()\n    if Mix_Linked_Version().is_since((1, 2, 3)):\n        volume = Mix_VolumeMusic(-1)\n        Mix_FadeInMusicPos(_current_music, loops, 0, start)\n        Mix_VolumeMusic(volume)\n    else:\n        if start:\n            raise NotImplementedError(\n                'music start position requires SDL_Mixer 1.2.3 or later')\n        Mix_PlayMusic(_current_music, loops)\n", "docstring": "Start the playback of the music stream."}
{"repo": "cocos-master/cocos/audio/pygame/music.py", "original_string": "def stop():\n    \"\"\"Stop the music playback.\n    Stops the current music if it is playing.  Any queued music will be\n    unqueued.\n    \"\"\"\n    mixer._mixer_init_check()\n    Mix_HaltMusic()\n    _free_loaded(False, True)\n", "docstring": "Stop the music playback."}
{"repo": "cocos-master/cocos/audio/pygame/music.py", "original_string": "def unpause():\n    \"\"\"Resume paused music.\n    This will resume the playback of a music stream after it has been paused.\n    \"\"\"\n    mixer._mixer_init_check()\n    Mix_ResumeMusic()\n", "docstring": "Resume paused music."}
{"repo": "cocos-master/cocos/audio/pygame/music.py", "original_string": "def set_volume(volume):\n    \"\"\"Set the music volume.\n    Set the volume of the music playback. The value argument is between\n    0.0 and 1.0. When new music is loaded the volume is reset.\n    :Parameters:\n        `volume` : float\n            Volume of music playback, in range [0.0, 1.0].\n    \"\"\"\n    mixer._mixer_init_check()\n    Mix_VolumeMusic(int(volume * 128))\n", "docstring": "Set the music volume."}
{"repo": "cocos-master/cocos/audio/pygame/music.py", "original_string": "def get_busy():\n    \"\"\"Check if the music stream is playing.\n    Returns True when the music stream is actively playing. When the music\n    is idle this returns False.\n    :rtype: bool\n    \"\"\"\n    mixer._mixer_init_check()\n    return Mix_PlayingMusic()\n", "docstring": "Check if the music stream is playing."}
{"repo": "cocos-master/cocos/audio/pygame/music.py", "original_string": "def queue(filename):\n    \"\"\"Queue a music file to follow the current one.\n    This will load a music file and queue it. A queued music file will begin\n    as soon as the current music naturally ends. If the current music is ever\n    stopped or changed, the queued song will be lost.\n    The following example will play music by Bach six times, then play\n    music by Mozart once::\n        pygame.mixer.music.load('bach.ogg')\n        pygame.mixer.music.play(5)        # Plays six times, not five\n        pygame.mixer.music.queue('mozart.ogg')\n    :Parameters:\n        `filename` : str\n            Filename of music file to queue.\n    \"\"\"\n    global _queue_music\n    mixer._mixer_init_check()\n    music = Mix_LoadMUS(filename)\n    _free_loaded(False, True)\n    _queue_music = music\n", "docstring": "Queue a music file to follow the current one."}
{"repo": "cocos-master/cocos/actions/instant_actions.py", "original_string": "    def init(self, position):\n        \"\"\"Init method.\n        :Parameters:\n            `position` : (x,y)\n                Coordinates where the sprite will be placed\n        \"\"\"\n        self.position = position\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, attrib, start, end, duration):\n        \"\"\"Init method.\n        :Parameters:\n            `attrib` : string\n                The name of the attrbiute where the value is stored\n            `start`  : float\n                The start value\n            `end`    : float\n                The end value\n            `duration` : float\n                Duration time in seconds\n        \"\"\"\n        self.attrib = attrib\n        self.duration = duration\n        self.start_p = start\n        self.end_p = end\n        self.delta = end-start\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, angle, duration):\n        \"\"\"Init method.\n        :Parameters:\n            `angle` : float\n                Degrees that the sprite will be rotated.\n                Positive degrees rotates the sprite clockwise.\n            `duration` : float\n                Duration time in seconds\n        \"\"\"\n        self.angle = angle          #: Quantity of degrees to rotate\n        self.duration = duration    #: Duration in seconds\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, angle, duration):\n        \"\"\"Init method.\n        :Parameters:\n            `angle` : float\n                Destination angle in degrees.\n            `duration` : float\n                Duration time in seconds\n        \"\"\"\n        self.angle = angle % 360      #: Destination angle in degrees\n        self.duration = duration    #: Duration in seconds\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, other, speed):\n        \"\"\"Init method.\n        :Parameters:\n            `other` : IntervalAction\n                The action that will be affected\n            `speed` : float\n                The speed change. 1 is no change.\n                2 means twice as fast, takes half the time\n                0.5 means half as fast, takes double the time\n        \"\"\"\n        self.other = other\n        self.speed = speed\n        self.duration = other.duration/speed\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, other, rate=2):\n        \"\"\"Init method.\n        :Parameters:\n            `other` : IntervalAction\n                The action that will be affected\n            `rate` : float\n                The acceleration rate. 1 is linear.\n                the new t is t**rate\n        \"\"\"\n        self.other = other\n        self.rate = rate\n        self.duration = other.duration\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, other):\n        \"\"\"Init method.\n        :Parameters:\n            `other` : IntervalAction\n                The action that will be affected\n        \"\"\"\n        self.other = other\n        self.duration = other.duration\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, dst_coords, duration=5):\n        \"\"\"Init method.\n        :Parameters:\n            `dst_coords` : (x,y)\n                Coordinates where the sprite will be placed at the end of the action\n            `duration` : float\n                Duration time in seconds\n        \"\"\"\n        self.end_position = Point2(*dst_coords)\n        self.duration = duration\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, delta, duration=5):\n        \"\"\"Init method.\n        :Parameters:\n            `delta` : (x,y)\n                Delta coordinates\n            `duration` : float\n                Duration time in seconds\n        \"\"\"\n        self.delta = Point2(*delta)\n        self.duration = duration\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, duration):\n        \"\"\"Init method.\n        :Parameters:\n            `duration` : float\n                Seconds that it will take to fade\n        \"\"\"\n        self.duration = duration\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, alpha, duration):\n        \"\"\"Init method.\n        :Parameters:\n            `alpha` : float\n                0-255 value of opacity\n            `duration` : float\n                Seconds that it will take to fade\n        \"\"\"\n        self.alpha = alpha\n        self.duration = duration\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, scale, duration=5):\n        \"\"\"Init method.\n        :Parameters:\n            `scale` : float\n                scale factor\n            `duration` : float\n                Duration time in seconds\n        \"\"\"\n        self.end_scale = scale\n        self.duration = duration\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, times, duration):\n        \"\"\"Init method.\n        :Parameters:\n            `times` : integer\n                Number of times to blink\n            `duration` : float\n                Duration time in seconds\n        \"\"\"\n        self.times = times\n        self.duration = duration\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, bezier, duration=5, forward=True):\n        \"\"\"Init method\n        :Parameters:\n            `bezier` : bezier_configuration instance\n                A bezier configuration\n            `duration` : float\n                Duration time in seconds\n        \"\"\"\n        self.duration = duration\n        self.bezier = bezier\n        self.forward = forward\n", "docstring": "Init method"}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, y=150, x=120, jumps=1, duration=5):\n        \"\"\"Init method\n        :Parameters:\n            `y` : integer\n                Height of jumps\n            `x` : integer\n                horizontal movement relative to the startin position\n            `jumps` : integer\n                quantity of jumps\n            `duration` : float\n                Duration time in seconds\n        \"\"\"\n        import warnings\n        warnings.warn('Deprecated \"Jump\" action. Consider using JumpBy instead', DeprecationWarning)\n        self.y = y\n        self.x = x\n        self.duration = duration\n        self.jumps = jumps\n", "docstring": "Init method"}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, position=(0, 0), height=100, jumps=1, duration=5):\n        \"\"\"Init method\n        :Parameters:\n            `position` : integer x integer tuple\n                horizontal and vertical movement relative to the\n                starting position\n            `height` : integer\n                Height of jumps\n            `jumps` : integer\n                quantity of jumps\n            `duration` : float\n                Duration time in seconds\n        \"\"\"\n        self.position = position\n        self.height = height\n        self.duration = duration\n        self.jumps = jumps\n", "docstring": "Init method"}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, delay):\n        \"\"\"Init method\n        :Parameters:\n            `delay` : float\n                Seconds of delay\n        \"\"\"\n        self.duration = delay\n", "docstring": "Init method"}
{"repo": "cocos-master/cocos/actions/interval_actions.py", "original_string": "    def init(self, low, hi):\n        \"\"\"Init method\n        :Parameters:\n            `low` : float\n                Minimun seconds of delay\n            `hi` : float\n                Maximun seconds of delay\n        \"\"\"\n        self.low = low\n        self.hi = hi\n", "docstring": "Init method"}
{"repo": "cocos-master/cocos/actions/move_actions.py", "original_string": "    def init(self, width, height):\n        \"\"\"Init method.\n        :Parameters:\n            `width` : integer\n                The width to wrap position at.\n            `height` : integer\n                The height to wrap position at.\n        \"\"\"\n        self.width, self.height = width, height\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/move_actions.py", "original_string": "    def init(self, width, height):\n        \"\"\"Init method.\n        :Parameters:\n            `width` : integer\n                The width to bound position at.\n            `height` : integer\n                The height to bound position at.\n        \"\"\"\n        self.width, self.height = width, height\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/tiledgrid_actions.py", "original_string": "    def place_tile(self, i, j):\n        t = self.tiles[(i, j)]\n        coords = self.get_original_tile(i, j)\n        for k in range(0, len(coords), 3):\n            coords[k] += int(t.position.x * self.target.grid.x_step)\n            coords[k+1] += int(t.position.y * self.target.grid.y_step)\n        self.set_tile(i, j, coords)\n", "docstring": "t = self.tiles[(i, j)]"}
{"repo": "cocos-master/cocos/actions/tiledgrid_actions.py", "original_string": "    def update(self, t):\n        # direction right - up\n        for i in range(self.grid.x):\n            for j in range(self.grid.y):\n                distance = self.test_func(i, j, t)\n                if distance == 0:\n                    self.turn_off_tile(i, j)\n                elif distance < 1:\n                    self.transform_tile(i, j, distance)\n                else:\n                    self.turn_on_tile(i, j)\n", "docstring": "direction right - up"}
{"repo": "cocos-master/cocos/actions/basegrid_actions.py", "original_string": "    def init(self, grid=(4, 4), duration=5):\n        \"\"\"Initialize the Grid Action\n        :Parameters:\n            `grid` : (int,int)\n                Number of horizontal and vertical quads in the grid\n            `duration` : int \n                Number of seconds that the action will last\n        \"\"\"\n        self.duration = duration\n        if not isinstance(grid, Point2):\n            grid = Point2(*grid)\n        self.grid = grid\n", "docstring": "Initialize the Grid Action"}
{"repo": "cocos-master/cocos/actions/basegrid_actions.py", "original_string": "    def get_vertex(self, x, y):\n        \"\"\"Get the current vertex coordinate\n        :Parameters:\n            `x` : int \n               x-vertex\n            `y` : int\n               y-vertex\n        :rtype: (float, float, float)\n        \"\"\"\n        return self.target.grid.get_vertex(x, y)\n", "docstring": "Get the current vertex coordinate"}
{"repo": "cocos-master/cocos/actions/basegrid_actions.py", "original_string": "    def set_vertex(self, x, y, v):\n        \"\"\"Set a vertex point is a certain value\n        :Parameters:\n            `x` : int \n               x-vertex\n            `y` : int\n               y-vertex\n            `v` : (float, float, float)\n                tuple value for the vertex\n        \"\"\"\n        return self.target.grid.set_vertex(x, y, v)\n", "docstring": "Set a vertex point is a certain value"}
{"repo": "cocos-master/cocos/actions/basegrid_actions.py", "original_string": "    def set_tile(self, x, y, coords):\n        \"\"\"Set the 4 tile coordinates\n        Coordinates positions::\n            3 <-- 2\n                  ^\n                  |\n            0 --> 1\n        :Parameters:\n            `x` : int \n                x coodinate of the tile\n            `y` : int \n                y coordinate of the tile\n            `coords` : [ float, float, float, float, float, float, float, float, float, float, float, float ]\n                The 4 coordinates in the format (x0, y0, z0, x1, y1, z1,..., x3, y3, z3)\n        \"\"\"\n        return self.target.grid.set_tile(x, y, coords)\n", "docstring": "Set the 4 tile coordinates"}
{"repo": "cocos-master/cocos/actions/basegrid_actions.py", "original_string": "    def get_original_tile(self, x, y):\n        \"\"\"Get the 4-original tile coordinates.\n        Coordinates positions::\n            3 <-- 2\n                  ^\n                  |\n            0 --> 1\n        :Parameters:\n            `x` : int\n                x coordinate of the tile\n            `y` : int\n                y coordinate of the tile\n        :rtype: [ float, float, float, float, float, float, float, float, float, float, float, float ]\n        :returns: The 4 coordinates with the following order: x0, y0, z0, x1, y1, z1,...,x3, y3, z3\n        \"\"\"\n        return self.target.grid.get_original_tile(x, y)\n", "docstring": "Get the 4-original tile coordinates."}
{"repo": "cocos-master/cocos/actions/basegrid_actions.py", "original_string": "    def init(self, other, rate=1.0):\n        \"\"\"Init method.\n        :Parameters:\n            `other` : `IntervalAction`\n                The action that will be affected\n            `rate` : float\n                The acceleration rate. 1 is linear (default value)\n        \"\"\"\n        if not hasattr(other, 'amplitude'):\n            raise GridException(\"Invalid Composition: IncAmplitude needs an action with amplitude\")\n        self.other = other\n        self.rate = rate\n        self.duration = other.duration\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/basegrid_actions.py", "original_string": "    def init(self, other, rate=1):\n        \"\"\"Init method.\n        :Parameters:\n            `other` : `IntervalAction`\n                The action that will be affected\n            `rate` : float\n                The acceleration rate. 1 is linear (default value)\n        \"\"\"\n        if not hasattr(other, 'amplitude'):\n            raise GridException(\"Invalid Composition: IncAmplitude needs an action with amplitude\")\n        \n        self.other = other\n        self.duration = other.duration\n        self.rate = rate\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/actions/camera_actions.py", "original_string": "    def init(self,  duration=2):\n        \"\"\"Initialize the Camera Action\n        :Parameters:\n            `duration` : int\n                Number of seconds that the action will last\n        \"\"\"\n        self.duration = duration\n", "docstring": "Initialize the Camera Action"}
{"repo": "cocos-master/cocos/actions/camera_actions.py", "original_string": "    def init(self, radius=None, delta_radius=0, angle_z=None, delta_z=0, angle_x=None, delta_x=0, *args, **kw):\n        \"\"\"Initialize the camera with spherical coordinates\n        :Parameters:\n            `radius` : float\n                Radius of the orbit. Default: current radius\n            `delta_radius` : float\n                Delta movement of the radius. Default: 0\n            `angle_z` : float\n                The zenith angle of the spherical coordinate in degrees. Default: current\n            `delta_z` : float\n                Relative movement of the zenith angle. Default: 0\n            `angle_x` : float\n                The azimuth angle of the spherical coordinate in degrees. Default: 0\n            `delta_x` : float\n                Relative movement of the azimuth angle. Default: 0\n        For more information regarding spherical coordinates, read this:\n            http://en.wikipedia.org/wiki/Spherical_coordinates\n        \"\"\"\n        super(OrbitCamera, self).init(*args, **kw)\n        width, height = director.get_window_size()\n        self.radius = radius\n        self.delta_radius = delta_radius\n        self.angle_x = angle_x\n        self.rad_delta_x = math.radians(delta_x)\n        self.angle_z = angle_z\n        self.rad_delta_z = math.radians(delta_z)\n", "docstring": "Initialize the camera with spherical coordinates"}
{"repo": "cocos-master/cocos/actions/camera_actions.py", "original_string": "    def get_spherical_coords(self):\n        \"\"\"returns the spherical coordinates from a cartesian coordinates\n        using this formula:\n            - http://www.math.montana.edu/frankw/ccp/multiworld/multipleIVP/spherical/body.htm#converting\n        :rtype: (radius, zenith, azimuth)\n        \"\"\"\n        eye = self.target.camera.eye - self.target.camera.center\n        radius = math.sqrt(pow(eye.x, 2) + pow(eye.y, 2) + pow(eye.z, 2))\n        s = math.sqrt(pow(eye.x, 2) + pow(eye.y, 2))\n        if s == 0:\n            s = 0.000000001\n        r = radius\n        if r == 0:\n            r = 0.000000001\n        angle_z = math.acos(eye.z / r)\n        if eye.x < 0:\n            angle_x = math.pi - math.asin(eye.y / s)\n        else:\n            angle_x = math.asin(eye.y / s)\n        radius = radius / self.target.camera.get_z_eye()\n        return radius, angle_z, angle_x\n", "docstring": "returns the spherical coordinates from a cartesian coordinates"}
{"repo": "cocos-master/cocos/actions/grid3d_actions.py", "original_string": "    def init(self, grid=(1, 1), *args, **kw):\n        if grid != (1, 1):\n            raise GridException(\"Invalid grid size.\")\n        super(FlipX3D, self).init(grid=grid, *args, **kw)\n", "docstring": "if grid != (1, 1):"}
{"repo": "cocos-master/cocos/actions/grid3d_actions.py", "original_string": "    def init(self, waves=4, amplitude=20, hsin=True, vsin=True, *args, **kw):\n        \"\"\"Initializes the Waves actions\n        :Parameters:\n            `waves` : int\n                Number of waves (2 * pi) that the action will perform. Default is 4\n            `amplitude` : int\n                Wave amplitude (height). Default is 20\n            `hsin` : bool\n                whether or not in will perform horizontal waves. Default is True\n            `vsin` : bool\n                whether or not in will perform vertical waves. Default is True\n        \"\"\"\n        super(Waves, self).init(*args, **kw)\n        #: whether or not it will do horizontal waves\n        self.hsin = hsin\n        #: whether or not it will do vertical waves\n        self.vsin = vsin\n        #: total number of wave\n        self.waves = waves\n        #: amplitude of the waves\n        self.amplitude = amplitude\n        #: amplitude rate. Default: 1.0\n        #: This value is modified by other actions like `AccelAmplitude`.\n        self.amplitude_rate = 1.0\n", "docstring": "Initializes the Waves actions"}
{"repo": "cocos-master/cocos/actions/base_actions.py", "original_string": "    def __init__(self, *args, **kwargs):\n        \"\"\"dont override - use init\"\"\"\n        self.duration = None  # The base action has potentially infinite duration\n        self.init(*args, **kwargs)\n        self.target = None              #: `CocosNode` object that is the target of the action\n        self._elapsed = 0.0\n        self._done = False\n        self.scheduled_to_remove = False  # exclusive use by cocosnode.remove_action\n", "docstring": "dont override - use init\n"}
{"repo": "cocos-master/cocos/actions/base_actions.py", "original_string": "    def __add__(self, action):\n        \"\"\"sequence operator - concatenates actions\n            action1 + action2 -> action_result\n            where action_result performs as:\n            first do all that action1 would do; then\n            perform all that action2 would do\n        \"\"\"\n        return sequence(self, action)\n", "docstring": "sequence operator - concatenates actions"}
{"repo": "cocos-master/cocos/actions/base_actions.py", "original_string": "    def __or__(self, action):\n        \"\"\"spawn operator -  runs two actions in parallel\n        action1 | action2 -> action_result\n        \"\"\"\n        return spawn(self, action)\n", "docstring": "spawn operator -  runs two actions in parallel"}
{"repo": "cocos-master/cocos/actions/base_actions.py", "original_string": "def Reverse(action):\n    \"\"\"Reverses the behavior of the action\n    Example::\n        # rotates the sprite 180 degrees in 2 seconds counter clockwise\n        action = Reverse( RotateBy( 180, 2 ) )\n        sprite.do( action )\n    \"\"\"\n    return action.__reversed__()\n", "docstring": "Reverses the behavior of the action"}
{"repo": "cocos-master/cocos/actions/base_actions.py", "original_string": "    def __init__(self, *args, **kwargs):\n        super(IntervalAction, self).__init__(*args, **kwargs)\n        self.duration = 0.0\n", "docstring": "super(IntervalAction, self).__init__(*args, **kwargs)"}
{"repo": "cocos-master/cocos/actions/base_actions.py", "original_string": "    def update(self, t):\n        \"\"\"does nothing - dont override\n        \"\"\"\n        pass\n", "docstring": "does nothing - dont override"}
{"repo": "cocos-master/cocos/actions/base_actions.py", "original_string": "    def __mul__(self, other):\n        if not isinstance(other, int):\n            raise TypeError(\"Can only multiply actions by ints\")\n        if other <= 1:\n            return self\n        return Loop_InstantAction(self, other)\n", "docstring": "if not isinstance(other, int):"}
{"repo": "cocos-master/cocos/actions/base_actions.py", "original_string": "    def init(self, one, times):\n        \"\"\"Init method\n        :Parameters:\n            `one` : `Action`\n                Action to be repeated\n            `times` : int\n                Number of times that the action will be repeated\n        \"\"\"\n        self.one = one\n        self.times = times\n        if not hasattr(self.one, \"duration\"):\n            raise Exception(\"You can only loop actions with finite duration, not repeats or others like that\")\n        self.duration = self.one.duration * times\n        self.current = None\n        self.last = None\n", "docstring": "Init method"}
{"repo": "cocos-master/cocos/actions/base_actions.py", "original_string": "def sequence(action_1, action_2):\n    \"\"\"Returns an action that runs first action_1 and then action_2\n       The returned action will be instance of the most narrow class\n       posible in InstantAction, IntervalAction, Action\n    \"\"\"\n    if isinstance(action_1, InstantAction) and isinstance(action_2, InstantAction):\n        cls = Sequence_InstantAction\n    elif (isinstance(action_1, IntervalAction) and\n          isinstance(action_2, IntervalAction)):\n        cls = Sequence_IntervalAction\n    else:\n        cls = Sequence_Action\n    return cls(action_1, action_2)\n", "docstring": "Returns an action that runs first action_1 and then action_2"}
{"repo": "cocos-master/cocos/actions/base_actions.py", "original_string": "    def init(self,  one, two, **kwargs):\n        \"\"\"Init method\n        :Parameters:\n            `one` : `Action`\n                The first action to execute\n            `two` : `Action`\n                The second action to execute\n        \"\"\"\n        self.one = copy.deepcopy(one)\n        self.two = copy.deepcopy(two)\n        self.actions = [self.one, self.two]\n        if not hasattr(self.one, \"duration\") or not hasattr(self.two, \"duration\"):\n            raise Exception(\"You can only sequence actions with finite duration, not repeats or others like that\")\n        self.duration = float(self.one.duration + self.two.duration)\n        try:\n            self.split = self.one.duration / self.duration\n        except ZeroDivisionError:\n            self.split = 0.0\n        self.last = None\n", "docstring": "Init method"}
{"repo": "cocos-master/cocos/actions/base_actions.py", "original_string": "def spawn(action_1, action_2):\n    \"\"\"Returns an action that runs action_1 and action_2 in paralel.\n       The returned action will be instance of the most narrow class\n       posible in InstantAction, IntervalAction, Action\n    \"\"\"\n    if isinstance(action_1, InstantAction) and isinstance(action_2, InstantAction):\n        cls = Spawn_InstantAction\n    elif (isinstance(action_1, IntervalAction) and\n          isinstance(action_2, IntervalAction)):\n        cls = Spawn_IntervalAction\n    else:\n        cls = Spawn_Action\n    return cls(action_1, action_2)\n", "docstring": "Returns an action that runs action_1 and action_2 in paralel."}
{"repo": "cocos-master/cocos/actions/base_actions.py", "original_string": "    def init(self, action):\n        \"\"\"Init method.\n        :Parameters:\n            `action` : `Action` instance\n                The action that will be repeated\n        \"\"\"\n        self.duration = None\n        self.original = action\n        self.action = copy.deepcopy(action)\n", "docstring": "Init method."}
{"repo": "cocos-master/cocos/scenes/transitions.py", "original_string": "    def __init__(self, dst, duration=1.25, src=None):\n        \"\"\"Initializes the transition\n        :Parameters:\n            `dst` : Scene\n                Incoming scene, the one that remains visible when the transition ends.\n            `duration` : float\n                Duration of the transition in seconds. Default: 1.25\n            `src` : Scene\n                Outgoing scene. Default: current scene\n        \"\"\"\n        super(TransitionScene, self).__init__()\n        if src is None:\n            src = director.scene\n            # if the director is already running a transition scene then terminate\n            # it so we may move on\n            if isinstance(src, TransitionScene):\n                tmp = src.in_scene.get('dst')\n                src.finish()\n                src = tmp\n        if src is dst:\n            raise Exception(\"Incoming scene must be different from outgoing scene\")\n        envelope = scene.Scene()\n        envelope.add(dst, name='dst')\n        self.in_scene = envelope   #: envelope with scene that will replace the old one\n        envelope = scene.Scene()\n        envelope.add(src, name='src')\n        self.out_scene = envelope   #: envelope with scene that will be replaced\n        self.duration = duration    #: duration in seconds of the transition\n        if not self.duration:\n            self.duration = 1.25\n        self.start()\n", "docstring": "Initializes the transition"}
{"repo": "cocos-master/cocos/scenes/transitions.py", "original_string": "    def finish(self):\n        \"\"\"Called when the time is over.\n        Envelopes are discarded and the dst scene will be the one runned by director.\n        \"\"\"\n        # devs:\n        # try to not override this method\n        # if you should, try to remain compatible with the recipe TransitionsWithPop\n        # if you can't, add in the docstring for your class that is not usable\n        # for that recipe, and bonus points if you add to the recipe that\n        # your class is not elegible for pop transitions\n        dst = self.in_scene.get('dst')\n        src = self.out_scene.get('src')\n        director.replace(dst)\n", "docstring": "Called when the time is over."}
{"repo": "cocos-master/cocos/scenes/transitions.py", "original_string": "    def hide_all(self):\n        \"\"\"Hides both the incoming and outgoing scenes\"\"\"\n        self.in_scene.visible = False\n        self.out_scene.visible = False\n", "docstring": "Hides both the incoming and outgoing scenes\n"}
{"repo": "cocos-master/cocos/scenes/transitions.py", "original_string": "    def start(self):\n        # don't call super. overriding order\n        self.add(self.in_scene, z=0)\n        self.add(self.out_scene, z=1)\n", "docstring": "don't call super. overriding order"}
{"repo": "cocos-master/cocos/scenes/transitions.py", "original_string": "    def start(self):\n        # don't call super. overriding order\n        self.add(self.in_scene, z=0)\n        self.add(self.out_scene, z=1)\n", "docstring": "don't call super. overriding order"}
{"repo": "cocos-master/cocos/scenes/transitions.py", "original_string": "    def finish(self):\n        # tested with the recipe TransitionsWithPop, works.\n        dst = self.in_scene.get('dst')\n        director.replace(dst)\n", "docstring": "tested with the recipe TransitionsWithPop, works."}
{"repo": "cocos-master/cocos/layer/scrolling.py", "original_string": "    def on_exit(self):\n        \"\"\"Called every time just before the node exits the stage.\"\"\"\n        super(ScrollableLayer, self).on_exit()\n        director.pop_handlers()\n", "docstring": "Called every time just before the node exits the stage.\n"}
{"repo": "cocos-master/cocos/layer/scrolling.py", "original_string": "    def draw(self):\n        \"\"\"Draws itself\"\"\"\n        # invoked by Cocos machinery\n        super(ScrollableLayer, self).draw()\n        # XXX overriding draw eh?\n        gl.glPushMatrix()\n        self.transform()\n        self.batch.draw()\n        gl.glPopMatrix()\n", "docstring": "Draws itself\n"}
{"repo": "cocos-master/cocos/layer/scrolling.py", "original_string": "    def on_cocos_resize(self, usable_width, usable_height):\n        \"\"\"Event handler for window resizing.\"\"\"\n        self.set_dirty()\n", "docstring": "Event handler for window resizing.\n"}
{"repo": "cocos-master/cocos/layer/scrolling.py", "original_string": "    def on_exit(self):\n        \"\"\"Called every time just before the node exits the stage.\"\"\"\n        director.pop_handlers()\n        super(ScrollingManager, self).on_exit()\n", "docstring": "Called every time just before the node exits the stage.\n"}
{"repo": "cocos-master/cocos/layer/scrolling.py", "original_string": "    def on_cocos_resize(self, usable_width, usable_height):\n        \"\"\"Event handler for Window resize.\"\"\"\n        # when using an explicit viewport you should adjust the viewport for\n        # resize changes here, before the lines that follows.\n        # Also, if your app performs other changes in viewport it should\n        # use the lines that follows to update viewport-related internal state\n        self.update_view_size()\n        self.refresh_focus()\n", "docstring": "Event handler for Window resize.\n"}
{"repo": "cocos-master/cocos/layer/scrolling.py", "original_string": "    def add(self, child, z=0, name=None):\n        \"\"\"Add the child and then update the manager's focus / viewport.\n        Args:\n            child (CocosNode): The node to add. Normally it's a\n                :class:`ScrollableLayer`.\n            z (int) : z-order for this child.\n            name (str) : The name of this child. [Optional]\n        \"\"\"\n        super(ScrollingManager, self).add(child, z=z, name=name)\n        # set the focus again and force it so we don't just skip because the\n        # focal point hasn't changed\n        self.set_focus(self.fx, self.fy, force=True)\n", "docstring": "Add the child and then update the manager's focus / viewport."}
{"repo": "cocos-master/cocos/layer/scrolling.py", "original_string": "    def screen_to_world(self, x, y):\n        \"\"\"Translates screen coordinates to world coordinates.\n        Account for viewport, layer and screen transformations.\n        Arguments:\n            x (int): x coordinate in screen space\n            y (int): y coordinate in screen space\n        Returns:\n            tuple[int, int]: coordinates in world-space\n        \"\"\"\n        # director display scaling\n        if director.autoscale:\n            x, y = director.get_virtual_coordinates(x, y)\n        # normalise x,y coord\n        ww, wh = director.get_window_size()\n        sx = x / self.view_w\n        sy = y / self.view_h\n        # get the map-space dimensions\n        vx, vy = self.childs_ox, self.childs_oy\n        # get our scaled view size\n        w = int(self.view_w / self.scale)\n        h = int(self.view_h / self.scale)\n        # convert screen pixel to map pixel\n        return int(vx + sx * w), int(vy + sy * h)\n", "docstring": "Translates screen coordinates to world coordinates."}
{"repo": "cocos-master/cocos/layer/scrolling.py", "original_string": "    def world_to_screen(self, x, y):\n        \"\"\"Translates world coordinates to screen coordinates.\n        Account for viewport, layer and screen transformations.\n        Arguments:\n            x (int): x coordinate in world space\n            y (int): y coordinate in world space\n        Returns:\n            tuple[int, int]: coordinates in screen space\n        \"\"\"\n        screen_x = self.scale * (x - self.childs_ox)\n        screen_y = self.scale * (y - self.childs_oy)\n        return int(screen_x), int(screen_y)\n", "docstring": "Translates world coordinates to screen coordinates."}
{"repo": "cocos-master/cocos/layer/scrolling.py", "original_string": "    def force_focus(self, fx, fy):\n        \"\"\"Force the manager to focus on a point, regardless of any managed layer\n        visible boundaries.\n        Args:\n            fx (int): the focus point x coordinate\n            fy (int): the focus point y coordinate\n        \"\"\"\n        # This calculation takes into account the scaling of this Layer (and\n        # therefore also its children).\n        # The result is that all children will have their viewport set, defining\n        # which of their pixels should be visible.\n        self.fx, self.fy = map(int, (fx, fy))\n        self.fx, self.fy = fx, fy\n        # get our scaled view size\n        w = int(self.view_w / self.scale)\n        h = int(self.view_h / self.scale)\n        w2, h2 = w // 2, h // 2\n        # bottom-left corner of the\n        x, y = fx - w2, fy - h2\n        childs_scroll_x = x  # - self.view_x/self.scale\n        childs_scroll_y = y  # - self.view_y/self.scale\n        self.childs_ox = childs_scroll_x - self.view_x/self.scale\n        self.childs_oy = childs_scroll_y - self.view_y/self.scale\n        for z, layer in self.children:\n            layer.set_view(childs_scroll_x, childs_scroll_y, w, h,\n                           self.view_x / self.scale, self.view_y / self.scale)\n", "docstring": "Force the manager to focus on a point, regardless of any managed layer"}
{"repo": "cocos-master/cocos/layer/scrolling.py", "original_string": "    def unset_state(self):\n        \"\"\"Unsets OpenGL state for using scissor test.\"\"\"\n        # restore gl scissors info\n        gl.glScissor(*self._old_scissor_flat)\n        if not self._scissor_enabled:\n            gl.glDisable(gl.GL_SCISSOR_TEST)\n", "docstring": "Unsets OpenGL state for using scissor test.\n"}
{"repo": "cocos-master/cocos/layer/python_interpreter.py", "original_string": "    def _scroll_to_bottom(self):\n        # on key press always move the view to the bottom of the screen\n        if self.layout.height < self.layout.content_height:\n            self.layout.anchor_y = 'bottom'\n            self.layout.y = 0\n            self.layout.view_y = 0\n        if self.caret.position < self.start_of_line:\n            self.caret.position = len(self.document.text)\n", "docstring": "on key press always move the view to the bottom of the screen"}
{"repo": "flask-restplus-server-example-master/migrations/env.py", "original_string": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n    Calls to context.execute() here emit the given string to the\n    script output.\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(url=url)\n    with context.begin_transaction():\n        context.run_migrations()\n", "docstring": "Run migrations in 'offline' mode."}
{"repo": "flask-restplus-server-example-master/migrations/versions/36954739c63_.py", "original_string": "def upgrade():\n    ### commands auto generated by Alembic - please adjust! ###\n    op.add_column('user', sa.Column('created', sa.DateTime(), nullable=True))\n    op.add_column('user', sa.Column('updated', sa.DateTime(), nullable=True))\n    with op.batch_alter_table('user') as batch_op:\n        batch_op.alter_column('password',\n               existing_type=sa.VARCHAR(length=128),\n               type_=sqlalchemy_utils.types.password.PasswordType(max_length=128),\n               existing_nullable=False,\n               postgresql_using='password::bytea')\n    ### end Alembic commands ###\n    user = sa.Table('user',\n        sa.MetaData(),\n        sa.Column('created', sa.DateTime()),\n        sa.Column('updated', sa.DateTime()),\n    )\n    op.execute(\n        user.update().values({'created': datetime.now(), 'updated': datetime.now()})\n    )\n", "docstring": "## commands auto generated by Alembic - please adjust! ###"}
{"repo": "flask-restplus-server-example-master/migrations/versions/2b5af066bb9_.py", "original_string": "def upgrade():\n    ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('team',\n        sa.Column('created', sa.DateTime(), nullable=False),\n        sa.Column('updated', sa.DateTime(), nullable=False),\n        sa.Column('id', sa.Integer(), nullable=False),\n        sa.Column('title', sa.String(length=50), nullable=False),\n        sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('team_members',\n        sa.Column('team_id', sa.Integer(), nullable=True),\n        sa.Column('user_id', sa.Integer(), nullable=True),\n        sa.ForeignKeyConstraint(['team_id'], ['team.id'], ),\n        sa.ForeignKeyConstraint(['user_id'], ['user.id'], )\n    )\n    ### end Alembic commands ###\n", "docstring": "## commands auto generated by Alembic - please adjust! ###"}
{"repo": "flask-restplus-server-example-master/migrations/versions/2e9d99288cd_.py", "original_string": "def upgrade():\n    ### commands auto generated by Alembic - please adjust! ###\n    with op.batch_alter_table('user') as batch_op:\n        batch_op.alter_column('created',\n               existing_type=sa.DATETIME(),\n               nullable=False)\n        batch_op.alter_column('updated',\n               existing_type=sa.DATETIME(),\n               nullable=False)\n    ### end Alembic commands ###\n", "docstring": "## commands auto generated by Alembic - please adjust! ###"}
{"repo": "flask-restplus-server-example-master/app/extensions/api/namespace.py", "original_string": "    def _register_access_restriction_decorator(self, func, decorator_to_register):\n        # pylint: disable=invalid-name\n        \"\"\"\n        Helper function to register decorator to function to perform checks\n        in options method\n        \"\"\"\n        if not hasattr(func, '_access_restriction_decorators'):\n            func._access_restriction_decorators = []  # pylint: disable=protected-access\n        func._access_restriction_decorators.append(decorator_to_register)  # pylint: disable=protected-access\n", "docstring": "pylint: disable=invalid-name"}
{"repo": "flask-restplus-server-example-master/app/extensions/api/namespace.py", "original_string": "        def decorator(func):\n            @wraps(func)\n            def wrapper(self_, parameters_args, *args, **kwargs):\n                queryset = func(self_, parameters_args, *args, **kwargs)\n                total_count = queryset.count()\n                return (\n                    queryset\n                        .offset(parameters_args['offset'])\n                        .limit(parameters_args['limit']),\n                    HTTPStatus.OK,\n                    {'X-Total-Count': total_count}\n                )\n            return self.parameters(parameters, locations)(wrapper)\n", "docstring": "@wraps(func)"}
{"repo": "flask-restplus-server-example-master/app/extensions/api/api.py", "original_string": "    def namespace(self, *args, **kwargs):\n        # The only purpose of this method is to pass custom Namespace class\n        _namespace = Namespace(*args, **kwargs)\n        self.namespaces.append(_namespace)\n        return _namespace\n", "docstring": "The only purpose of this method is to pass custom Namespace class"}
{"repo": "flask-restplus-server-example-master/app/extensions/flask_sqlalchemy/__init__.py", "original_string": "def set_sqlite_pragma(dbapi_connection, connection_record):\n    # pylint: disable=unused-argument\n    \"\"\"\n    SQLite supports FOREIGN KEY syntax when emitting CREATE statements for\n    tables, however by default these constraints have no effect on the\n    operation of the table.\n    http://docs.sqlalchemy.org/en/latest/dialects/sqlite.html#foreign-key-support\n    \"\"\"\n    if not isinstance(dbapi_connection, sqlite3.Connection):\n        return\n    cursor = dbapi_connection.cursor()\n    cursor.execute(\"PRAGMA foreign_keys=ON\")\n    cursor.close()\n", "docstring": "pylint: disable=unused-argument"}
{"repo": "flask-restplus-server-example-master/app/extensions/auth/oauth2.py", "original_string": "    def _tokensetter(self, token, request, *args, **kwargs):\n        # pylint: disable=method-hidden,unused-argument\n        # TODO: review expiration time\n        expires_in = token['expires_in']\n        expires = datetime.utcnow() + timedelta(seconds=expires_in)\n        try:\n            with db.session.begin():\n                token_instance = self._token_class(\n                    access_token=token['access_token'],\n                    refresh_token=token.get('refresh_token'),\n                    token_type=token['token_type'],\n                    scopes=[scope for scope in token['scope'].split(' ') if scope],\n                    expires=expires,\n                    client_id=request.client.client_id,\n                    user_id=request.user.id,\n                )\n                db.session.add(token_instance)\n        except sqlalchemy.exc.IntegrityError:\n            log.exception(\"Token-setter has failed.\")\n            return None\n        return token_instance\n", "docstring": "pylint: disable=method-hidden,unused-argument"}
{"repo": "flask-restplus-server-example-master/app/extensions/auth/oauth2.py", "original_string": "    def __init__(self, *args, **kwargs):\n        super(OAuth2Provider, self).__init__(*args, **kwargs)\n        self.invalid_response(api_invalid_response)\n", "docstring": "super(OAuth2Provider, self).__init__(*args, **kwargs)"}
{"repo": "flask-restplus-server-example-master/app/modules/users/models.py", "original_string": "        def mask(self):\n            return self.value[0]\n", "docstring": "return self.value[0]"}
{"repo": "flask-restplus-server-example-master/app/modules/users/permissions/rules.py", "original_string": "    def base(self):\n        # XXX: it handles only the first appropriate Rule base class\n        # TODO: PR this case to permission project\n        for base_class in self.__class__.__bases__:\n            if issubclass(base_class, Rule):\n                if base_class in {Rule, BaseRule}:\n                    continue\n                return base_class()\n        return None\n", "docstring": "XXX: it handles only the first appropriate Rule base class"}
{"repo": "flask-restplus-server-example-master/app/modules/users/permissions/rules.py", "original_string": "    def check(self):\n        return True\n", "docstring": "return True"}
{"repo": "flask-restplus-server-example-master/app/modules/users/permissions/rules.py", "original_string": "    def check(self):\n        # Do not override DENY_ABORT_HTTP_CODE because inherited classes will\n        # better use HTTP 403/Forbidden code on denial.\n        self.DENY_ABORT_HTTP_CODE = HTTPStatus.UNAUTHORIZED\n        # NOTE: `is_active` implies `is_authenticated`.\n        return current_user.is_active\n", "docstring": "Do not override DENY_ABORT_HTTP_CODE because inherited classes will"}
{"repo": "flask-restplus-server-example-master/app/modules/users/permissions/__init__.py", "original_string": "    def __init__(self, password_required=False, password=None, **kwargs):\n        # NOTE: kwargs is required since it is a mixin\n        \"\"\"\n        Args:\n            password_required (bool) - in some cases you may need to ask\n                users for a password to allow certain actions, enforce this\n                requirement by setting this :bool:`True`.\n            password (str) - pass a user-specified password here.\n        \"\"\"\n        self._password_required = password_required\n        self._password = password\n        super(PasswordRequiredPermissionMixin, self).__init__(**kwargs)\n", "docstring": "NOTE: kwargs is required since it is a mixin"}
{"repo": "flask-restplus-server-example-master/app/modules/users/permissions/__init__.py", "original_string": "    def rule(self):\n        return rules.InternalRoleRule() | rules.AdminRoleRule() | rules.WriteAccessRule()\n", "docstring": "return rules.InternalRoleRule() | rules.AdminRoleRule() | rules.WriteAccessRule()"}
{"repo": "flask-restplus-server-example-master/app/modules/users/permissions/__init__.py", "original_string": "    def rule(self):\n        return rules.ActiveUserRoleRule()\n", "docstring": "return rules.ActiveUserRoleRule()"}
{"repo": "flask-restplus-server-example-master/app/modules/auth/views.py", "original_string": "def access_token(*args, **kwargs):\n    # pylint: disable=unused-argument\n    \"\"\"\n    This endpoint is for exchanging/refreshing an access token.\n    Returns:\n        response (dict): a dictionary or None as the extra credentials for\n        creating the token response.\n    \"\"\"\n    return None\n", "docstring": "pylint: disable=unused-argument"}
{"repo": "flask-restplus-server-example-master/flask_restplus_patched/model.py", "original_string": "    def __deepcopy__(self, memo):\n        # XXX: Flask-RESTplus makes unnecessary data copying, while\n        # marshmallow.Schema doesn't support deepcopyng.\n        return self\n", "docstring": "XXX: Flask-RESTplus makes unnecessary data copying, while"}
{"repo": "flask-restplus-server-example-master/flask_restplus_patched/model.py", "original_string": "    def __init__(self, name, model, **kwargs):\n        # XXX: Wrapping with __schema__ is not a very elegant solution.\n        super(Model, self).__init__(name, {'__schema__': model}, **kwargs)\n", "docstring": "XXX: Wrapping with __schema__ is not a very elegant solution."}
{"repo": "flask-restplus-server-example-master/flask_restplus_patched/namespace.py", "original_string": "        def decorator(func):\n            if locations is None and parameters.many:\n                _locations = ('json', )\n            else:\n                _locations = locations\n            if _locations is not None:\n                parameters.context['in'] = _locations\n            return self.doc(params=parameters)(\n                self.response(code=HTTPStatus.UNPROCESSABLE_ENTITY)(\n                    self.WEBARGS_PARSER.use_args(parameters, locations=_locations)(\n                        func\n                    )\n                )\n            )\n", "docstring": "if locations is None and parameters.many:"}
{"repo": "flask-restplus-server-example-master/flask_restplus_patched/namespace.py", "original_string": "        def wrapper(self, *args, **kwargs):\n            if 'Access-Control-Request-Method' in flask.request.headers:\n                response = flask.Response(status=HTTPStatus.OK)\n                response.headers['Access-Control-Allow-Methods'] = \", \".join(self.methods)\n                return response\n            return func(self, *args, **kwargs)\n", "docstring": "if 'Access-Control-Request-Method' in flask.request.headers:"}
{"repo": "flask-restplus-server-example-master/flask_restplus_patched/api.py", "original_string": "    def __schema__(self):\n        # The only purpose of this method is to pass custom Swagger class\n        return Swagger(self).as_dict()\n", "docstring": "The only purpose of this method is to pass custom Swagger class"}
{"repo": "flask-restplus-server-example-master/flask_restplus_patched/api.py", "original_string": "    def namespace(self, *args, **kwargs):\n        # The only purpose of this method is to pass a custom Namespace class\n        _namespace = Namespace(*args, **kwargs)\n        self.add_namespace(_namespace)\n        return _namespace\n", "docstring": "The only purpose of this method is to pass a custom Namespace class"}
{"repo": "flask-restplus-server-example-master/flask_restplus_patched/parameters.py", "original_string": "    def make_instance(self, data):\n        # pylint: disable=unused-argument\n        \"\"\"\n        This is a no-op function which shadows ``ModelSchema.make_instance``\n        method (when inherited classes inherit from ``ModelSchema``). Thus, we\n        avoid a new instance creation because it is undesirable behaviour for\n        parameters (they can be used not only for saving new instances).\n        \"\"\"\n        return\n", "docstring": "pylint: disable=unused-argument"}
{"repo": "flask-restplus-server-example-master/flask_restplus_patched/parameters.py", "original_string": "    def add(cls, obj, field, value, state):\n        raise NotImplementedError()\n", "docstring": "raise NotImplementedError()"}
{"repo": "flask-restplus-server-example-master/tasks/app/dependencies.py", "original_string": "def install_swagger_ui(context, force=False):\n    # pylint: disable=unused-argument\n    \"\"\"\n    Install Swagger UI HTML/JS/CSS assets.\n    \"\"\"\n    log.info(\"Installing Swagger UI assets...\")\n    try:\n        _FileExistsError = FileExistsError\n    except NameError:\n        _FileExistsError = OSError\n    try:\n        os.makedirs(os.path.join(context.app.static_root, 'bower'))\n    except _FileExistsError:\n        pass\n    swagger_ui_zip_filepath = os.path.join(context.app.static_root, 'bower', 'swagger-ui.zip')\n    swagger_ui_root = os.path.join(context.app.static_root, 'bower', 'swagger-ui')\n    if force:\n        try:\n            os.remove(swagger_ui_zip_filepath)\n        except FileNotFoundError:\n            pass\n        try:\n            shutil.rmtree(swagger_ui_root)\n        except FileNotFoundError:\n            pass\n    # We are going to install Swagger UI from a fork which includes useful patches\n    log.info(\"Downloading Swagger UI assets...\")\n    download_file(\n        url=\"https://github.com/swagger-api/swagger-ui/archive/v2.2.10.zip\",\n        local_filepath=swagger_ui_zip_filepath\n    )\n    # Unzip swagger-ui.zip/dist into swagger-ui folder\n    log.info(\"Unpacking Swagger UI assets...\")\n    with zipfile.ZipFile(swagger_ui_zip_filepath) as swagger_ui_zip_file:\n        for zipped_member in swagger_ui_zip_file.infolist():\n            zipped_member_path = os.path.relpath(zipped_member.filename, 'swagger-ui-2.2.10')\n            # We only need the 'dist' folder\n            try:\n                commonpath = os.path.commonpath\n            except AttributeError:  # Python 2.x fallback\n                commonpath = os.path.commonprefix\n            if not commonpath([zipped_member_path, 'dist']):\n                continue\n            extract_path = os.path.join(swagger_ui_root, zipped_member_path)\n            if not os.path.split(zipped_member.filename)[1]:\n                # If the path is folder, just create a folder\n                try:\n                    os.makedirs(extract_path)\n                except _FileExistsError:\n                    pass\n            else:\n                # Otherwise, read zipped file contents and write them to a file\n                with swagger_ui_zip_file.open(zipped_member) as zipped_file:\n                    with open(extract_path, mode='wb') as unzipped_file:\n                        unzipped_file.write(zipped_file.read())\n    log.info(\"Swagger UI is installed.\")\n", "docstring": "pylint: disable=unused-argument"}
{"repo": "flask-restplus-server-example-master/tasks/app/db.py", "original_string": "def init(context, directory='migrations', multidb=False):\n    \"\"\"Generates a new migration\"\"\"\n    config = Config()\n    config.set_main_option('script_location', directory)\n    config.config_file_name = os.path.join(directory, 'alembic.ini')\n    if multidb:\n        command.init(config, directory, 'flask-multidb')\n    else:\n        command.init(config, directory, 'flask')\n", "docstring": "Generates a new migration\n"}
{"repo": "flask-restplus-server-example-master/tasks/app/db.py", "original_string": "def edit(context, revision='current', directory='migrations'):\n    \"\"\"Upgrade to a later version\"\"\"\n    if alembic_version >= (0, 8, 0):\n        config = _get_config(directory)\n        command.edit(config, revision)\n    else:\n        raise RuntimeError('Alembic 0.8.0 or greater is required')\n", "docstring": "Upgrade to a later version\n"}
{"repo": "flask-restplus-server-example-master/tasks/app/db.py", "original_string": "def downgrade(context, directory='migrations', revision='-1', sql=False, tag=None, x_arg=None):\n    \"\"\"Revert to a previous version\"\"\"\n    config = _get_config(directory, x_arg=x_arg)\n    if sql and revision == '-1':\n        revision = 'head:-1'\n    command.downgrade(config, revision, sql=sql, tag=tag)\n", "docstring": "Revert to a previous version\n"}
{"repo": "flask-restplus-server-example-master/tasks/app/db.py", "original_string": "def show(context, directory='migrations', revision='head'):\n    \"\"\"Show the revision denoted by the given symbol.\"\"\"\n    if alembic_version >= (0, 7, 0):\n        config = _get_config(directory)\n        command.show(config, revision)\n    else:\n        raise RuntimeError('Alembic 0.7.0 or greater is required')\n", "docstring": "Show the revision denoted by the given symbol.\n"}
{"repo": "flask-restplus-server-example-master/tasks/app/db.py", "original_string": "def history(context, directory='migrations', rev_range=None, verbose=False):\n    \"\"\"List changeset scripts in chronological order.\"\"\"\n    config = _get_config(directory)\n    if alembic_version >= (0, 7, 0):\n        command.history(config, rev_range, verbose=verbose)\n    else:\n        command.history(config, rev_range)\n", "docstring": "List changeset scripts in chronological order.\n"}
{"repo": "flask-restplus-server-example-master/tasks/app/db.py", "original_string": "def heads(context, directory='migrations', verbose=False, resolve_dependencies=False):\n    \"\"\"Show current available heads in the script directory\"\"\"\n    if alembic_version >= (0, 7, 0):\n        config = _get_config(directory)\n        command.heads(config, verbose=verbose,\n                      resolve_dependencies=resolve_dependencies)\n    else:\n        raise RuntimeError('Alembic 0.7.0 or greater is required')\n", "docstring": "Show current available heads in the script directory\n"}
{"repo": "flask-restplus-server-example-master/tasks/app/db.py", "original_string": "def branches(context, directory='migrations', verbose=False):\n    \"\"\"Show current branch points\"\"\"\n    config = _get_config(directory)\n    if alembic_version >= (0, 7, 0):\n        command.branches(config, verbose=verbose)\n    else:\n        command.branches(config)\n", "docstring": "Show current branch points\n"}
{"repo": "flask-restplus-server-example-master/tasks/app/db.py", "original_string": "def current(context, directory='migrations', verbose=False, head_only=False):\n    \"\"\"Display the current revision for each database.\"\"\"\n    config = _get_config(directory)\n    if alembic_version >= (0, 7, 0):\n        command.current(config, verbose=verbose, head_only=head_only)\n    else:\n        command.current(config)\n", "docstring": "Display the current revision for each database.\n"}
{"repo": "flask-restplus-server-example-master/tasks/app/db.py", "original_string": "def stamp(context, directory='migrations', revision='head', sql=False, tag=None):\n    \"\"\"'stamp' the revision table with the given revision; don't run any\n    migrations\"\"\"\n    config = _get_config(directory)\n    command.stamp(config, revision, sql=sql, tag=tag)\n", "docstring": "'stamp' the revision table with the given revision; don't run any"}
{"repo": "flask-restplus-server-example-master/tasks/app/db_templates/flask/env.py", "original_string": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n    Calls to context.execute() here emit the given string to the\n    script output.\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(url=url)\n    with context.begin_transaction():\n        context.run_migrations()\n", "docstring": "Run migrations in 'offline' mode."}
{"repo": "flask-restplus-server-example-master/tests/utils.py", "original_string": "    def json(self):\n        return json.loads(self.get_data(as_text=True))\n", "docstring": "return json.loads(self.get_data(as_text=True))"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/conftest.py", "original_string": "def patch_User_password_scheme():\n    # pylint: disable=invalid-name,protected-access\n    \"\"\"\n    By default, the application uses ``bcrypt`` to store passwords securely.\n    However, ``bcrypt`` is a slow hashing algorithm (by design), so it is\n    better to downgrade it to ``plaintext`` while testing, since it will save\n    us quite some time.\n    \"\"\"\n    # NOTE: It seems a hacky way, but monkeypatching is a hack anyway.\n    password_field_context = models.User.password.property.columns[0].type.context\n    # NOTE: This is used here to forcefully resolve the LazyCryptContext\n    password_field_context.context_kwds\n    password_field_context._config._init_scheme_list(('plaintext', ))\n    password_field_context._config._init_records()\n    password_field_context._config._init_default_schemes()\n    yield\n    password_field_context._config._init_scheme_list(('bcrypt', ))\n    password_field_context._config._init_records()\n    password_field_context._config._init_default_schemes()\n", "docstring": "pylint: disable=invalid-name,protected-access"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/conftest.py", "original_string": "def user_instance(patch_User_password_scheme):\n    # pylint: disable=unused-argument,invalid-name\n    user_id = 1\n    _user_instance = utils.generate_user_instance(user_id=user_id)\n    _user_instance.get_id = lambda: user_id\n    return _user_instance\n", "docstring": "pylint: disable=unused-argument,invalid-name"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/test_permissions.py", "original_string": "def test_ActiveUserRoleRule_anonymous(anonymous_user_instance):\n    # pylint: disable=unused-argument\n    assert permissions.rules.ActiveUserRoleRule().check() is False\n", "docstring": "pylint: disable=unused-argument"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/test_permissions.py", "original_string": "def test_ActiveUserRolePermission_anonymous_user(anonymous_user_instance):\n    # pylint: disable=unused-argument\n    with pytest.raises(HTTPException):\n        with permissions.ActiveUserRolePermission():\n            pass\n", "docstring": "pylint: disable=unused-argument"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/test_permissions.py", "original_string": "def test_AdminRolePermission_anonymous_user(anonymous_user_instance):\n    # pylint: disable=unused-argument\n    with pytest.raises(HTTPException):\n        with permissions.AdminRolePermission():\n            pass\n", "docstring": "pylint: disable=unused-argument"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/test_permissions.py", "original_string": "def test_AdminRolePermission_anonymous_user_with_password(anonymous_user_instance):\n    # pylint: disable=unused-argument\n    with pytest.raises(HTTPException):\n        with permissions.AdminRolePermission(password_required=True, password=\"any_password\"):\n            pass\n", "docstring": "pylint: disable=unused-argument"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/test_permissions.py", "original_string": "def test_SupervisorRolePermission_anonymous_user(anonymous_user_instance):\n    # pylint: disable=unused-argument\n    with pytest.raises(HTTPException):\n        with permissions.SupervisorRolePermission():\n            pass\n", "docstring": "pylint: disable=unused-argument"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/test_permissions.py", "original_string": "def test_SupervisorRolePermission_anonymous_user_with_password(anonymous_user_instance):\n    # pylint: disable=unused-argument\n    obj = Mock()\n    obj.check_supervisor = lambda user: False\n    with pytest.raises(HTTPException):\n        with permissions.SupervisorRolePermission(\n            obj=obj,\n            password_required=True,\n            password=\"any_password\"\n        ):\n            pass\n", "docstring": "pylint: disable=unused-argument"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/test_permissions.py", "original_string": "def test_OwnerRolePermission_anonymous_user(anonymous_user_instance):\n    # pylint: disable=unused-argument\n    with pytest.raises(HTTPException):\n        with permissions.OwnerRolePermission():\n            pass\n", "docstring": "pylint: disable=unused-argument"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/test_permissions.py", "original_string": "def test_OwnerRolePermission_anonymous_user_with_password(anonymous_user_instance):\n    # pylint: disable=unused-argument\n    obj = Mock()\n    obj.check_owner = lambda user: False\n    with pytest.raises(HTTPException):\n        with permissions.OwnerRolePermission(\n            obj=obj,\n            password_required=True,\n            password=\"any_password\"\n        ):\n            pass\n", "docstring": "pylint: disable=unused-argument"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/resources/test_getting_users_info.py", "original_string": "def test_getting_list_of_users_by_authorized_user(flask_app_client, admin_user, auth_scopes):\n    # pylint: disable=invalid-name\n    with flask_app_client.login(admin_user, auth_scopes=auth_scopes):\n        response = flask_app_client.get('/api/v1/users/')\n    assert response.status_code == 200\n    assert response.content_type == 'application/json'\n    assert isinstance(response.json, list)\n    assert set(response.json[0].keys()) >= {'id', 'username'}\n", "docstring": "pylint: disable=invalid-name"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/resources/test_getting_users_info.py", "original_string": "def test_getting_user_info_by_authorized_user(flask_app_client, regular_user, admin_user):\n    # pylint: disable=invalid-name\n    with flask_app_client.login(admin_user, auth_scopes=('users:read',)):\n        response = flask_app_client.get('/api/v1/users/%d' % regular_user.id)\n    assert response.status_code == 200\n    assert response.content_type == 'application/json'\n    assert isinstance(response.json, dict)\n    assert set(response.json.keys()) >= {'id', 'username'}\n    assert 'password' not in response.json.keys()\n", "docstring": "pylint: disable=invalid-name"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/resources/test_modifying_users_info.py", "original_string": "def test_modifying_user_info_by_owner(flask_app_client, regular_user, db):\n    # pylint: disable=invalid-name\n    saved_middle_name = regular_user.middle_name\n    with flask_app_client.login(regular_user, auth_scopes=('users:write',)):\n        response = flask_app_client.patch(\n            '/api/v1/users/%d' % regular_user.id,\n            content_type='application/json',\n            data=json.dumps([\n                {\n                    'op': 'test',\n                    'path': '/current_password',\n                    'value': regular_user.password_secret,\n                },\n                {\n                    'op': 'replace',\n                    'path': '/middle_name',\n                    'value': \"Modified Middle Name\",\n                },\n            ])\n        )\n    assert response.status_code == 200\n    assert response.content_type == 'application/json'\n    assert isinstance(response.json, dict)\n    assert set(response.json.keys()) >= {'id', 'username'}\n    assert response.json['id'] == regular_user.id\n    assert 'password' not in response.json.keys()\n    # Restore original state\n    from app.modules.users.models import User\n    user1_instance = User.query.get(response.json['id'])\n    assert user1_instance.username == regular_user.username\n    assert user1_instance.middle_name == \"Modified Middle Name\"\n    user1_instance.middle_name = saved_middle_name\n    with db.session.begin():\n        db.session.merge(user1_instance)\n", "docstring": "pylint: disable=invalid-name"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/resources/test_modifying_users_info.py", "original_string": "def test_modifying_user_info_admin_fields_by_not_admin(flask_app_client, regular_user, db):\n    # pylint: disable=invalid-name\n    with flask_app_client.login(regular_user, auth_scopes=('users:write',)):\n        response = flask_app_client.patch(\n            '/api/v1/users/%d' % regular_user.id,\n            content_type='application/json',\n            data=json.dumps([\n                {\n                    'op': 'test',\n                    'path': '/current_password',\n                    'value': regular_user.password_secret,\n                },\n                {\n                    'op': 'replace',\n                    'path': '/middle_name',\n                    'value': \"Modified Middle Name\",\n                },\n                {\n                    'op': 'replace',\n                    'path': '/is_active',\n                    'value': False,\n                },\n                {\n                    'op': 'replace',\n                    'path': '/is_regular_user',\n                    'value': False,\n                },\n                {\n                    'op': 'replace',\n                    'path': '/is_admin',\n                    'value': True,\n                },\n            ])\n        )\n    assert response.status_code == 403\n    assert response.content_type == 'application/json'\n    assert isinstance(response.json, dict)\n    assert set(response.json.keys()) >= {'status', 'message'}\n", "docstring": "pylint: disable=invalid-name"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/resources/test_modifying_users_info.py", "original_string": "def test_modifying_user_info_with_invalid_password_must_fail(flask_app_client, regular_user):\n    # pylint: disable=invalid-name\n    with flask_app_client.login(regular_user, auth_scopes=('users:write',)):\n        response = flask_app_client.patch(\n            '/api/v1/users/%d' % regular_user.id,\n            content_type='application/json',\n            data=json.dumps([\n                {\n                    'op': 'test',\n                    'path': '/current_password',\n                    'value': \"invalid_password\",\n                },\n                {\n                    'op': 'replace',\n                    'path': '/middle_name',\n                    'value': \"Modified Middle Name\",\n                },\n            ])\n        )\n    assert response.status_code == 403\n    assert response.content_type == 'application/json'\n    assert isinstance(response.json, dict)\n    assert set(response.json.keys()) >= {'status', 'message'}\n", "docstring": "pylint: disable=invalid-name"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/resources/test_signup.py", "original_string": "def test_new_user_creation(patch_User_password_scheme, flask_app_client, db):\n    # pylint: disable=invalid-name,unused-argument\n    user_id = create_new_user(\n        flask_app_client,\n        data={\n            'username': \"user1\",\n            'email': \"user1@email.com\",\n            'password': \"user1_password\",\n        }\n    )\n    assert isinstance(user_id, int)\n    # Cleanup\n    from app.modules.users.models import User\n    user1_instance = User.query.get(user_id)\n    assert user1_instance.username == \"user1\"\n    assert user1_instance.email == \"user1@email.com\"\n    assert user1_instance.password == \"user1_password\"\n    with db.session.begin():\n        db.session.delete(user1_instance)\n", "docstring": "pylint: disable=invalid-name,unused-argument"}
{"repo": "flask-restplus-server-example-master/tests/modules/users/resources/test_signup.py", "original_string": "def test_new_user_creation_with_incorrect_captcha_must_fail(flask_app_client):\n    # pylint: disable=invalid-name\n    response = create_new_user(\n        flask_app_client,\n        data={\n            'recaptcha_key': 'invalid_captcha_key',\n            'username': \"user1\",\n            'email': \"user1@email.com\",\n            'password': \"user1_password\",\n        },\n        must_succeed=False\n    )\n    assert response.status_code == 403\n    assert response.content_type == 'application/json'\n    assert set(response.json.keys()) >= {'status', 'message'}\n", "docstring": "pylint: disable=invalid-name"}
{"repo": "flask-restplus-server-example-master/tests/modules/teams/resources/test_modifying_teams.py", "original_string": "def test_new_team_creation(flask_app_client, db, regular_user):\n    # pylint: disable=invalid-name\n    team_title = \"Test Team Title\"\n    with flask_app_client.login(regular_user, auth_scopes=('teams:write', )):\n        response = flask_app_client.post('/api/v1/teams/', data={'title': team_title})\n    assert response.status_code == 200\n    assert response.content_type == 'application/json'\n    assert set(response.json.keys()) >= {'id', 'title'}\n    assert response.json['title'] == team_title\n    # Cleanup\n    team = models.Team.query.get(response.json['id'])\n    assert team.title == team_title\n    with db.session.begin():\n        db.session.delete(team)\n", "docstring": "pylint: disable=invalid-name"}
{"repo": "flask-restplus-server-example-master/tests/modules/teams/resources/test_modifying_teams.py", "original_string": "def test_new_team_creation_with_invalid_data_must_fail(flask_app_client, regular_user):\n    # pylint: disable=invalid-name\n    with flask_app_client.login(regular_user, auth_scopes=('teams:write', )):\n        response = flask_app_client.post('/api/v1/teams/', data={'title': \"\"})\n    assert response.status_code == 409\n    assert response.content_type == 'application/json'\n    assert set(response.json.keys()) >= {'status', 'message'}\n", "docstring": "pylint: disable=invalid-name"}
{"repo": "flask-restplus-server-example-master/tests/modules/auth/conftest.py", "original_string": "def regular_user_oauth2_client(regular_user, temp_db_instance_helper):\n    # pylint: disable=invalid-name,unused-argument\n    from app.modules.auth.models import OAuth2Client\n    for _ in temp_db_instance_helper(\n            OAuth2Client(\n                user=regular_user,\n                client_id='regular_user_client',\n                client_secret='regular_user_secret',\n                redirect_uris=[],\n                default_scopes=['auth:read', 'auth:write']\n            )\n        ):\n        yield _\n", "docstring": "pylint: disable=invalid-name,unused-argument"}
{"repo": "django-money-master/djmoney/money.py", "original_string": "    def decimal_places_display(self, value):\n        \"\"\" Set number of digits being displayed - `None` resets to `DECIMAL_PLACES_DISPLAY` setting \"\"\"\n        _warn_decimal_places_display_deprecated()\n        self._decimal_places_display = value\n", "docstring": "Set number of digits being displayed - `None` resets to `DECIMAL_PLACES_DISPLAY` setting \n"}
{"repo": "django-money-master/djmoney/money.py", "original_string": "    def __rtruediv__(self, other):\n        # Backported from py-moneyed, non released bug-fix\n        # https://github.com/py-moneyed/py-moneyed/blob/c518745dd9d7902781409daec1a05699799474dd/moneyed/classes.py#L217-L218\n        raise TypeError(\"Cannot divide non-Money by a Money instance.\")\n", "docstring": "Backported from py-moneyed, non released bug-fix"}
{"repo": "django-money-master/djmoney/money.py", "original_string": "def get_current_locale(for_babel=True):\n    # get_language can return None starting from Django 1.8\n    language = translation.get_language() or settings.LANGUAGE_CODE\n    locale = translation.to_locale(language)\n    if for_babel:\n        return locale\n    if locale.upper() in moneyed.localization._FORMATTER.formatting_definitions:\n        return locale\n    locale = (\"{}_{}\".format(locale, locale)).upper()\n    if locale in moneyed.localization._FORMATTER.formatting_definitions:\n        return locale\n    return \"\"\n", "docstring": "get_language can return None starting from Django 1.8"}
{"repo": "django-money-master/djmoney/contrib/exchange/backends/base.py", "original_string": "    def parse_json(self, response):\n        if isinstance(response, bytes):\n            response = response.decode(\"utf-8\")\n        return json.loads(response, parse_float=Decimal)\n", "docstring": "if isinstance(response, bytes):"}
{"repo": "django-money-master/djmoney/models/fields.py", "original_string": "    def __init__(self, field):\n        self.field = field\n        self.currency_field_name = get_currency_field_name(self.field.name, self.field)\n", "docstring": "self.field = field"}
{"repo": "django-money-master/djmoney/models/fields.py", "original_string": "    def get_default(self):\n        if isinstance(self.default, Money):\n            return self.default\n        else:\n            return super().get_default()\n", "docstring": "if isinstance(self.default, Money):"}
{"repo": "django-money-master/djmoney/models/fields.py", "original_string": "    def _has_default(self):\n        # Whether the field has an explicitly provided non-empty default.\n        # `None` was used by django-money before, and we need to check it because it can come from historical migrations\n        return self.default not in (None, NOT_PROVIDED)\n", "docstring": "Whether the field has an explicitly provided non-empty default."}
{"repo": "django-money-master/djmoney/models/managers.py", "original_string": "def _get_clean_name(model, name):\n    # Get rid of __lt, __gt etc for the currency lookup\n    if LOOKUP_SEP not in name:\n        return name\n    lookup_fields = name.split(LOOKUP_SEP)\n    field = _get_field(model, name)\n    return name.rsplit(LOOKUP_SEP, lookup_fields.index(field.name) + 1)[0]\n", "docstring": "Get rid of __lt, __gt etc for the currency lookup"}
{"repo": "django-money-master/djmoney/models/managers.py", "original_string": "def _handle_currency_field(model, name, kwargs):\n    name = _get_clean_name(model, name)\n    field = _get_field(model, name)\n    money_field = field.price_field\n    if money_field.default is not NOT_PROVIDED and money_field.name not in kwargs:\n        kwargs[\"defaults\"] = kwargs.get(\"defaults\", {})\n        kwargs[\"defaults\"][money_field.name] = money_field.default.amount\n", "docstring": "name = _get_clean_name(model, name)"}
{"repo": "django-money-master/djmoney/models/managers.py", "original_string": "def add_money_comprehension_to_queryset(qs):\n    # Decorate each relevant method with understands_money in the queryset given\n    for attr in RELEVANT_QUERYSET_METHODS:\n        method = getattr(qs, attr, None)\n        if method is not None:\n            setattr(qs, attr, understands_money(method))\n    return qs\n", "docstring": "Decorate each relevant method with understands_money in the queryset given"}
{"repo": "django-money-master/djmoney/models/managers.py", "original_string": "        def get_queryset(self, *args, **kwargs):\n            queryset = super().get_queryset(*args, **kwargs)\n            return add_money_comprehension_to_queryset(queryset)\n", "docstring": "queryset = super().get_queryset(*args, **kwargs)"}
{"repo": "django-money-master/tests/test_managers.py", "original_string": "    def test_simple(self, value, expected):\n        assert _expand_money_kwargs(ModelWithNonMoneyField, kwargs=value)[1] == expected\n", "docstring": "assert _expand_money_kwargs(ModelWithNonMoneyField, kwargs=value)[1] == expected"}
{"repo": "django-money-master/tests/test_serialization.py", "original_string": "def fixture_file(tmpdir):\n    return tmpdir.join(\"dump.json\")\n", "docstring": "return tmpdir.join(\"dump.json\")"}
{"repo": "django-money-master/tests/test_serialization.py", "original_string": "def test_patched_get_model(fixture_file):\n    \"\"\"Sometimes it is useful to patch `django.code.serializers.python._get_model`.\n    Our code should use the patched version.\"\"\"\n    data = '[{\"model\": \"testapp.unknown_model\", \"pk\": 1, \"fields\": {\"money_currency\": \"USD\", \"money\": \"1.00\"}}]'\n    fixture_file.write(data)\n    def _get_model(identifier):\n        return ModelWithDefaultAsInt\n    with patch(\"django.core.serializers.python._get_model\", _get_model):\n        loaddata(fixture_file)\n    assert ModelWithDefaultAsInt.objects.get().money == Money(1, \"USD\")\n", "docstring": "Sometimes it is useful to patch `django.code.serializers.python._get_model`."}
{"repo": "django-money-master/tests/contrib/exchange/test_backends.py", "original_string": "def no_certifi():\n    certifi = sys.modules[\"certifi\"]\n    sys.modules[\"certifi\"] = None\n    base = sys.modules.pop(\"djmoney.contrib.exchange.backends.base\")\n    yield\n    sys.modules[\"certifi\"] = certifi\n    # Return the old module to keep all existing mocks in other tests\n    sys.modules[\"djmoney.contrib.exchange.backends.base\"] = base\n", "docstring": "certifi = sys.modules[\"certifi\"]"}
{"repo": "django-money-master/tests/migrations/test_migrations.py", "original_string": "    def run(self, content):\n        return self.testdir.runpython_c(\n            dedent(\n                \"\"\"\n        import os\n        os.environ['DJANGO_SETTINGS_MODULE'] = 'app_settings'\n        from django import setup\n        setup()\n        %s\n        \"\"\"\n                % content\n            )\n        )\n", "docstring": "return self.testdir.runpython_c("}
{"repo": "xmltodict-master/ez_setup.py", "original_string": "def _build_egg(egg, archive_filename, to_dir):\n    \"\"\"Build Setuptools egg.\"\"\"\n    with archive_context(archive_filename):\n        # building an egg\n        log.warn('Building a Setuptools egg in %s', to_dir)\n        _python_cmd('setup.py', '-q', 'bdist_egg', '--dist-dir', to_dir)\n    # returning the result\n    log.warn(egg)\n    if not os.path.exists(egg):\n        raise IOError('Could not build the egg.')\n", "docstring": "Build Setuptools egg.\n"}
{"repo": "xmltodict-master/ez_setup.py", "original_string": "    def __enter__(self):\n        return self\n", "docstring": "return self"}
{"repo": "xmltodict-master/ez_setup.py", "original_string": "    def __new__(cls, *args, **kwargs):\n        \"\"\"Construct a ZipFile or ContextualZipFile as appropriate.\"\"\"\n        if hasattr(zipfile.ZipFile, '__exit__'):\n            return zipfile.ZipFile(*args, **kwargs)\n        return super(ContextualZipFile, cls).__new__(cls)\n", "docstring": "Construct a ZipFile or ContextualZipFile as appropriate.\n"}
{"repo": "xmltodict-master/ez_setup.py", "original_string": "def use_setuptools(\n        version=DEFAULT_VERSION, download_base=DEFAULT_URL,\n        to_dir=DEFAULT_SAVE_DIR, download_delay=15):\n    \"\"\"\n    Ensure that a setuptools version is installed.\n    Return None. Raise SystemExit if the requested version\n    or later cannot be installed.\n    \"\"\"\n    to_dir = os.path.abspath(to_dir)\n    # prior to importing, capture the module state for\n    # representative modules.\n    rep_modules = 'pkg_resources', 'setuptools'\n    imported = set(sys.modules).intersection(rep_modules)\n    try:\n        import pkg_resources\n        pkg_resources.require(\"setuptools>=\" + version)\n        # a suitable version is already installed\n        return\n    except ImportError:\n        # pkg_resources not available; setuptools is not installed; download\n        pass\n    except pkg_resources.DistributionNotFound:\n        # no version of setuptools was found; allow download\n        pass\n    except pkg_resources.VersionConflict as VC_err:\n        if imported:\n            _conflict_bail(VC_err, version)\n        # otherwise, unload pkg_resources to allow the downloaded version to\n        #  take precedence.\n        del pkg_resources\n        _unload_pkg_resources()\n    return _do_download(version, download_base, to_dir, download_delay)\n", "docstring": "version=DEFAULT_VERSION, download_base=DEFAULT_URL,"}
{"repo": "xmltodict-master/ez_setup.py", "original_string": "def download_file_curl(url, target):\n    cmd = ['curl', url, '--location', '--silent', '--output', target]\n    _clean_check(cmd, target)\n", "docstring": "cmd = ['curl', url, '--location', '--silent', '--output', target]"}
{"repo": "xmltodict-master/ez_setup.py", "original_string": "def download_file_insecure(url, target):\n    \"\"\"Use Python to download the file, without connection authentication.\"\"\"\n    src = urlopen(url)\n    try:\n        # Read all the data in one block.\n        data = src.read()\n    finally:\n        src.close()\n    # Write all the data in one block to avoid creating a partial file.\n    with open(target, \"wb\") as dst:\n        dst.write(data)\n", "docstring": "Use Python to download the file, without connection authentication.\n"}
{"repo": "xmltodict-master/ez_setup.py", "original_string": "def _download_args(options):\n    \"\"\"Return args for download_setuptools function from cmdline args.\"\"\"\n    return dict(\n        version=options.version,\n        download_base=options.download_base,\n        downloader_factory=options.downloader_factory,\n        to_dir=options.to_dir,\n    )\n", "docstring": "Return args for download_setuptools function from cmdline args.\n"}
{"repo": "xmltodict-master/tests/test_xmltodict.py", "original_string": "        def force_list(path, key, value):\n            \"\"\"Only return True for servers/server, but not for skip/server.\"\"\"\n            if key != 'server':\n                return False\n            return path and path[-1][0] == 'servers'\n", "docstring": "Only return True for servers/server, but not for skip/server.\n"}
{"repo": "bunch-master/bunch/__init__.py", "original_string": "    def __contains__(self, k):\n        \"\"\" >>> b = Bunch(ponies='are pretty!')\n            >>> 'ponies' in b\n            True\n            >>> 'foo' in b\n            False\n            >>> b['foo'] = 42\n            >>> 'foo' in b\n            True\n            >>> b.hello = 'hai'\n            >>> 'hello' in b\n            True\n            >>> b[None] = 123\n            >>> None in b\n            True\n            >>> b[False] = 456\n            >>> False in b\n            True\n        \"\"\"\n        try:\n            return dict.__contains__(self, k) or hasattr(self, k)\n        except:\n            return False\n", "docstring": ">>> b = Bunch(ponies='are pretty!')"}
{"repo": "bunch-master/bunch/__init__.py", "original_string": "    def __getattr__(self, k):\n        \"\"\" Gets key if it exists, otherwise throws AttributeError.\n            \n            nb. __getattr__ is only called if key is not found in normal places.\n            \n            >>> b = Bunch(bar='baz', lol={})\n            >>> b.foo\n            Traceback (most recent call last):\n                ...\n            AttributeError: foo\n            \n            >>> b.bar\n            'baz'\n            >>> getattr(b, 'bar')\n            'baz'\n            >>> b['bar']\n            'baz'\n            \n            >>> b.lol is b['lol']\n            True\n            >>> b.lol is getattr(b, 'lol')\n            True\n        \"\"\"\n        try:\n            # Throws exception if not in prototype chain\n            return object.__getattribute__(self, k)\n        except AttributeError:\n            try:\n                return self[k]\n            except KeyError:\n                raise AttributeError(k)\n", "docstring": "Gets key if it exists, otherwise throws AttributeError."}
{"repo": "bunch-master/bunch/__init__.py", "original_string": "    def __setattr__(self, k, v):\n        \"\"\" Sets attribute k if it exists, otherwise sets key k. A KeyError\n            raised by set-item (only likely if you subclass Bunch) will \n            propagate as an AttributeError instead.\n            \n            >>> b = Bunch(foo='bar', this_is='useful when subclassing')\n            >>> b.values                            #doctest: +ELLIPSIS\n            <built-in method values of Bunch object at 0x...>\n            >>> b.values = 'uh oh'\n            >>> b.values\n            'uh oh'\n            >>> b['values']\n            Traceback (most recent call last):\n                ...\n            KeyError: 'values'\n        \"\"\"\n        try:\n            # Throws exception if not in prototype chain\n            object.__getattribute__(self, k)\n        except AttributeError:\n            try:\n                self[k] = v\n            except:\n                raise AttributeError(k)\n        else:\n            object.__setattr__(self, k, v)\n", "docstring": "Sets attribute k if it exists, otherwise sets key k. A KeyError"}
{"repo": "bunch-master/bunch/__init__.py", "original_string": "    def __delattr__(self, k):\n        \"\"\" Deletes attribute k if it exists, otherwise deletes key k. A KeyError\n            raised by deleting the key--such as when the key is missing--will\n            propagate as an AttributeError instead.\n            \n            >>> b = Bunch(lol=42)\n            >>> del b.values\n            Traceback (most recent call last):\n                ...\n            AttributeError: 'Bunch' object attribute 'values' is read-only\n            >>> del b.lol\n            >>> b.lol\n            Traceback (most recent call last):\n                ...\n            AttributeError: lol\n        \"\"\"\n        try:\n            # Throws exception if not in prototype chain\n            object.__getattribute__(self, k)\n        except AttributeError:\n            try:\n                del self[k]\n            except KeyError:\n                raise AttributeError(k)\n        else:\n            object.__delattr__(self, k)\n", "docstring": "Deletes attribute k if it exists, otherwise deletes key k. A KeyError"}
{"repo": "bunch-master/bunch/__init__.py", "original_string": "    def toDict(self):\n        \"\"\" Recursively converts a bunch back into a dictionary.\n            \n            >>> b = Bunch(foo=Bunch(lol=True), hello=42, ponies='are pretty!')\n            >>> b.toDict()\n            {'ponies': 'are pretty!', 'foo': {'lol': True}, 'hello': 42}\n            \n            See unbunchify for more info.\n        \"\"\"\n        return unbunchify(self)\n", "docstring": "Recursively converts a bunch back into a dictionary."}
{"repo": "bunch-master/bunch/__init__.py", "original_string": "    def __repr__(self):\n        \"\"\" Invertible* string-form of a Bunch.\n            \n            >>> b = Bunch(foo=Bunch(lol=True), hello=42, ponies='are pretty!')\n            >>> print (repr(b))\n            Bunch(foo=Bunch(lol=True), hello=42, ponies='are pretty!')\n            >>> eval(repr(b))\n            Bunch(foo=Bunch(lol=True), hello=42, ponies='are pretty!')\n            \n            (*) Invertible so long as collection contents are each repr-invertible.\n        \"\"\"\n        keys = list(iterkeys(self))\n        keys.sort()\n        args = ', '.join(['%s=%r' % (key, self[key]) for key in keys])\n        return '%s(%s)' % (self.__class__.__name__, args)\n", "docstring": "Invertible* string-form of a Bunch."}
{"repo": "bunch-master/bunch/__init__.py", "original_string": "    def fromDict(d):\n        \"\"\" Recursively transforms a dictionary into a Bunch via copy.\n            \n            >>> b = Bunch.fromDict({'urmom': {'sez': {'what': 'what'}}})\n            >>> b.urmom.sez.what\n            'what'\n            \n            See bunchify for more info.\n        \"\"\"\n        return bunchify(d)\n", "docstring": "Recursively transforms a dictionary into a Bunch via copy."}
{"repo": "bunch-master/bunch/__init__.py", "original_string": "def bunchify(x):\n    \"\"\" Recursively transforms a dictionary into a Bunch via copy.\n        \n        >>> b = bunchify({'urmom': {'sez': {'what': 'what'}}})\n        >>> b.urmom.sez.what\n        'what'\n        \n        bunchify can handle intermediary dicts, lists and tuples (as well as \n        their subclasses), but ymmv on custom datatypes.\n        \n        >>> b = bunchify({ 'lol': ('cats', {'hah':'i win again'}), \n        ...         'hello': [{'french':'salut', 'german':'hallo'}] })\n        >>> b.hello[0].french\n        'salut'\n        >>> b.lol[1].hah\n        'i win again'\n        \n        nb. As dicts are not hashable, they cannot be nested in sets/frozensets.\n    \"\"\"\n    if isinstance(x, dict):\n        return Bunch( (k, bunchify(v)) for k,v in iteritems(x) )\n    elif isinstance(x, (list, tuple)):\n        return type(x)( bunchify(v) for v in x )\n    else:\n        return x\n", "docstring": "Recursively transforms a dictionary into a Bunch via copy."}
{"repo": "bunch-master/bunch/__init__.py", "original_string": "    def toJSON(self, **options):\n        \"\"\" Serializes this Bunch to JSON. Accepts the same keyword options as `json.dumps()`.\n            \n            >>> b = Bunch(foo=Bunch(lol=True), hello=42, ponies='are pretty!')\n            >>> json.dumps(b)\n            '{\"ponies\": \"are pretty!\", \"foo\": {\"lol\": true}, \"hello\": 42}'\n            >>> b.toJSON()\n            '{\"ponies\": \"are pretty!\", \"foo\": {\"lol\": true}, \"hello\": 42}'\n        \"\"\"\n        return json.dumps(self, **options)\n", "docstring": "Serializes this Bunch to JSON. Accepts the same keyword options as `json.dumps()`."}
{"repo": "bunch-master/bunch/__init__.py", "original_string": "    def from_yaml(loader, node):\n        \"\"\" PyYAML support for Bunches using the tag `!bunch` and `!bunch.Bunch`.\n            \n            >>> import yaml\n            >>> yaml.load('''\n            ... Flow style: !bunch.Bunch { Clark: Evans, Brian: Ingerson, Oren: Ben-Kiki }\n            ... Block style: !bunch\n            ...   Clark : Evans\n            ...   Brian : Ingerson\n            ...   Oren  : Ben-Kiki\n            ... ''') #doctest: +NORMALIZE_WHITESPACE\n            {'Flow style': Bunch(Brian='Ingerson', Clark='Evans', Oren='Ben-Kiki'), \n             'Block style': Bunch(Brian='Ingerson', Clark='Evans', Oren='Ben-Kiki')}\n            \n            This module registers itself automatically to cover both Bunch and any \n            subclasses. Should you want to customize the representation of a subclass,\n            simply register it with PyYAML yourself.\n        \"\"\"\n        data = Bunch()\n        yield data\n        value = loader.construct_mapping(node)\n        data.update(value)\n", "docstring": "PyYAML support for Bunches using the tag `!bunch` and `!bunch.Bunch`."}
{"repo": "bunch-master/bunch/__init__.py", "original_string": "    def to_yaml_safe(dumper, data):\n        \"\"\" Converts Bunch to a normal mapping node, making it appear as a\n            dict in the YAML output.\n            \n            >>> b = Bunch(foo=['bar', Bunch(lol=True)], hello=42)\n            >>> import yaml\n            >>> yaml.safe_dump(b, default_flow_style=True)\n            '{foo: [bar, {lol: true}], hello: 42}\\\\n'\n        \"\"\"\n        return dumper.represent_dict(data)\n", "docstring": "Converts Bunch to a normal mapping node, making it appear as a"}
{"repo": "bunch-master/bunch/__init__.py", "original_string": "    def to_yaml(dumper, data):\n        \"\"\" Converts Bunch to a representation node.\n            \n            >>> b = Bunch(foo=['bar', Bunch(lol=True)], hello=42)\n            >>> import yaml\n            >>> yaml.dump(b, default_flow_style=True)\n            '!bunch.Bunch {foo: [bar, !bunch.Bunch {lol: true}], hello: 42}\\\\n'\n        \"\"\"\n        return dumper.represent_mapping(u('!bunch.Bunch'), data)\n", "docstring": "Converts Bunch to a representation node."}
{"repo": "bunch-master/bunch/__init__.py", "original_string": "    def toYAML(self, **options):\n        \"\"\" Serializes this Bunch to YAML, using `yaml.safe_dump()` if \n            no `Dumper` is provided. See the PyYAML documentation for more info.\n            \n            >>> b = Bunch(foo=['bar', Bunch(lol=True)], hello=42)\n            >>> import yaml\n            >>> yaml.safe_dump(b, default_flow_style=True)\n            '{foo: [bar, {lol: true}], hello: 42}\\\\n'\n            >>> b.toYAML(default_flow_style=True)\n            '{foo: [bar, {lol: true}], hello: 42}\\\\n'\n            >>> yaml.dump(b, default_flow_style=True)\n            '!bunch.Bunch {foo: [bar, !bunch.Bunch {lol: true}], hello: 42}\\\\n'\n            >>> b.toYAML(Dumper=yaml.Dumper, default_flow_style=True)\n            '!bunch.Bunch {foo: [bar, !bunch.Bunch {lol: true}], hello: 42}\\\\n'\n        \"\"\"\n        opts = dict(indent=4, default_flow_style=False)\n        opts.update(options)\n        if 'Dumper' not in opts:\n            return yaml.safe_dump(self, **opts)\n        else:\n            return yaml.dump(self, **opts)\n", "docstring": "Serializes this Bunch to YAML, using `yaml.safe_dump()` if"}
{"repo": "algorithmic-trading-with-python-master/listings/chapter_4/4_4_portfolio_history_class.py", "original_string": "    def __init__(self):\n        # Keep track of positions, recorded in this list after close\n        self.position_history: List[Position] = []\n        self._logged_positions: Set[Position] = set()\n        # Keep track of the last seen date\n        self.last_date: pd.Timestamp = pd.Timestamp.min\n        # Readonly fields\n        self._cash_history: Dict[pd.Timestamp, Dollars] = dict()\n        self._simulation_finished = False\n        self._spy: pd.DataFrame = pd.DataFrame()\n        self._spy_log_returns: pd.Series = pd.Series()\n", "docstring": "Keep track of positions, recorded in this list after close"}
{"repo": "algorithmic-trading-with-python-master/listings/chapter_4/4_4_portfolio_history_class.py", "original_string": "    def spy(self):\n        if self._spy.empty:\n            self._spy = data_io.load_spy_data()\n        return self._spy\n", "docstring": "if self._spy.empty:"}
{"repo": "algorithmic-trading-with-python-master/listings/chapter_4/4_2_position_class.py", "original_string": "def _pdate(date: pd.Timestamp):\n    \"\"\"Pretty-print a datetime with just the date\"\"\"\n    return date.strftime(DATE_FORMAT_STR)\n", "docstring": "Pretty-print a datetime with just the date\n"}
{"repo": "algorithmic-trading-with-python-master/listings/chapter_4/4_2_position_class.py", "original_string": "    def last_value(self) -> Dollars:\n        return self.last_price * self.shares\n", "docstring": "return self.last_price * self.shares"}
{"repo": "algorithmic-trading-with-python-master/listings/chapter_4/4_2_position_class.py", "original_string": "    def percent_return(self) -> float:\n        return (self.exit_price / self.entry_price) - 1\n", "docstring": "return (self.exit_price / self.entry_price) - 1"}
{"repo": "algorithmic-trading-with-python-master/listings/chapter_4/4_6_simple_simulator_class.py", "original_string": "    def _assert_equal_columns(*args: Iterable[pd.DataFrame]):\n        column_names = set(args[0].columns.values)\n        for arg in args[1:]:\n            assert set(arg.columns.values) == column_names, \\\n                'Found unequal column names in input data frames.'\n", "docstring": "column_names = set(args[0].columns.values)"}
{"repo": "algorithmic-trading-with-python-master/listings/chapter_5/5_1_grid_search_optimizer.py", "original_string": "    def __init__(self, parameters: Parameters, performance: Performance):\n        # Make sure no collisions between performance metrics and params\n        assert len(parameters.keys() & performance.keys()) == 0, \\\n            'parameter name matches performance metric name'\n        self.parameters = parameters\n        self.performance = performance\n", "docstring": "Make sure no collisions between performance metrics and params"}
{"repo": "algorithmic-trading-with-python-master/listings/chapter_5/5_1_grid_search_optimizer.py", "original_string": "    def as_dict(self) -> Dict[str, float]:\n        \"\"\"Combines the dictionaries after we are sure of no collisions\"\"\"\n        return {**self.parameters, **self.performance}\n", "docstring": "Combines the dictionaries after we are sure of no collisions\n"}
{"repo": "algorithmic-trading-with-python-master/listings/chapter_5/5_1_grid_search_optimizer.py", "original_string": "    def plot_2d_line(self, x, y, show=True, **filter_kwargs):\n        _results = self.results\n        for k, v in filter_kwargs.items():\n            _results = _results[getattr(_results, k) == v]\n        ax = _results.plot(x, y)\n        if filter_kwargs:\n            k_str = ', '.join([f'{k}={v}' for k,v in filter_kwargs.items()])\n            ax.legend([f'{x} ({k_str})'])\n        if show:\n            plt.show()\n", "docstring": "_results = self.results"}
{"repo": "algorithmic-trading-with-python-master/listings/chapter_7/7_7_simulation_with_machine_learning_model.py", "original_string": "def simulate_portfolio():\n    # All the data we have to work with\n    symbols, eod_data, alt_data = load_data()\n    # Load classifier from file\n    classifier = load(os.path.join(SRC_DIR, 'ml_model.joblib'))\n    # Generate signals from classifier\n    print('Calculating signals ...')\n    signal = calculate_signals(classifier, symbols, eod_data, alt_data)\n    # Get rid of eod_data before valid signals\n    first_signal_date = signal.first_valid_index()\n    eod_data = eod_data[eod_data.index > first_signal_date]\n    # Set the preference to increase by row, so new trades are preferred\n    print('Calculating preference matrix ...')\n    preference = pd.DataFrame(\n        np.random.random(eod_data.shape), \n        columns=eod_data.columns, \n        index=eod_data.index,\n    )\n    # Run the simulator\n    simulator = simulation.SimpleSimulator(\n        initial_cash=10000,\n        max_active_positions=10,\n        percent_slippage=0.0005,\n        trade_fee=1,\n    )\n    simulator.simulate(eod_data, signal, preference)\n    # Print results\n    simulator.portfolio_history.print_position_summaries()\n    simulator.print_initial_parameters()\n    simulator.portfolio_history.print_summary()\n    simulator.portfolio_history.plot()\n    simulator.portfolio_history.plot_benchmark_comparison()\n", "docstring": "All the data we have to work with"}
{"repo": "algorithmic-trading-with-python-master/listings/chapter_7/7_1_symmetric_cusum_filter_on_revenue.py", "original_string": "def calculate_events_for_revenue_series(series: pd.Series, \n    filter_threshold: float, lookback: int=365) -> pd.DatetimeIndex:\n    \"\"\"\n    Calculate the symmetric cusum filter to generate events on YoY changes in \n    the log revenue series\n    \"\"\"\n    series = np.log(series)\n    series = filters.calculate_non_uniform_lagged_change(series, lookback)\n    return filters.calculate_cusum_events(series, filter_threshold)\n", "docstring": "filter_threshold: float, lookback: int=365) -> pd.DatetimeIndex:"}
{"repo": "algorithmic-trading-with-python-master/src/simulate_alternative_data_portfolio.py", "original_string": "def simulate_portfolio():\n    # All the data we have to work with\n    symbols, eod_data, alt_data = load_data()\n    # Load classifier from file\n    classifier = load(os.path.join(SRC_DIR, 'ml_model.joblib'))\n    # Generate signals from classifier\n    print('Calculating signals ...')\n    signal = calculate_signals(classifier, symbols, eod_data, alt_data)\n    # Get rid of eod_data before valid signals\n    first_signal_date = signal.first_valid_index()\n    eod_data = eod_data[eod_data.index > first_signal_date]\n    # Set the preference to increase by row, so new trades are preferred\n    print('Calculating preference matrix ...')\n    preference = pd.DataFrame(\n        np.random.random(eod_data.shape), \n        columns=eod_data.columns, \n        index=eod_data.index,\n    )\n    # Run the simulator\n    simulator = simulation.SimpleSimulator(\n        initial_cash=10000,\n        max_active_positions=10,\n        percent_slippage=0.0005,\n        trade_fee=1,\n    )\n    simulator.simulate(eod_data, signal, preference)\n    # Print results\n    simulator.portfolio_history.print_position_summaries()\n    simulator.print_initial_parameters()\n    simulator.portfolio_history.print_summary()\n    simulator.portfolio_history.plot()\n    simulator.portfolio_history.plot_benchmark_comparison()\n", "docstring": "All the data we have to work with"}
{"repo": "algorithmic-trading-with-python-master/src/pypm/optimization.py", "original_string": "    def __init__(self, parameters: Parameters, performance: Performance):\n        # Make sure no collisions between performance metrics and params\n        assert len(parameters.keys() & performance.keys()) == 0, \\\n            'parameter name matches performance metric name'\n        self.parameters = parameters\n        self.performance = performance\n", "docstring": "Make sure no collisions between performance metrics and params"}
{"repo": "algorithmic-trading-with-python-master/src/pypm/optimization.py", "original_string": "    def as_dict(self) -> Dict[str, float]:\n        \"\"\"Combines the dictionaries after we are sure of no collisions\"\"\"\n        return {**self.parameters, **self.performance}\n", "docstring": "Combines the dictionaries after we are sure of no collisions\n"}
{"repo": "algorithmic-trading-with-python-master/src/pypm/optimization.py", "original_string": "    def plot_2d_line(self, x, y, show=True, **filter_kwargs):\n        _results = self.results\n        for k, v in filter_kwargs.items():\n            _results = _results[getattr(_results, k) == v]\n        ax = _results.plot(x, y)\n        if filter_kwargs:\n            k_str = ', '.join([f'{k}={v}' for k,v in filter_kwargs.items()])\n            ax.legend([f'{x} ({k_str})'])\n        if show:\n            plt.show()\n", "docstring": "_results = self.results"}
{"repo": "algorithmic-trading-with-python-master/src/pypm/metrics.py", "original_string": "def calculate_sharpe_ratio(price_series: pd.Series, \n    benchmark_rate: float=0) -> float:\n    \"\"\"\n    Calculates the Sharpe ratio given a price series. Defaults to benchmark_rate\n    of zero.\n    \"\"\"\n    cagr = calculate_cagr(price_series)\n    return_series = calculate_return_series(price_series)\n    volatility = calculate_annualized_volatility(return_series)\n    return (cagr - benchmark_rate) / volatility\n", "docstring": "benchmark_rate: float=0) -> float:"}
{"repo": "algorithmic-trading-with-python-master/src/pypm/metrics.py", "original_string": "def calculate_annualized_downside_deviation(return_series: pd.Series,\n    benchmark_rate: float=0) -> float:\n    \"\"\"\n    Calculates the downside deviation for use in the Sortino ratio.\n    Benchmark rate is assumed to be annualized. It will be adjusted according\n    to the number of periods per year seen in the data.\n    \"\"\"\n    # For both de-annualizing the benchmark rate and annualizing result\n    years_past = get_years_past(return_series)\n    entries_per_year = return_series.shape[0] / years_past\n    adjusted_benchmark_rate = ((1+benchmark_rate) ** (1/entries_per_year)) - 1\n    downside_series = adjusted_benchmark_rate - return_series\n    downside_sum_of_squares = (downside_series[downside_series > 0] ** 2).sum()\n    denominator = return_series.shape[0] - 1\n    downside_deviation = np.sqrt(downside_sum_of_squares / denominator)\n    return downside_deviation * np.sqrt(entries_per_year)\n", "docstring": "benchmark_rate: float=0) -> float:"}
{"repo": "algorithmic-trading-with-python-master/src/pypm/metrics.py", "original_string": "def calculate_max_drawdown_with_metadata(series: pd.Series, \n    method: str='log') -> Dict[str, Any]:\n    \"\"\"\n    Calculates max_drawndown and stores metadata about when and where. Returns \n    a dictionary of the form \n        {\n            'max_drawdown': float,\n            'peak_date': pd.Timestamp,\n            'peak_price': float,\n            'trough_date': pd.Timestamp,\n            'trough_price': float,\n        }\n    \"\"\"\n    assert method in DRAWDOWN_EVALUATORS, \\\n        f'Method \"{method}\" must by one of {list(DRAWDOWN_EVALUATORS.keys())}'\n    evaluator = DRAWDOWN_EVALUATORS[method]\n    max_drawdown = 0\n    local_peak_date = peak_date = trough_date = series.index[0]\n    local_peak_price = peak_price = trough_price = series.iloc[0]\n    for date, price in series.iteritems():\n        # Keep track of the rolling max\n        if price > local_peak_price:\n            local_peak_date = date\n            local_peak_price = price\n        # Compute the drawdown\n        drawdown = evaluator(price, local_peak_price)\n        # Store new max drawdown values\n        if drawdown > max_drawdown:\n            max_drawdown = drawdown\n            peak_date = local_peak_date\n            peak_price = local_peak_price\n            trough_date = date\n            trough_price = price\n    return {\n        'max_drawdown': max_drawdown,\n        'peak_date': peak_date,\n        'peak_price': peak_price,\n        'trough_date': trough_date,\n        'trough_price': trough_price\n    }\n", "docstring": "method: str='log') -> Dict[str, Any]:"}
{"repo": "algorithmic-trading-with-python-master/src/pypm/indicators.py", "original_string": "def calculate_simple_moving_average(series: pd.Series, n: int=20) -> pd.Series:\n    \"\"\"Calculates the simple moving average\"\"\"\n    return series.rolling(n).mean()\n", "docstring": "Calculates the simple moving average\n"}
{"repo": "algorithmic-trading-with-python-master/src/pypm/portfolio.py", "original_string": "def _pdate(date: pd.Timestamp):\n    \"\"\"Pretty-print a datetime with just the date\"\"\"\n    return date.strftime(DATE_FORMAT_STR)\n", "docstring": "Pretty-print a datetime with just the date\n"}
{"repo": "algorithmic-trading-with-python-master/src/pypm/portfolio.py", "original_string": "    def last_value(self) -> Dollars:\n        return self.last_price * self.shares\n", "docstring": "return self.last_price * self.shares"}
{"repo": "algorithmic-trading-with-python-master/src/pypm/portfolio.py", "original_string": "    def percent_return(self) -> float:\n        return (self.exit_price / self.entry_price) - 1\n", "docstring": "return (self.exit_price / self.entry_price) - 1"}
{"repo": "algorithmic-trading-with-python-master/src/pypm/portfolio.py", "original_string": "    def __init__(self):\n        # Keep track of positions, recorded in this list after close\n        self.position_history: List[Position] = []\n        self._logged_positions: Set[Position] = set()\n        # Keep track of the last seen date\n        self.last_date: pd.Timestamp = pd.Timestamp.min\n        # Readonly fields\n        self._cash_history: Dict[pd.Timestamp, Dollars] = dict()\n        self._simulation_finished = False\n        self._spy: pd.DataFrame = pd.DataFrame()\n        self._spy_log_returns: pd.Series = pd.Series()\n", "docstring": "Keep track of positions, recorded in this list after close"}
{"repo": "algorithmic-trading-with-python-master/src/pypm/portfolio.py", "original_string": "    def record_cash(self, date, cash):\n        self._cash_history[date] = cash\n        self.last_date = max(self.last_date, date)\n", "docstring": "self._cash_history[date] = cash"}
{"repo": "algorithmic-trading-with-python-master/src/pypm/portfolio.py", "original_string": "    def spy(self):\n        if self._spy.empty:\n            first_date = self.cash_series.index[0]\n            _spy = data_io.load_spy_data()\n            self._spy = _spy[_spy.index > first_date]\n        return self._spy\n", "docstring": "if self._spy.empty:"}
{"repo": "algorithmic-trading-with-python-master/src/pypm/simulation.py", "original_string": "    def _assert_equal_columns(*args: Iterable[pd.DataFrame]):\n        column_names = set(args[0].columns.values)\n        for arg in args[1:]:\n            assert set(arg.columns.values) == column_names, \\\n                'Found unequal column names in input dataframes.'\n", "docstring": "column_names = set(args[0].columns.values)"}
{"repo": "dnaplotlib-master/gallery/repressilator_animate/repressilator_figure.py", "original_string": "def expression(val, lims):\n    \"\"\"function takes a value between two limits (as a tuple) and returns the value normalized\n    by the limits to be between 0 and 1\"\"\"\n    new_val = (val - lims[0]) / (lims[1] - lims[0])\n    return new_val\n", "docstring": "function takes a value between two limits (as a tuple) and returns the value normalized"}
{"repo": "dnaplotlib-master/gallery/repressilator_animate/repressilator_animate.py", "original_string": "def expression(val, lims):\n    \"\"\"function takes a value between two limits (as a tuple) and returns the value normalized\n    by the limits to be between 0 and 1\"\"\"\n    new_val = (val - lims[0]) / (lims[1] - lims[0])\n    return new_val\n", "docstring": "function takes a value between two limits (as a tuple) and returns the value normalized"}
{"repo": "dnaplotlib-master/gallery/sbol_interactive/assembly.py", "original_string": "def remove_annotation(parent_component, deleted_ann):\n    \"\"\" An annotation is removed.  The precedes relationship, start and end indexes of other annotations\n    are updated accordingly \"\"\"\n    downstream_ann = deleted_ann.precedes[0]  # Find annotation downstream of the one to be removed\n    # Finds the upstream annotation that precedes the annotation to be removed\n    for ann in parent_component.annotations:\n        if deleted_ann in ann.precedes:\n            upstream_ann = ann\n    # Update precedes relationship of annotations\n    upstream_ann.precedes.remove(upstream_ann.precedes[0])\n    upstream_ann.precedes.append(downstream_ann)\n    # Update all start and end indices for annotations downstream from insertion\n    deletion_size = deleted_ann.end - deleted_ann.start + 1\n    while (len(upstream_ann.precedes) > 0):\n        downstream_ann = upstream_ann.precedes[0]\n        old_start = downstream_ann.start\n        old_end = downstream_ann.end\n        new_start = old_start - deletion_size\n        new_end = old_end - deletion_size\n        downstream_ann.start = new_start\n        downstream_ann.end = new_end\n        upstream_ann = downstream_ann\n    #doc.sequences.remove(deleted_ann.subcomponent.sequence)\n    #doc.components.remove(deleted_ann.subcomponent)\n    #doc.annotations.remove(deleted_ann)\n    parent_component.annotations.remove(deleted_ann)\n", "docstring": "An annotation is removed.  The precedes relationship, start and end indexes of other annotations"}
{"repo": "dnaplotlib-master/gallery/sbol_interactive/assembly.py", "original_string": "def insert_annotation_upstream(parent_component, insert_ann, downstream_ann):\n    \"\"\" A new annotation (upstream) is inserted before the downstream annotation\n    The precedes relationship, start and end indexes are update accordingly \"\"\"\n    #print downstream_ann.uri\n    #print\n    for i_ann, ann in enumerate(parent_component.annotations):\n        #print i_ann, ann.uri\n        if downstream_ann in ann.precedes:\n            upstream_uri = ann.uri  # finds the annotation upstream, because it owns the precedes\n    print('Upstream uri: %s' %upstream_uri)\n    upstream_ann = parent_component.annotations[upstream_uri]\n    insert_annotation_downstream(parent_component, upstream_ann, insert_ann)\n", "docstring": "A new annotation (upstream) is inserted before the downstream annotation"}
{"repo": "dnaplotlib-master/gallery/sbol_interactive/assembly.py", "original_string": "def getSequenceAnnotationsAtBaseNo(parent_component, base_no, annotations_found = None):\n    # Assumes parent_component is an SBOL data structure of the general form DNAComponent(->SequenceAnnotation->DNAComponent)n\n    # where n+1 is an integer describing how many hierarchical levels are in the SBOL structure\n    if not annotations_found :\n        annotations_found = []\n    # print \"Searching for base no %d\" %base_no\n    # Look at each of this component's annotations, is the target base there?\n    for ann in parent_component.annotations :\n        # print ann.uri, ann.start, ann.end\n        # If target base is found ...\n        if base_no >= ann.start and base_no <= ann.end :\n            #print \"Annotation FOUND\"\n            annotations_found.append(ann)\n            # Is this the lowest level of the hierarchy, or are there subcomponents?\n            if ann.subcomponent and len(ann.subcomponent.annotations) > 0:\n                #print \"Descending one level\"\n                annotations_found = annotations_found[:-1]  # Remove parent annotation, continue search for leaf annotations\n                sub_annotations_found = getSequenceAnnotationsAtBaseNo(ann.subcomponent, base_no, annotations_found)\n                if len(sub_annotations_found) == len(annotations_found):  # If no leaf annotations were found at the lower level, replace the higher level annotation\n                    #print \"No sub annotations found\"\n                    annotations_found.append(ann)\n                    return annotations_found\n                else:\n                    #print \"Sub annotations found\"\n                    return sub_annotations_found\n            else:\n                #print \"No sub annotations found\"\n                return annotations_found\n    #print \"Completing search at this level\"\n    return annotations_found\n            #    return annotations_found\n            # else :\n            #     print base_no, ann.start, ann.end\n            #     annotations_found.append(ann)\n            #     return annotations_found\n", "docstring": "Assumes parent_component is an SBOL data structure of the general form DNAComponent(->SequenceAnnotation->DNAComponent)n"}
{"repo": "dnaplotlib-master/gallery/sbol_interactive/assembly.py", "original_string": "def initialize_design(doc):\n    n_designs = len([part for part in doc.components if part.type and part.type == DESIGN])\n    root = sbol.DNAComponent(doc, '%s/Design_%d' %(BASE_URI, n_designs + 1))\n    root.type = DESIGN\n    root.display_id = 'Design %d' %(n_designs + 1)\n    root.name = 'Design %d' %(n_designs + 1)\n    root.sequence = sbol.DNASequence(doc, '%s/Design_%d/Seq_%d' %(BASE_URI, n_designs + 1, n_designs + 1))\n    root.sequence.nucleotides = 'n'\n    return root\n", "docstring": "n_designs = len([part for part in doc.components if part.type and part.type == DESIGN])"}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def write_label (ax, label_text, x_pos, opts=None):\n    \"\"\" Renders labels on parts.\n    \"\"\"\n    zorder_add = 0.0\n    y_offset = 0.0\n    label_style = 'normal'\n    label_size = 7\n    label_y_offset = 0\n    label_x_offset = 0\n    label_color = (0,0,0)\n    label_rotation = 0\n    if opts != None:\n        if 'zorder_add' in list(opts.keys()):\n            zorder_add = opts['zorder_add']\n        if 'y_offset' in list(opts.keys()):\n            y_offset = opts['y_offset']\n        if 'label_style' in list(opts.keys()):\n            label_style = opts['label_style']\n        if 'label_size' in list(opts.keys()):\n            label_size = opts['label_size']\n        if 'label_y_offset' in list(opts.keys()):\n            label_y_offset = opts['label_y_offset']\n        if 'label_x_offset' in list(opts.keys()):\n            label_x_offset = opts['label_x_offset']\n        if 'label_color' in list(opts.keys()):\n            label_color = opts['label_color']\n        if 'label_rotation' in list(opts.keys()):\n            label_rotation = opts['label_rotation']\n    ax.text(x_pos+label_x_offset, label_y_offset+y_offset, label_text, horizontalalignment='center',\n            verticalalignment='center', fontsize=label_size, fontstyle=label_style, \n            color=label_color, rotation=label_rotation, zorder=30+zorder_add)\n", "docstring": "Renders labels on parts."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def sbol_cds (ax, type, num, start, end, prev_end, scale, linewidth, opts):\n    \"\"\" Built-in SBOL coding sequence renderer.\n    \"\"\"\n    # Default options\n    zorder_add = 0.0\n    color = (0.7,0.7,0.7)\n    hatch = ''\n    start_pad = 1.0\n    end_pad = 1.0\n    y_extent = 5\n    x_extent = 30\n    arrowhead_height = 4\n    arrowhead_length = 8\n    edgecolor = (0,0,0)\n    # Reset defaults if provided\n    if opts != None:\n        if 'zorder_add' in list(opts.keys()):\n            zorder_add = opts['zorder_add']\n        if 'color' in list(opts.keys()):\n            color = opts['color']\n        if 'hatch' in list(opts.keys()):\n            hatch = opts['hatch']\n        if 'start_pad' in list(opts.keys()):\n            start_pad = opts['start_pad']\n        if 'end_pad' in list(opts.keys()):\n            end_pad = opts['end_pad']\n        if 'y_extent' in list(opts.keys()):\n            y_extent = opts['y_extent']\n        if 'x_extent' in list(opts.keys()):\n            x_extent = opts['x_extent']\n        if 'arrowhead_height' in list(opts.keys()):\n            arrowhead_height = opts['arrowhead_height']\n        if 'arrowhead_length' in list(opts.keys()):\n            arrowhead_length = opts['arrowhead_length']\n        if 'linewidth' in list(opts.keys()):\n            linewidth = opts['linewidth']\n        if 'scale' in list(opts.keys()):\n            scale = opts['scale']\n        if 'edge_color' in list(opts.keys()):\n            edgecolor = opts['edge_color']\n    # Check direction add start padding\n    dir_fac = 1.0\n    final_end = end\n    final_start = prev_end\n    if start > end:\n        dir_fac = -1.0\n        start = prev_end+end_pad+x_extent\n        end = prev_end+end_pad\n        final_end = start+start_pad\n    else:\n        start = prev_end+start_pad\n        end = start+x_extent\n        final_end = end+end_pad\n    # Draw the CDS symbol\n    p1 = Polygon([(start, y_extent), \n                  (start, -y_extent),\n                  (end-dir_fac*arrowhead_length, -y_extent),\n                  (end-dir_fac*arrowhead_length, -y_extent-arrowhead_height),\n                  (end, 0),\n                  (end-dir_fac*arrowhead_length, y_extent+arrowhead_height),\n                  (end-dir_fac*arrowhead_length, y_extent)],\n                  edgecolor=edgecolor, facecolor=color, linewidth=linewidth, \n                  hatch=hatch, zorder=11+zorder_add, \n                  path_effects=[Stroke(joinstyle=\"miter\")]) # This is a work around for matplotlib < 1.4.0\n    ax.add_patch(p1)\n    if opts != None and 'label' in list(opts.keys()):\n        if final_start > final_end:\n            write_label(ax, opts['label'], final_end+((final_start-final_end)/2.0), opts=opts)\n        else:\n            write_label(ax, opts['label'], final_start+((final_end-final_start)/2.0), opts=opts)\n    if final_start > final_end:\n        return prev_end, final_start\n    else:\n        return prev_end, final_end\n", "docstring": "Built-in SBOL coding sequence renderer."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def sbol_rbs (ax, type, num, start, end, prev_end, scale, linewidth, opts):\n    \"\"\" Built-in SBOL ribosome binding site renderer.\n    \"\"\"\n    # Default options\n    zorder_add = 0.0\n    color = (0.7,0.7,0.7)\n    start_pad = 2.0\n    end_pad = 2.0\n    x_extent = 10.0\n    edgecolor = (0,0,0)\n    # Reset defaults if provided\n    if opts != None:\n        if 'zorder_add' in list(opts.keys()):\n            zorder_add = opts['zorder_add']\n        if 'color' in list(opts.keys()):\n            color = opts['color']\n        if 'start_pad' in list(opts.keys()):\n            start_pad = opts['start_pad']\n        if 'end_pad' in list(opts.keys()):\n            end_pad = opts['end_pad']\n        if 'x_extent' in list(opts.keys()):\n            x_extent = opts['x_extent']\n        if 'linewidth' in list(opts.keys()):\n            linewidth = opts['linewidth']\n        if 'scale' in list(opts.keys()):\n            scale = opts['scale']\n        if 'edge_color' in list(opts.keys()):\n            edgecolor = opts['edge_color']\n    # Check direction add start padding\n    dir_fac = 1.0\n    final_end = end\n    final_start = prev_end\n    rbs_center = (0,0)\n    if start > end:\n        start = prev_end+end_pad+x_extent\n        end = prev_end+end_pad\n        final_end = start+start_pad\n        rbs_center = (end+((start-end)/2.0),0)\n        w1 = Wedge(rbs_center, x_extent/2.0, 180, 360, linewidth=linewidth, \n                   facecolor=color, edgecolor=edgecolor, zorder=8+zorder_add)\n        ax.add_patch(w1)\n    else:\n        start = prev_end+start_pad\n        end = start+x_extent\n        final_end = end+end_pad\n        rbs_center = (start+((end-start)/2.0),0)\n        w1 = Wedge(rbs_center, x_extent/2.0, 0, 180, linewidth=linewidth, \n                   facecolor=color, edgecolor=edgecolor, zorder=8+zorder_add)\n        ax.add_patch(w1)\n    if opts != None and 'label' in list(opts.keys()):\n        if final_start > final_end:\n            write_label(ax, opts['label'], final_end+((final_start-final_end)/2.0), opts=opts)\n        else:\n            write_label(ax, opts['label'], final_start+((final_end-final_start)/2.0), opts=opts)\n    if final_start > final_end:\n        return prev_end, final_start\n    else:\n        return prev_end, final_end\n", "docstring": "Built-in SBOL ribosome binding site renderer."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def sbol_scar (ax, type, num, start, end, prev_end, scale, linewidth, opts):\n    \"\"\" Built-in SBOL scar renderer.\n    \"\"\"\n    # Default options\n    zorder_add = 0.0\n    color = (0,0,0)\n    start_pad = 2.0\n    end_pad = 2.0\n    x_extent = 6.0\n    y_extent = 1.0\n    linestyle = '-'\n    # Reset defaults if provided\n    if opts != None:\n        if 'zorder_add' in list(opts.keys()):\n            zorder_add = opts['zorder_add']\n        if 'color' in list(opts.keys()):\n            color = opts['color']\n        if 'start_pad' in list(opts.keys()):\n            start_pad = opts['start_pad']\n        if 'end_pad' in list(opts.keys()):\n            end_pad = opts['end_pad']\n        if 'x_extent' in list(opts.keys()):\n            x_extent = opts['x_extent']\n        if 'y_extent' in list(opts.keys()):\n            y_extent = opts['y_extent']\n        if 'linestyle' in list(opts.keys()):\n            linestyle = opts['linestyle']\n        if 'linewidth' in list(opts.keys()):\n            linewidth = opts['linewidth']\n        if 'scale' in list(opts.keys()):\n            scale = opts['scale']\n    # Check direction add start padding\n    final_end = end\n    final_start = prev_end\n    start = prev_end+start_pad\n    end = start+x_extent\n    final_end = end+end_pad\n    \n    l_top    = Line2D([start,start+x_extent],[y_extent,y_extent], \n                linewidth=linewidth, color=color, zorder=12+zorder_add, linestyle=linestyle)\n    l_bottom = Line2D([start,start+x_extent],[-1*y_extent,-1*y_extent], \n                linewidth=linewidth, color=color, zorder=12+zorder_add, linestyle=linestyle)\n    #white rectangle overlays backbone line\n    p1 = Polygon([(start, y_extent), \n                  (start, -y_extent),\n                  (start+x_extent, -y_extent),\n                  (start+x_extent, y_extent)],\n                  edgecolor=(1,1,1), facecolor=(1,1,1), linewidth=linewidth, zorder=11+zorder_add, \n                  path_effects=[Stroke(joinstyle=\"miter\")]) # This is a work around for matplotlib < 1.4.0)\n    ax.add_patch(p1)\n    ax.add_line(l_top)\n    ax.add_line(l_bottom)\n    if opts != None and 'label' in list(opts.keys()):\n        if final_start > final_end:\n            write_label(ax, opts['label'], final_end+((final_start-final_end)/2.0), opts=opts)\n        else:\n            write_label(ax, opts['label'], final_start+((final_end-final_start)/2.0), opts=opts)\n    if final_start > final_end:\n        return prev_end, final_start\n    else:\n        return prev_end, final_end\n", "docstring": "Built-in SBOL scar renderer."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def sbol_5_overhang (ax, type, num, start, end, prev_end, scale, linewidth, opts):\n    \"\"\" Built-in SBOL 5' overhang renderer.\n    \"\"\"\n    # Default options\n    zorder_add = 0.0\n    color = (0,0,0)\n    start_pad = 0.0\n    end_pad = 2.0\n    x_extent = 6.0\n    y_extent = 1.0\n    linestyle = '-'\n    # Reset defaults if provided\n    if opts != None:\n        if 'zorder_add' in list(opts.keys()):\n            zorder_add = opts['zorder_add']\n        if 'color' in list(opts.keys()):\n            color = opts['color']\n        if 'start_pad' in list(opts.keys()):\n            start_pad = opts['start_pad']\n        if 'end_pad' in list(opts.keys()):\n            end_pad = opts['end_pad']\n        if 'x_extent' in list(opts.keys()):\n            x_extent = opts['x_extent']\n        if 'y_extent' in list(opts.keys()):\n            y_extent = opts['y_extent']\n        if 'linestyle' in list(opts.keys()):\n            linestyle = opts['linestyle']\n        if 'linewidth' in list(opts.keys()):\n            linewidth = opts['linewidth']\n        if 'scale' in list(opts.keys()):\n            scale = opts['scale']\n    # Check direction add start padding\n    final_end = end\n    final_start = prev_end\n    start = prev_end+start_pad\n    end = start+x_extent\n    final_end = end+end_pad\n    \n    l_top    = Line2D([start,start+x_extent],[y_extent,y_extent], \n                linewidth=linewidth, color=color, zorder=12+zorder_add, linestyle=linestyle)\n    l_bottom = Line2D([start+(x_extent/2.0),start+x_extent],[-1*y_extent,-1*y_extent], \n                linewidth=linewidth, color=color, zorder=12+zorder_add, linestyle=linestyle)\n    #white rectangle overlays backbone line\n    p1 = Polygon([(start, y_extent), \n                  (start, -y_extent),\n                  (start+x_extent, -y_extent),\n                  (start+x_extent, y_extent)],\n                  edgecolor=(1,1,1), facecolor=(1,1,1), linewidth=linewidth, zorder=11+zorder_add, \n                  path_effects=[Stroke(joinstyle=\"miter\")]) # This is a work around for matplotlib < 1.4.0)     \n    ax.add_patch(p1)\n    ax.add_line(l_top)\n    ax.add_line(l_bottom)\n    if opts != None and 'label' in list(opts.keys()):\n        if final_start > final_end:\n            write_label(ax, opts['label'], final_end+((final_start-final_end)/2.0), opts=opts)\n        else:\n            write_label(ax, opts['label'], final_start+((final_end-final_start)/2.0), opts=opts)\n    if final_start > final_end:\n        return prev_end, final_start\n    else:\n        return prev_end, final_end\n", "docstring": "Built-in SBOL 5' overhang renderer."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def sbol_blunt_restriction_site (ax, type, num, start, end, prev_end, scale, linewidth, opts):\n    \"\"\" Built-in SBOL blunt-end restriction site renderer.\n    \"\"\"\n    # Default options\n    zorder_add = 0.0\n    color = (0,0,0)\n    start_pad = 2.0\n    end_pad = 2.0\n    y_extent = 4.0\n    x_extent = 1.5\n    site_space = 1.5\n    linestyle = '-'\n    # Reset defaults if provided\n    if opts != None:\n        if 'zorder_add' in list(opts.keys()):\n            zorder_add = opts['zorder_add']\n        if 'color' in list(opts.keys()):\n            color = opts['color']\n        if 'site_space' in list(opts.keys()):\n            site_space = opts['site_space']\n        if 'start_pad' in list(opts.keys()):\n            start_pad = opts['start_pad']\n        if 'end_pad' in list(opts.keys()):\n            end_pad = opts['end_pad']\n        if 'x_extent' in list(opts.keys()):\n            x_extent = opts['x_extent']\n        if 'y_extent' in list(opts.keys()):\n            y_extent = opts['y_extent']\n        if 'linestyle' in list(opts.keys()):\n            linestyle = opts['linestyle']\n        if 'linewidth' in list(opts.keys()):\n            linewidth = opts['linewidth']\n        if 'scale' in list(opts.keys()):\n            scale = opts['scale']\n    \n    # Direction is meaningless for this part => start is always < end\n    if start > end:\n        temp_end = end\n        end = start\n        start = temp_end\n    # Check direction add start padding\n    final_end = end\n    final_start = prev_end\n    start = prev_end+start_pad\n    end = start+x_extent+site_space+x_extent\n    final_end = end+end_pad\n    \n    l1        = Line2D([start+x_extent,start+x_extent],[-y_extent,y_extent], \n                   linewidth=linewidth, color=color, zorder=12+zorder_add, linestyle=linestyle)\n    l1_top    = Line2D([start,start+x_extent],[y_extent,y_extent], \n                   linewidth=linewidth, color=color, zorder=12+zorder_add, linestyle=linestyle)\n    l1_bottom = Line2D([start,start+x_extent],[-y_extent,-y_extent], \n                   linewidth=linewidth, color=color, zorder=12+zorder_add, linestyle=linestyle)\n    l2        = Line2D([end-x_extent,end-x_extent],[-y_extent,y_extent], \n                   linewidth=linewidth, color=color, zorder=12+zorder_add, linestyle=linestyle)\n    l2_top    = Line2D([end,end-x_extent],[y_extent,y_extent], \n                   linewidth=linewidth, color=color, zorder=12+zorder_add, linestyle=linestyle)\n    l2_bottom = Line2D([end,end-x_extent],[-y_extent,-y_extent], \n                   linewidth=linewidth, color=color, zorder=12+zorder_add, linestyle=linestyle)\n    \n    ax.add_line(l1)\n    ax.add_line(l1_top)\n    ax.add_line(l1_bottom)\n    ax.add_line(l2)\n    ax.add_line(l2_top)\n    ax.add_line(l2_bottom)\n    if opts != None and 'label' in list(opts.keys()):\n        write_label(ax, opts['label'], final_start+((final_end-final_start)/2.0), opts=opts)\n    return final_start, final_end\n", "docstring": "Built-in SBOL blunt-end restriction site renderer."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def sbol_5_sticky_restriction_site  (ax, type, num, start, end, prev_end, scale, linewidth, opts):\n    \"\"\" Built-in SBOL 5' sticky-end restriction site renderer.\n    \"\"\"\n    # Default options\n    zorder_add = 0.0\n    color = (0,0,0)\n    start_pad = 2.0\n    end_pad = 2.0\n    y_extent = 4.0\n    x_extent = 8.0\n    end_space = 1.0\n    linestyle = '-'\n    # Reset defaults if provided\n    if opts != None:\n        if 'zorder_add' in list(opts.keys()):\n            zorder_add = opts['zorder_add']\n        if 'color' in list(opts.keys()):\n            color = opts['color']\n        if 'end_space' in list(opts.keys()):\n            end_space = opts['end_space']\n        if 'start_pad' in list(opts.keys()):\n            start_pad = opts['start_pad']\n        if 'end_pad' in list(opts.keys()):\n            end_pad = opts['end_pad']\n        if 'x_extent' in list(opts.keys()):\n            x_extent = opts['x_extent']\n        if 'y_extent' in list(opts.keys()):\n            y_extent = opts['y_extent']\n        if 'linestyle' in list(opts.keys()):\n            linestyle = opts['linestyle']\n        if 'linewidth' in list(opts.keys()):\n            linewidth = opts['linewidth']\n        if 'scale' in list(opts.keys()):\n            scale = opts['scale']\n    \n    # Direction is meaningless for this part => start is always < end\n    if start > end:\n        temp_end = end\n        end = start\n        start = temp_end\n    # Check direction add start padding\n    final_end = end\n    final_start = prev_end\n    start = prev_end+start_pad\n    end = start+end_space+x_extent+end_space\n    final_end = end+end_pad\n    \n    l1        = Line2D([start+end_space,start+end_space+x_extent],[0,0], \n                   linewidth=linewidth, color=color, zorder=12+zorder_add, linestyle=linestyle)\n    l1_top    = Line2D([start+end_space,start+end_space],[0,y_extent], \n                   linewidth=linewidth, color=color, zorder=12+zorder_add, linestyle=linestyle)\n    l1_bottom = Line2D([start+end_space+x_extent,start+end_space+x_extent],[0,-y_extent], \n                   linewidth=linewidth, color=color, zorder=12+zorder_add, linestyle=linestyle)\n    ax.add_line(l1)\n    ax.add_line(l1_top)\n    ax.add_line(l1_bottom)\n    # White rectangle overlays backbone line\n    p1 = Polygon([(start, y_extent), \n                  (start, -y_extent),\n                  (end, -y_extent),\n                  (end, y_extent)],\n                  edgecolor=(1,1,1), facecolor=(1,1,1), linewidth=linewidth, zorder=11+zorder_add, \n                  path_effects=[Stroke(joinstyle=\"miter\")]) # This is a work around for matplotlib < 1.4.0)     \n    ax.add_patch(p1)\n    if opts != None and 'label' in list(opts.keys()):\n        write_label(ax, opts['label'], final_start+((final_end-final_start)/2.0), opts=opts)\n    return final_start, final_end\n", "docstring": "Built-in SBOL 5' sticky-end restriction site renderer."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def sbol_user_defined  (ax, type, num, start, end, prev_end, scale, linewidth, opts):\n    \"\"\" Built-in SBOL user-defined element renderer.\n    \"\"\"\n    # Default options\n    zorder_add = 0.0\n    color = (0,0,0)\n    start_pad = 2.0\n    end_pad = 2.0\n    x_extent = 12.0\n    y_extent = 3.0\n    linestyle = '-'\n    fill_color = (1,1,1)\n    # Reset defaults if provided\n    if opts != None:\n        if 'zorder_add' in list(opts.keys()):\n            zorder_add = opts['zorder_add']\n        if 'color' in list(opts.keys()):\n            color = opts['color']\n        if 'fill_color' in list(opts.keys()):\n            fill_color = opts['fill_color']\n        if 'start_pad' in list(opts.keys()):\n            start_pad = opts['start_pad']\n        if 'end_pad' in list(opts.keys()):\n            end_pad = opts['end_pad']\n        if 'x_extent' in list(opts.keys()):\n            x_extent = opts['x_extent']\n        if 'y_extent' in list(opts.keys()):\n            y_extent = opts['y_extent']\n        if 'linestyle' in list(opts.keys()):\n            linestyle = opts['linestyle']\n        if 'linewidth' in list(opts.keys()):\n            linewidth = opts['linewidth']\n        if 'scale' in list(opts.keys()):\n            scale = opts['scale']\n    # Check direction add start padding\n    final_end = end\n    final_start = prev_end\n    start = prev_end+start_pad\n    end = start+x_extent\n    final_end = end+end_pad\n    \n    #white rectangle overlays backbone line\n    p1 = Polygon([(start, y_extent), \n                  (start, -y_extent),\n                  (start+x_extent, -y_extent),\n                  (start+x_extent, y_extent)],\n                  edgecolor=color, facecolor=fill_color, linewidth=linewidth, zorder=11+zorder_add, \n                  path_effects=[Stroke(joinstyle=\"miter\")]) # This is a work around for matplotlib < 1.4.0)     \n    ax.add_patch(p1)\n    \n    if opts != None and 'label' in list(opts.keys()):\n        if final_start > final_end:\n            write_label(ax, opts['label'], final_end+((final_start-final_end)/2.0), opts=opts)\n        else:\n            write_label(ax, opts['label'], final_start+((final_end-final_start)/2.0), opts=opts)\n    if final_start > final_end:\n        return prev_end, final_start\n    else:\n        return prev_end, final_end\n", "docstring": "Built-in SBOL user-defined element renderer."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def sbol_restriction_site (ax, type, num, start, end, prev_end, scale, linewidth, opts):\n    \"\"\" Built-in SBOL restriction site renderer.\n    \"\"\"\n    # Default options\n    zorder_add = 0.0\n    color = (0,0,0)\n    start_pad = 2.0\n    end_pad = 2.0\n    y_extent = 4.0\n    linestyle = '-'\n    # Reset defaults if provided\n    if opts != None:\n        if 'zorder_add' in list(opts.keys()):\n            zorder_add = opts['zorder_add']\n        if 'color' in list(opts.keys()):\n            color = opts['color']\n        if 'start_pad' in list(opts.keys()):\n            start_pad = opts['start_pad']\n        if 'end_pad' in list(opts.keys()):\n            end_pad = opts['end_pad']\n        if 'y_extent' in list(opts.keys()):\n            y_extent = opts['y_extent']\n        if 'linestyle' in list(opts.keys()):\n            linestyle = opts['linestyle']\n        if 'linewidth' in list(opts.keys()):\n            linewidth = opts['linewidth']\n        if 'scale' in list(opts.keys()):\n            scale = opts['scale']\n    # Check direction add start padding\n    final_end = end\n    final_start = prev_end\n    start = prev_end+start_pad\n    end = start + linewidth\n    final_end = end+end_pad\n    \n    l1    = Line2D([start,start],[-y_extent,y_extent], \n                   linewidth=linewidth, color=color, zorder=12+zorder_add, linestyle=linestyle)\n    ax.add_line(l1)\n    if opts != None and 'label' in list(opts.keys()):\n        if final_start > final_end:\n            write_label(ax, opts['label'], final_end+((final_start-final_end)/2.0), opts=opts)\n        else:\n            write_label(ax, opts['label'], final_start+((final_end-final_start)/2.0), opts=opts)\n    if final_start > final_end:\n        return prev_end, final_start\n    else:\n        return prev_end, final_end\n", "docstring": "Built-in SBOL restriction site renderer."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def sbol_origin (ax, type, num, start, end, prev_end, scale, linewidth, opts):\n    \"\"\" Built-in SBOL origin renderer.\n    \"\"\"\n    # Default options\n    zorder_add = 0.0\n    color = (0,0,0)\n    start_pad = 2.0\n    end_pad = 2.0\n    x_extent = 10.0\n    y_extent = 10.0\n    linestyle = '-'\n    # Reset defaults if provided\n    if opts != None:\n        if 'zorder_add' in list(opts.keys()):\n            zorder_add = opts['zorder_add']\n        if 'color' in list(opts.keys()):\n            color = opts['color']\n        if 'start_pad' in list(opts.keys()):\n            start_pad = opts['start_pad']\n        if 'end_pad' in list(opts.keys()):\n            end_pad = opts['end_pad']\n        if 'x_extent' in list(opts.keys()):\n            x_extent = opts['x_extent']\n        if 'y_extent' in list(opts.keys()):\n            y_extent = opts['y_extent']\n        if 'linestyle' in list(opts.keys()):\n            linestyle = opts['linestyle']\n        if 'linewidth' in list(opts.keys()):\n            linewidth = opts['linewidth']\n        if 'scale' in list(opts.keys()):\n            scale = opts['scale']\n    # Check direction add start padding\n    final_end = end\n    final_start = prev_end\n    \n    start = prev_end+start_pad\n    end = start+x_extent\n    final_end = end+end_pad\n    ori_center = (start+((end-start)/2.0),0)\n    \n    c1 = Circle(ori_center, x_extent/2.0, linewidth=linewidth, edgecolor=color, \n                facecolor=(1,1,1), zorder=12+zorder_add)\n    \n    ax.add_patch(c1)\n    \n    if opts != None and 'label' in list(opts.keys()):\n        if final_start > final_end:\n            write_label(ax, opts['label'], final_end+((final_start-final_end)/2.0), opts=opts)\n        else:\n            write_label(ax, opts['label'], final_start+((final_end-final_start)/2.0), opts=opts)\n    if final_start > final_end:\n        return prev_end, final_start\n    else:\n        return prev_end, final_end\n", "docstring": "Built-in SBOL origin renderer."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def sbol_insulator (ax, type, num, start, end, prev_end, scale, linewidth, opts):\n    \"\"\" Built-in SBOL insulator renderer.\n    \"\"\"\n    # Default options\n    zorder_add = 0.0\n    color = (0,0,0)\n    start_pad = 2.0\n    end_pad = 2.0\n    x_extent = 8.0\n    y_extent = 4.0\n    linestyle = '-'\n    # Reset defaults if provided\n    if opts != None:\n        if 'zorder_add' in list(opts.keys()):\n            zorder_add = opts['zorder_add']\n        if 'color' in list(opts.keys()):\n            color = opts['color']\n        if 'start_pad' in list(opts.keys()):\n            start_pad = opts['start_pad']\n        if 'end_pad' in list(opts.keys()):\n            end_pad = opts['end_pad']\n        if 'x_extent' in list(opts.keys()):\n            x_extent = opts['x_extent']\n        if 'y_extent' in list(opts.keys()):\n            y_extent = opts['y_extent']\n        if 'linestyle' in list(opts.keys()):\n            linestyle = opts['linestyle']\n        if 'linewidth' in list(opts.keys()):\n            linewidth = opts['linewidth']\n        if 'scale' in list(opts.keys()):\n            scale = opts['scale']\n    \n    # Check direction add start padding\n    final_end = end\n    final_start = prev_end\n    start = prev_end+start_pad\n    end = start+x_extent\n    final_end = end+end_pad\n    \n    #white rectangle overlays backbone line\n    p1 = Polygon([(start, y_extent), \n                  (start, -y_extent),\n                  (start+x_extent, -y_extent),\n                  (start+x_extent, y_extent)],\n                  edgecolor=(0,0,0), facecolor=(1,1,1), linewidth=linewidth, zorder=11+zorder_add, \n                  path_effects=[Stroke(joinstyle=\"miter\")]) # This is a work around for matplotlib < 1.4.0)     \n    bits = 5.0\n    gap_size = ((end-start)/bits)\n    x_inset_start = start + gap_size\n    x_inset_end = start + ((bits-1.0)*gap_size)\n    # Inside rectangle\n    p2 = Polygon([(x_inset_start,  y_extent-gap_size), \n                  (x_inset_start, -y_extent+gap_size),\n                  (x_inset_end, -y_extent+gap_size),\n                  (x_inset_end,  y_extent-gap_size)],\n                  edgecolor=(0,0,0), facecolor=(1,1,1), linewidth=linewidth, zorder=12+zorder_add, \n                  path_effects=[Stroke(joinstyle=\"miter\")]) # This is a work around for matplotlib < 1.4.0)     \n    ax.add_patch(p1)\n    ax.add_patch(p2)\n    \n    if opts != None and 'label' in list(opts.keys()):\n        if final_start > final_end:\n            write_label(ax, opts['label'], final_end+((final_start-final_end)/2.0), opts=opts)\n        else:\n            write_label(ax, opts['label'], final_start+((final_end-final_start)/2.0), opts=opts)\n    if final_start > final_end:\n        return prev_end, final_start\n    else:\n        return prev_end, final_end\n", "docstring": "Built-in SBOL insulator renderer."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def temporary_repressor (ax, type, num, start, end, prev_end, scale, linewidth, opts):\n    # Default options\n    zorder_add = 0.0\n    color = (0.7,0.7,0.7)\n    start_pad = 2.0\n    end_pad = 2.0\n    y_extent = 10\n    x_extent = 10\n    arrowhead_height = 2\n    arrowhead_length = 4\n    # Reset defaults if provided\n    if opts != None:\n        if 'zorder_add' in list(opts.keys()):\n            zorder_add = opts['zorder_add']\n        if 'color' in list(opts.keys()):\n            color = opts['color']\n        if 'start_pad' in list(opts.keys()):\n            start_pad = opts['start_pad']\n        if 'end_pad' in list(opts.keys()):\n            end_pad = opts['end_pad']\n        if 'y_extent' in list(opts.keys()):\n            y_extent = opts['y_extent']\n        if 'x_extent' in list(opts.keys()):\n            x_extent = opts['x_extent']\n        if 'arrowhead_height' in list(opts.keys()):\n            arrowhead_height = opts['arrowhead_height']\n        if 'arrowhead_length' in list(opts.keys()):\n            arrowhead_length = opts['arrowhead_length']\n        if 'linewidth' in list(opts.keys()):\n            linewidth = opts['linewidth']\n        if 'scale' in list(opts.keys()):\n            scale = opts['scale']\n    # Check direction add start padding\n    dir_fac = 1.0\n    final_end = end\n    final_start = prev_end\n    if start > end:\n        dir_fac = -1.0\n        start = prev_end+end_pad+x_extent\n        end = prev_end+end_pad\n        final_end = start+start_pad\n    else:\n        start = prev_end+start_pad\n        end = start+x_extent\n        final_end = end+end_pad\n    \n    e1center = (start+((end-start)/2.0),0)\n    e2center = (start+((end-start)/2.0)+x_extent/3.75,0)\n    e1 = Ellipse(e1center, y_extent/2, y_extent, edgecolor=(0,0,0), facecolor=color, \n                linewidth=linewidth, fill=True, zorder=12+zorder_add)\n    e2 = Ellipse(e2center, y_extent/2, y_extent, edgecolor=(0,0,0), facecolor=color, \n                linewidth=linewidth, fill=True, zorder=11+zorder_add)\n    ax.add_patch(e1)\n    ax.add_patch(e2)\n    if final_start > final_end:\n        return prev_end, final_start\n    else:\n        return prev_end, final_end\n", "docstring": "Default options"}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def repress (ax, type, num, from_part, to_part, scale, linewidth, arc_height_index, opts):\n    \"\"\" Standard repression regulation renderer.\n    \"\"\"\n    regulation(ax, type, num, from_part, to_part, scale, linewidth, arc_height_index, opts)\n", "docstring": "Standard repression regulation renderer."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def connect (ax, type, num, from_part, to_part, scale, linewidth, arc_height_index, opts):\n    \"\"\" Standard induction regulation renderer.\n    \"\"\"\n    regulation(ax, type, num, from_part, to_part, scale, linewidth, arc_height_index, opts)\n", "docstring": "Standard induction regulation renderer."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def trace_rbs (ax, type, num, start_bp, end_bp, prev_end, scale, linewidth, opts):\n    \"\"\" Built-in trace-based ribosome binding site renderer.\n    \"\"\"\n    # Default options\n    zorder_add = 0.0\n    color = (0.16,0.68,0.15)\n    y_offset = 0.0\n    y_extent = 3.5\n    x_extent = 10.0\n    highlight_y_extent = 0.8\n    # Reset defaults if provided\n    if opts != None:\n        if 'zorder_add' in list(opts.keys()):\n            zorder_add = opts['zorder_add']\n        if 'color' in list(opts.keys()):\n            color = opts['color']\n        if 'y_offset' in list(opts.keys()):\n            y_offset = opts['y_offset']\n        if 'y_extent' in list(opts.keys()):\n            y_extent = opts['y_extent']\n        if 'x_extent' in list(opts.keys()):\n            x_extent = opts['x_extent']\n        if 'highlight_y_extent' in list(opts.keys()):\n            highlight_y_extent = opts['highlight_y_extent']\n        if 'linewidth' in list(opts.keys()):\n            linewidth = opts['linewidth']\n        if 'scale' in list(opts.keys()):\n            scale = opts['scale']\n    # Check direction add start padding\n    dir_fac = 1.0\n    if start_bp > end_bp:\n        dir_fac = -1.0\n    # Draw the RBS symbol\n    l1 = Line2D([start_bp,start_bp],[0+y_offset,dir_fac*y_extent+y_offset], linewidth=linewidth, color=color, zorder=14+zorder_add)\n    ax.add_line(l1)\n    c1 = Ellipse((start_bp,dir_fac*y_extent+y_offset),width=(x_extent*scale),height=y_extent*0.4,color=color, zorder=14+zorder_add)\n    ax.add_artist(c1)\n    # Shade the promoter area (normally smaller than symbol extent)\n    p2 = Polygon([(start_bp, -highlight_y_extent+y_offset), \n                  (start_bp, highlight_y_extent+y_offset),\n                  (end_bp, highlight_y_extent+y_offset),\n                  (end_bp, -highlight_y_extent+y_offset)], facecolor=color, edgecolor=color, linewidth=linewidth, zorder=14+zorder_add, \n                  path_effects=[Stroke(joinstyle=\"miter\")]) # This is a work around for matplotlib < 1.4.0)\n    ax.add_patch(p2)\n    if opts != None and 'label' in list(opts.keys()):\n        if start_bp > end_bp:\n            write_label(ax, opts['label'], end_bp+((start_bp-end_bp)/2.0), opts=opts)\n        else:\n            write_label(ax, opts['label'], start_bp+((end_bp-start_bp)/2.0), opts=opts)\n    if start_bp > end_bp:\n        return end_bp, start_bp\n    else:\n        return start_bp, end_bp\n", "docstring": "Built-in trace-based ribosome binding site renderer."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def trace_cds (ax, type, num, start_bp, end_bp, prev_end, scale, linewidth, opts):\n    \"\"\" Built-in trace-based coding sequence renderer.\n    \"\"\"\n    # Default options\n    zorder_add = 0.0\n    color = (0.7,0.7,0.7)\n    hatch = ''\n    y_offset = 0.0\n    y_extent = 1.5\n    arrowhead_height = 1.0\n    arrowhead_length = 30.0\n    # Reset defaults if provided\n    if opts != None:\n        if 'zorder_add' in list(opts.keys()):\n            zorder_add = opts['zorder_add']\n        if 'color' in list(opts.keys()):\n            color = opts['color']\n        if 'hatch' in list(opts.keys()):\n            hatch = opts['hatch']\n        if 'y_offset' in list(opts.keys()):\n            y_offset = opts['y_offset']\n        if 'y_extent' in list(opts.keys()):\n            y_extent = opts['y_extent']\n        if 'arrowhead_height' in list(opts.keys()):\n            arrowhead_height = opts['arrowhead_height']\n        if 'arrowhead_length' in list(opts.keys()):\n            arrowhead_length = opts['arrowhead_length']\n        if 'linewidth' in list(opts.keys()):\n            linewidth = opts['linewidth']\n        if 'scale' in list(opts.keys()):\n            scale = opts['scale']\n    # Check direction add start padding\n    dir_fac = 1.0\n    if start_bp > end_bp:\n        dir_fac = -1.0\n    # Draw the CDS symbol\n    p1 = Polygon([(start_bp, y_extent+y_offset), \n                  (start_bp, -y_extent+y_offset),\n                  (end_bp-dir_fac*arrowhead_length*scale, -y_extent+y_offset),\n                  (end_bp-dir_fac*arrowhead_length*scale, -y_extent-arrowhead_height+y_offset),\n                  (end_bp, 0+y_offset),\n                  (end_bp-dir_fac*arrowhead_length*scale, y_extent+arrowhead_height+y_offset),\n                  (end_bp-dir_fac*arrowhead_length*scale, y_extent+y_offset)],\n                  edgecolor=(0.0,0.0,0.0), facecolor=color, linewidth=linewidth, \n                  hatch=hatch, zorder=15+zorder_add, \n                  path_effects=[Stroke(joinstyle=\"miter\")]) # This is a work around for matplotlib < 1.4.0)\n    ax.add_patch(p1)\n    if opts != None and 'label' in list(opts.keys()):\n        if start_bp > end_bp:\n            write_label(ax, opts['label'], end_bp+((start_bp-end_bp)/2.0), opts=opts)\n        else:\n            write_label(ax, opts['label'], start_bp+((end_bp-start_bp)/2.0), opts=opts)\n    if start_bp > end_bp:\n        return end_bp, start_bp\n    else:\n        return start_bp, end_bp\n", "docstring": "Built-in trace-based coding sequence renderer."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "    def trace_part_renderers (self):\n        \"\"\" Return dictionary of all standard built-in trace part renderers.\n        \"\"\"\n        return {\n            'Promoter'         :trace_promoter, \n            'CDS'              :trace_cds, \n            'Terminator'       :trace_terminator,\n            'RBS'              :trace_rbs,\n            'UserDefined'      :trace_user_defined} \n", "docstring": "Return dictionary of all standard built-in trace part renderers."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def plot_sbol_designs (axes, dna_designs, regulations=None, plot_params={}, plot_names=None):\n    \"\"\" Plot SBOL designs to axes.\n    Parameters\n    ----------\n    axes : list(matplotlib.axis)\n        List of axis objects to plot the designs to. \n    dna_designs : list(dict(design_information))\n        List of designs to plot.\n    regulations : list(dict(regulation_information)) (default=None)\n        List of regulations to use for each design.\n    plot_params : dict (default={})\n        General plotting parameters to use.\n    plot_names : list(string) (default=None)\n        List of names to use on each plot. If None provided then no titles displayed.\n    Returns\n    -------\n    xlims : [float, float]\n        The x-axis range for each axis.\n    ylims : [float, float]\n        The y-axis range for each axis.\n    \"\"\"\n    # Standard plotting parameters\n    if 'axis_y' not in list(plot_params.keys()):\n        plot_params['axis_y'] = 35\n    left_pad = 0.0\n    right_pad = 0.0\n    scale = 1.0\n    linewidth = 1.0\n    fig_y = 5.0\n    fig_x = 5.0\n    if 'backbone_pad_left' in list(plot_params.keys()):\n        left_pad = plot_params['backbone_pad_left']\n    if 'backbone_pad_right' in list(plot_params.keys()):\n        right_pad = plot_params['backbone_pad_right']\n    if 'scale' in list(plot_params.keys()):\n        scale = plot_params['scale']\n    if 'linewidth' in list(plot_params.keys()):\n        linewidth = plot_params['linewidth']\n    dr = DNARenderer(scale=scale, linewidth=linewidth,\n                         backbone_pad_left=left_pad, \n                         backbone_pad_right=right_pad)\n    # We default to the standard regulation renderers\n    reg_renderers = dr.std_reg_renderers()\n    # We default to the SBOL part renderers\n    part_renderers = dr.SBOL_part_renderers()\n    # Plot each design on the appropriate axis\n    num_of_designs = len(dna_designs)\n    max_dna_len = 0.0\n    for i in range(num_of_designs):\n        # Create axis for the design and plot\n        regs = None\n        if(regulations != None):\n            regs   =  regulations[i]\n        design =  dna_designs[i]\n        ax = axes[i]\n        if plot_names != None:\n            ax.set_title(plot_names[i], fontsize=8)\n        start, end = dr.renderDNA(ax, design, part_renderers, regs, reg_renderers)\n        dna_len = end-start\n        if max_dna_len < dna_len:\n            max_dna_len = dna_len\n    # Update formatting and resize all axis in similar way\n    for ax in axes:\n        ax.set_xticks([])\n        ax.set_yticks([])\n        # Set bounds\n        ax.set_xlim([(-0.01*max_dna_len)-left_pad,\n                    max_dna_len+(0.01*max_dna_len)+right_pad])\n        ax.set_ylim([-plot_params['axis_y'],plot_params['axis_y']])\n        ax.set_aspect('equal')\n        ax.set_axis_off()\n    # xlims, ylims are returned\n    return max_dna_len, [(-0.01*max_dna_len)-left_pad, max_dna_len+(0.01*max_dna_len)+right_pad], [-plot_params['axis_y'],plot_params['axis_y']]\n", "docstring": "Plot SBOL designs to axes."}
{"repo": "dnaplotlib-master/dnaplotlib/dnaplotlib.py", "original_string": "def load_design_from_gff (filename, chrom, type_map=dpl_default_type_map, region=None):\n    # Load the GFF data\n    gff = []\n    data_reader = csv.reader(open(filename, 'rU'), delimiter='\\t')\n    for row in data_reader:\n        if len(row) == 9:\n            cur_chrom = row[0]\n            part_type = row[2]\n            start_bp = int(row[3])\n            end_bp = int(row[4])\n            part_dir = row[6]\n            part_attribs = {}\n            split_attribs = row[8].split(';')\n            part_name = None\n            for attrib in split_attribs:\n                key_value = attrib.split('=')\n                if len(key_value) == 2:\n                    if key_value[0] == 'Name':\n                        part_name = key_value[1]\n                    else:\n                        part_attribs[key_value[0]] = convert_attrib(key_value[1])\n            if part_name != None and cur_chrom == chrom and part_type in list(type_map.keys()):\n                # Check feature start falls in region\n                if region != None and (start_bp > region[0] and start_bp < region[1]):\n                    gff.append([part_name, type_map[part_type], part_dir, start_bp, end_bp, part_attribs])\n    # Convert to DNAplotlib design (sort on start position first)\n    design = []\n    for gff_el in sorted(gff, key=itemgetter(3)):\n        new_part = {}\n        new_part['name'] = gff_el[0]\n        new_part['type'] = gff_el[1]\n        if gff_el[2] == '+':\n            new_part['fwd'] = True\n        else:\n            new_part['fwd'] = False\n        new_part['start'] = gff_el[3]\n        new_part['end'] = gff_el[4]\n        new_part['opts'] = gff_el[5]\n        design.append(new_part)\n    # Return the sorted design\n    return design\n", "docstring": "Load the GFF data"}
{"repo": "dnaplotlib-master/dnaplotlib/sbol/sbolplotlib.py", "original_string": "    def SO_terms(self):\n        \"\"\" Return dictionary of all standard built-in SBOL part renderers referenced by Sequence Ontology term\n        \"\"\"\n        return {\n        'SO_0000167': 'Promoter',\n        'SO_0000316': 'CDS',\n        'SO_0000141': 'Terminator',\n        'SO_0000552': 'RBS',\n        'SO_0001953': 'Scar',\n        # No SO Term : 'Spacer',\n        # No SO Term : 'EmptySpace',\n        'SO_000037': 'Ribozyme',\n        'SO_0001977': 'Ribonuclease',\n        'SO_0001955': 'ProteinStability',\n        'SO_0001956': 'Protease',\n        'SO_0000057': 'Operator',\n        # SO term insulator does not have same semantics : 'Insulator',\n        'SO_0000296': 'Origin',\n        'SO_0001932': '5Overhang',\n        'SO_0001933': '3Overhang',\n        'SO_0001687': 'RestrictionSite',\n        'SO_0000299': 'RecombinaseSite',\n        'SO_0001691': 'BluntRestrictionSite',\n        'SO_0005850': 'PrimerBindingSite',\n        'SO_0001694': '5StickyRestrictionSite',\n        'SO_0001690': '3StickyRestrictionSite',\n        'SO_0000001': 'UserDefined',\n        'SO_0001978': 'Signature',\n        }\n", "docstring": "Return dictionary of all standard built-in SBOL part renderers referenced by Sequence Ontology term"}
{"repo": "netutils-linux-master/setup.py", "original_string": "def read(*paths):\n    \"\"\"Build a file path from *paths* and return the contents.\"\"\"\n    with open(os.path.join(*paths), 'r') as f:\n        return f.read()\n", "docstring": "Build a file path from *paths* and return the contents.\n"}
{"repo": "netutils-linux-master/netutils_linux_tuning/rss_ladder.py", "original_string": "    def eval(self):\n        \"\"\" Top of all the logic, decide what to do and then apply new settings \"\"\"\n        interrupts = open(self.interrupts_file).readlines()\n        extract_func = self.queue_suffix_extract if 'pci' in self.options.dev else self.queue_postfix_extract\n        for queue_pattern in sorted(self.queue_pattern_detect(interrupts, extract_func)):\n            self.apply(self.__eval(queue_pattern, interrupts))\n", "docstring": "Top of all the logic, decide what to do and then apply new settings \n"}
{"repo": "netutils-linux-master/netutils_linux_tuning/rx_buffers.py", "original_string": "    def parse(self):\n        \"\"\" get maximum and current rx ring buffers values via ethtool \"\"\"\n        self.network_scripts_check()\n        self.run_ethtool('-i', 1)\n        self.maximum, self.current = self.parse_ethtool_buffers()\n", "docstring": "get maximum and current rx ring buffers values via ethtool \n"}
{"repo": "netutils-linux-master/netutils_linux_tuning/rx_buffers.py", "original_string": "    def apply(self, decision):\n        \"\"\" doing all the job, applying new buffer's size if required \"\"\"\n        if decision == self.current:\n            print_(\"{0}'s RX ring buffer already has fine size {1}.\".format(self.options.dev, self.current))\n            return\n        assert decision, \"Can't eval prefered RX ring buffer size.\"\n        command = 'ethtool -G {0} rx {1}'.format(self.options.dev, decision)\n        print_('run:', command)\n        if not self.options.dry_run:\n            system(command)\n", "docstring": "doing all the job, applying new buffer's size if required \n"}
{"repo": "netutils-linux-master/netutils_linux_tuning/auto_softirq_tune.py", "original_string": "    def eval(self):\n        \"\"\" Evaluates CPU mask used as decision for the apply() \"\"\"\n        self.topology = Topology(lscpu_output=self.lscpu())\n        if not any([self.options.socket is not None, self.options.cpus, self.options.cpu_mask]):\n            self.socket_detect()\n        self.mask_detect()\n", "docstring": "Evaluates CPU mask used as decision for the apply() \n"}
{"repo": "netutils-linux-master/netutils_linux_tuning/auto_softirq_tune.py", "original_string": "    def cpus2mask(cpus, cpus_count):\n        \"\"\" There's no need to fill mask with zeroes, kernel does it automatically.\n        :param cpus: which cpus to use in mask calculation (e.g. [4,5,6,7])\n        :param cpus_count: how many cpus in this system (e.g. 8)\n        :return: cpu_mask to apply\n        \"\"\"\n        bitmap = [0] * cpus_count\n        for cpu in cpus:\n            bitmap[cpu] = 1\n        return hex(int(''.join([str(cpu) for cpu in bitmap]), 2))[2:]  # no need to write 0x\n", "docstring": "There's no need to fill mask with zeroes, kernel does it automatically."}
{"repo": "netutils-linux-master/netutils_linux_tuning/base_tune.py", "original_string": "    def make_parser():\n        \"\"\" Make parser with options common for all tune utils \"\"\"\n        parser = ArgumentParser()\n        parser.add_argument('-t', '--test-dir', type=str,\n                            help='Use prepared test dataset in TEST_DIR directory instead of running lscpu.')\n        parser.add_argument('-d', '--dry-run', help=\"Don't apply any settings.\", action='store_true', default=False)\n        return parser\n", "docstring": "Make parser with options common for all tune utils \n"}
{"repo": "netutils-linux-master/netutils_linux_tuning/base_tune.py", "original_string": "    def parse_options(self):\n        \"\"\" Parse options for specific util \"\"\"\n", "docstring": "Parse options for specific util \n"}
{"repo": "netutils-linux-master/netutils_linux_tuning/base_tune.py", "original_string": "    def parse(self):\n        \"\"\" Parse some system data required to decide how to do the best \"\"\"\n", "docstring": "Parse some system data required to decide how to do the best \n"}
{"repo": "netutils-linux-master/netutils_linux_tuning/base_tune.py", "original_string": "    def eval(self):\n        \"\"\" Decide what to do with NIC \"\"\"\n", "docstring": "Decide what to do with NIC \n"}
{"repo": "netutils-linux-master/netutils_linux_tuning/base_tune.py", "original_string": "    def apply(self, decision):\n        \"\"\" Applying decision about NIC \"\"\"\n", "docstring": "Applying decision about NIC \n"}
{"repo": "netutils-linux-master/netutils_linux_tuning/base_tune.py", "original_string": "    def make_parser():\n        \"\"\" Argument parser for CPU based tune-utils \"\"\"\n        parser = BaseTune.make_parser()\n        parser.add_argument('-c', '--cpus', help='Explicitly define list of CPUs for binding NICs queues', type=int,\n                            nargs='+')\n        parser.add_argument('dev', type=str)\n        parser.add_argument('socket', nargs='?', type=int)\n        return parser\n", "docstring": "Argument parser for CPU based tune-utils \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/softirqs.py", "original_string": "    def colorize_net_rx(net_rx):\n        \"\"\" :returns: highlighted by warning/error net_rx string \"\"\"\n        return Color.colorize(net_rx, 40000, 80000)\n", "docstring": ":returns: highlighted by warning/error net_rx string \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/softirqs.py", "original_string": "    def colorize_net_tx(net_tx):\n        \"\"\" :returns: highlighted by warning/error net_tx string \"\"\"\n        return Color.colorize(net_tx, 20000, 30000)\n", "docstring": ":returns: highlighted by warning/error net_tx string \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/colors.py", "original_string": "    def wrap(word, color):\n        \"\"\" wrap string in given color \"\"\"\n        return '{0}{1}{2}'.format(color, word, Style.RESET_ALL)\n", "docstring": "wrap string in given color \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/irqtop.py", "original_string": "    def colorize_irq_per_cpu(irq_per_cpu):\n        \"\"\" :returns: highlighted by warning/error irq string \"\"\"\n        return Color.colorize(irq_per_cpu, 40000, 80000)\n", "docstring": ":returns: highlighted by warning/error irq string \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/irqtop.py", "original_string": "    def eval_diff_total_column(self, column, cpucount):\n        \"\"\" returns sum of all interrupts on given CPU \"\"\"\n        return sum(int(row[column]) for row in self.diff if len(row) > cpucount + 1)\n", "docstring": "returns sum of all interrupts on given CPU \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/irqtop.py", "original_string": "    def has_diff(self, row):\n        \"\"\" detect if there were interrupts in this tick() on this IRQ \"\"\"\n        return any(x > self.options.delta_small_hide_limit for x in row if isinstance(x, int))\n", "docstring": "detect if there were interrupts in this tick() on this IRQ \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/softnet_stat.py", "original_string": "    def parse_list(self, data):\n        \"\"\" Initialize SoftnetStat by list of integers \"\"\"\n        self.cpu, self.total, self.dropped, self.time_squeeze, self.cpu_collision, self.received_rps = data\n        return self\n", "docstring": "Initialize SoftnetStat by list of integers \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/softnet_stat.py", "original_string": "    def colorize_total(total):\n        \"\"\" :returns: highlighted by warning/error total string \"\"\"\n        return Color.colorize(total, 300000, 900000)\n", "docstring": ":returns: highlighted by warning/error total string \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/softnet_stat.py", "original_string": "    def colorize_dropped(dropped):\n        \"\"\" :returns: highlighted by warning/error dropped string \"\"\"\n        return Color.colorize(dropped, 1, 1)\n", "docstring": ":returns: highlighted by warning/error dropped string \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/softnet_stat.py", "original_string": "    def colorize_time_squeeze(time_squeeze):\n        \"\"\" :returns: highlighted by warning/error time_squeeze string \"\"\"\n        return Color.colorize(time_squeeze, 1, 300)\n", "docstring": ":returns: highlighted by warning/error time_squeeze string \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/link_rate.py", "original_string": "    def __indent__(column, value, maxvalue=0):\n        \"\"\" May be used for special indent for first column \"\"\"\n        return \"{0:<14}\".format(value) if column == maxvalue else \"{0:>11}\".format(value)\n", "docstring": "May be used for special indent for first column \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/link_rate.py", "original_string": "    def devices_list_regex(self):\n        \"\"\" Returns list of network devices matching --device-regex \"\"\"\n        net_dev_list = listdir('/sys/class/net/')\n        return [dev for dev in net_dev_list if match(self.options.device_regex, dev)]\n", "docstring": "Returns list of network devices matching --device-regex \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/link_rate.py", "original_string": "    def post_optparse(self):\n        \"\"\" Asserting and applying parsing options \"\"\"\n        self.options.devices = self.devices_list()\n        if not self.options.devices:\n            raise ValueError(\"No devices've been specified\")\n        if self.options.rx_only:\n            self.stats = [\n                stat for stat in self.stats if stat.filename.startswith('rx')]\n        if self.options.simple_mode:\n            simple_stats = ('rx_packets', 'rx_bytes', 'rx_errors', 'tx_packets', 'tx_bytes', 'tx_errors')\n            self.stats = [\n                stat for stat in self.stats if stat.filename in simple_stats]\n        self.unit_change()\n        self.header = self.make_header()\n        self.align_map = ['l'] + ['r'] * (len(self.header) - 1)\n        if not self.pci:\n            self.pci = PCI()\n            self.pci.devices = self.pci.node_dev_dict(self.options.devices, self.options.random)\n        self.color = Color(topology=None, enabled=self.options.color)\n", "docstring": "Asserting and applying parsing options \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/topology.py", "original_string": "    def __detect_layout_lscpu():\n        process = Popen(['lscpu', '-p'], stdout=PIPE, stderr=PIPE)\n        stdout, _ = process.communicate()\n        return stdout, process.returncode\n", "docstring": "process = Popen(['lscpu', '-p'], stdout=PIPE, stderr=PIPE)"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/snmptop.py", "original_string": "    def __listify(lines, keys_id, values_id):\n        \"\"\" :returns: list[list] = [[IpReceived, 23123], [IpSend, 231]] \"\"\"\n        return [list(tpl) for tpl in zip(lines[keys_id][1:], lines[values_id][1:])]\n", "docstring": ":returns: list[list] = [[IpReceived, 23123], [IpSend, 231]] \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/snmptop.py", "original_string": "    def make_header():\n        \"\"\" :returns: header for prettytable output (provides unique invisible whitespace-headers)\n        6, 5, 4 spaces are for column blinking avoidance.\n        \"\"\"\n        return ['IP', ' ' * 6, 'TCP', ' ' * 5, 'UDP', ' ' * 4, 'ICMP', '']\n", "docstring": ":returns: header for prettytable output (provides unique invisible whitespace-headers)"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/network_top.py", "original_string": "    def __repr__(self):\n        output = [\n            BaseTop.header,\n            self.__repr_irq(),\n            self.__repr_cpu(),\n            self.__repr_dev(),\n        ]\n        if not self.options.clear:\n            del output[0]\n        return '\\n'.join(output)\n", "docstring": "output = ["}
{"repo": "netutils-linux-master/netutils_linux_monitoring/base_top.py", "original_string": "    def make_base_parser(parser=None):\n        \"\"\" That should be explicitly called in __main__ part of any top-like utils \"\"\"\n        if not parser:\n            parser = argparse.ArgumentParser()\n        parser.add_argument('-i', '--interval', default=1, type=int,\n                            help='Interval between screen renew in seconds.')\n        parser.add_argument('-n', '--iterations', dest='iterations', default=60, type=int,\n                            help='Count of screen\\'s renews, -1 - infinite loop.')\n        parser.add_argument('--no-delta-mode', action='store_false', dest='delta_mode',\n                            default=True, help=\"Shows metrics' values instead of growth.\")\n        parser.add_argument('--no-delta-small-hide', action='store_false',\n                            dest='delta_small_hide', default=True,\n                            help='Prevent lines with only small changes or without'\n                                 'changes at all from hiding.')\n        parser.add_argument('-l', '--delta-small-hide-limit', default=80, type=int,\n                            help='Hides lines with only changes less than this limit')\n        parser.add_argument('--no-color', dest='color', default=True, action='store_false',\n                            help=\"Don't highlight NUMA nodes or sockets\")\n        parser.add_argument('--spaces', default=False, action='store_true',\n                            help=\"Add spaces in numbers' representation, e.g. '1234567' \"\n                                 \"will be '1 234 567'\")\n        parser.add_argument('--random', default=False, action='store_true',\n                            help='Shows random diff data instead of real evaluation. '\n                                 'Helpful for testing on static files')\n        parser.add_argument('--no-clear', default=True, dest='clear', action='store_false',\n                            help=\"Don't clear screen after each iteration. \"\n                                 \"May be useful in scripts/logging to file.\")\n        parser.add_argument('--lscpu-output', help='Specify file with lscpu -p output')\n        return parser\n", "docstring": "That should be explicitly called in __main__ part of any top-like utils \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/base_top.py", "original_string": "    def tick(self):\n        \"\"\" Gathers new data + evaluate diff between current & previous data \"\"\"\n        self.previous = self.current\n        self.current = self.parse()\n        if all((self.previous, self.current)):\n            self.eval()\n", "docstring": "Gathers new data + evaluate diff between current & previous data \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/base_top.py", "original_string": "    def run(self):\n        \"\"\" Default main()-like function for specific top-like utils except meta-utils. \"\"\"\n        infinite = -1\n        if self.options.iterations != infinite:\n            self.options.iterations += 1\n        try:\n            while self.options.iterations > 0 or self.options.iterations == infinite:\n                if self.options.iterations != infinite:\n                    self.options.iterations -= 1\n                sleep(self.options.interval)\n                self.tick()\n                if self.options.clear:\n                    system('clear')\n                if self.diff:\n                    print_(self)\n        except KeyboardInterrupt:\n            print_()\n            exit(0)\n", "docstring": "Default main()-like function for specific top-like utils except meta-utils. \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/base_top.py", "original_string": "    def parse(self):\n        \"\"\" Should read some file(s) into python structure (dict/list) \"\"\"\n", "docstring": "Should read some file(s) into python structure (dict/list) \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/base_top.py", "original_string": "    def eval(self):\n        \"\"\" Should evaluate self.diff using self.previous / self.current \"\"\"\n", "docstring": "Should evaluate self.diff using self.previous / self.current \n"}
{"repo": "netutils-linux-master/netutils_linux_monitoring/base_top.py", "original_string": "    def __repr__(self):\n        \"\"\" Should return string, representing self.diff \"\"\"\n", "docstring": "Should return string, representing self.diff \n"}
{"repo": "netutils-linux-master/netutils_linux_hardware/disk.py", "original_string": "        def parse(text):\n            types = ['SSD', 'HDD']\n            if not text:\n                return dict()\n            _text = text.replace(':', ': ').replace('/sys/block/', '').replace('/queue/rotational', '')\n            data = yaml.load(_text, yaml.loader.SafeLoader)\n            return dict((k, types[v]) for k, v in data.items())\n", "docstring": "types = ['SSD', 'HDD']"}
{"repo": "netutils-linux-master/netutils_linux_hardware/interrupts.py", "original_string": "    def irq2cpucount(text):\n        \"\"\" IDK maybe /proc/interrupts cpu count differ from nproc \"\"\"\n        return len(text.split('\\n')[0].split())\n", "docstring": "IDK maybe /proc/interrupts cpu count differ from nproc \n"}
{"repo": "netutils-linux-master/netutils_linux_hardware/server.py", "original_string": "    def collect(self):\n        \"\"\" Save raw data to given directory \"\"\"\n        already_exists = os.path.exists(self.directory)\n        if already_exists and not self.args.collect:\n            return\n        if already_exists:\n            shutil.rmtree(self.directory)\n        os.makedirs(self.directory)\n        os.system('server-info-collect {0}'.format(self.directory))\n        self.archive()\n", "docstring": "Save raw data to given directory \n"}
{"repo": "netutils-linux-master/netutils_linux_hardware/server.py", "original_string": "    def rate(self):\n        \"\"\" Rater of parsed data \"\"\"\n        info = self.read()\n        folding = Folding(self.args)\n        rates = dict()\n        for key, subsystem in self.subsystems.items():\n            if getattr(self.args, key):\n                rates[key] = subsystem(info, folding).rate()\n        return folding.fold(rates, Folding.SERVER)\n", "docstring": "Rater of parsed data \n"}
{"repo": "netutils-linux-master/netutils_linux_hardware/net.py", "original_string": "    def parse(text):\n        \"\"\" # 0 - id, 1 - dev, 2 - _, 3 - state, 4 - _, 5 - details, 6 - _, 7 - mtu, 8 - _, 9 - master\n        :param text: # 3: eth1 state DOWN : <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 master br1 state disabled\n        :return: analyzed netdevs\n        \"\"\"\n        __dev__ = 1\n        netdevs_keys = [line.split()[__dev__] for line in text.strip().split('\\n')]\n        return NetdevParser.parse(netdevs_keys)\n", "docstring": "# 0 - id, 1 - dev, 2 - _, 3 - state, 4 - _, 5 - details, 6 - _, 7 - mtu, 8 - _, 9 - master"}
{"repo": "netutils-linux-master/netutils_linux_hardware/net.py", "original_string": "    def parse_file(self, filepath, **kwargs):\n        return self.parse(os.listdir(filepath))\n", "docstring": "return self.parse(os.listdir(filepath))"}
{"repo": "netutils-linux-master/netutils_linux_hardware/subsystem.py", "original_string": "    def collect(self):\n        \"\"\" Collecting required data from host \"\"\"\n        pass\n", "docstring": "Collecting required data from host \n"}
{"repo": "netutils-linux-master/netutils_linux_hardware/subsystem.py", "original_string": "    def parse(self):\n        \"\"\" Parse that data to dict or something like this \"\"\"\n        pass\n", "docstring": "Parse that data to dict or something like this \n"}
{"repo": "netutils-linux-master/netutils_linux_hardware/subsystem.py", "original_string": "    def rate(self):\n        \"\"\" Rating every detail in the parsed data \"\"\"\n        pass\n", "docstring": "Rating every detail in the parsed data \n"}
{"repo": "netutils-linux-master/netutils_linux_hardware/grade.py", "original_string": "    def int(value, _min, _max, scale=10):\n        \"\"\" Well, it's tricky function writen by all the twitter \"\"\"\n        value = any2int(value)\n        return min(scale, max(1, int(1 + round_((value - _min) * (scale - 1.) / (_max - _min) + .001))))\n", "docstring": "Well, it's tricky function writen by all the twitter \n"}
{"repo": "netutils-linux-master/netutils_linux_hardware/rate_math.py", "original_string": "def __str2int(value):\n    result = re.sub(r'[^0-9.]+', '', value)\n    try:\n        return int(float(result)) if '.' in result else int(result)\n    except ValueError:\n        return 0\n", "docstring": "result = re.sub(r'[^0-9.]+', '', value)"}
{"repo": "deuces-master/deuces/card.py", "original_string": "    def int_to_str(card_int):\n        rank_int = Card.get_rank_int(card_int)\n        suit_int = Card.get_suit_int(card_int)\n        return Card.STR_RANKS[rank_int] + Card.INT_SUIT_TO_CHAR_SUIT[suit_int]\n", "docstring": "rank_int = Card.get_rank_int(card_int)"}
{"repo": "python-elgato-streamdeck-master/src/example_animated.py", "original_string": "def key_change_callback(deck, key, state):\n    # Use a scoped-with on the deck to ensure we're the only thread using it\n    # right now.\n    with deck:\n        # Reset deck, clearing all button images.\n        deck.reset()\n        # Close deck handle, terminating internal worker threads.\n        deck.close()\n", "docstring": "Use a scoped-with on the deck to ensure we're the only thread using it"}
{"repo": "python-elgato-streamdeck-master/src/example_animated.py", "original_string": "        def animate(fps):\n            # Convert frames per second to frame time in seconds.\n            #\n            # Frame time often cannot be fully expressed by a float type,\n            # meaning that we have to use fractions.\n            frame_time = Fraction(1, fps)\n            # Get a starting absolute time reference point.\n            #\n            # We need to use an absolute time clock, instead of relative sleeps\n            # with a constant value, to avoid drifting.\n            #\n            # Drifting comes from an overhead of scheduling the sleep itself -\n            # it takes some small amount of time for `time.sleep()` to execute.\n            next_frame = Fraction(time.monotonic())\n            # Periodic loop that will render every frame at the set FPS until\n            # the StreamDeck device we're using is closed.\n            while True:\n                try:\n                    # Use a scoped-with on the deck to ensure we're the only\n                    # thread using it right now.\n                    with deck:\n                        # Update the key images with the next animation frame.\n                        for key, frames in key_images.items():\n                            deck.set_key_image(key, next(frames))\n                except TransportError as err:\n                    print(\"TransportError: {0}\".format(err))\n                    # Something went wrong while communicating with the device\n                    # (closed?) - don't re-schedule the next animation frame.\n                    break\n                # Set the next frame absolute time reference point.\n                #\n                # We are running at the fixed `fps`, so this is as simple as\n                # adding the frame time we calculated earlier.\n                next_frame += frame_time\n                # Knowing the start of the next frame we can calculate how long\n                # we have to sleep until its start.\n                sleep_interval = float(next_frame) - time.monotonic()\n                # Schedule the next periodic frame update.\n                #\n                # `sleep_interval` can be a negative number when current FPS\n                # setting is too high for the combination of host and\n                # StreamDeck to handle. If this is the case, we skip sleeping\n                # immediately render the next frame to try to catch up.\n                if sleep_interval >= 0:\n                    time.sleep(sleep_interval)\n", "docstring": "Convert frames per second to frame time in seconds."}
{"repo": "python-elgato-streamdeck-master/src/example_tileimage.py", "original_string": "def key_change_callback(deck, key, state):\n    # Use a scoped-with on the deck to ensure we're the only thread using it\n    # right now.\n    with deck:\n        # Reset deck, clearing all button images.\n        deck.reset()\n        # Close deck handle, terminating internal worker threads.\n        deck.close()\n", "docstring": "Use a scoped-with on the deck to ensure we're the only thread using it"}
{"repo": "python-elgato-streamdeck-master/src/example_basic.py", "original_string": "def render_key_image(deck, icon_filename, font_filename, label_text):\n    # Resize the source image asset to best-fit the dimensions of a single key,\n    # leaving a margin at the bottom so that we can draw the key title\n    # afterwards.\n    icon = Image.open(icon_filename)\n    image = PILHelper.create_scaled_image(deck, icon, margins=[0, 0, 20, 0])\n    # Load a custom TrueType font and use it to overlay the key index, draw key\n    # label onto the image a few pixels from the bottom of the key.\n    draw = ImageDraw.Draw(image)\n    font = ImageFont.truetype(font_filename, 14)\n    draw.text((image.width / 2, image.height - 5), text=label_text, font=font, anchor=\"ms\", fill=\"white\")\n    return PILHelper.to_native_format(deck, image)\n", "docstring": "Resize the source image asset to best-fit the dimensions of a single key,"}
{"repo": "python-elgato-streamdeck-master/src/example_basic.py", "original_string": "def get_key_style(deck, key, state):\n    # Last button in the example application is the exit button.\n    exit_key_index = deck.key_count() - 1\n    if key == exit_key_index:\n        name = \"exit\"\n        icon = \"{}.png\".format(\"Exit\")\n        font = \"Roboto-Regular.ttf\"\n        label = \"Bye\" if state else \"Exit\"\n    else:\n        name = \"emoji\"\n        icon = \"{}.png\".format(\"Pressed\" if state else \"Released\")\n        font = \"Roboto-Regular.ttf\"\n        label = \"Pressed!\" if state else \"Key {}\".format(key)\n    return {\n        \"name\": name,\n        \"icon\": os.path.join(ASSETS_PATH, icon),\n        \"font\": os.path.join(ASSETS_PATH, font),\n        \"label\": label\n    }\n", "docstring": "Last button in the example application is the exit button."}
{"repo": "python-elgato-streamdeck-master/src/example_basic.py", "original_string": "def update_key_image(deck, key, state):\n    # Determine what icon and label to use on the generated key.\n    key_style = get_key_style(deck, key, state)\n    # Generate the custom key with the requested image and label.\n    image = render_key_image(deck, key_style[\"icon\"], key_style[\"font\"], key_style[\"label\"])\n    # Use a scoped-with on the deck to ensure we're the only thread using it\n    # right now.\n    with deck:\n        # Update requested key with the generated image.\n        deck.set_key_image(key, image)\n", "docstring": "Determine what icon and label to use on the generated key."}
{"repo": "python-elgato-streamdeck-master/src/example_basic.py", "original_string": "def key_change_callback(deck, key, state):\n    # Print new key state\n    print(\"Deck {} Key {} = {}\".format(deck.id(), key, state), flush=True)\n    # Update the key image based on the new key state.\n    update_key_image(deck, key, state)\n    # Check if the key is changing to the pressed state.\n    if state:\n        key_style = get_key_style(deck, key, state)\n        # When an exit button is pressed, close the application.\n        if key_style[\"name\"] == \"exit\":\n            # Use a scoped-with on the deck to ensure we're the only thread\n            # using it right now.\n            with deck:\n                # Reset deck, clearing all button images.\n                deck.reset()\n                # Close deck handle, terminating internal worker threads.\n                deck.close()\n", "docstring": "Print new key state"}
{"repo": "python-elgato-streamdeck-master/src/StreamDeck/Devices/StreamDeck.py", "original_string": "        def callback(*args):\n            asyncio.run_coroutine_threadsafe(async_callback(*args), loop)\n", "docstring": "asyncio.run_coroutine_threadsafe(async_callback(*args), loop)"}
{"repo": "Flake8Lint-master/lint.py", "original_string": "def tools_versions():\n    \"\"\"Return all lint tools versions.\"\"\"\n    return (\n        ('pep8', pep8.__version__),\n        ('flake8', flake8_version),\n        ('pyflakes', pyflakes_version),\n        ('mccabe', mccabe.__version__),\n        ('pydocstyle', pydocstyle_version),\n        ('naming', pep8ext_naming.__version__),\n        ('debugger', flake8_debugger.__version__),\n        ('import-order', flake8_import_order_version),\n    )\n", "docstring": "Return all lint tools versions.\n"}
{"repo": "Flake8Lint-master/lint.py", "original_string": "    def __init__(self, options):\n        \"\"\"Initialize reporter.\"\"\"\n        super(Pep8Report, self).__init__(options)\n        # errors \"collection\"\n        self.errors = []\n", "docstring": "Initialize reporter.\n"}
{"repo": "Flake8Lint-master/lint.py", "original_string": "    def __init__(self):\n        \"\"\"Construct a Reporter.\"\"\"\n        # errors \"collection\"\n        self.errors = []\n", "docstring": "Construct a Reporter.\n"}
{"repo": "Flake8Lint-master/lint.py", "original_string": "    def __init__(self, tree, filename, lines, order_style='cryptography'):\n        \"\"\"Initialize linter.\"\"\"\n        super(ImportOrderLinter, self).__init__(filename, tree)\n        self.lines = lines\n        self.options = {\n            'import_order_style': order_style,\n        }\n", "docstring": "Initialize linter.\n"}
{"repo": "Flake8Lint-master/lint.py", "original_string": "    def error(self, node, code, message):\n        \"\"\"Format lint error.\"\"\"\n        lineno, col_offset = node.lineno, node.col_offset\n        return (lineno, col_offset, '{0} {1}'.format(code, message))\n", "docstring": "Format lint error.\n"}
{"repo": "Flake8Lint-master/lint.py", "original_string": "def load_flake8_config(filename, global_config=False, project_config=False):\n    \"\"\"Return flake8 settings from config file.\n    More info: http://flake8.readthedocs.org/en/latest/config.html\n    \"\"\"\n    parser = RawConfigParser()\n    # check global config\n    if global_config and os.path.isfile(DEFAULT_CONFIG_FILE):\n        parser.read(DEFAULT_CONFIG_FILE)\n    # search config in filename dir and all parent dirs\n    if project_config:\n        parent = tail = os.path.abspath(filename)\n        while tail:\n            if parser.read([os.path.join(parent, fn) for fn in CONFIG_FILES]):\n                break\n            parent, tail = os.path.split(parent)\n    result = {}\n    if parser.has_section('flake8'):\n        options = (\n            ('ignore', 'ignore', 'list'),\n            ('select', 'select', 'list'),\n            ('exclude', 'ignore_files', 'list'),\n            ('max_line_length', 'pep8_max_line_length', 'int')\n        )\n        for config, plugin, option_type in options:\n            if not parser.has_option('flake8', config):\n                config = config.replace('_', '-')\n            if parser.has_option('flake8', config):\n                if option_type == 'list':\n                    option_value = parser.get('flake8', config).strip()\n                    if option_value:\n                        result[plugin] = option_value.split(',')\n                elif option_type == 'int':\n                    option_value = parser.get('flake8', config).strip()\n                    if option_value:\n                        result[plugin] = parser.getint('flake8', config)\n    return result\n", "docstring": "Return flake8 settings from config file."}
{"repo": "Flake8Lint-master/lint.py", "original_string": "def lint_external(lines, settings, interpreter, linter):\n    \"\"\"Run flake8 lint with external interpreter.\"\"\"\n    import subprocess\n    # first argument is interpreter\n    arguments = [interpreter, linter]\n    # do we need to run pyflake lint\n    if settings.get('pyflakes', True):\n        arguments.append('--pyflakes')\n        builtins = settings.get('builtins')\n        if builtins:\n            arguments.append('--builtins')\n            arguments.append(','.join(builtins))\n    # do we need to run pep8 lint\n    if settings.get('pep8', True):\n        arguments.append('--pep8')\n        max_line_length = settings.get('pep8_max_line_length', 79)\n        arguments.append('--pep8-max-line-length')\n        arguments.append(str(max_line_length))\n    # do we need to run pydocstyle lint\n    if settings.get('pydocstyle', False):\n        arguments.append('--pydocstyle')\n    # do we need to run naming lint\n    if settings.get('naming', True):\n        arguments.append('--naming')\n    # do we need to run debugger lint\n    if settings.get('debugger', True):\n        arguments.append('--debugger')\n    # do we need to run import order lint\n    if settings.get('import_order', False):\n        arguments.append('--import-order')\n    # get import order style\n    import_order_style = settings.get('import_order_style')\n    if import_order_style in ('cryptography', 'google'):\n        arguments.extend(('--import-order-style', import_order_style))\n    else:\n        arguments.extend(('--import-order-style', 'cryptography'))\n    # do we need to run complexity check\n    complexity = settings.get('complexity', -1)\n    arguments.extend(('--complexity', str(complexity)))\n    # place for warnings =)\n    warnings = []\n    startupinfo = None\n    if os.name == 'nt':\n        startupinfo = subprocess.STARTUPINFO()\n        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n    # run subprocess\n    proc = subprocess.Popen(\n        arguments,\n        stdout=subprocess.PIPE,\n        stdin=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        startupinfo=startupinfo\n    )\n    result = proc.communicate(input=lines.encode('utf-8'))[0]\n    # parse STDOUT for warnings and errors\n    for line in result.splitlines():\n        line = line.decode('utf-8').strip()\n        warning = line.split(':', 2)\n        if len(warning) == 3:\n            try:\n                warnings.append((int(warning[0]), int(warning[1]), warning[2]))\n            except (TypeError, ValueError):\n                print(\"Flake8Lint ERROR: {0}\".format(line))\n        else:\n            print(\"Flake8Lint ERROR: {0}\".format(line))\n    # and return them =)\n    return warnings\n", "docstring": "Run flake8 lint with external interpreter.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def __init__(self):\n        \"\"\"Initialize settings.\"\"\"\n        editor_settings = sublime.load_settings('Preferences.sublime-settings')\n        editor_settings.clear_on_change('flake8lint-color-scheme')\n        editor_settings.add_on_change('flake8lint-color-scheme',\n                                      lambda: update_color_scheme(settings))\n        self.settings = sublime.load_settings('Flake8Lint.sublime-settings')\n        self.settings.clear_on_change('reload')\n        self.settings.add_on_change('reload', self.setup)\n        self.setup()\n", "docstring": "Initialize settings.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "def log(msg, level=None):\n    \"\"\"Log to ST python console.\n    If log level 'debug' (or None) print only if debug setting is enabled.\n    \"\"\"\n    if level is None:\n        level = 'debug'\n    if level == 'debug' and not settings.debug:\n        return\n    print(\"[Flake8Lint {0}] {1}\".format(level.upper(), msg))\n", "docstring": "Log to ST python console."}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "def isname(symbol):\n    \"\"\"Return `True` if `symbol` is part of function, class, etc name.\"\"\"\n    return bool(re.match(r'[_a-zA-Z0-9]', symbol))\n", "docstring": "Return `True` if `symbol` is part of function, class, etc name.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "def operator_prev(line, col):\n    \"\"\"Check if there is an operator in line, ends at `col`.\n    Returns operator length if so.\n    \"\"\"\n    line_piece = line[col - len(OPERATORS[0]):col]\n    for oper in OPERATORS:\n        if line_piece.endswith(oper):\n            return len(oper)\n", "docstring": "Check if there is an operator in line, ends at `col`."}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "def filename_match(filename, patterns):\n    \"\"\"Return `True` if filename is matched with patterns.\"\"\"\n    for path_part in filename.split(os.path.sep):\n        if any(fnmatch.fnmatch(path_part, pattern) for pattern in patterns):\n            return True\n    return False\n", "docstring": "Return `True` if filename is matched with patterns.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def _noqa(line):\n        \"\"\"Check if line ends with 'noqa' comment.\"\"\"\n        return line.strip().lower().endswith('# noqa')\n", "docstring": "Check if line ends with 'noqa' comment.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def update(view):\n        \"\"\"Update status bar with error.\"\"\"\n        # get view errors (exit if no errors found)\n        view_errors = ERRORS_IN_VIEWS.get(view.id())\n        if view_errors is None:\n            return\n        # get view selection (exit if no selection)\n        view_selection = view.sel()\n        if not view_selection:\n            return\n        current_line = SublimeView.get_current_line(view)\n        if current_line is None:\n            return\n        if current_line in view_errors:\n            # there is an error on current line\n            errors = view_errors[current_line]\n            view.set_status('flake8-tip', 'flake8: %s' % ' / '.join(errors))\n        else:\n            # no errors - clear statusbar\n            SublimeStatusBar.clear(view)\n", "docstring": "Update status bar with error.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def clear(view):\n        \"\"\"Clear status bar flake8 error.\"\"\"\n        view.erase_status('flake8-tip')\n", "docstring": "Clear status bar flake8 error.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def view_settings(view):\n        \"\"\"Return dict with view settings.\n        Settings are taken from (see README for more info):\n        - ST plugin settings (global, user, project)\n        - flake8 settings (global, project)\n        \"\"\"\n        result = {}\n        # get settings from global (user) plugin settings\n        view_settings = view.settings().get('flake8lint') or {}\n        for param in PROJECT_SETTINGS_KEYS:\n            result[param] = view_settings.get(param, getattr(settings, param))\n        # this is fallback to setting 'pydocstyle' old name 'pep257'\n        if hasattr(settings, 'pep257') and not hasattr(settings, 'pydocstyle'):\n            pep257 = getattr(settings, 'pep257')\n            result['pydocstyle'] = view_settings.get('pydocstyle', pep257)\n        global_config = result.get('use_flake8_global_config', True)\n        project_config = result.get('use_flake8_project_config', True)\n        if global_config or project_config:\n            filename = os.path.abspath(view.file_name())\n            flake8_config = load_flake8_config(filename, global_config,\n                                               project_config)\n            for param in FLAKE8_SETTINGS_KEYS:\n                if param in flake8_config:\n                    result[param] = flake8_config.get(param)\n        return result\n", "docstring": "Return dict with view settings."}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def get_current_line(view):\n        \"\"\"Get current line (line under cursor).\"\"\"\n        view_selection = view.sel()\n        if not view_selection:\n            return None\n        point = view_selection[0].end()\n        position = view.rowcol(point)\n        return position[0]\n", "docstring": "Get current line (line under cursor).\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def set_ruler_guide(view):\n        \"\"\"Set view ruler guide.\"\"\"\n        if not view.match_selector(0, 'source.python'):\n            return\n        log(\"set view ruler guide\")\n        view_settings = SublimeView.view_settings(view)\n        max_line_length = view_settings.get('pep8_max_line_length', 79)\n        try:\n            max_line_length = int(max_line_length)\n        except (TypeError, ValueError):\n            log(\"can't parse 'pep8_max_line_length' setting\", level='error')\n            max_line_length = 79\n        view.settings().set('rulers', [max_line_length])\n        log(\"view ruler guide is set to {0}\".format(max_line_length))\n", "docstring": "Set view ruler guide.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def __init__(self, view, errors_list, view_settings, quiet=False):\n        \"\"\"Initialize reporter.\"\"\"\n        self.view = view\n        self.errors_list = errors_list\n        self.errors_to_show = []\n        self.regions = {'critical': [], 'error': [], 'warning': []}\n        self.prepare_settings(view_settings)\n        self.prepare_errors(errors_list)\n        if self.errors_list:\n            self.show_errors(quiet=quiet)\n        else:\n            self.report_success(quiet=quiet)\n", "docstring": "Initialize reporter.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def prepare_settings(self, view_settings):\n        \"\"\"Get view lint settings.\"\"\"\n        self.get_gutter_mark()\n        self.select = view_settings.get('select') or []\n        self.ignore = view_settings.get('ignore') or []\n        self.is_highlight = settings.highlight\n        self.is_popup = settings.popup\n        log(\"'select' setting: {0}\".format(self.select))\n        log(\"'ignore' setting: {0}\".format(self.ignore))\n        log(\"'is_highlight' setting: {0}\".format(self.is_highlight))\n        log(\"'is_popup' setting: {0}\".format(self.is_popup))\n", "docstring": "Get view lint settings.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def error_selected(self, item_selected):\n        \"\"\"Error was selected - go to error.\"\"\"\n        if item_selected == -1:\n            log(\"close errors popup window\")\n            return\n        log(\"error was selected from popup window: scroll to line\")\n        # get error region\n        error = self.errors_list[item_selected]\n        region_begin = self.view.text_point(error[0] - 1, error[1])\n        # go to error\n        self.view.sel().clear()\n        self.view.sel().add(sublime.Region(region_begin, region_begin))\n        self.view.window().focus_view(self.view)\n        self.view.show_at_center(region_begin)\n        # work around sublime bug with caret position not refreshing\n        # see also: https://github.com/SublimeTextIssues/Core/issues/485\n        bug_key = 'selection_bug_demo_workaround_regions_key'\n        self.view.add_regions(bug_key, [], 'no_scope', '', sublime.HIDDEN)\n        self.view.erase_regions(bug_key)\n        SublimeStatusBar.update(self.view)\n", "docstring": "Error was selected - go to error.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def wait_and_lint(view):\n        \"\"\"Set rullers and run file lint after file was loaded.\"\"\"\n        window = sublime.active_window()\n        if not window:\n            return\n        window_views = (window_view.id() for window_view in window.views())\n        if view.id() not in window_views:  # view is preview\n            # FIXME: that if view will closed while we wait for it?\n            sublime.set_timeout(\n                lambda: Flake8Lint.wait_and_lint(view), 300\n            )\n            return\n        log(\"run lint by 'on_load' hook\")\n        Flake8Lint.do_lint(view)\n", "docstring": "Set rullers and run file lint after file was loaded.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def on_file_load(view=None, retry=False):\n        \"\"\"Run actions on file load.\n        Wait until file was finally loaded and run actions if needed.\n        \"\"\"\n        set_ruler_guide = settings.set_ruler_guide\n        lint_on_load = settings.lint_on_load\n        if not (set_ruler_guide or lint_on_load):\n            return  # no need to do anything\n        log(\"wait until file was loaded\")\n        if not retry:  # first run - wait a little bit\n            sublime.set_timeout(\n                lambda: Flake8Lint.on_file_load(view, True), 100\n            )\n            return\n        if view is None:\n            window = sublime.active_window()\n            if not window:\n                return\n            view = window.active_view()\n            if not view:\n                return\n        if view.is_loading():  # view is still running - wait again\n            sublime.set_timeout(\n                lambda: Flake8Lint.on_file_load(view, True), 100\n            )\n            return\n        if view.window() is None:  # view window is not initialized - wait...\n            sublime.set_timeout(\n                lambda: Flake8Lint.on_file_load(view, True), 100\n            )\n            return\n        if view.window().active_view().id() != view.id():\n            log(\"view is not active anymore, forget about lint\")\n            return  # not active anymore, don't lint it!\n        if set_ruler_guide:\n            SublimeView.set_ruler_guide(view)\n        else:\n            log(\"do not set ruler guide due to plugin settings\")\n        if lint_on_load:\n            Flake8Lint.wait_and_lint(view)\n        else:\n            log(\"skip lint by 'on_load' hook due to plugin settings\")\n", "docstring": "Run actions on file load."}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def cleanup(view):\n        \"\"\"Clear regions and statusbar.\"\"\"\n        # cleanup errors in cache\n        ERRORS_IN_VIEWS.pop(view.id(), None)\n        # we need to always clear regions. three situations here:\n        # - we need to clear regions with fixed previous errors\n        # - is user will turn off 'highlight' in settings and then run lint\n        # - user adds file with errors to 'ignore_files' list\n        for level in ('warning', 'error', 'critical', 'success'):\n            view.erase_regions('flake8lint-{0}'.format(level))\n        # we need to always erase status too. same situations.\n        view.erase_status('flake8-tip')\n", "docstring": "Clear regions and statusbar.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def do_lint(view, quiet=False):\n        \"\"\"Do view lint.\"\"\"\n        log(\"run flake8 lint\")\n        if view.id() in DISABLED_VIEWS:\n            log(\"skip lint because view linting is disabled\")\n            Flake8Lint.cleanup(view)\n            return\n        # check if view is scratch\n        if view.is_scratch():\n            log(\"skip lint because view is scratch\")\n            Flake8Lint.cleanup(view)\n            return  # do not lint scratch views\n        # check if active view contains file\n        filename = view.file_name()\n        if not filename:\n            log(\"skip view: filename is empty\")\n            Flake8Lint.cleanup(view)\n            return\n        filename = os.path.abspath(filename)\n        # check only Python files\n        if not view.match_selector(0, 'source.python'):\n            log(\"skip file: view source type is not 'python'\")\n            Flake8Lint.cleanup(view)\n            return\n        # get view settings\n        view_settings = SublimeView.view_settings(view)\n        # skip files by pattern\n        patterns = view_settings.get('ignore_files')\n        log(\"ignore file patterns: {0}\".format(patterns))\n        if patterns:\n            # add file basename to check list\n            paths = [os.path.basename(filename)]\n            # add file relative paths to check list\n            for folder in sublime.active_window().folders():\n                folder_name = folder.rstrip(os.path.sep) + os.path.sep\n                if filename.startswith(folder_name):\n                    paths.append(filename[len(folder_name):])\n            try:\n                if any(filename_match(path, patterns) for path in set(paths)):\n                    message = \"File '{0}' lint was skipped by 'ignore' setting\"\n                    print(message.format(filename))\n                    Flake8Lint.cleanup(view)\n                    return\n            except (TypeError, ValueError):\n                sublime.error_message(\n                    \"Python Flake8 Lint error:\\n\"\n                    \"'ignore_files' option is not a list of file masks\"\n                )\n        if int(sublime.version()) >= 3000:\n            set_timeout = sublime.set_timeout_async\n        else:\n            set_timeout = sublime.set_timeout\n        set_timeout(\n            lambda: Flake8Lint.async_lint(view, view_settings, quiet=quiet), 0\n        )\n", "docstring": "Do view lint.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def async_lint(view, view_settings, quiet=False):\n        \"\"\"Do view lint asynchronously.\"\"\"\n        # try to get interpreter\n        interpreter = view_settings.get('python_interpreter', 'auto')\n        log(\"python interpreter: {0}\".format(interpreter))\n        lines = view.substr(sublime.Region(0, view.size()))\n        # skip file check if 'noqa' for whole file is set\n        if FLAKE8_NOQA(lines) is not None:\n            log(\"skip file: 'noqa' is set\")\n            Flake8Lint.cleanup(view)\n            return\n        start_time = time.time()\n        if not interpreter or interpreter == 'internal':\n            # if interpreter is Sublime Text internal python - lint file\n            log(\"interpreter is internal\")\n            errors_list = lint(lines, view_settings)\n        else:\n            # else - check interpreter\n            log(\"interpreter is external\")\n            if interpreter == 'auto':\n                if os.name == 'nt':\n                    interpreter = 'pythonw'\n                else:\n                    interpreter = 'python'\n                log(\"guess interpreter: '{0}'\".format(interpreter))\n            elif not os.path.exists(interpreter):\n                sublime.error_message(\n                    \"Python Flake8 Lint error:\\n\"\n                    \"python interpreter '%s' is not found\" % interpreter\n                )\n            # build linter path for Packages Manager installation\n            linter = os.path.join(PLUGIN_DIR, 'lint.py')\n            log(\"linter file: {0}\".format(linter))\n            # build linter path for installation from git\n            if not os.path.exists(linter):\n                linter = os.path.join(\n                    sublime.packages_path(), 'Python Flake8 Lint', 'lint.py')\n                log(\"linter is not exists, try this: {0}\".format(linter))\n            if not os.path.exists(linter):\n                sublime.error_message(\n                    \"Python Flake8 Lint error:\\n\"\n                    \"sorry, can't find correct plugin path\"\n                )\n            # and lint file in subprocess\n            log(\"interpreter is external\")\n            errors_list = lint_external(lines, view_settings,\n                                        interpreter, linter)\n        if not errors_list:\n            errors_list = []\n        lint_time = time.time() - start_time\n        log(\"lint time: {0:.3f}ms\".format(lint_time))\n        log(\"lint errors found: {0}\".format(len(errors_list)))\n        # clean regions and statusbar\n        Flake8Lint.cleanup(view)\n        # show errors\n        LintReport(view, errors_list, view_settings, quiet=quiet)\n", "docstring": "Do view lint asynchronously.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def run(self, edit):\n        \"\"\"Disable current view linting.\"\"\"\n        DISABLED_VIEWS.add(self.view.id())\n        Flake8Lint.cleanup(self.view)\n", "docstring": "Disable current view linting.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def run(self, edit):\n        \"\"\"Jump to next lint error.\"\"\"\n        log(\"jump to next lint error\")\n        if self.view.id() in DISABLED_VIEWS:\n            log(\"view lint is disabled\")\n            if not sublime.ok_cancel_dialog(\"Enable lint for this view?\"):\n                return\n            DISABLED_VIEWS.remove(self.view.id())\n        view_errors = ERRORS_IN_VIEWS.get(self.view.id())\n        if not view_errors:\n            log(\"no view errors found\")\n            return\n        # get view selection (exit if no selection)\n        view_selection = self.view.sel()\n        if not view_selection:\n            return\n        current_line = SublimeView.get_current_line(self.view)\n        if current_line is None:\n            return\n        next_line = None\n        for i, error_line in enumerate(sorted(view_errors.keys())):\n            if i == 0:\n                next_line = error_line\n            if error_line > current_line:\n                next_line = error_line\n                break\n        log(\"jump to line {0}\".format(next_line))\n        point = self.view.text_point(next_line, 0)\n        self.view.sel().clear()\n        self.view.sel().add(sublime.Region(point))\n        self.view.show(point)\n", "docstring": "Jump to next lint error.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def run(self, edit):\n        \"\"\"Run flake8 lint.\"\"\"\n        if self.view.id() in DISABLED_VIEWS:\n            log(\"view lint is disabled\")\n            if not sublime.ok_cancel_dialog(\"Enable lint for this view?\"):\n                return\n            DISABLED_VIEWS.remove(self.view.id())\n        Flake8Lint.do_lint(self.view)\n", "docstring": "Run flake8 lint.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize events listener.\"\"\"\n        super(Flake8LintBackground, self).__init__(*args, **kwargs)\n        self._last_selected_line = None\n        self._latest_keypresses = {}\n        if int(sublime.version()) >= 3000:\n            self.set_timeout = sublime.set_timeout_async\n        else:\n            self.set_timeout = sublime.set_timeout\n", "docstring": "Initialize events listener.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def on_post_save(self, view):\n        \"\"\"Do lint on file save.\"\"\"\n        if view.is_scratch():\n            log(\"skip lint because view is scratch\")\n            return  # do not lint scratch views\n        if settings.lint_on_save:\n            log(\"run lint by 'on_post_save' hook\")\n            Flake8Lint.do_lint(view)\n        else:\n            log(\"skip lint by 'on_post_save' hook due to plugin settings\")\n", "docstring": "Do lint on file save.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "    def on_modified(self, view):\n        \"\"\"View was modified: run delayed lint if needed.\"\"\"\n        if settings.live_mode:\n            self.delayed_lint(view)\n", "docstring": "View was modified: run delayed lint if needed.\n"}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "        def callback():\n            \"\"\"Live mode lint delay callback.\n            Run lint if no key pressed after timeout was set.\n            \"\"\"\n            if self._latest_keypresses.get(view_id, None) == keypress_time:\n                log(\"run delayed lint (live_mode)\")\n                Flake8Lint.do_lint(view, quiet=True)\n", "docstring": "Live mode lint delay callback."}
{"repo": "Flake8Lint-master/Flake8Lint.py", "original_string": "def plugin_loaded():\n    \"\"\"Do some staff when 'plugin was loaded' event appears.\"\"\"\n    global settings\n    settings = Flake8LintSettings()\n    log(\"plugin was loaded\")\n    print(\"Lint tools versions:\\n- Python Flake8 Lint: {0}{1}\".format(\n        __version__,\n        ''.join((\n            \"\\n- {0}: {1}\".format(tool[0], tool[1])\n            for tool in tools_versions()\n        ))\n    ))\n    update_color_scheme(settings)\n    Flake8Lint.on_file_load()\n", "docstring": "Do some staff when 'plugin was loaded' event appears.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def readlines(filename):\n        \"\"\"Read the source code.\"\"\"\n        with open(filename, 'rU') as f:\n            return f.readlines()\n", "docstring": "Read the source code.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def readlines(filename):\n        \"\"\"Read the source code.\"\"\"\n        try:\n            with open(filename, 'rb') as f:\n                (coding, lines) = tokenize.detect_encoding(f.readline)\n                f = TextIOWrapper(f, coding, line_buffering=True)\n                return [l.decode(coding) for l in lines] + f.readlines()\n        except (LookupError, SyntaxError, UnicodeError):\n            # Fall back if file encoding is improperly declared\n            with open(filename, encoding='latin-1') as f:\n                return f.readlines()\n", "docstring": "Read the source code.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "def parse_udiff(diff, patterns=None, parent='.'):\n    \"\"\"Return a dictionary of matching lines.\"\"\"\n    # For each file of the diff, the entry key is the filename,\n    # and the value is a set of row numbers to consider.\n    rv = {}\n    path = nrows = None\n    for line in diff.splitlines():\n        if nrows:\n            if line[:1] != '-':\n                nrows -= 1\n            continue\n        if line[:3] == '@@ ':\n            hunk_match = HUNK_REGEX.match(line)\n            (row, nrows) = [int(g or '1') for g in hunk_match.groups()]\n            rv[path].update(range(row, row + nrows))\n        elif line[:3] == '+++':\n            path = line[4:].split('\\t', 1)[0]\n            if path[:2] == 'b/':\n                path = path[2:]\n            rv[path] = set()\n    return dict([(os.path.join(parent, path), rows)\n                 for (path, rows) in rv.items()\n                 if rows and filename_match(path, patterns)])\n", "docstring": "Return a dictionary of matching lines.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "def filename_match(filename, patterns, default=True):\n    \"\"\"Check if patterns contains a pattern that matches filename.\n    If patterns is unspecified, this always returns True.\n    \"\"\"\n    if not patterns:\n        return default\n    return any(fnmatch(filename, pattern) for pattern in patterns)\n", "docstring": "Check if patterns contains a pattern that matches filename."}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "def init_checks_registry():\n    \"\"\"Register all globally visible functions.\n    The first argument name is either 'physical_line' or 'logical_line'.\n    \"\"\"\n    mod = inspect.getmodule(register_check)\n    for (name, function) in inspect.getmembers(mod, inspect.isfunction):\n        register_check(function)\n", "docstring": "Register all globally visible functions."}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def readline(self):\n        \"\"\"Get the next line from the input buffer.\"\"\"\n        if self.line_number >= self.total_lines:\n            return ''\n        line = self.lines[self.line_number]\n        self.line_number += 1\n        if self.indent_char is None and line[:1] in WHITESPACE:\n            self.indent_char = line[0]\n        return line\n", "docstring": "Get the next line from the input buffer.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def init_checker_state(self, name, argument_names):\n        \"\"\" Prepares a custom state for the specific checker plugin.\"\"\"\n        if 'checker_state' in argument_names:\n            self.checker_state = self._checker_states.setdefault(name, {})\n", "docstring": "Prepares a custom state for the specific checker plugin.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def build_tokens_line(self):\n        \"\"\"Build a logical line from tokens.\"\"\"\n        logical = []\n        comments = []\n        length = 0\n        prev_row = prev_col = mapping = None\n        for token_type, text, start, end, line in self.tokens:\n            if token_type in SKIP_TOKENS:\n                continue\n            if not mapping:\n                mapping = [(0, start)]\n            if token_type == tokenize.COMMENT:\n                comments.append(text)\n                continue\n            if token_type == tokenize.STRING:\n                text = mute_string(text)\n            if prev_row:\n                (start_row, start_col) = start\n                if prev_row != start_row:    # different row\n                    prev_text = self.lines[prev_row - 1][prev_col - 1]\n                    if prev_text == ',' or (prev_text not in '{[(' and\n                                            text not in '}])'):\n                        text = ' ' + text\n                elif prev_col != start_col:  # different column\n                    text = line[prev_col:start_col] + text\n            logical.append(text)\n            length += len(text)\n            mapping.append((length, end))\n            (prev_row, prev_col) = end\n        self.logical_line = ''.join(logical)\n        self.noqa = comments and noqa(''.join(comments))\n        return mapping\n", "docstring": "Build a logical line from tokens.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def check_ast(self):\n        \"\"\"Build the file's AST and run all AST checks.\"\"\"\n        try:\n            tree = compile(''.join(self.lines), '', 'exec', PyCF_ONLY_AST)\n        except (ValueError, SyntaxError, TypeError):\n            return self.report_invalid_syntax()\n        for name, cls, __ in self._ast_checks:\n            checker = cls(tree, self.filename)\n            for lineno, offset, text, check in checker.run():\n                if not self.lines or not noqa(self.lines[lineno - 1]):\n                    self.report_error(lineno, offset, text, check)\n", "docstring": "Build the file's AST and run all AST checks.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def maybe_check_physical(self, token):\n        \"\"\"If appropriate (based on token), check current physical line(s).\"\"\"\n        # Called after every token, but act only on end of line.\n        if _is_eol_token(token):\n            # Obviously, a newline token ends a single physical line.\n            self.check_physical(token[4])\n        elif token[0] == tokenize.STRING and '\\n' in token[1]:\n            # Less obviously, a string that contains newlines is a\n            # multiline string, either triple-quoted or with internal\n            # newlines backslash-escaped. Check every physical line in the\n            # string *except* for the last one: its newline is outside of\n            # the multiline string, so we consider it a regular physical\n            # line, and will check it like any other physical line.\n            #\n            # Subtleties:\n            # - we don't *completely* ignore the last line; if it contains\n            #   the magical \"# noqa\" comment, we disable all physical\n            #   checks for the entire multiline string\n            # - have to wind self.line_number back because initially it\n            #   points to the last line of the string, and we want\n            #   check_physical() to give accurate feedback\n            if noqa(token[4]):\n                return\n            self.multiline = True\n            self.line_number = token[2][0]\n            for line in token[1].split('\\n')[:-1]:\n                self.check_physical(line + '\\n')\n                self.line_number += 1\n            self.multiline = False\n", "docstring": "If appropriate (based on token), check current physical line(s).\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def stop(self):\n        \"\"\"Stop the timer.\"\"\"\n        self.elapsed = time.time() - self._start_time\n", "docstring": "Stop the timer.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def increment_logical_line(self):\n        \"\"\"Signal a new logical line.\"\"\"\n        self.counters['logical lines'] += 1\n", "docstring": "Signal a new logical line.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def get_file_results(self):\n        \"\"\"Return the count of errors and warnings for this file.\"\"\"\n        return self.file_errors\n", "docstring": "Return the count of errors and warnings for this file.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def get_statistics(self, prefix=''):\n        \"\"\"Get statistics for message codes that start with the prefix.\n        prefix='' matches all errors and warnings\n        prefix='E' matches all errors\n        prefix='W' matches all warnings\n        prefix='E4' matches all errors that have to do with imports\n        \"\"\"\n        return ['%-7s %s %s' % (self.counters[key], key, self.messages[key])\n                for key in sorted(self.messages) if key.startswith(prefix)]\n", "docstring": "Get statistics for message codes that start with the prefix."}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def print_benchmark(self):\n        \"\"\"Print benchmark numbers.\"\"\"\n        print('%-7.2f %s' % (self.elapsed, 'seconds elapsed'))\n        if self.elapsed:\n            for key in self._benchmark_keys:\n                print('%-7d %s per second (%d total)' %\n                      (self.counters[key] / self.elapsed, key,\n                       self.counters[key]))\n", "docstring": "Print benchmark numbers.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def error(self, line_number, offset, text, check):\n        \"\"\"Report an error, according to options.\"\"\"\n        code = super(StandardReport, self).error(line_number, offset,\n                                                 text, check)\n        if code and (self.counters[code] == 1 or self._repeat):\n            self._deferred_print.append(\n                (line_number, offset, code, text[5:], check.__doc__))\n        return code\n", "docstring": "Report an error, according to options.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def __init__(self, *args, **kwargs):\n        # build options from the command line\n        self.checker_class = kwargs.pop('checker_class', Checker)\n        parse_argv = kwargs.pop('parse_argv', False)\n        config_file = kwargs.pop('config_file', False)\n        parser = kwargs.pop('parser', None)\n        # build options from dict\n        options_dict = dict(*args, **kwargs)\n        arglist = None if parse_argv else options_dict.get('paths', None)\n        options, self.paths = process_options(\n            arglist, parse_argv, config_file, parser)\n        if options_dict:\n            options.__dict__.update(options_dict)\n            if 'paths' in options_dict:\n                self.paths = options_dict['paths']\n        self.runner = self.input_file\n        self.options = options\n        if not options.reporter:\n            options.reporter = BaseReport if options.quiet else StandardReport\n        options.select = tuple(options.select or ())\n        if not (options.select or options.ignore or\n                options.testsuite or options.doctest) and DEFAULT_IGNORE:\n            # The default choice: ignore controversial checks\n            options.ignore = tuple(DEFAULT_IGNORE.split(','))\n        else:\n            # Ignore all checks which are not explicitly selected\n            options.ignore = ('',) if options.select else tuple(options.ignore)\n        options.benchmark_keys = BENCHMARK_KEYS[:]\n        options.ignore_code = self.ignore_code\n        options.physical_checks = self.get_checks('physical_line')\n        options.logical_checks = self.get_checks('logical_line')\n        options.ast_checks = self.get_checks('tree')\n        self.init_report()\n", "docstring": "build options from the command line"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def check_files(self, paths=None):\n        \"\"\"Run all checks on the paths.\"\"\"\n        if paths is None:\n            paths = self.paths\n        report = self.options.report\n        runner = self.runner\n        report.start()\n        try:\n            for path in paths:\n                if os.path.isdir(path):\n                    self.input_dir(path)\n                elif not self.excluded(path):\n                    runner(path)\n        except KeyboardInterrupt:\n            print('... stopped')\n        report.stop()\n        return report\n", "docstring": "Run all checks on the paths.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def input_dir(self, dirname):\n        \"\"\"Check all files in this directory and all subdirectories.\"\"\"\n        dirname = dirname.rstrip('/')\n        if self.excluded(dirname):\n            return 0\n        counters = self.options.report.counters\n        verbose = self.options.verbose\n        filepatterns = self.options.filename\n        runner = self.runner\n        for root, dirs, files in os.walk(dirname):\n            if verbose:\n                print('directory ' + root)\n            counters['directories'] += 1\n            for subdir in sorted(dirs):\n                if self.excluded(subdir, root):\n                    dirs.remove(subdir)\n            for filename in sorted(files):\n                # contain a pattern that matches?\n                if ((filename_match(filename, filepatterns) and\n                     not self.excluded(filename, root))):\n                    runner(os.path.join(root, filename))\n", "docstring": "Check all files in this directory and all subdirectories.\n"}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "    def ignore_code(self, code):\n        \"\"\"Check if the error code should be ignored.\n        If 'options.select' contains a prefix of the error code,\n        return False.  Else, if 'options.ignore' contains a prefix of\n        the error code, return True.\n        \"\"\"\n        if len(code) < 4 and any(s.startswith(code)\n                                 for s in self.options.select):\n            return False\n        return (code.startswith(self.options.ignore) and\n                not code.startswith(self.options.select))\n", "docstring": "Check if the error code should be ignored."}
{"repo": "Flake8Lint-master/contrib/pep8.py", "original_string": "def _main():\n    \"\"\"Parse options and run checks on Python source.\"\"\"\n    import signal\n    # Handle \"Broken pipe\" gracefully\n    try:\n        signal.signal(signal.SIGPIPE, lambda signum, frame: sys.exit(1))\n    except AttributeError:\n        pass    # not supported on Windows\n    pep8style = StyleGuide(parse_argv=True)\n    options = pep8style.options\n    if options.doctest or options.testsuite:\n        from testsuite.support import run_tests\n        report = run_tests(pep8style)\n    else:\n        report = pep8style.check_files()\n    if options.statistics:\n        report.print_statistics()\n    if options.benchmark:\n        report.print_benchmark()\n    if options.testsuite and not options.quiet:\n        report.print_results()\n    if report.total_errors:\n        if options.count:\n            sys.stderr.write(str(report.total_errors) + '\\n')\n        sys.exit(1)\n", "docstring": "Parse options and run checks on Python source.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def source(self):\n        \"\"\"Return the source code for the definition.\"\"\"\n        full_src = self._source[self._slice]\n        def is_empty_or_comment(line):\n            return line.strip() == '' or line.strip().startswith('#')\n        filtered_src = dropwhile(is_empty_or_comment, reversed(full_src))\n        return ''.join(reversed(list(filtered_src)))\n", "docstring": "Return the source code for the definition.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def is_public(self):\n        # Check if we are a setter/deleter method, and mark as private if so.\n        for decorator in self.decorators:\n            # Given 'foo', match 'foo.bar' but not 'foobar' or 'sfoo'\n            if re(r\"^{0}\\.\".format(self.name)).match(decorator.name):\n                return False\n        name_is_public = (not self.name.startswith('_') or\n                          self.name in VARIADIC_MAGIC_METHODS or\n                          is_magic(self.name))\n        return self.parent.is_public and name_is_public\n", "docstring": "Check if we are a setter/deleter method, and mark as private if so."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def consume(self, kind):\n        \"\"\"Consume one token and verify it is of the expected kind.\"\"\"\n        next_token = self.stream.move()\n        assert next_token.kind == kind\n", "docstring": "Consume one token and verify it is of the expected kind.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def parse_docstring(self):\n        \"\"\"Parse a single docstring and return its value.\"\"\"\n        log.debug(\"parsing docstring, token is %r (%s)\",\n                  self.current.kind, self.current.value)\n        while self.current.kind in (tk.COMMENT, tk.NEWLINE, tk.NL):\n            self.stream.move()\n            log.debug(\"parsing docstring, token is %r (%s)\",\n                      self.current.kind, self.current.value)\n        if self.current.kind == tk.STRING:\n            docstring = self.current.value\n            self.stream.move()\n            return docstring\n        return None\n", "docstring": "Parse a single docstring and return its value.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def parse_definitions(self, class_, all=False):\n        \"\"\"Parse multiple definitions and yield them.\"\"\"\n        while self.current is not None:\n            log.debug(\"parsing definition list, current token is %r (%s)\",\n                      self.current.kind, self.current.value)\n            if all and self.current.value == '__all__':\n                self.parse_all()\n            elif self.current.kind == tk.OP and self.current.value == '@':\n                self.consume(tk.OP)\n                self.parse_decorators()\n            elif self.current.value in ['def', 'class']:\n                yield self.parse_definition(class_._nest(self.current.value))\n            elif self.current.kind == tk.INDENT:\n                self.consume(tk.INDENT)\n                for definition in self.parse_definitions(class_):\n                    yield definition\n            elif self.current.kind == tk.DEDENT:\n                self.consume(tk.DEDENT)\n                return\n            elif self.current.value == 'from':\n                self.parse_from_import_statement()\n            else:\n                self.stream.move()\n", "docstring": "Parse multiple definitions and yield them.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def parse_module(self):\n        \"\"\"Parse a module (and its children) and return a Module object.\"\"\"\n        log.debug(\"parsing module.\")\n        start = self.line\n        docstring = self.parse_docstring()\n        children = list(self.parse_definitions(Module, all=True))\n        assert self.current is None, self.current\n        end = self.line\n        cls = Module\n        if self.filename.endswith('__init__.py'):\n            cls = Package\n        module = cls(self.filename, self.source, start, end,\n                     [], docstring, children, None, self.all)\n        for child in module.children:\n            child.parent = module\n        module.future_imports = self.future_imports\n        log.debug(\"finished parsing module.\")\n        return module\n", "docstring": "Parse a module (and its children) and return a Module object.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def parse_from_import_statement(self):\n        \"\"\"Parse a 'from x import y' statement.\n        The purpose is to find __future__ statements.\n        \"\"\"\n        log.debug('parsing from/import statement.')\n        assert self.current.value == 'from', self.current.value\n        self.stream.move()\n        if self.current.value != '__future__':\n            return\n        self.stream.move()\n        assert self.current.value == 'import', self.current.value\n        self.stream.move()\n        if self.current.value == '(':\n            self.consume(tk.OP)\n            expected_end_kind = tk.OP\n        else:\n            expected_end_kind = tk.NEWLINE\n        while self.current.kind != expected_end_kind and not(\n                self.current.kind == tk.OP and self.current.value == ';'):\n            if self.current.kind != tk.NAME:\n                self.stream.move()\n                continue\n            log.debug(\"parsing import, token is %r (%s)\",\n                      self.current.kind, self.current.value)\n            log.debug('found future import: %s', self.current.value)\n            self.future_imports[self.current.value] = True\n            self.consume(tk.NAME)\n            log.debug(\"parsing import, token is %r (%s)\",\n                      self.current.kind, self.current.value)\n            if self.current.kind == tk.NAME and self.current.value == 'as':\n                self.consume(tk.NAME)  # as\n                if self.current.kind == tk.NAME:\n                    self.consume(tk.NAME)  # new name, irrelevant\n            if self.current.value == ',':\n                self.consume(tk.OP)\n            log.debug(\"parsing import, token is %r (%s)\",\n                      self.current.kind, self.current.value)\n", "docstring": "Parse a 'from x import y' statement."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "def check_initialized(method):\n    \"\"\"Check that the configuration object was initialized.\"\"\"\n    def _decorator(self, *args, **kwargs):\n        if self._arguments is None or self._options is None:\n            raise RuntimeError('using an uninitialized configuration')\n        return method(self, *args, **kwargs)\n    return _decorator\n", "docstring": "Check that the configuration object was initialized.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def __init__(self):\n        \"\"\"Create a configuration parser.\"\"\"\n        self._cache = {}\n        self._override_by_cli = None\n        self._options = self._arguments = self._run_conf = None\n        self._parser = self._create_option_parser()\n", "docstring": "Create a configuration parser.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def get_default_run_configuration(self):\n        \"\"\"Return a `RunConfiguration` object set with default values.\"\"\"\n        options, _ = self._parse_args([])\n        return self._create_run_config(options)\n", "docstring": "Return a `RunConfiguration` object set with default values.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def get_user_run_configuration(self):\n        \"\"\"Return the run configuration for the script.\"\"\"\n        return self._run_conf\n", "docstring": "Return the run configuration for the script.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def get_files_to_check(self):\n        \"\"\"Generate files and error codes to check on each one.\n        Walk dir trees under `self._arguments` and generate yield filnames\n        that `match` under each directory that `match_dir`.\n        The method locates the configuration for each file name and yields a\n        tuple of (filename, [error_codes]).\n        With every discovery of a new configuration file `IllegalConfiguration`\n        might be raised.\n        \"\"\"\n        def _get_matches(config):\n            \"\"\"Return the `match` and `match_dir` functions for `config`.\"\"\"\n            match_func = re(config.match + '$').match\n            match_dir_func = re(config.match_dir + '$').match\n            return match_func, match_dir_func\n        for name in self._arguments:\n            if os.path.isdir(name):\n                for root, dirs, filenames in os.walk(name):\n                    config = self._get_config(root)\n                    match, match_dir = _get_matches(config)\n                    # Skip any dirs that do not match match_dir\n                    dirs[:] = [dir for dir in dirs if match_dir(dir)]\n                    for filename in filenames:\n                        if match(filename):\n                            full_path = os.path.join(root, filename)\n                            yield full_path, list(config.checked_codes)\n            else:\n                config = self._get_config(name)\n                match, _ = _get_matches(config)\n                if match(name):\n                    yield name, list(config.checked_codes)\n", "docstring": "Generate files and error codes to check on each one."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def _merge_configuration(self, parent_config, child_options):\n        \"\"\"Merge parent config into the child options.\n        The migration process requires an `options` object for the child in\n        order to distinguish between mutually exclusive codes, add-select and\n        add-ignore error codes.\n        \"\"\"\n        # Copy the parent error codes so we won't override them\n        error_codes = copy.deepcopy(parent_config.checked_codes)\n        if self._has_exclusive_option(child_options):\n            error_codes = self._get_exclusive_error_codes(child_options)\n        self._set_add_options(error_codes, child_options)\n        match = child_options.match \\\n            if child_options.match is not None else parent_config.match\n        match_dir = child_options.match_dir \\\n            if child_options.match_dir is not None else parent_config.match_dir\n        return CheckConfiguration(checked_codes=error_codes,\n                                  match=match,\n                                  match_dir=match_dir)\n", "docstring": "Merge parent config into the child options."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def _create_run_config(options):\n        \"\"\"Create a `RunConfiguration` object from `options`.\"\"\"\n        values = dict([(opt, getattr(options, opt)) for opt in\n                       RunConfiguration._fields])\n        return RunConfiguration(**values)\n", "docstring": "Create a `RunConfiguration` object from `options`.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def _create_check_config(cls, options, use_dafaults=True):\n        \"\"\"Create a `CheckConfiguration` object from `options`.\n        If `use_dafaults`, any of the match options that are `None` will\n        be replaced with their default value and the default convention will be\n        set for the checked codes.\n        \"\"\"\n        match = cls.DEFAULT_MATCH_RE \\\n            if options.match is None and use_dafaults \\\n            else options.match\n        match_dir = cls.DEFAULT_MATCH_DIR_RE \\\n            if options.match_dir is None and use_dafaults \\\n            else options.match_dir\n        checked_codes = None\n        if cls._has_exclusive_option(options) or use_dafaults:\n            checked_codes = cls._get_checked_errors(options)\n        return CheckConfiguration(checked_codes=checked_codes,\n                                  match=match, match_dir=match_dir)\n", "docstring": "Create a `CheckConfiguration` object from `options`."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def _get_section_name(cls, parser):\n        \"\"\"Parse options from relevant section.\"\"\"\n        for section_name in cls.POSSIBLE_SECTION_NAMES:\n            if parser.has_section(section_name):\n                return section_name\n        return None\n", "docstring": "Parse options from relevant section.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def _get_config_file_in_folder(cls, path):\n        \"\"\"Look for a configuration file in `path`.\n        If exists return it's full path, otherwise None.\n        \"\"\"\n        if os.path.isfile(path):\n            path = os.path.dirname(path)\n        for fn in cls.PROJECT_CONFIG_FILES:\n            config = RawConfigParser()\n            full_path = os.path.join(path, fn)\n            if config.read(full_path) and cls._get_section_name(config):\n                return full_path\n", "docstring": "Look for a configuration file in `path`."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def _get_exclusive_error_codes(options):\n        \"\"\"Extract the error codes from the selected exclusive option.\"\"\"\n        codes = set(ErrorRegistry.get_error_codes())\n        checked_codes = None\n        if options.ignore is not None:\n            checked_codes = codes - options.ignore\n        elif options.select is not None:\n            checked_codes = options.select\n        elif options.convention is not None:\n            checked_codes = getattr(conventions, options.convention)\n        # To not override the conventions nor the options - copy them.\n        return copy.deepcopy(checked_codes)\n", "docstring": "Extract the error codes from the selected exclusive option.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def _set_add_options(checked_codes, options):\n        \"\"\"Set `checked_codes` by the `add_ignore` or `add_select` options.\"\"\"\n        checked_codes |= options.add_select\n        checked_codes -= options.add_ignore\n", "docstring": "Set `checked_codes` by the `add_ignore` or `add_select` options.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def _get_checked_errors(cls, options):\n        \"\"\"Extract the codes needed to be checked from `options`.\"\"\"\n        checked_codes = cls._get_exclusive_error_codes(options)\n        if checked_codes is None:\n            checked_codes = cls.DEFAULT_CONVENTION\n        cls._set_add_options(checked_codes, options)\n        return checked_codes\n", "docstring": "Extract the codes needed to be checked from `options`.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def _validate_options(cls, options):\n        \"\"\"Validate the mutually exclusive options.\n        Return `True` iff only zero or one of `BASE_ERROR_SELECTION_OPTIONS`\n        was selected.\n        \"\"\"\n        for opt1, opt2 in \\\n                itertools.permutations(cls.BASE_ERROR_SELECTION_OPTIONS, 2):\n            if getattr(options, opt1) and getattr(options, opt2):\n                log.error('Cannot pass both {0} and {1}. They are '\n                          'mutually exclusive.'.format(opt1, opt2))\n                return False\n        if options.convention and options.convention not in conventions:\n            log.error(\"Illegal convention '{0}'. Possible conventions: {1}\"\n                      .format(options.convention,\n                              ', '.join(conventions.keys())))\n            return False\n        return True\n", "docstring": "Validate the mutually exclusive options."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def _has_exclusive_option(cls, options):\n        \"\"\"Return `True` iff one or more exclusive options were selected.\"\"\"\n        return any([getattr(options, opt) is not None for opt in\n                    cls.BASE_ERROR_SELECTION_OPTIONS])\n", "docstring": "Return `True` iff one or more exclusive options were selected.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def _fix_set_options(options):\n        \"\"\"Alter the set options from None/strings to sets in place.\"\"\"\n        optional_set_options = ('ignore', 'select')\n        mandatory_set_options = ('add_ignore', 'add_select')\n        def _get_set(value_str):\n            \"\"\"Split `value_str` by the delimiter `,` and return a set.\n            Removes any occurrences of '' in the set.\n            \"\"\"\n            return set(value_str.split(',')) - set([''])\n        for opt in optional_set_options:\n            value = getattr(options, opt)\n            if value is not None:\n                setattr(options, opt, _get_set(value))\n        for opt in mandatory_set_options:\n            value = getattr(options, opt)\n            if value is None:\n                value = ''\n            if not isinstance(value, Set):\n                value = _get_set(value)\n            setattr(options, opt, value)\n        return options\n", "docstring": "Alter the set options from None/strings to sets in place.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def _create_option_parser(cls):\n        \"\"\"Return an option parser to parse the command line arguments.\"\"\"\n        from optparse import OptionParser\n        parser = OptionParser(\n            version=__version__,\n            usage='Usage: pydocstyle [options] [<file|dir>...]')\n        option = parser.add_option\n        # Run configuration options\n        option('-e', '--explain', action='store_true', default=False,\n               help='show explanation of each error')\n        option('-s', '--source', action='store_true', default=False,\n               help='show source for each error')\n        option('-d', '--debug', action='store_true', default=False,\n               help='print debug information')\n        option('-v', '--verbose', action='store_true', default=False,\n               help='print status information')\n        option('--count', action='store_true', default=False,\n               help='print total number of errors to stdout')\n        # Error check options\n        option('--select', metavar='<codes>', default=None,\n               help='choose the basic list of checked errors by '\n                    'specifying which errors to check for (with a list of '\n                    'comma-separated error codes). '\n                    'for example: --select=D101,D202')\n        option('--ignore', metavar='<codes>', default=None,\n               help='choose the basic list of checked errors by '\n                    'specifying which errors to ignore (with a list of '\n                    'comma-separated error codes). '\n                    'for example: --ignore=D101,D202')\n        option('--convention', metavar='<name>', default=None,\n               help='choose the basic list of checked errors by specifying an '\n                    'existing convention. Possible conventions: {0}'\n                    .format(', '.join(conventions)))\n        option('--add-select', metavar='<codes>', default=None,\n               help='amend the list of errors to check for by specifying '\n                    'more error codes to check.')\n        option('--add-ignore', metavar='<codes>', default=None,\n               help='amend the list of errors to check for by specifying '\n                    'more error codes to ignore.')\n        # Match clauses\n        option('--match', metavar='<pattern>', default=None,\n               help=(\"check only files that exactly match <pattern> regular \"\n                     \"expression; default is --match='{0}' which matches \"\n                     \"files that don't start with 'test_' but end with \"\n                     \"'.py'\").format(cls.DEFAULT_MATCH_RE))\n        option('--match-dir', metavar='<pattern>', default=None,\n               help=(\"search only dirs that exactly match <pattern> regular \"\n                     \"expression; default is --match-dir='{0}', which \"\n                     \"matches all dirs that don't start with \"\n                     \"a dot\").format(cls.DEFAULT_MATCH_DIR_RE))\n        return parser\n", "docstring": "Return an option parser to parse the command line arguments.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "def setup_stream_handlers(conf):\n    \"\"\"Setup logging stream handlers according to the options.\"\"\"\n    class StdoutFilter(logging.Filter):\n        def filter(self, record):\n            return record.levelno in (logging.DEBUG, logging.INFO)\n    log.handlers = []\n    stdout_handler = logging.StreamHandler(sys.stdout)\n    stdout_handler.setLevel(logging.WARNING)\n    stdout_handler.addFilter(StdoutFilter())\n    if conf.debug:\n        stdout_handler.setLevel(logging.DEBUG)\n    elif conf.verbose:\n        stdout_handler.setLevel(logging.INFO)\n    else:\n        stdout_handler.setLevel(logging.WARNING)\n    log.addHandler(stdout_handler)\n    stderr_handler = logging.StreamHandler(sys.stderr)\n    stderr_handler.setLevel(logging.WARNING)\n    log.addHandler(stderr_handler)\n", "docstring": "Setup logging stream handlers according to the options.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def check_docstring_missing(self, definition, docstring):\n        \"\"\"D10{0,1,2,3}: Public definitions should have docstrings.\n        All modules should normally have docstrings.  [...] all functions and\n        classes exported by a module should also have docstrings. Public\n        methods (including the __init__ constructor) should also have\n        docstrings.\n        Note: Public (exported) definitions are either those with names listed\n              in __all__ variable (if present), or those that do not start\n              with a single underscore.\n        \"\"\"\n        if (not docstring and definition.is_public or\n                docstring and is_blank(ast.literal_eval(docstring))):\n            codes = {Module: D100, Class: D101, NestedClass: D101,\n                     Method: (lambda: D105() if is_magic(definition.name)\n                              else D102()),\n                     Function: D103, NestedFunction: D103, Package: D104}\n            return codes[type(definition)]()\n", "docstring": "D10{0,1,2,3}: Public definitions should have docstrings."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def check_one_liners(self, definition, docstring):\n        \"\"\"D200: One-liner docstrings should fit on one line with quotes.\n        The closing quotes are on the same line as the opening quotes.\n        This looks better for one-liners.\n        \"\"\"\n        if docstring:\n            lines = ast.literal_eval(docstring).split('\\n')\n            if len(lines) > 1:\n                non_empty_lines = sum(1 for l in lines if not is_blank(l))\n                if non_empty_lines == 1:\n                    return D200(len(lines))\n", "docstring": "D200: One-liner docstrings should fit on one line with quotes."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def check_no_blank_before(self, function, docstring):  # def\n        \"\"\"D20{1,2}: No blank lines allowed around function/method docstring.\n        There's no blank line either before or after the docstring.\n        \"\"\"\n        # NOTE: This does not take into account functions with groups of code.\n        if docstring:\n            before, _, after = function.source.partition(docstring)\n            blanks_before = list(map(is_blank, before.split('\\n')[:-1]))\n            blanks_after = list(map(is_blank, after.split('\\n')[1:]))\n            blanks_before_count = sum(takewhile(bool, reversed(blanks_before)))\n            blanks_after_count = sum(takewhile(bool, blanks_after))\n            if blanks_before_count != 0:\n                yield D201(blanks_before_count)\n            if not all(blanks_after) and blanks_after_count != 0:\n                yield D202(blanks_after_count)\n", "docstring": "D20{1,2}: No blank lines allowed around function/method docstring."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def check_blank_before_after_class(self, class_, docstring):\n        \"\"\"D20{3,4}: Class docstring should have 1 blank line around them.\n        Insert a blank line before and after all docstrings (one-line or\n        multi-line) that document a class -- generally speaking, the class's\n        methods are separated from each other by a single blank line, and the\n        docstring needs to be offset from the first method by a blank line;\n        for symmetry, put a blank line between the class header and the\n        docstring.\n        \"\"\"\n        # NOTE: this gives false-positive in this case\n        # class Foo:\n        #\n        #     \"\"\"Docstring.\"\"\"\n        #\n        #\n        # # comment here\n        # def foo(): pass\n        if docstring:\n            before, _, after = class_.source.partition(docstring)\n            blanks_before = list(map(is_blank, before.split('\\n')[:-1]))\n            blanks_after = list(map(is_blank, after.split('\\n')[1:]))\n            blanks_before_count = sum(takewhile(bool, reversed(blanks_before)))\n            blanks_after_count = sum(takewhile(bool, blanks_after))\n            if blanks_before_count != 0:\n                yield D211(blanks_before_count)\n            if blanks_before_count != 1:\n                yield D203(blanks_before_count)\n            if not all(blanks_after) and blanks_after_count != 1:\n                yield D204(blanks_after_count)\n", "docstring": "D20{3,4}: Class docstring should have 1 blank line around them."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def check_blank_after_summary(self, definition, docstring):\n        \"\"\"D205: Put one blank line between summary line and description.\n        Multi-line docstrings consist of a summary line just like a one-line\n        docstring, followed by a blank line, followed by a more elaborate\n        description. The summary line may be used by automatic indexing tools;\n        it is important that it fits on one line and is separated from the\n        rest of the docstring by a blank line.\n        \"\"\"\n        if docstring:\n            lines = ast.literal_eval(docstring).strip().split('\\n')\n            if len(lines) > 1:\n                post_summary_blanks = list(map(is_blank, lines[1:]))\n                blanks_count = sum(takewhile(bool, post_summary_blanks))\n                if blanks_count != 1:\n                    return D205(blanks_count)\n", "docstring": "D205: Put one blank line between summary line and description."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def check_indent(self, definition, docstring):\n        \"\"\"D20{6,7,8}: The entire docstring should be indented same as code.\n        The entire docstring is indented the same as the quotes at its\n        first line.\n        \"\"\"\n        if docstring:\n            before_docstring, _, _ = definition.source.partition(docstring)\n            _, _, indent = before_docstring.rpartition('\\n')\n            lines = docstring.split('\\n')\n            if len(lines) > 1:\n                lines = lines[1:]  # First line does not need indent.\n                indents = [leading_space(l) for l in lines if not is_blank(l)]\n                if set(' \\t') == set(''.join(indents) + indent):\n                    yield D206()\n                if (len(indents) > 1 and min(indents[:-1]) > indent or\n                        indents[-1] > indent):\n                    yield D208()\n                if min(indents) < indent:\n                    yield D207()\n", "docstring": "D20{6,7,8}: The entire docstring should be indented same as code."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def check_newline_after_last_paragraph(self, definition, docstring):\n        \"\"\"D209: Put multi-line docstring closing quotes on separate line.\n        Unless the entire docstring fits on a line, place the closing\n        quotes on a line by themselves.\n        \"\"\"\n        if docstring:\n            lines = [l for l in ast.literal_eval(docstring).split('\\n')\n                     if not is_blank(l)]\n            if len(lines) > 1:\n                if docstring.split(\"\\n\")[-1].strip() not in ['\"\"\"', \"'''\"]:\n                    return D209()\n", "docstring": "D209: Put multi-line docstring closing quotes on separate line."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def check_surrounding_whitespaces(self, definition, docstring):\n        \"\"\"D210: No whitespaces allowed surrounding docstring text.\"\"\"\n        if docstring:\n            lines = ast.literal_eval(docstring).split('\\n')\n            if lines[0].startswith(' ') or \\\n                    len(lines) == 1 and lines[0].endswith(' '):\n                return D210()\n", "docstring": "D210: No whitespaces allowed surrounding docstring text.\n"}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def check_ends_with_period(self, definition, docstring):\n        \"\"\"D400: First line should end with a period.\n        The [first line of a] docstring is a phrase ending in a period.\n        \"\"\"\n        if docstring:\n            summary_line = ast.literal_eval(docstring).strip().split('\\n')[0]\n            if not summary_line.endswith('.'):\n                return D400(summary_line[-1])\n", "docstring": "D400: First line should end with a period."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def check_imperative_mood(self, function, docstring):  # def context\n        \"\"\"D401: First line should be in imperative mood: 'Do', not 'Does'.\n        [Docstring] prescribes the function or method's effect as a command:\n        (\"Do this\", \"Return that\"), not as a description; e.g. don't write\n        \"Returns the pathname ...\".\n        \"\"\"\n        if docstring:\n            stripped = ast.literal_eval(docstring).strip()\n            if stripped:\n                first_word = stripped.split()[0]\n                if first_word.endswith('s') and not first_word.endswith('ss'):\n                    return D401(first_word[:-1], first_word)\n", "docstring": "D401: First line should be in imperative mood: 'Do', not 'Does'."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def check_no_signature(self, function, docstring):  # def context\n        \"\"\"D402: First line should not be function's or method's \"signature\".\n        The one-line docstring should NOT be a \"signature\" reiterating the\n        function/method parameters (which can be obtained by introspection).\n        \"\"\"\n        if docstring:\n            first_line = ast.literal_eval(docstring).strip().split('\\n')[0]\n            if function.name + '(' in first_line.replace(' ', ''):\n                return D402()\n", "docstring": "D402: First line should not be function's or method's \"signature\"."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def check_capitalized(self, function, docstring):\n        \"\"\"D403: First word of the first line should be properly capitalized.\n        The [first line of a] docstring is a phrase ending in a period.\n        \"\"\"\n        if docstring:\n            first_word = ast.literal_eval(docstring).split()[0]\n            if first_word == first_word.upper():\n                return\n            for char in first_word:\n                if char not in string.ascii_letters and char != \"'\":\n                    return\n            if first_word != first_word.capitalize():\n                return D403(first_word.capitalize(), first_word)\n", "docstring": "D403: First word of the first line should be properly capitalized."}
{"repo": "Flake8Lint-master/contrib/pydocstyle.py", "original_string": "    def SKIP_check_return_type(self, function, docstring):\n        \"\"\"D40x: Return value type should be mentioned.\n        [T]he nature of the return value cannot be determined by\n        introspection, so it should be mentioned.\n        \"\"\"\n        if docstring and function.returns_value:\n            if 'return' not in docstring.lower():\n                return Error()\n", "docstring": "D40x: Return value type should be mentioned."}
{"repo": "Flake8Lint-master/contrib/pep8ext_naming.py", "original_string": "    def tag_class_functions(self, cls_node):\n        \"\"\"Tag functions if they are methods, classmethods, staticmethods\"\"\"\n        # tries to find all 'old style decorators' like\n        # m = staticmethod(m)\n        late_decoration = {}\n        for node in iter_child_nodes(cls_node):\n            if not (isinstance(node, ast.Assign) and\n                    isinstance(node.value, ast.Call) and\n                    isinstance(node.value.func, ast.Name)):\n                continue\n            func_name = node.value.func.id\n            if func_name in ('classmethod', 'staticmethod'):\n                meth = (len(node.value.args) == 1 and node.value.args[0])\n                if isinstance(meth, ast.Name):\n                    late_decoration[meth.id] = func_name\n        # iterate over all functions and tag them\n        for node in iter_child_nodes(cls_node):\n            if not isinstance(node, ast.FunctionDef):\n                continue\n            node.function_type = 'method'\n            if node.name == '__new__':\n                node.function_type = 'classmethod'\n            if node.name in late_decoration:\n                node.function_type = late_decoration[node.name]\n            elif node.decorator_list:\n                names = [d.id for d in node.decorator_list\n                         if isinstance(d, ast.Name) and\n                         d.id in ('classmethod', 'staticmethod')]\n                if names:\n                    node.function_type = names[0]\n", "docstring": "Tag functions if they are methods, classmethods, staticmethods\n"}
{"repo": "Flake8Lint-master/contrib/mccabe.py", "original_string": "    def _subgraph_parse(self, node, pathnode, extra_blocks):\n        \"\"\"parse the body and any `else` block of `if` and `for` statements\"\"\"\n        loose_ends = []\n        self.tail = pathnode\n        self.dispatch_list(node.body)\n        loose_ends.append(self.tail)\n        for extra in extra_blocks:\n            self.tail = pathnode\n            self.dispatch_list(extra.body)\n            loose_ends.append(self.tail)\n        if node.orelse:\n            self.tail = pathnode\n            self.dispatch_list(node.orelse)\n            loose_ends.append(self.tail)\n        else:\n            loose_ends.append(pathnode)\n        if pathnode:\n            bottom = PathNode(\"\", look='point')\n            for le in loose_ends:\n                self.graph.connect(le, bottom)\n            self.tail = bottom\n", "docstring": "parse the body and any `else` block of `if` and `for` statements\n"}
{"repo": "Flake8Lint-master/contrib/flake8_import_order/flake8_linter.py", "original_string": "    def add_options(cls, parser):\n        # List of application import names. They go last.\n        parser.add_option(\n            \"--application-import-names\",\n            default=\"\",\n            action=\"store\",\n            type=\"string\",\n            help=\"Import names to consider as application specific\"\n        )\n        parser.add_option(\n            \"--import-order-style\",\n            default=DEFAULT_IMPORT_ORDER_STYLE,\n            action=\"store\",\n            type=\"string\",\n            help=\"Style to follow. Available: cryptography, google\"\n        )\n        parser.config_options.append(\"application-import-names\")\n        parser.config_options.append(\"import-order-style\")\n", "docstring": "List of application import names. They go last."}
{"repo": "Flake8Lint-master/contrib/pyflakes/api.py", "original_string": "def _exitOnSignal(sigName, message):\n    \"\"\"Handles a signal with sys.exit.\n    Some of these signals (SIGPIPE, for example) don't exist or are invalid on\n    Windows. So, ignore errors that might arise.\n    \"\"\"\n    import signal\n    try:\n        sigNumber = getattr(signal, sigName)\n    except AttributeError:\n        # the signal constants defined in the signal module are defined by\n        # whether the C library supports them or not. So, SIGPIPE might not\n        # even be defined.\n        return\n    def handler(sig, f):\n        sys.exit(message)\n    try:\n        signal.signal(sigNumber, handler)\n    except ValueError:\n        # It's also possible the signal is defined, but then it's invalid. In\n        # this case, signal.signal raises ValueError.\n        pass\n", "docstring": "Handles a signal with sys.exit."}
{"repo": "Flake8Lint-master/contrib/pyflakes/checker.py", "original_string": "    def getNodeType(node_class):\n        # workaround str.upper() which is locale-dependent\n        return str(unicode(node_class.__name__).upper())\n", "docstring": "workaround str.upper() which is locale-dependent"}
{"repo": "Flake8Lint-master/contrib/pyflakes/checker.py", "original_string": "    def _get_fields(self, node_class):\n        # handle iter before target, and generators before element\n        fields = node_class._fields\n        if 'iter' in fields:\n            key_first = 'iter'.find\n        elif 'generators' in fields:\n            key_first = 'generators'.find\n        else:\n            key_first = 'value'.find\n        return tuple(sorted(fields, key=key_first, reverse=True))\n", "docstring": "handle iter before target, and generators before element"}
{"repo": "Flake8Lint-master/contrib/pyflakes/checker.py", "original_string": "    def __init__(self, name, source):\n        self.name = name\n        self.source = source\n        self.used = False\n", "docstring": "self.name = name"}
{"repo": "Flake8Lint-master/contrib/pyflakes/checker.py", "original_string": "def getNodeName(node):\n    # Returns node.id, or node.name, or None\n    if hasattr(node, 'id'):     # One of the many nodes with an id\n        return node.id\n    if hasattr(node, 'name'):   # a ExceptHandler node\n        return node.name\n", "docstring": "Returns node.id, or node.name, or None"}
{"repo": "Flake8Lint-master/contrib/pyflakes/checker.py", "original_string": "    def scope(self):\n        return self.scopeStack[-1]\n", "docstring": "return self.scopeStack[-1]"}
{"repo": "Flake8Lint-master/contrib/pyflakes/checker.py", "original_string": "    def report(self, messageClass, *args, **kwargs):\n        self.messages.append(messageClass(self.filename, *args, **kwargs))\n", "docstring": "self.messages.append(messageClass(self.filename, *args, **kwargs))"}
{"repo": "Flake8Lint-master/contrib/pyflakes/checker.py", "original_string": "    def differentForks(self, lnode, rnode):\n        \"\"\"True, if lnode and rnode are located on different forks of IF/TRY\"\"\"\n        ancestor = self.getCommonAncestor(lnode, rnode, self.root)\n        parts = getAlternatives(ancestor)\n        if parts:\n            for items in parts:\n                if self.descendantOf(lnode, items, ancestor) ^ \\\n                   self.descendantOf(rnode, items, ancestor):\n                    return True\n        return False\n", "docstring": "True, if lnode and rnode are located on different forks of IF/TRY\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/checker.py", "original_string": "    def handleChildren(self, tree, omit=None):\n        for node in iter_child_nodes(tree, omit=omit):\n            self.handleNode(node, tree)\n", "docstring": "for node in iter_child_nodes(tree, omit=omit):"}
{"repo": "Flake8Lint-master/contrib/pyflakes/checker.py", "original_string": "    def handleNode(self, node, parent):\n        if node is None:\n            return\n        if self.offset and getattr(node, 'lineno', None) is not None:\n            node.lineno += self.offset[0]\n            node.col_offset += self.offset[1]\n        if self.traceTree:\n            print('  ' * self.nodeDepth + node.__class__.__name__)\n        if self.futuresAllowed and not (isinstance(node, ast.ImportFrom) or\n                                        self.isDocstring(node)):\n            self.futuresAllowed = False\n        self.nodeDepth += 1\n        node.depth = self.nodeDepth\n        node.parent = parent\n        try:\n            handler = self.getNodeHandler(node.__class__)\n            handler(node)\n        finally:\n            self.nodeDepth -= 1\n        if self.traceTree:\n            print('  ' * self.nodeDepth + 'end ' + node.__class__.__name__)\n", "docstring": "if node is None:"}
{"repo": "Flake8Lint-master/contrib/pyflakes/checker.py", "original_string": "    def GENERATOREXP(self, node):\n        self.pushScope(GeneratorScope)\n        self.handleChildren(node)\n        self.popScope()\n", "docstring": "self.pushScope(GeneratorScope)"}
{"repo": "Flake8Lint-master/contrib/pyflakes/checker.py", "original_string": "    def YIELD(self, node):\n        self.scope.isGenerator = True\n        self.handleNode(node.value, node)\n", "docstring": "self.scope.isGenerator = True"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_api.py", "original_string": "    def __init__(self, lineno, col_offset=0):\n        self.lineno = lineno\n        self.col_offset = col_offset\n", "docstring": "self.lineno = lineno"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_api.py", "original_string": "    def unexpectedError(self, filename, message):\n        self.log.append(('unexpectedError', filename, message))\n", "docstring": "self.log.append(('unexpectedError', filename, message))"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_api.py", "original_string": "    def setUp(self):\n        self.tempdir = tempfile.mkdtemp()\n        self.tempfilepath = os.path.join(self.tempdir, 'temp')\n", "docstring": "self.tempdir = tempfile.mkdtemp()"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_other.py", "original_string": "    def test_modernProperty(self):\n        self.flakes(\"\"\"\n        class A:\n            @property\n            def t(self):\n                pass\n            @t.setter\n            def t(self, value):\n                pass\n            @t.deleter\n            def t(self):\n                pass\n        \"\"\")\n", "docstring": "self.flakes(\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_other.py", "original_string": "        def a():\n            b = True\n            while b:\n                b = False\n", "docstring": "b = True"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_other.py", "original_string": "        def a():\n            b.foo = 1\n", "docstring": "b.foo = 1"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_other.py", "original_string": "        def f():\n            [None for i in range(10)]\n", "docstring": "[None for i in range(10)]"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_other.py", "original_string": "        def f():\n            x = None\n            for i in range(10):\n                if i > 2:\n                    return x\n                x = i * 2\n", "docstring": "x = None"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_other.py", "original_string": "        def f(tup):\n            [x, y] = tup\n", "docstring": "[x, y] = tup"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_other.py", "original_string": "        def barMaker():\n            foo = 5\n            def bar():\n                def baz():\n                    return foo\n            return bar\n", "docstring": "foo = 5"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_other.py", "original_string": "        def download_review():\n            try: pass\n            except Exception%se: e\n", "docstring": "try: pass"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_other.py", "original_string": "        def foo():\n            try: pass\n            except (tokenize.TokenError, IndentationError): pass\n", "docstring": "try: pass"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_other.py", "original_string": "    def test_asyncDef(self):\n        self.flakes('''\n        async def bar():\n            return 42\n        ''')\n", "docstring": "self.flakes('''"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_imports.py", "original_string": "    def test_redefinedTryElse(self):\n        self.flakes(\"\"\"\n        try:\n            from aa import mixer\n        except ImportError:\n            pass\n        else:\n            from bb import mixer\n        mixer(123)\n        \"\"\", m.RedefinedWhileUnused)\n", "docstring": "self.flakes(\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_imports.py", "original_string": "            def test_get_transport(self):\n                transport = 'transport'\n                self.assertIsNotNone(transport)\n", "docstring": "transport = 'transport'"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_imports.py", "original_string": "        def fun():\n            print(fu)\n", "docstring": "print(fu)"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_imports.py", "original_string": "        def fun():\n            return fu\n", "docstring": "return fu"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_imports.py", "original_string": "    def test_usedInBackquote(self):\n        self.flakes('import fu; `fu`')\n", "docstring": "self.flakes('import fu; `fu`')"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_imports.py", "original_string": "    def test_assignRHSFirst(self):\n        self.flakes('import fu; fu = fu')\n        self.flakes('import fu; fu, bar = fu')\n        self.flakes('import fu; [fu, bar] = fu')\n        self.flakes('import fu; fu += fu')\n", "docstring": "self.flakes('import fu; fu = fu')"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_imports.py", "original_string": "    def test_importedInClass(self):\n        \"\"\"Imports in class scope can be used through self.\"\"\"\n        self.flakes('''\n        class c:\n            import i\n            def __init__(self):\n                self.i\n        ''')\n", "docstring": "Imports in class scope can be used through self.\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_imports.py", "original_string": "    def test_futureImport(self):\n        \"\"\"__future__ is special.\"\"\"\n        self.flakes('from __future__ import division')\n        self.flakes('''\n        \"docstring is allowed before future import\"\n        from __future__ import division\n        ''')\n", "docstring": "__future__ is special.\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_imports.py", "original_string": "    def test_futureImportUsed(self):\n        \"\"\"__future__ is special, but names are injected in the namespace.\"\"\"\n        self.flakes('''\n        from __future__ import division\n        from __future__ import print_function\n        assert print_function is not division\n        ''')\n", "docstring": "__future__ is special, but names are injected in the namespace.\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_imports.py", "original_string": "        def f():\n            return \"hello\"\n", "docstring": "return \"hello\""}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "    def test_globalImportStar(self):\n        \"\"\"Can't find undefined names with import *.\"\"\"\n        self.flakes('from fu import *; bar', m.ImportStarUsed)\n", "docstring": "Can't find undefined names with import *.\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "        def a():\n            from fu import *\n", "docstring": "from fu import *"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "    def test_unpackedParameter(self):\n        \"\"\"Unpacked function parameters create bindings.\"\"\"\n        self.flakes('''\n        def a((bar, baz)):\n            bar; baz\n        ''')\n", "docstring": "Unpacked function parameters create bindings.\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "        def foo():\n            print(x)\n", "docstring": "print(x)"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "    def test_del(self):\n        \"\"\"Del deletes bindings.\"\"\"\n        self.flakes('a = 1; del a; a', m.UndefinedName)\n", "docstring": "Del deletes bindings.\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "    def test_delUndefined(self):\n        \"\"\"Del an undefined name.\"\"\"\n        self.flakes('del a', m.UndefinedName)\n", "docstring": "Del an undefined name.\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "        def test():\n            foo = 'bar'\n            while False:\n                del foo\n            assert(foo)\n", "docstring": "foo = 'bar'"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "        def _worker():\n            o = True\n            while o is not True:\n                while True:\n                    with context():\n                        del o\n                o = False\n", "docstring": "o = True"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "    def test_globalFromNestedScope(self):\n        \"\"\"Global names are available from nested scopes.\"\"\"\n        self.flakes('''\n        a = 1\n        def b():\n            def c():\n                a\n        ''')\n", "docstring": "Global names are available from nested scopes.\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "    def test_badNestedClass(self):\n        \"\"\"Free variables in nested classes must bind at class creation.\"\"\"\n        self.flakes('''\n        def f():\n            class C:\n                bar = foo\n            foo = 456\n            return foo\n        f()\n        ''', m.UndefinedName)\n", "docstring": "Free variables in nested classes must bind at class creation.\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "    def test_definedAsStarUnpack(self):\n        \"\"\"Star names in unpack are defined.\"\"\"\n        self.flakes('''\n        a, *b = range(10)\n        print(a, b)\n        ''')\n        self.flakes('''\n        *a, b = range(10)\n        print(a, b)\n        ''')\n        self.flakes('''\n        a, *b, c = range(10)\n        print(a, b, c)\n        ''')\n", "docstring": "Star names in unpack are defined.\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "    def test_keywordOnlyArgs(self):\n        \"\"\"Keyword-only arg names are defined.\"\"\"\n        self.flakes('''\n        def f(*, a, b=None):\n            print(a, b)\n        ''')\n        self.flakes('''\n        import default_b\n        def f(*, a, b=default_b):\n            print(a, b)\n        ''')\n", "docstring": "Keyword-only arg names are defined.\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "    def test_keywordOnlyArgsUndefined(self):\n        \"\"\"Typo in kwonly name.\"\"\"\n        self.flakes('''\n        def f(*, a, b=default_c):\n            print(a, b)\n        ''', m.UndefinedName)\n", "docstring": "Typo in kwonly name.\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "    def test_annotationUndefined(self):\n        \"\"\"Undefined annotations.\"\"\"\n        self.flakes('''\n        from abc import note1, note2, note3, note4, note5\n        def func(a: note1, *args: note2,\n                 b: note3=12, **kw: note4) -> note5: pass\n        ''')\n        self.flakes('''\n        def func():\n            d = e = 42\n            def func(a: {1, d}) -> (lambda c: e): pass\n        ''')\n", "docstring": "Undefined annotations.\n"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_undefined_names.py", "original_string": "    def test_metaClassUndefined(self):\n        self.flakes('''\n        from abc import ABCMeta\n        class A(metaclass=ABCMeta): pass\n        ''')\n", "docstring": "self.flakes('''"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_doctests.py", "original_string": "    def test_offsetInDoctests(self):\n        exc = self.flakes('''\n        def doctest_stuff():\n            \"\"\"\n                >>> x # line 5\n            \"\"\"\n        ''', m.UndefinedName).messages[0]\n        self.assertEqual(exc.lineno, 5)\n        self.assertEqual(exc.col, 12)\n", "docstring": "exc = self.flakes('''"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_doctests.py", "original_string": "    def test_offsetAfterDoctests(self):\n        exc = self.flakes('''\n        def doctest_stuff():\n            \"\"\"\n                >>> x = 5\n            \"\"\"\n        x\n        ''', m.UndefinedName).messages[0]\n        self.assertEqual(exc.lineno, 8)\n        self.assertEqual(exc.col, 0)\n", "docstring": "exc = self.flakes('''"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_doctests.py", "original_string": "    def test_indentationErrorInDoctest(self):\n        exc = self.flakes('''\n        def doctest_stuff():\n            \"\"\"\n                >>> if True:\n                ... pass\n            \"\"\"\n        ''', m.DoctestSyntaxError).messages[0]\n        self.assertEqual(exc.lineno, 5)\n        self.assertEqual(exc.col, 16)\n", "docstring": "exc = self.flakes('''"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_doctests.py", "original_string": "    def test_noOffsetSyntaxErrorInDoctest(self):\n        exceptions = self.flakes(\n            '''\n            def buildurl(base, *args, **kwargs):\n                \"\"\"\n                >>> buildurl('/blah.php', ('a', '&'), ('b', '=')\n                '/blah.php?a=%26&b=%3D'\n                >>> buildurl('/blah.php', a='&', 'b'='=')\n                '/blah.php?b=%3D&a=%26'\n                \"\"\"\n                pass\n            ''',\n            m.DoctestSyntaxError,\n            m.DoctestSyntaxError).messages\n        exc = exceptions[0]\n        self.assertEqual(exc.lineno, 4)\n        exc = exceptions[1]\n        self.assertEqual(exc.lineno, 6)\n", "docstring": "exceptions = self.flakes("}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_doctests.py", "original_string": "        def func():\n            \"\"\"A docstring\n            >>> func()\n            1\n            >>> _\n            1\n            \"\"\"\n            return 1\n", "docstring": "A docstring"}
{"repo": "Flake8Lint-master/contrib/pyflakes/test/test_doctests.py", "original_string": "    def test_futureImport(self):\n        \"\"\"XXX This test can't work in a doctest\"\"\"\n", "docstring": "XXX This test can't work in a doctest\n"}
{"repo": "Flake8Lint-master/contrib/elementtree_contrib/SimpleXMLTreeBuilder.py", "original_string": "def fixname(name, split=string.split):\n    # xmllib in 2.0 and later provides limited (and slightly broken)\n    # support for XML namespaces.\n    if \" \" not in name:\n        return name\n    return \"{%s}%s\" % tuple(split(name, \" \", 1))\n", "docstring": "xmllib in 2.0 and later provides limited (and slightly broken)"}
{"repo": "Flake8Lint-master/contrib/elementtree_contrib/SimpleXMLWriter.py", "original_string": "    def encode(s, encoding):\n        # 1.5.2: application must use the right encoding\n        return s\n", "docstring": "1.5.2: application must use the right encoding"}
{"repo": "Flake8Lint-master/contrib/elementtree_contrib/SimpleXMLWriter.py", "original_string": "def encode_entity(text, pattern=_escape):\n    # map reserved and non-ascii characters to numerical entities\n    def escape_entities(m):\n        out = []\n        for char in m.group():\n            out.append(\"&#%d;\" % ord(char))\n        return string.join(out, \"\")\n    return encode(pattern.sub(escape_entities, text), \"ascii\")\n", "docstring": "map reserved and non-ascii characters to numerical entities"}
{"repo": "Flake8Lint-master/contrib/elementtree_contrib/ElementTree.py", "original_string": "def iselement(element):\n    # FIXME: not sure about this; might be a better idea to look\n    # for tag/attrib/text attributes\n    return isinstance(element, _ElementInterface) or hasattr(element, \"tag\")\n", "docstring": "FIXME: not sure about this; might be a better idea to look"}
{"repo": "Flake8Lint-master/contrib/elementtree_contrib/ElementTree.py", "original_string": "def dump(elem):\n    # debugging\n    if not isinstance(elem, ElementTree):\n        elem = ElementTree(elem)\n    elem.write(sys.stdout)\n    tail = elem.getroot().tail\n    if not tail or tail[-1] != \"\\n\":\n        sys.stdout.write(\"\\n\")\n", "docstring": "debugging"}
{"repo": "Flake8Lint-master/contrib/elementtree_contrib/ElementTree.py", "original_string": "def _escape_cdata(text, encoding=None, replace=string.replace):\n    # escape character data\n    try:\n        if encoding:\n            try:\n                text = _encode(text, encoding)\n            except UnicodeError:\n                return _encode_entity(text)\n        text = replace(text, \"&\", \"&amp;\")\n        text = replace(text, \"<\", \"&lt;\")\n        text = replace(text, \">\", \"&gt;\")\n        return text\n    except (TypeError, AttributeError):\n        _raise_serialization_error(text)\n", "docstring": "escape character data"}
{"repo": "Flake8Lint-master/contrib/elementtree_contrib/ElementTree.py", "original_string": "def fixtag(tag, namespaces):\n    # given a decorated tag (of the form {uri}tag), return prefixed\n    # tag and namespace declaration, if any\n    if isinstance(tag, QName):\n        tag = tag.text\n    namespace_uri, tag = string.split(tag[1:], \"}\", 1)\n    prefix = namespaces.get(namespace_uri)\n    if prefix is None:\n        prefix = _namespace_map.get(namespace_uri)\n        if prefix is None:\n            prefix = \"ns%d\" % len(namespaces)\n        namespaces[namespace_uri] = prefix\n        if prefix == \"xml\":\n            xmlns = None\n        else:\n            xmlns = (\"xmlns:%s\" % prefix, namespace_uri)\n    else:\n        xmlns = None\n    return \"%s:%s\" % (prefix, tag), xmlns\n", "docstring": "given a decorated tag (of the form {uri}tag), return prefixed"}
{"repo": "Flake8Lint-master/contrib/elementtree_contrib/ElementTree.py", "original_string": "    def _fixname(self, key):\n        # expand qname, and convert name string to ascii, if possible\n        try:\n            name = self._names[key]\n        except KeyError:\n            name = key\n            if \"}\" in name:\n                name = \"{\" + name\n            self._names[key] = name = self._fixtext(name)\n        return name\n", "docstring": "expand qname, and convert name string to ascii, if possible"}
{"repo": "Flake8Lint-master/contrib/elementtree_contrib/TidyTools.py", "original_string": "def getbody(file, **options):\n    # get clean body from text file\n    # get xhtml tree\n    try:\n        tree = apply(tidy, (file,), options)\n        if tree is None:\n            return\n    except IOError, v:\n        print \"***\", v\n        return None\n    NS = NS_XHTML\n    # remove namespace uris\n    for node in tree.getiterator():\n        if node.tag.startswith(NS):\n            node.tag = node.tag[len(NS):]\n    body = tree.getroot().find(\"body\")\n    return body\n", "docstring": "get clean body from text file"}
{"repo": "Flake8Lint-master/contrib/flake8/engine.py", "original_string": "def _load_entry_point(entry_point, verify_requirements):\n    \"\"\"Based on the version of setuptools load an entry-point correctly.\n    setuptools 11.3 deprecated `require=False` in the call to EntryPoint.load.\n    To load entry points correctly after that without requiring all\n    dependencies be present, the proper way is to call EntryPoint.resolve.\n    This function will provide backwards compatibility for older versions of\n    setuptools while also ensuring we do the right thing for the future.\n    \"\"\"\n    if hasattr(entry_point, 'resolve') and hasattr(entry_point, 'require'):\n        if verify_requirements:\n            entry_point.require()\n        plugin = entry_point.resolve()\n    else:\n        plugin = entry_point.load(require=verify_requirements)\n    return plugin\n", "docstring": "Based on the version of setuptools load an entry-point correctly."}
{"repo": "Flake8Lint-master/contrib/flake8/engine.py", "original_string": "def get_parser():\n    \"\"\"This returns an instance of optparse.OptionParser with all the\n    extensions registered and options set. This wraps ``pep8.get_parser``.\n    \"\"\"\n    (extensions, parser_hooks, options_hooks, ignored) = _register_extensions()\n    details = ', '.join('%s: %s' % ext for ext in extensions)\n    python_version = get_python_version()\n    parser = pep8.get_parser('flake8', '%s (%s) %s' % (\n        __version__, details, python_version\n    ))\n    for opt in ('--repeat', '--testsuite', '--doctest'):\n        try:\n            parser.remove_option(opt)\n        except ValueError:\n            pass\n    if multiprocessing:\n        parser.config_options.append('jobs')\n        parser.add_option('-j', '--jobs', type='string', default='auto',\n                          help=\"number of jobs to run simultaneously, \"\n                          \"or 'auto'. This is ignored on Windows.\")\n    parser.add_option('--exit-zero', action='store_true',\n                      help=\"exit with code 0 even if there are errors\")\n    for parser_hook in parser_hooks:\n        parser_hook(parser)\n    # See comment above regarding why this has to be a callback.\n    parser.add_option('--install-hook', default=False, dest='install_hook',\n                      help='Install the appropriate hook for this '\n                      'repository.', action='callback',\n                      callback=callbacks.install_vcs_hook)\n    parser.add_option('--output-file', default=None,\n                      help='Redirect report to a file.',\n                      type='string', nargs=1, action='callback',\n                      callback=callbacks.redirect_stdout)\n    parser.add_option('--enable-extensions', default='',\n                      dest='enabled_extensions',\n                      help='Enable plugins and extensions that are disabled '\n                           'by default',\n                      type='string')\n    parser.config_options.extend(['output_file', 'enable_extensions'])\n    parser.ignored_extensions = ignored\n    return parser, options_hooks\n", "docstring": "This returns an instance of optparse.OptionParser with all the"}
{"repo": "Flake8Lint-master/contrib/flake8/engine.py", "original_string": "    def input_file(self, filename, lines=None, expected=None, line_offset=0):\n        \"\"\"Run all checks on a Python source file.\"\"\"\n        if self.options.verbose:\n            print('checking %s' % filename)\n        fchecker = self.checker_class(\n            filename, lines=lines, options=self.options)\n        # Any \"flake8: noqa\" comments to ignore the entire file?\n        if any(_flake8_noqa(line) for line in fchecker.lines):\n            return 0\n        return fchecker.check_all(expected=expected, line_offset=line_offset)\n", "docstring": "Run all checks on a Python source file.\n"}
{"repo": "Flake8Lint-master/contrib/flake8/engine.py", "original_string": "    def __init__(self, **kwargs):\n        # This allows us to inject a mocked StyleGuide in the tests.\n        self._styleguide = kwargs.pop('styleguide', NoQAStyleGuide(**kwargs))\n", "docstring": "This allows us to inject a mocked StyleGuide in the tests."}
{"repo": "Flake8Lint-master/contrib/flake8/engine.py", "original_string": "def get_style_guide(**kwargs):\n    \"\"\"Parse the options and configure the checker. This returns a sub-class\n    of ``pep8.StyleGuide``.\"\"\"\n    kwargs['parser'], options_hooks = get_parser()\n    styleguide = StyleGuide(**kwargs)\n    options = styleguide.options\n    _disable_extensions(kwargs['parser'], options)\n    if options.exclude and not isinstance(options.exclude, list):\n        options.exclude = pep8.normalize_paths(options.exclude)\n    elif not options.exclude:\n        options.exclude = []\n    # Add patterns in EXTRA_EXCLUDE to the list of excluded patterns\n    options.exclude.extend(pep8.normalize_paths(EXTRA_EXCLUDE))\n    for options_hook in options_hooks:\n        options_hook(options)\n    if util.warn_when_using_jobs(options):\n        if not multiprocessing:\n            warnings.warn(\"The multiprocessing module is not available. \"\n                          \"Ignoring --jobs arguments.\")\n        if util.is_windows():\n            warnings.warn(\"The --jobs option is not available on Windows. \"\n                          \"Ignoring --jobs arguments.\")\n        if util.is_using_stdin(styleguide.paths):\n            warnings.warn(\"The --jobs option is not compatible with supplying \"\n                          \"input using - . Ignoring --jobs arguments.\")\n        if options.diff:\n            warnings.warn(\"The --diff option was specified with --jobs but \"\n                          \"they are not compatible. Ignoring --jobs arguments.\"\n                          )\n    if options.diff:\n        options.jobs = None\n    force_disable_jobs = util.force_disable_jobs(styleguide)\n    if multiprocessing and options.jobs and not force_disable_jobs:\n        if options.jobs.isdigit():\n            n_jobs = int(options.jobs)\n        else:\n            try:\n                n_jobs = multiprocessing.cpu_count()\n            except NotImplementedError:\n                n_jobs = 1\n        if n_jobs > 1:\n            options.jobs = n_jobs\n            reporter = QueueReport\n            if options.quiet:\n                reporter = BaseQReport\n                if options.quiet == 1:\n                    reporter = FileQReport\n            report = styleguide.init_report(reporter)\n            report.input_file = styleguide.input_file\n            styleguide.runner = report.task_queue.put\n    return styleguide\n", "docstring": "Parse the options and configure the checker. This returns a sub-class"}
{"repo": "Flake8Lint-master/contrib/flake8/callbacks.py", "original_string": "def install_vcs_hook(option, option_str, value, parser):\n    # For now, there's no way to affect a change in how pep8 processes\n    # options. If no args are provided and there's no config file present,\n    # it will error out because no input was provided. To get around this,\n    # when we're using --install-hook, we'll say that there were arguments so\n    # we can actually attempt to install the hook.\n    # See: https://gitlab.com/pycqa/flake8/issues/2 and\n    # https://github.com/jcrocholl/pep8/blob/4c5bf00cb613be617c7f48d3b2b82a1c7b895ac1/pep8.py#L1912\n    # for more context.\n    parser.values.install_hook = True\n    parser.rargs.append('.')\n", "docstring": "For now, there's no way to affect a change in how pep8 processes"}
{"repo": "Flake8Lint-master/contrib/flake8/reporter.py", "original_string": "    def _put_done(self):\n        # collect queues\n        for i in range(self.n_jobs):\n            self.task_queue.put('DONE')\n            self.update_state(self.result_queue.get())\n", "docstring": "collect queues"}
{"repo": "Flake8Lint-master/contrib/flake8/main.py", "original_string": "def main():\n    \"\"\"Parse options and run checks on Python source.\"\"\"\n    # Prepare\n    flake8_style = get_style_guide(parse_argv=True, config_file=DEFAULT_CONFIG)\n    options = flake8_style.options\n    if options.install_hook:\n        from flake8.hooks import install_hook\n        install_hook()\n    # Run the checkers\n    report = flake8_style.check_files()\n    exit_code = print_report(report, flake8_style)\n    if exit_code > 0:\n        raise SystemExit(exit_code > 0)\n", "docstring": "Parse options and run checks on Python source.\n"}
{"repo": "Flake8Lint-master/contrib/flake8/main.py", "original_string": "def check_file(path, ignore=(), complexity=-1):\n    \"\"\"Checks a file using pep8 and pyflakes by default and mccabe\n    optionally.\n    :param str path: path to the file to be checked\n    :param tuple ignore: (optional), error and warning codes to be ignored\n    :param int complexity: (optional), enables the mccabe check for values > 0\n    \"\"\"\n    ignore = set(ignore).union(EXTRA_IGNORE)\n    flake8_style = get_style_guide(\n        config_file=DEFAULT_CONFIG, ignore=ignore, max_complexity=complexity)\n    return flake8_style.input_file(path)\n", "docstring": "Checks a file using pep8 and pyflakes by default and mccabe"}
{"repo": "Flake8Lint-master/contrib/flake8/_pyflakes.py", "original_string": "def patch_pyflakes():\n    \"\"\"Add error codes to Pyflakes messages.\"\"\"\n    codes = dict([line.split()[::-1] for line in (\n        'F401 UnusedImport',\n        'F402 ImportShadowedByLoopVar',\n        'F403 ImportStarUsed',\n        'F404 LateFutureImport',\n        'F810 Redefined',               # XXX Obsolete?\n        'F811 RedefinedWhileUnused',\n        'F812 RedefinedInListComp',\n        'F821 UndefinedName',\n        'F822 UndefinedExport',\n        'F823 UndefinedLocal',\n        'F831 DuplicateArgument',\n        'F841 UnusedVariable',\n    )])\n    for name, obj in vars(pyflakes.messages).items():\n        if name[0].isupper() and obj.message:\n            obj.flake8_msg = '%s %s' % (codes.get(name, 'F999'), obj.message)\n", "docstring": "Add error codes to Pyflakes messages.\n"}
{"repo": "Flake8Lint-master/contrib/flake8/util.py", "original_string": "    def add(self, value):\n        if value not in self:\n            self.append(value)\n", "docstring": "if value not in self:"}
{"repo": "Flake8Lint-master/contrib/flake8/util.py", "original_string": "def is_using_stdin(paths):\n    \"\"\"Determine if we're running checks on stdin.\"\"\"\n    return '-' in paths\n", "docstring": "Determine if we're running checks on stdin.\n"}
{"repo": "Flake8Lint-master/contrib/flake8/tests/test_integration.py", "original_string": "    def this_file(self):\n        \"\"\"Return the real path of this file.\"\"\"\n        this_file = os.path.realpath(__file__)\n        if this_file.endswith(\"pyc\"):\n            this_file = this_file[:-1]\n        return this_file\n", "docstring": "Return the real path of this file.\n"}
{"repo": "Flake8Lint-master/contrib/flake8/tests/test_integration.py", "original_string": "    def test_no_args(self):\n        # assert there are no reported errors\n        self.check_files()\n", "docstring": "assert there are no reported errors"}
{"repo": "Flake8Lint-master/contrib/flake8/tests/_test_warnings.py", "original_string": "    def this_file(self):\n        \"\"\"Return the real path of this file.\"\"\"\n        this_file = os.path.realpath(__file__)\n        if this_file.endswith(\"pyc\"):\n            this_file = this_file[:-1]\n        return this_file\n", "docstring": "Return the real path of this file.\n"}
{"repo": "Flake8Lint-master/contrib/flake8/tests/_test_warnings.py", "original_string": "    def check_files_collect_warnings(self,\n                                     arglist=[],\n                                     explicit_stdin=False,\n                                     count=0,\n                                     verbose=False):\n        \"\"\"Call check_files and collect any warnings that are issued.\"\"\"\n        if verbose:\n            arglist.append('--verbose')\n        if explicit_stdin:\n            target_file = \"-\"\n        else:\n            target_file = self.this_file()\n        argv = ['flake8'] + arglist + [target_file]\n        with mock.patch(\"sys.argv\", argv):\n            (style_guide,\n             collected_warnings,\n             ) = self.get_style_guide_with_warnings(engine,\n                                                    parse_argv=True)\n            report = style_guide.check_files()\n        self.assertEqual(report.total_errors, count)\n        return style_guide, report, collected_warnings\n", "docstring": "arglist=[],"}
{"repo": "Flake8Lint-master/contrib/flake8/tests/_test_warnings.py", "original_string": "    def _job_tester(self, jobs, verbose=False):\n        # mock stdout.flush so we can count the number of jobs created\n        with mock.patch('sys.stdout.flush') as mocked:\n            (guide,\n             report,\n             collected_warnings,\n             ) = self.check_files_collect_warnings(\n                arglist=['--jobs=%s' % jobs],\n                verbose=verbose)\n            if is_windows():\n                # The code path where guide.options.jobs gets converted to an\n                # int is not run on windows. So, do the int conversion here.\n                self.assertEqual(int(guide.options.jobs), jobs)\n                # On windows, call count is always zero.\n                self.assertEqual(mocked.call_count, 0)\n            else:\n                self.assertEqual(guide.options.jobs, jobs)\n                self.assertEqual(mocked.call_count, jobs)\n            expected_warings = []\n            if verbose and is_windows():\n                expected_warings.append(self.windows_warning_text)\n            self.verify_warnings(collected_warnings, expected_warings)\n", "docstring": "mock stdout.flush so we can count the number of jobs created"}
{"repo": "Flake8Lint-master/contrib/flake8/tests/test_reporter.py", "original_string": "    def test_does_not_raise_a_bad_pipe_ioerror(self):\n        \"\"\"Test that no EPIPE IOError exception is re-raised or leaked.\"\"\"\n        report = ioerror_report_factory(errno.EPIPE)\n        try:\n            report.process_main()\n        except IOError:\n            self.fail('BaseQReport.process_main raised an IOError for EPIPE'\n                      ' but it should have caught this exception.')\n", "docstring": "Test that no EPIPE IOError exception is re-raised or leaked.\n"}
{"repo": "nanomsg-python-master/_nanomsg_ctypes/__init__.py", "original_string": "def create_writable_buffer(size):\n    \"\"\"Returns a writable buffer.\n    This is the ctypes implementation.\n    \"\"\"\n    return (ctypes.c_ubyte*size)()\n", "docstring": "Returns a writable buffer."}
{"repo": "nanomsg-python-master/_nanomsg_ctypes/__init__.py", "original_string": "def nn_getsockopt(socket, level, option, value):\n    \"\"\"retrieve a socket option\n    socket - socket number\n    level - option level\n    option - option\n    value - a writable byte buffer (e.g. a bytearray) which the option value\n    will be copied to\n    returns - number of bytes copied or on error nunber < 0\n    \"\"\"\n    if memoryview(value).readonly:\n        raise TypeError('Writable buffer is required')\n    size_t_size = ctypes.c_size_t(len(value))\n    rtn = _nn_getsockopt(socket, level, option, ctypes.addressof(value),\n                         ctypes.byref(size_t_size))\n    return (rtn, size_t_size.value)\n", "docstring": "retrieve a socket option"}
{"repo": "nanomsg-python-master/nanomsg/__init__.py", "original_string": "    def create_writable_buffer(size):\n        \"\"\"Returns a writable buffer\"\"\"\n        return bytearray(size)\n", "docstring": "Returns a writable buffer\n"}
{"repo": "nanomsg-python-master/nanomsg/__init__.py", "original_string": "def terminate_all():\n    \"\"\"Close all sockets and devices\"\"\"\n    global nanoconfig_started\n    if nanoconfig_started:\n        wrapper.nc_term()\n        nanoconfig_started = False\n    wrapper.nn_term()\n", "docstring": "Close all sockets and devices\n"}
{"repo": "nanomsg-python-master/nanomsg/__init__.py", "original_string": "    def fd(self):\n        \"\"\"Socket file descripter.\n        Note this is not an OS file descripter (see .send_fd, .recv_fd).\n        \"\"\"\n        return self._fd\n", "docstring": "Socket file descripter."}
{"repo": "nanomsg-python-master/nanomsg/__init__.py", "original_string": "    def endpoints(self):\n        \"\"\"Endpoints list\n        \"\"\"\n        return list(self._endpoints)\n", "docstring": "Endpoints list"}
{"repo": "nanomsg-python-master/nanomsg/__init__.py", "original_string": "    def connect(self, address):\n        \"\"\"Add a remote endpoint to the socket\"\"\"\n        if self.uses_nanoconfig:\n            raise ValueError(\"Nanoconfig address must be sole endpoint\")\n        endpoint_id = _nn_check_positive_rtn(\n            wrapper.nn_connect(self.fd, address)\n        )\n        ep = Socket.ConnectEndpoint(self, endpoint_id, address)\n        self._endpoints.append(ep)\n        return ep\n", "docstring": "Add a remote endpoint to the socket\n"}
{"repo": "nanomsg-python-master/nanomsg/__init__.py", "original_string": "    def close(self):\n        \"\"\"Close the socket\"\"\"\n        if self.is_open():\n            fd = self._fd\n            self._fd = -1\n            if self.uses_nanoconfig:\n                wrapper.nc_close(fd)\n            else:\n                _nn_check_positive_rtn(wrapper.nn_close(fd))\n", "docstring": "Close the socket\n"}
{"repo": "nanomsg-python-master/nanomsg/__init__.py", "original_string": "    def recv(self, buf=None, flags=0):\n        \"\"\"Recieve a message.\"\"\"\n        if buf is None:\n            rtn, out_buf = wrapper.nn_recv(self.fd, flags)\n        else:\n            rtn, out_buf = wrapper.nn_recv(self.fd, buf, flags)\n        _nn_check_positive_rtn(rtn)\n        return bytes(buffer(out_buf))[:rtn]\n", "docstring": "Recieve a message.\n"}
{"repo": "plotly.py-master/packages/python/plotly/setup.py", "original_string": "def js_prerelease(command, strict=False):\n    \"\"\"decorator for building minified js/css prior to another command\"\"\"\n    class DecoratedCommand(command):\n        def run(self):\n            jsdeps = self.distribution.get_command_obj(\"jsdeps\")\n            if not is_repo and all(os.path.exists(t) for t in jsdeps.targets):\n                # sdist, nothing to do\n                command.run(self)\n                self.distribution.data_files.extend(prebuilt_assets)\n                return\n            try:\n                self.distribution.run_command(\"jsdeps\")\n            except Exception as e:\n                missing = [t for t in jsdeps.targets if not os.path.exists(t)]\n                if strict or missing:\n                    log.warn(\"rebuilding js and css failed\")\n                    if missing:\n                        log.error(\"missing files: %s\" % missing)\n                    raise e\n                else:\n                    log.warn(\"rebuilding js and css failed (not a problem)\")\n                    log.warn(str(e))\n            command.run(self)\n            update_package_data(self.distribution)\n    return DecoratedCommand\n", "docstring": "decorator for building minified js/css prior to another command\n"}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def get_root():\n    \"\"\"Get the project root directory.\n    We require that all commands are run from the project root, i.e. the\n    directory that contains setup.py, setup.cfg, and versioneer.py .\n    \"\"\"\n    root = os.path.realpath(os.path.abspath(os.getcwd()))\n    setup_py = os.path.join(root, \"setup.py\")\n    versioneer_py = os.path.join(root, \"versioneer.py\")\n    if not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n        # allow 'python path/to/setup.py COMMAND'\n        root = os.path.dirname(os.path.realpath(os.path.abspath(sys.argv[0])))\n        setup_py = os.path.join(root, \"setup.py\")\n        versioneer_py = os.path.join(root, \"versioneer.py\")\n    if not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n        err = (\n            \"Versioneer was unable to run the project root directory. \"\n            \"Versioneer requires setup.py to be executed from \"\n            \"its immediate directory (like 'python setup.py COMMAND'), \"\n            \"or in a way that lets it use sys.argv[0] to find the root \"\n            \"(like 'python path/to/setup.py COMMAND').\"\n        )\n        raise VersioneerBadRootError(err)\n    try:\n        # Certain runtime workflows (setup.py install/develop in a setuptools\n        # tree) execute all dependencies in a single python process, so\n        # \"versioneer\" may be imported multiple times, and python's shared\n        # module-import table will cache the first one. So we can't use\n        # os.path.dirname(__file__), as that will find whichever\n        # versioneer.py was first imported, even in later projects.\n        me = os.path.realpath(os.path.abspath(__file__))\n        me_dir = os.path.normcase(os.path.splitext(me)[0])\n        vsr_dir = os.path.normcase(os.path.splitext(versioneer_py)[0])\n        if me_dir != vsr_dir:\n            print(\n                \"Warning: build in %s is using versioneer.py from %s\"\n                % (os.path.dirname(me), versioneer_py)\n            )\n    except NameError:\n        pass\n    return root\n", "docstring": "Get the project root directory."}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def register_vcs_handler(vcs, method):  # decorator\n    \"\"\"Decorator to mark a method as the handler for a particular VCS.\"\"\"\n    def decorate(f):\n        \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n    return decorate\n", "docstring": "Decorator to mark a method as the handler for a particular VCS.\n"}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def get_keywords():\n    \"\"\"Get the keywords needed to look up the version information.\"\"\"\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = \"%(DOLLAR)sFormat:%%d%(DOLLAR)s\"\n    git_full = \"%(DOLLAR)sFormat:%%H%(DOLLAR)s\"\n    git_date = \"%(DOLLAR)sFormat:%%ci%(DOLLAR)s\"\n    keywords = {\"refnames\": git_refnames, \"full\": git_full, \"date\": git_date}\n    return keywords\n", "docstring": "Get the keywords needed to look up the version information.\n"}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def get_config():\n    \"\"\"Create, populate and return the VersioneerConfig() object.\"\"\"\n    # these strings are filled in when 'setup.py versioneer' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = \"git\"\n    cfg.style = \"%(STYLE)s\"\n    cfg.tag_prefix = \"%(TAG_PREFIX)s\"\n    cfg.parentdir_prefix = \"%(PARENTDIR_PREFIX)s\"\n    cfg.versionfile_source = \"%(VERSIONFILE_SOURCE)s\"\n    cfg.verbose = False\n    return cfg\n", "docstring": "Create, populate and return the VersioneerConfig() object.\n"}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def register_vcs_handler(vcs, method):  # decorator\n    \"\"\"Decorator to mark a method as the handler for a particular VCS.\"\"\"\n    def decorate(f):\n        \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n    return decorate\n", "docstring": "Decorator to mark a method as the handler for a particular VCS.\n"}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def versions_from_parentdir(parentdir_prefix, root, verbose):\n    \"\"\"Try to determine the version from the parent directory name.\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    \"\"\"\n    rootdirs = []\n    for i in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {\"version\": dirname[len(parentdir_prefix):],\n                    \"full-revisionid\": None,\n                    \"dirty\": False, \"error\": None, \"date\": None}\n        else:\n            rootdirs.append(root)\n            root = os.path.dirname(root)  # up a level\n    if verbose:\n        print(\"Tried directories %%s but none started with prefix %%s\" %%\n              (str(rootdirs), parentdir_prefix))\n    raise NotThisMethod(\"rootdir doesn't start with parentdir_prefix\")\n", "docstring": "Try to determine the version from the parent directory name."}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def git_get_keywords(versionfile_abs):\n    \"\"\"Extract version information from the given file.\"\"\"\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don't want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        f = open(versionfile_abs, \"r\")\n        for line in f.readlines():\n            if line.strip().startswith(\"git_refnames =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"refnames\"] = mo.group(1)\n            if line.strip().startswith(\"git_full =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"full\"] = mo.group(1)\n            if line.strip().startswith(\"git_date =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"date\"] = mo.group(1)\n        f.close()\n    except EnvironmentError:\n        pass\n    return keywords\n", "docstring": "Extract version information from the given file.\n"}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def git_versions_from_keywords(keywords, tag_prefix, verbose):\n    \"\"\"Get version information from git keywords.\"\"\"\n    if not keywords:\n        raise NotThisMethod(\"no keywords at all, weird\")\n    date = keywords.get(\"date\")\n    if date is not None:\n        # git-2.2.0 added \"%%cI\", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer \"%%ci\" (which expands to an \"ISO-8601\n        # -like\" string, which we must then edit to make compliant), because\n        # it's been around since git-1.5.3, and it's too difficult to\n        # discover which version we're using, or to work around using an\n        # older one.\n        date = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n    refnames = keywords[\"refnames\"].strip()\n    if refnames.startswith(\"$Format\"):\n        if verbose:\n            print(\"keywords are unexpanded, not using\")\n        raise NotThisMethod(\"unexpanded keywords, not a git-archive tarball\")\n    refs = set([r.strip() for r in refnames.strip(\"()\").split(\",\")])\n    # starting in git-1.8.3, tags are listed as \"tag: foo-1.0\" instead of\n    # just \"foo-1.0\". If we see a \"tag: \" prefix, prefer those.\n    TAG = \"tag: \"\n    tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)])\n    if not tags:\n        # Either we're using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %%d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like \"release\" and\n        # \"stabilization\", as well as \"HEAD\" and \"master\".\n        tags = set([r for r in refs if re.search(r'\\d', r)])\n        if verbose:\n            print(\"discarding '%%s', no digits\" %% \",\".join(refs - tags))\n    if verbose:\n        print(\"likely tags: %%s\" %% \",\".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. \"2.0\" over \"2.0rc1\"\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix):]\n            if verbose:\n                print(\"picking %%s\" %% r)\n            return {\"version\": r,\n                    \"full-revisionid\": keywords[\"full\"].strip(),\n                    \"dirty\": False, \"error\": None,\n                    \"date\": date}\n    # no suitable tags, so version is \"0+unknown\", but full hex is still there\n    if verbose:\n        print(\"no suitable tags, using unknown + full revision id\")\n    return {\"version\": \"0+unknown\",\n            \"full-revisionid\": keywords[\"full\"].strip(),\n            \"dirty\": False, \"error\": \"no suitable tags\", \"date\": None}\n", "docstring": "Get version information from git keywords.\n"}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def render_pep440(pieces):\n    \"\"\"Build up version string, with post-release \"local version identifier\".\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += plus_or_dot(pieces)\n            rendered += \"%%d.g%%s\" %% (pieces[\"distance\"], pieces[\"short\"])\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0+untagged.%%d.g%%s\" %% (pieces[\"distance\"],\n                                          pieces[\"short\"])\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n", "docstring": "Build up version string, with post-release \"local version identifier\"."}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def render_pep440_post(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]+gHEX] .\n    The \".dev0\" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear \"older\" than the corresponding clean one),\n    but you shouldn't be releasing software with -dirty anyways.\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%%d\" %% pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"g%%s\" %% pieces[\"short\"]\n    else:\n        # exception #1\n        rendered = \"0.post%%d\" %% pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n        rendered += \"+g%%s\" %% pieces[\"short\"]\n    return rendered\n", "docstring": "TAG[.postDISTANCE[.dev0]+gHEX] ."}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def render_git_describe(pieces):\n    \"\"\"TAG[-DISTANCE-gHEX][-dirty].\n    Like 'git describe --tags --dirty --always'.\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"]:\n            rendered += \"-%%d-g%%s\" %% (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n", "docstring": "TAG[-DISTANCE-gHEX][-dirty]."}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def render(pieces, style):\n    \"\"\"Render the given version pieces into the requested style.\"\"\"\n    if pieces[\"error\"]:\n        return {\"version\": \"unknown\",\n                \"full-revisionid\": pieces.get(\"long\"),\n                \"dirty\": None,\n                \"error\": pieces[\"error\"],\n                \"date\": None}\n    if not style or style == \"default\":\n        style = \"pep440\"  # the default\n    if style == \"pep440\":\n        rendered = render_pep440(pieces)\n    elif style == \"pep440-pre\":\n        rendered = render_pep440_pre(pieces)\n    elif style == \"pep440-post\":\n        rendered = render_pep440_post(pieces)\n    elif style == \"pep440-old\":\n        rendered = render_pep440_old(pieces)\n    elif style == \"git-describe\":\n        rendered = render_git_describe(pieces)\n    elif style == \"git-describe-long\":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(\"unknown style '%%s'\" %% style)\n    return {\"version\": rendered, \"full-revisionid\": pieces[\"long\"],\n            \"dirty\": pieces[\"dirty\"], \"error\": None,\n            \"date\": pieces.get(\"date\")}\n", "docstring": "Render the given version pieces into the requested style.\n"}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def git_get_keywords(versionfile_abs):\n    \"\"\"Extract version information from the given file.\"\"\"\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don't want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        f = open(versionfile_abs, \"r\")\n        for line in f.readlines():\n            if line.strip().startswith(\"git_refnames =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"refnames\"] = mo.group(1)\n            if line.strip().startswith(\"git_full =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"full\"] = mo.group(1)\n            if line.strip().startswith(\"git_date =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"date\"] = mo.group(1)\n        f.close()\n    except EnvironmentError:\n        pass\n    return keywords\n", "docstring": "Extract version information from the given file.\n"}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def git_versions_from_keywords(keywords, tag_prefix, verbose):\n    \"\"\"Get version information from git keywords.\"\"\"\n    if not keywords:\n        raise NotThisMethod(\"no keywords at all, weird\")\n    date = keywords.get(\"date\")\n    if date is not None:\n        # git-2.2.0 added \"%cI\", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer \"%ci\" (which expands to an \"ISO-8601\n        # -like\" string, which we must then edit to make compliant), because\n        # it's been around since git-1.5.3, and it's too difficult to\n        # discover which version we're using, or to work around using an\n        # older one.\n        date = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n    refnames = keywords[\"refnames\"].strip()\n    if refnames.startswith(\"$Format\"):\n        if verbose:\n            print(\"keywords are unexpanded, not using\")\n        raise NotThisMethod(\"unexpanded keywords, not a git-archive tarball\")\n    refs = set([r.strip() for r in refnames.strip(\"()\").split(\",\")])\n    # starting in git-1.8.3, tags are listed as \"tag: foo-1.0\" instead of\n    # just \"foo-1.0\". If we see a \"tag: \" prefix, prefer those.\n    TAG = \"tag: \"\n    tags = set([r[len(TAG) :] for r in refs if r.startswith(TAG)])\n    if not tags:\n        # Either we're using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like \"release\" and\n        # \"stabilization\", as well as \"HEAD\" and \"master\".\n        tags = set([r for r in refs if re.search(r\"\\d\", r)])\n        if verbose:\n            print(\"discarding '%s', no digits\" % \",\".join(refs - tags))\n    if verbose:\n        print(\"likely tags: %s\" % \",\".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. \"2.0\" over \"2.0rc1\"\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix) :]\n            if verbose:\n                print(\"picking %s\" % r)\n            return {\n                \"version\": r,\n                \"full-revisionid\": keywords[\"full\"].strip(),\n                \"dirty\": False,\n                \"error\": None,\n                \"date\": date,\n            }\n    # no suitable tags, so version is \"0+unknown\", but full hex is still there\n    if verbose:\n        print(\"no suitable tags, using unknown + full revision id\")\n    return {\n        \"version\": \"0+unknown\",\n        \"full-revisionid\": keywords[\"full\"].strip(),\n        \"dirty\": False,\n        \"error\": \"no suitable tags\",\n        \"date\": None,\n    }\n", "docstring": "Get version information from git keywords.\n"}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def versions_from_parentdir(parentdir_prefix, root, verbose):\n    \"\"\"Try to determine the version from the parent directory name.\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    \"\"\"\n    rootdirs = []\n    for i in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {\n                \"version\": dirname[len(parentdir_prefix) :],\n                \"full-revisionid\": None,\n                \"dirty\": False,\n                \"error\": None,\n                \"date\": None,\n            }\n        else:\n            rootdirs.append(root)\n            root = os.path.dirname(root)  # up a level\n    if verbose:\n        print(\n            \"Tried directories %s but none started with prefix %s\"\n            % (str(rootdirs), parentdir_prefix)\n        )\n    raise NotThisMethod(\"rootdir doesn't start with parentdir_prefix\")\n", "docstring": "Try to determine the version from the parent directory name."}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def versions_from_file(filename):\n    \"\"\"Try to determine the version from _version.py if present.\"\"\"\n    try:\n        with open(filename) as f:\n            contents = f.read()\n    except EnvironmentError:\n        raise NotThisMethod(\"unable to read _version.py\")\n    mo = re.search(\n        r\"version_json = '''\\n(.*)'''  # END VERSION_JSON\", contents, re.M | re.S\n    )\n    if not mo:\n        mo = re.search(\n            r\"version_json = '''\\r\\n(.*)'''  # END VERSION_JSON\", contents, re.M | re.S\n        )\n    if not mo:\n        raise NotThisMethod(\"no version_json in _version.py\")\n    return json.loads(mo.group(1))\n", "docstring": "Try to determine the version from _version.py if present.\n"}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def plus_or_dot(pieces):\n    \"\"\"Return a + if we don't already have one, else return a .\"\"\"\n    if \"+\" in pieces.get(\"closest-tag\", \"\"):\n        return \".\"\n    return \"+\"\n", "docstring": "Return a + if we don't already have one, else return a .\n"}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def render_pep440_pre(pieces):\n    \"\"\"TAG[.post.devDISTANCE] -- No -dirty.\n    Exceptions:\n    1: no tags. 0.post.devDISTANCE\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"]:\n            rendered += \".post.dev%d\" % pieces[\"distance\"]\n    else:\n        # exception #1\n        rendered = \"0.post.dev%d\" % pieces[\"distance\"]\n    return rendered\n", "docstring": "TAG[.post.devDISTANCE] -- No -dirty."}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def render_pep440_old(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]] .\n    The \".dev0\" means dirty.\n    Eexceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%d\" % pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n    else:\n        # exception #1\n        rendered = \"0.post%d\" % pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n    return rendered\n", "docstring": "TAG[.postDISTANCE[.dev0]] ."}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def render_git_describe_long(pieces):\n    \"\"\"TAG-DISTANCE-gHEX[-dirty].\n    Like 'git describe --tags --dirty --always -long'.\n    The distance/hash is unconditional.\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n", "docstring": "TAG-DISTANCE-gHEX[-dirty]."}
{"repo": "plotly.py-master/packages/python/plotly/versioneer.py", "original_string": "def get_versions(verbose=False):\n    \"\"\"Get the project version from whatever source is available.\n    Returns dict with two keys: 'version' and 'full'.\n    \"\"\"\n    if \"versioneer\" in sys.modules:\n        # see the discussion in cmdclass.py:get_cmdclass()\n        del sys.modules[\"versioneer\"]\n    root = get_root()\n    cfg = get_config_from_root(root)\n    assert cfg.VCS is not None, \"please set [versioneer]VCS= in setup.cfg\"\n    handlers = HANDLERS.get(cfg.VCS)\n    assert handlers, \"unrecognized VCS '%s'\" % cfg.VCS\n    verbose = verbose or cfg.verbose\n    assert (\n        cfg.versionfile_source is not None\n    ), \"please set versioneer.versionfile_source\"\n    assert cfg.tag_prefix is not None, \"please set versioneer.tag_prefix\"\n    versionfile_abs = os.path.join(root, cfg.versionfile_source)\n    # extract version from first of: _version.py, VCS command (e.g. 'git\n    # describe'), parentdir. This is meant to work for developers using a\n    # source checkout, for users of a tarball created by 'setup.py sdist',\n    # and for users of a tarball/zipball created by 'git archive' or github's\n    # download-from-tag feature or the equivalent in other VCSes.\n    get_keywords_f = handlers.get(\"get_keywords\")\n    from_keywords_f = handlers.get(\"keywords\")\n    if get_keywords_f and from_keywords_f:\n        try:\n            keywords = get_keywords_f(versionfile_abs)\n            ver = from_keywords_f(keywords, cfg.tag_prefix, verbose)\n            if verbose:\n                print(\"got version from expanded keyword %s\" % ver)\n            return ver\n        except NotThisMethod:\n            pass\n    try:\n        ver = versions_from_file(versionfile_abs)\n        if verbose:\n            print(\"got version from file %s %s\" % (versionfile_abs, ver))\n        return ver\n    except NotThisMethod:\n        pass\n    from_vcs_f = handlers.get(\"pieces_from_vcs\")\n    if from_vcs_f:\n        try:\n            pieces = from_vcs_f(cfg.tag_prefix, root, verbose)\n            ver = render(pieces, cfg.style)\n            if verbose:\n                print(\"got version from VCS %s\" % ver)\n            return ver\n        except NotThisMethod:\n            pass\n    try:\n        if cfg.parentdir_prefix:\n            ver = versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n            if verbose:\n                print(\"got version from parentdir %s\" % ver)\n            return ver\n    except NotThisMethod:\n        pass\n    if verbose:\n        print(\"unable to compute version\")\n    return {\n        \"version\": \"0+unknown\",\n        \"full-revisionid\": None,\n        \"dirty\": None,\n        \"error\": \"unable to compute version\",\n        \"date\": None,\n    }\n", "docstring": "Get the project version from whatever source is available."}
{"repo": "plotly.py-master/packages/python/plotly/templategen/definitions.py", "original_string": "def ggplot2():\n    # Define colors\n    # -------------\n    # Based on theme_gray from\n    # https://github.com/tidyverse/ggplot2/blob/master/R/theme-defaults.r\n    # Set colorscale\n    # Colors picked using colorpicker from\n    # https://ggplot2.tidyverse.org/reference/scale_colour_continuous.html\n    colorscale = [[0, \"rgb(20,44,66)\"], [1, \"rgb(90,179,244)\"]]\n    # Hue cycle for 5 categories\n    colorway = [\"#F8766D\", \"#A3A500\", \"#00BF7D\", \"#00B0F6\", \"#E76BF3\"]\n    # Set colorbar_common\n    # Note the light inward ticks in\n    # https://ggplot2.tidyverse.org/reference/scale_colour_continuous.html\n    colorbar_common = dict(\n        outlinewidth=0, tickcolor=colors[\"gray93\"], ticks=\"inside\", ticklen=6\n    )\n    # Common axis common properties\n    axis_common = dict(\n        showgrid=True,\n        gridcolor=\"white\",\n        linecolor=\"white\",\n        tickcolor=colors[\"gray20\"],\n        ticks=\"outside\",\n        title=dict(standoff=15),\n    )\n    # semi-transparent black and no outline\n    shape_defaults = dict(fillcolor=\"black\", line={\"width\": 0}, opacity=0.3)\n    # Remove arrow head and make line thinner\n    annotation_defaults = {\"arrowhead\": 0, \"arrowwidth\": 1}\n    template = initialize_template(\n        paper_clr=\"white\",\n        font_clr=colors[\"gray20\"],\n        panel_background_clr=colors[\"gray93\"],\n        panel_grid_clr=\"white\",\n        axis_ticks_clr=colors[\"gray20\"],\n        zerolinecolor_clr=\"white\",\n        table_cell_clr=colors[\"gray93\"],\n        table_header_clr=colors[\"gray85\"],\n        table_line_clr=\"white\",\n        colorway=colorway,\n        colorbar_common=colorbar_common,\n        colorscale=colorscale,\n        axis_common=axis_common,\n        annotation_defaults=annotation_defaults,\n        shape_defaults=shape_defaults,\n    )\n    # Increase grid width for 3d plots\n    template.layout.scene.xaxis.gridwidth = 2\n    template.layout.scene.yaxis.gridwidth = 2\n    template.layout.scene.zaxis.gridwidth = 2\n    # Automargin for pie chart\n    template.data.pie = [{\"automargin\": True}]\n    return template\n", "docstring": "Define colors"}
{"repo": "plotly.py-master/packages/python/plotly/templategen/definitions.py", "original_string": "def simple_white():\n    # Set colorbar_common\n    colorbar_common = dict(outlinewidth=1, tickcolor=colors[\"gray14\"], ticks=\"outside\")\n    # Common axis common properties\n    axis_common = dict(\n        showgrid=False,\n        gridcolor=colors[\"gray91\"],\n        linecolor=colors[\"gray14\"],\n        ticks=\"outside\",\n        showline=True,\n        title=dict(standoff=15),\n    )\n    # semi-transparent black and no outline\n    shape_defaults = dict(fillcolor=\"black\", line={\"width\": 0}, opacity=0.3)\n    # Remove arrow head and make line thinner\n    annotation_defaults = {\"arrowhead\": 0, \"arrowwidth\": 1}\n    template = initialize_template(\n        paper_clr=\"white\",\n        font_clr=colors[\"gray14\"],\n        panel_background_clr=\"white\",\n        panel_grid_clr=\"white\",\n        axis_ticks_clr=colors[\"gray14\"],\n        zerolinecolor_clr=colors[\"gray14\"],\n        table_cell_clr=colors[\"gray93\"],\n        table_header_clr=colors[\"gray85\"],\n        table_line_clr=\"white\",\n        colorway=px.colors.qualitative.D3,\n        colorbar_common=colorbar_common,\n        colorscale=px.colors.sequential.Viridis,\n        colorscale_diverging=px.colors.diverging.RdBu,\n        axis_common=axis_common,\n        annotation_defaults=annotation_defaults,\n        shape_defaults=shape_defaults,\n    )\n    # Left align title\n    template.layout.title.x = 0.05\n    # Increase grid width for 3d plots\n    opts = dict(gridwidth=2, gridcolor=colors[\"gray91\"], zeroline=False)\n    template.layout.scene.xaxis.update(opts)\n    template.layout.scene.yaxis.update(opts)\n    template.layout.scene.zaxis.update(opts)\n    # Darken ternary\n    opts = dict(linecolor=colors[\"gray14\"], gridcolor=colors[\"gray91\"])\n    template.layout.ternary.aaxis.update(opts)\n    template.layout.ternary.baxis.update(opts)\n    template.layout.ternary.caxis.update(opts)\n    # Remove lines through the origin\n    template.layout.xaxis.update(zeroline=False)\n    template.layout.yaxis.update(zeroline=False)\n    # Separate histogram bins wit ha white line\n    opts = {\"marker\": {\"line\": {\"width\": 0.6, \"color\": \"white\"}}}\n    template.data.histogram = [opts]\n    # Mapbox light style\n    template.layout.mapbox.style = \"light\"\n    # Automargin for pie chart\n    template.data.pie = [{\"automargin\": True}]\n    return template\n", "docstring": "Set colorbar_common"}
{"repo": "plotly.py-master/packages/python/plotly/templategen/definitions.py", "original_string": "def plotly():\n    # Define colors\n    # -------------\n    colorscale = plasma\n    # Set colorbar_common\n    colorbar_common = dict(outlinewidth=0, ticks=\"\")\n    # Common axis common properties\n    axis_common = dict(\n        gridcolor=\"white\", linecolor=\"white\", ticks=\"\", title=dict(standoff=15),\n    )\n    # Near black line color, no fill\n    annotation_clr = plotly_clrs[\"Rhino Core\"]\n    shape_defaults = dict(line_color=annotation_clr)\n    # Remove arrow head and make line thinner\n    annotation_defaults = {\n        \"arrowcolor\": annotation_clr,\n        \"arrowhead\": 0,\n        \"arrowwidth\": 1,\n    }\n    template = initialize_template(\n        paper_clr=\"white\",\n        font_clr=plotly_clrs[\"Rhino Core\"],\n        panel_background_clr=plotly_clrs[\"Rhino Light 1.5\"],\n        panel_grid_clr=\"white\",\n        axis_ticks_clr=plotly_clrs[\"Rhino Core\"],\n        zerolinecolor_clr=\"white\",\n        table_cell_clr=plotly_clrs[\"Rhino Light 2\"],\n        table_header_clr=plotly_clrs[\"Rhino Medium 2\"],\n        table_line_clr=\"white\",\n        colorway=plotly_colorway,\n        colorbar_common=colorbar_common,\n        colorscale=colorscale,\n        colorscale_diverging=plotly_diverging,\n        axis_common=axis_common,\n        annotation_defaults=annotation_defaults,\n        shape_defaults=shape_defaults,\n    )\n    # Left align title\n    template.layout.title.x = 0.05\n    # Increase grid width for 3d plots\n    template.layout.scene.xaxis.gridwidth = 2\n    template.layout.scene.yaxis.gridwidth = 2\n    template.layout.scene.zaxis.gridwidth = 2\n    # Increase width of cartesian zero lines\n    template.layout.xaxis.zerolinewidth = 2\n    template.layout.yaxis.zerolinewidth = 2\n    # Mapbox light style\n    template.layout.mapbox.style = \"light\"\n    # Automargin for pie chart\n    template.data.pie = [{\"automargin\": True}]\n    # Set table header font color to white\n    return template\n", "docstring": "Define colors"}
{"repo": "plotly.py-master/packages/python/plotly/templategen/definitions.py", "original_string": "def plotly_white():\n    # Define colors\n    # -------------\n    colorscale = plasma\n    # Set colorbar_common\n    colorbar_common = dict(outlinewidth=0, ticks=\"\")\n    # Common axis common properties\n    axis_common = dict(\n        gridcolor=plotly_clrs[\"Rhino Light 2\"],\n        linecolor=plotly_clrs[\"Rhino Light 2\"],\n        ticks=\"\",\n        title=dict(standoff=15),\n    )\n    # Near black line color, no fill\n    annotation_clr = plotly_clrs[\"Rhino Core\"]\n    shape_defaults = dict(line_color=annotation_clr)\n    # Remove arrow head and make line thinner\n    annotation_defaults = {\n        \"arrowcolor\": annotation_clr,\n        \"arrowhead\": 0,\n        \"arrowwidth\": 1,\n    }\n    template = initialize_template(\n        paper_clr=\"white\",\n        font_clr=plotly_clrs[\"Rhino Core\"],\n        panel_background_clr=\"white\",\n        panel_grid_clr=plotly_clrs[\"Rhino Medium 2\"],\n        axis_ticks_clr=plotly_clrs[\"Rhino Core\"],\n        zerolinecolor_clr=plotly_clrs[\"Rhino Light 2\"],\n        table_cell_clr=plotly_clrs[\"Rhino Light 2\"],\n        table_header_clr=plotly_clrs[\"Rhino Medium 2\"],\n        table_line_clr=\"white\",\n        colorway=plotly_colorway,\n        colorbar_common=colorbar_common,\n        colorscale=colorscale,\n        colorscale_diverging=plotly_diverging,\n        axis_common=axis_common,\n        annotation_defaults=annotation_defaults,\n        shape_defaults=shape_defaults,\n    )\n    # Left align title\n    template.layout.title.x = 0.05\n    # Increase grid width for 3d plots\n    opts = dict(gridwidth=2, gridcolor=plotly_clrs[\"Rhino Light 1\"])\n    template.layout.scene.xaxis.update(opts)\n    template.layout.scene.yaxis.update(opts)\n    template.layout.scene.zaxis.update(opts)\n    # Darken ternary\n    opts = dict(\n        linecolor=plotly_clrs[\"Rhino Medium 1\"], gridcolor=plotly_clrs[\"Rhino Light 1\"]\n    )\n    template.layout.ternary.aaxis.update(opts)\n    template.layout.ternary.baxis.update(opts)\n    template.layout.ternary.caxis.update(opts)\n    # Increase width of cartesian zero lines\n    template.layout.xaxis.zerolinewidth = 2\n    template.layout.yaxis.zerolinewidth = 2\n    # Mapbox light style\n    template.layout.mapbox.style = \"light\"\n    # Automargin for pie chart\n    template.data.pie = [{\"automargin\": True}]\n    # Set table header font color to white\n    return template\n", "docstring": "Define colors"}
{"repo": "plotly.py-master/packages/python/plotly/templategen/definitions.py", "original_string": "def plotly_dark():\n    # Define colors\n    # -------------\n    colorscale = plasma\n    # Set colorbar_common\n    colorbar_common = dict(outlinewidth=0, ticks=\"\")\n    # Common axis common properties\n    grid_color = plotly_clrs[\"Rhino Dark\"]\n    axis_common = dict(\n        gridcolor=grid_color, linecolor=grid_color, ticks=\"\", title=dict(standoff=15),\n    )\n    # Near white line color, no fill\n    annotation_clr = plotly_clrs[\"Rhino Light 4\"]\n    shape_defaults = dict(line_color=annotation_clr)\n    # Remove arrow head and make line thinner\n    annotation_defaults = {\n        \"arrowcolor\": annotation_clr,\n        \"arrowhead\": 0,\n        \"arrowwidth\": 1,\n    }\n    template = initialize_template(\n        paper_clr=jupyterlab_output_clr,\n        font_clr=plotly_clrs[\"Rhino Light 4\"],\n        panel_background_clr=jupyterlab_output_clr,\n        panel_grid_clr=grid_color,\n        axis_ticks_clr=plotly_clrs[\"Rhino Medium 1\"],\n        zerolinecolor_clr=plotly_clrs[\"Rhino Medium 2\"],\n        table_cell_clr=plotly_clrs[\"Rhino Dark\"],\n        table_header_clr=plotly_clrs[\"Rhino Core\"],\n        table_line_clr=jupyterlab_output_clr,\n        colorway=plotly_colorway,\n        colorbar_common=colorbar_common,\n        colorscale=colorscale,\n        colorscale_diverging=plotly_diverging,\n        axis_common=axis_common,\n        annotation_defaults=annotation_defaults,\n        shape_defaults=shape_defaults,\n    )\n    # Left align title\n    template.layout.title.x = 0.05\n    # Increase grid width for 3d plots\n    template.layout.scene.xaxis.gridwidth = 2\n    template.layout.scene.yaxis.gridwidth = 2\n    template.layout.scene.zaxis.gridwidth = 2\n    # Button styling\n    template.layout.updatemenudefaults.bgcolor = plotly_clrs[\"Rhino Dark\"]\n    template.layout.updatemenudefaults.borderwidth = 0\n    # Slider styling\n    template.layout.sliderdefaults.bgcolor = \"#C8D4E3\"\n    template.layout.sliderdefaults.borderwidth = 1\n    template.layout.sliderdefaults.bordercolor = \"rgb(17,17,17)\"\n    template.layout.sliderdefaults.tickwidth = 0\n    # Darken cartesian grid lines a little more\n    template.layout.xaxis.gridcolor = plotly_clrs[\"Rhino Darker\"]\n    template.layout.yaxis.gridcolor = plotly_clrs[\"Rhino Darker\"]\n    # Increase width of cartesian zero lines\n    template.layout.xaxis.zerolinecolor = plotly_clrs[\"Rhino Darker\"]\n    template.layout.yaxis.zerolinecolor = plotly_clrs[\"Rhino Darker\"]\n    template.layout.xaxis.zerolinewidth = 2\n    template.layout.yaxis.zerolinewidth = 2\n    # Mapbox light style\n    template.layout.mapbox.style = \"dark\"\n    # Set marker outline color\n    opts = {\"marker\": {\"line\": {\"color\": plotly_clrs[\"Rhino Darker\"]}}}\n    template.data.scatter = [opts]\n    template.data.scattergl = [opts]\n    # Automargin for pie chart\n    template.data.pie = [{\"automargin\": True}]\n    # Automargin for pie chart\n    template.data.pie = [{\"automargin\": True}]\n    # Set table header font color to white\n    return template\n", "docstring": "Define colors"}
{"repo": "plotly.py-master/packages/python/plotly/codegen/utils.py", "original_string": "    def __repr__(self):\n        return self.path_str\n", "docstring": "return self.path_str"}
{"repo": "plotly.py-master/packages/python/plotly/codegen/utils.py", "original_string": "    def __init__(self, plotly_schema, node_path=(), parent=None):\n        super().__init__(plotly_schema, node_path, parent)\n", "docstring": "super().__init__(plotly_schema, node_path, parent)"}
{"repo": "plotly.py-master/packages/python/plotly/codegen/utils.py", "original_string": "    def __init__(self, plotly_schema, node_path=(), parent=None):\n        # Get main layout properties\n        layout = plotly_schema[\"layout\"][\"layoutAttributes\"]\n        # Get list of additional layout properties for each trace\n        trace_layouts = [\n            plotly_schema[\"traces\"][trace].get(\"layoutAttributes\", {})\n            for trace in plotly_schema[\"traces\"]\n            if trace != \"barpolar\"\n        ]\n        extra_polar_nodes = plotly_schema[\"traces\"][\"barpolar\"].get(\n            \"layoutAttributes\", {}\n        )\n        layout[\"polar\"].update(extra_polar_nodes)\n        # Chain together into layout_data\n        self.layout_data = ChainMap(layout, *trace_layouts)\n        # Call superclass constructor\n        super().__init__(plotly_schema, node_path, parent)\n", "docstring": "Get main layout properties"}
{"repo": "plotly.py-master/packages/python/plotly/codegen/utils.py", "original_string": "    def node_data(self):\n        return {}\n", "docstring": "return {}"}
{"repo": "plotly.py-master/packages/python/plotly/codegen/utils.py", "original_string": "    def node_data(self):\n        return {}\n", "docstring": "return {}"}
{"repo": "plotly.py-master/packages/python/plotly/codegen/validators.py", "original_string": "    def __init__(self, plotly_name={params['plotly_name']},\n                       parent_name={params['parent_name']},\n                       **kwargs):\"\"\"\n", "docstring": "parent_name={params['parent_name']},"}
{"repo": "plotly.py-master/packages/python/plotly/codegen/validators.py", "original_string": "    def __init__(self, plotly_name={params['plotly_name']},\n                       parent_name={params['parent_name']},\n                       **kwargs):\n        super(DataValidator, self).__init__(class_strs_map={params['class_strs_map']},\n                         plotly_name=plotly_name,\n                         parent_name=parent_name,\n                         **kwargs)\"\"\"\n", "docstring": "parent_name={params['parent_name']},"}
{"repo": "plotly.py-master/packages/python/plotly/codegen/compatibility.py", "original_string": "    def __init__(self, *args, **kwargs):\n        \\\"\\\"\\\"\n        {depr_msg}\n        \\\"\\\"\\\"\n        warnings.warn(\\\"\\\"\\\"{depr_msg}\\\"\\\"\\\", DeprecationWarning)\n        super({class_name}, self).__init__(*args, **kwargs)\\n\\n\\n\"\"\"\n        )\n", "docstring": "\\\"\\\"\\\""}
{"repo": "plotly.py-master/packages/python/plotly/codegen/__init__.py", "original_string": "    def __getattr__(import_name):\n        if import_name == \"FigureWidget\":\n            try:\n                import ipywidgets\n                from distutils.version import LooseVersion\n                if LooseVersion(ipywidgets.__version__) >= LooseVersion(\"7.0.0\"):\n                    from ..graph_objs._figurewidget import FigureWidget\n                    return FigureWidget\n                else:\n                    raise ImportError()\n            except Exception:\n                from ..missing_ipywidgets import FigureWidget\n                return FigureWidget\n        return orig_getattr(import_name)\n", "docstring": "if import_name == \"FigureWidget\":"}
{"repo": "plotly.py-master/packages/python/plotly/codegen/datatypes.py", "original_string": "    def _subplotid_validators(self):\n        \\\"\\\"\\\"\n        dict of validator classes for each subplot type\n        Returns\n        -------\n        dict\n        \\\"\\\"\\\"\n        from plotly.validators.layout import ({validator_csv})\n        return {subplot_dict_str}\n        \n", "docstring": "\\\"\\\"\\\""}
{"repo": "plotly.py-master/packages/python/plotly/codegen/datatypes.py", "original_string": "def add_docstring(\n    buffer, node, header, prepend_extras=(), append_extras=(), return_type=None\n", "docstring": "buffer, node, header, prepend_extras=(), append_extras=(), return_type=None"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/shapeannotation.py", "original_string": "def annotation_params_for_line(shape_type, shape_args, position):\n    # all x0, x1, y0, y1 are used to place the annotation, that way it could\n    # work with a slanted line\n    # even with a slanted line, there are the horizontal and vertical\n    # conventions of placing a shape\n    x0 = shape_args[\"x0\"]\n    x1 = shape_args[\"x1\"]\n    y0 = shape_args[\"y0\"]\n    y1 = shape_args[\"y1\"]\n    X = [x0, x1]\n    Y = [y0, y1]\n    R = \"right\"\n    T = \"top\"\n    L = \"left\"\n    C = \"center\"\n    B = \"bottom\"\n    M = \"middle\"\n    aY = max(Y)\n    iY = min(Y)\n    eY = _mean(Y)\n    aaY = _argmax(Y)\n    aiY = _argmin(Y)\n    aX = max(X)\n    iX = min(X)\n    eX = _mean(X)\n    aaX = _argmax(X)\n    aiX = _argmin(X)\n    position, pos_str = _prepare_position(position)\n    if shape_type == \"vline\":\n        if position == set([\"top\", \"left\"]):\n            return _df_anno(R, T, X[aaY], aY)\n        if position == set([\"top\", \"right\"]):\n            return _df_anno(L, T, X[aaY], aY)\n        if position == set([\"top\"]):\n            return _df_anno(C, B, X[aaY], aY)\n        if position == set([\"bottom\", \"left\"]):\n            return _df_anno(R, B, X[aiY], iY)\n        if position == set([\"bottom\", \"right\"]):\n            return _df_anno(L, B, X[aiY], iY)\n        if position == set([\"bottom\"]):\n            return _df_anno(C, T, X[aiY], iY)\n        if position == set([\"left\"]):\n            return _df_anno(R, M, eX, eY)\n        if position == set([\"right\"]):\n            return _df_anno(L, M, eX, eY)\n    elif shape_type == \"hline\":\n        if position == set([\"top\", \"left\"]):\n            return _df_anno(L, B, iX, Y[aiX])\n        if position == set([\"top\", \"right\"]):\n            return _df_anno(R, B, aX, Y[aaX])\n        if position == set([\"top\"]):\n            return _df_anno(C, B, eX, eY)\n        if position == set([\"bottom\", \"left\"]):\n            return _df_anno(L, T, iX, Y[aiX])\n        if position == set([\"bottom\", \"right\"]):\n            return _df_anno(R, T, aX, Y[aaX])\n        if position == set([\"bottom\"]):\n            return _df_anno(C, T, eX, eY)\n        if position == set([\"left\"]):\n            return _df_anno(R, M, iX, Y[aiX])\n        if position == set([\"right\"]):\n            return _df_anno(L, M, aX, Y[aaX])\n    raise ValueError('Invalid annotation position \"%s\"' % (pos_str,))\n", "docstring": "all x0, x1, y0, y1 are used to place the annotation, that way it could"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/_version.py", "original_string": "def get_keywords():\n    \"\"\"Get the keywords needed to look up the version information.\"\"\"\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = \" (HEAD -> master)\"\n    git_full = \"c67f80067210d66e61c2f8f5e3b746a9a6c739a0\"\n    git_date = \"2021-08-03 16:46:28 -0400\"\n    keywords = {\"refnames\": git_refnames, \"full\": git_full, \"date\": git_date}\n    return keywords\n", "docstring": "Get the keywords needed to look up the version information.\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/_version.py", "original_string": "def get_config():\n    \"\"\"Create, populate and return the VersioneerConfig() object.\"\"\"\n    # these strings are filled in when 'setup.py versioneer' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = \"git\"\n    cfg.style = \"pep440\"\n    cfg.tag_prefix = \"v\"\n    cfg.parentdir_prefix = \"plotly-\"\n    cfg.versionfile_source = \"plotly/_version.py\"\n    cfg.verbose = False\n    return cfg\n", "docstring": "Create, populate and return the VersioneerConfig() object.\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/_version.py", "original_string": "def register_vcs_handler(vcs, method):  # decorator\n    \"\"\"Decorator to mark a method as the handler for a particular VCS.\"\"\"\n    def decorate(f):\n        \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n    return decorate\n", "docstring": "Decorator to mark a method as the handler for a particular VCS.\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/_version.py", "original_string": "def versions_from_parentdir(parentdir_prefix, root, verbose):\n    \"\"\"Try to determine the version from the parent directory name.\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    \"\"\"\n    rootdirs = []\n    for i in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {\n                \"version\": dirname[len(parentdir_prefix) :],\n                \"full-revisionid\": None,\n                \"dirty\": False,\n                \"error\": None,\n                \"date\": None,\n            }\n        else:\n            rootdirs.append(root)\n            root = os.path.dirname(root)  # up a level\n    if verbose:\n        print(\n            \"Tried directories %s but none started with prefix %s\"\n            % (str(rootdirs), parentdir_prefix)\n        )\n    raise NotThisMethod(\"rootdir doesn't start with parentdir_prefix\")\n", "docstring": "Try to determine the version from the parent directory name."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/_version.py", "original_string": "def git_get_keywords(versionfile_abs):\n    \"\"\"Extract version information from the given file.\"\"\"\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don't want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        f = open(versionfile_abs, \"r\")\n        for line in f.readlines():\n            if line.strip().startswith(\"git_refnames =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"refnames\"] = mo.group(1)\n            if line.strip().startswith(\"git_full =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"full\"] = mo.group(1)\n            if line.strip().startswith(\"git_date =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"date\"] = mo.group(1)\n        f.close()\n    except EnvironmentError:\n        pass\n    return keywords\n", "docstring": "Extract version information from the given file.\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/_version.py", "original_string": "def git_versions_from_keywords(keywords, tag_prefix, verbose):\n    \"\"\"Get version information from git keywords.\"\"\"\n    if not keywords:\n        raise NotThisMethod(\"no keywords at all, weird\")\n    date = keywords.get(\"date\")\n    if date is not None:\n        # git-2.2.0 added \"%cI\", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer \"%ci\" (which expands to an \"ISO-8601\n        # -like\" string, which we must then edit to make compliant), because\n        # it's been around since git-1.5.3, and it's too difficult to\n        # discover which version we're using, or to work around using an\n        # older one.\n        date = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n    refnames = keywords[\"refnames\"].strip()\n    if refnames.startswith(\"$Format\"):\n        if verbose:\n            print(\"keywords are unexpanded, not using\")\n        raise NotThisMethod(\"unexpanded keywords, not a git-archive tarball\")\n    refs = set([r.strip() for r in refnames.strip(\"()\").split(\",\")])\n    # starting in git-1.8.3, tags are listed as \"tag: foo-1.0\" instead of\n    # just \"foo-1.0\". If we see a \"tag: \" prefix, prefer those.\n    TAG = \"tag: \"\n    tags = set([r[len(TAG) :] for r in refs if r.startswith(TAG)])\n    if not tags:\n        # Either we're using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like \"release\" and\n        # \"stabilization\", as well as \"HEAD\" and \"master\".\n        tags = set([r for r in refs if re.search(r\"\\d\", r)])\n        if verbose:\n            print(\"discarding '%s', no digits\" % \",\".join(refs - tags))\n    if verbose:\n        print(\"likely tags: %s\" % \",\".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. \"2.0\" over \"2.0rc1\"\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix) :]\n            if verbose:\n                print(\"picking %s\" % r)\n            return {\n                \"version\": r,\n                \"full-revisionid\": keywords[\"full\"].strip(),\n                \"dirty\": False,\n                \"error\": None,\n                \"date\": date,\n            }\n    # no suitable tags, so version is \"0+unknown\", but full hex is still there\n    if verbose:\n        print(\"no suitable tags, using unknown + full revision id\")\n    return {\n        \"version\": \"0+unknown\",\n        \"full-revisionid\": keywords[\"full\"].strip(),\n        \"dirty\": False,\n        \"error\": \"no suitable tags\",\n        \"date\": None,\n    }\n", "docstring": "Get version information from git keywords.\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/_version.py", "original_string": "def render_pep440(pieces):\n    \"\"\"Build up version string, with post-release \"local version identifier\".\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += plus_or_dot(pieces)\n            rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0+untagged.%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n", "docstring": "Build up version string, with post-release \"local version identifier\"."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/_version.py", "original_string": "def render_pep440_post(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]+gHEX] .\n    The \".dev0\" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear \"older\" than the corresponding clean one),\n    but you shouldn't be releasing software with -dirty anyways.\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%d\" % pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"g%s\" % pieces[\"short\"]\n    else:\n        # exception #1\n        rendered = \"0.post%d\" % pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n        rendered += \"+g%s\" % pieces[\"short\"]\n    return rendered\n", "docstring": "TAG[.postDISTANCE[.dev0]+gHEX] ."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/_version.py", "original_string": "def render_git_describe(pieces):\n    \"\"\"TAG[-DISTANCE-gHEX][-dirty].\n    Like 'git describe --tags --dirty --always'.\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"]:\n            rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n", "docstring": "TAG[-DISTANCE-gHEX][-dirty]."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/_version.py", "original_string": "def render(pieces, style):\n    \"\"\"Render the given version pieces into the requested style.\"\"\"\n    if pieces[\"error\"]:\n        return {\n            \"version\": \"unknown\",\n            \"full-revisionid\": pieces.get(\"long\"),\n            \"dirty\": None,\n            \"error\": pieces[\"error\"],\n            \"date\": None,\n        }\n    if not style or style == \"default\":\n        style = \"pep440\"  # the default\n    if style == \"pep440\":\n        rendered = render_pep440(pieces)\n    elif style == \"pep440-pre\":\n        rendered = render_pep440_pre(pieces)\n    elif style == \"pep440-post\":\n        rendered = render_pep440_post(pieces)\n    elif style == \"pep440-old\":\n        rendered = render_pep440_old(pieces)\n    elif style == \"git-describe\":\n        rendered = render_git_describe(pieces)\n    elif style == \"git-describe-long\":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(\"unknown style '%s'\" % style)\n    return {\n        \"version\": rendered,\n        \"full-revisionid\": pieces[\"long\"],\n        \"dirty\": pieces[\"dirty\"],\n        \"error\": None,\n        \"date\": pieces.get(\"date\"),\n    }\n", "docstring": "Render the given version pieces into the requested style.\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/callbacks.py", "original_string": "    def __init__(self, point_inds=[], xs=[], ys=[], trace_name=None, trace_index=None):\n        self._point_inds = point_inds\n        self._xs = xs\n        self._ys = ys\n        self._trace_name = trace_name\n        self._trace_index = trace_index\n", "docstring": "self._point_inds = point_inds"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/callbacks.py", "original_string": "    def __init__(self, xrange=None, yrange=None, **_):\n        self._type = \"box\"\n        self._xrange = xrange\n        self._yrange = yrange\n", "docstring": "self._type = \"box\""}
{"repo": "plotly.py-master/packages/python/plotly/plotly/callbacks.py", "original_string": "    def __init__(self, xs=None, ys=None, **_):\n        self._type = \"lasso\"\n        self._xs = xs\n        self._ys = ys\n", "docstring": "self._type = \"lasso\""}
{"repo": "plotly.py-master/packages/python/plotly/plotly/utils.py", "original_string": "    def __init__(self, v, threshold, indent):\n        self.v = v\n        self.indent = indent\n        self.threshold = threshold\n", "docstring": "self.v = v"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "        def _make_hyphen_key(key):\n            if \"_\" in key[1:]:\n                # For valid properties that contain underscores (error_x)\n                # replace the underscores with hyphens to protect them\n                # from being split up\n                for under_prop, hyphen_prop in underscore_props.items():\n                    key = key.replace(under_prop, hyphen_prop)\n            return key\n", "docstring": "For valid properties that contain underscores (error_x)"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "def _combine_dicts(dicts):\n    all_args = dict()\n    for d in dicts:\n        for k in d:\n            all_args[k] = d[k]\n    return all_args\n", "docstring": "all_args = dict()"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "def _is_select_subplot_coordinates_arg(*args):\n    \"\"\" Returns true if any args are lists or the string 'all' \"\"\"\n    return any((a == \"all\") or isinstance(a, list) for a in args)\n", "docstring": "Returns true if any args are lists or the string 'all' \n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "def _generator(i):\n    \"\"\" \"cast\" an iterator to a generator \"\"\"\n    for x in i:\n        yield x\n", "docstring": "\"cast\" an iterator to a generator \n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "    def __iter__(self):\n        return iter((\"data\", \"layout\", \"frames\"))\n", "docstring": "return iter((\"data\", \"layout\", \"frames\"))"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "    def _perform_select_traces(self, filter_by_subplot, grid_subplot_refs, selector):\n        from plotly.subplots import _get_subplot_ref_for_trace\n        # functions for filtering\n        def _filter_by_subplot_ref(trace):\n            trace_subplot_ref = _get_subplot_ref_for_trace(trace)\n            return trace_subplot_ref in grid_subplot_refs\n        funcs = []\n        if filter_by_subplot:\n            funcs.append(_filter_by_subplot_ref)\n        return _generator(self._filter_by_selector(self.data, funcs, selector))\n", "docstring": "functions for filtering"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "    def _select_annotations_like(\n        self, prop, selector=None, row=None, col=None, secondary_y=None\n", "docstring": "self, prop, selector=None, row=None, col=None, secondary_y=None"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "        def _filter_row(obj):\n            \"\"\" Filter objects in rows by column \"\"\"\n            return (col is None) or (xref_to_col.get(obj.xref, None) == col)\n", "docstring": "Filter objects in rows by column \n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "        def _filter_sec_y(obj):\n            \"\"\" Filter objects on secondary y axes \"\"\"\n            return (secondary_y is None) or (\n                yref_to_secondary_y.get(obj.yref, None) == secondary_y\n            )\n", "docstring": "Filter objects on secondary y axes \n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "    def _raise_invalid_rows_cols(name, n, invalid):\n        rows_err_msg = \"\"\"\n        If specified, the {name} parameter must be a list or tuple of integers\n        of length {n} (The number of traces being added)\n        Received: {invalid}\n        \"\"\".format(\n            name=name, n=n, invalid=invalid\n        )\n        raise ValueError(rows_err_msg)\n", "docstring": "rows_err_msg = \n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "    def _set_trace_grid_position(self, trace, row, col, secondary_y=False):\n        from plotly.subplots import _set_trace_grid_reference\n        grid_ref = self._validate_get_grid_ref()\n        return _set_trace_grid_reference(\n            trace, self.layout, grid_ref, row, col, secondary_y\n        )\n", "docstring": "from plotly.subplots import _set_trace_grid_reference"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "    def _initialize_layout_template(self):\n        import plotly.io as pio\n        if self._layout_obj._props.get(\"template\", None) is None:\n            if pio.templates.default is not None:\n                # Assume default template is already validated\n                if self._allow_disable_validation:\n                    self._layout_obj._validate = False\n                try:\n                    if isinstance(pio.templates.default, BasePlotlyType):\n                        # Template object. Don't want to actually import `Template`\n                        # here for performance so we check against `BasePlotlyType`\n                        template_object = pio.templates.default\n                    else:\n                        # Name of registered template object\n                        template_object = pio.templates[pio.templates.default]\n                    self._layout_obj.template = template_object\n                finally:\n                    self._layout_obj._validate = self._validate\n", "docstring": "import plotly.io as pio"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "    def layout(self, new_layout):\n        # Validate new layout\n        # -------------------\n        new_layout = self._layout_validator.validate_coerce(new_layout)\n        new_layout_data = deepcopy(new_layout._props)\n        # Unparent current layout\n        # -----------------------\n        if self._layout_obj:\n            old_layout_data = deepcopy(self._layout_obj._props)\n            self._layout_obj._orphan_props.update(old_layout_data)\n            self._layout_obj._parent = None\n        # Parent new layout\n        # -----------------\n        self._layout = new_layout_data\n        new_layout._parent = self\n        new_layout._orphan_props.clear()\n        self._layout_obj = new_layout\n        # Initialize template object\n        # --------------------------\n        self._initialize_layout_template()\n        # Notify JS side\n        self._send_relayout_msg(new_layout_data)\n", "docstring": "Validate new layout"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "    def frames(self, new_frames):\n        # Note: Frames are not supported by the FigureWidget subclass so we\n        # only validate coerce the frames. We don't emit any events on frame\n        # changes, and we don't reparent the frames.\n        # Validate frames\n        self._frame_objs = self._frames_validator.validate_coerce(new_frames)\n", "docstring": "Note: Frames are not supported by the FigureWidget subclass so we"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "    def plotly_update(\n        self, restyle_data=None, relayout_data=None, trace_indexes=None, **kwargs\n", "docstring": "self, restyle_data=None, relayout_data=None, trace_indexes=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "    def _has_subplots(self):\n        \"\"\" Returns True if figure contains subplots, otherwise it contains a\n        single plot and so this returns False. \"\"\"\n        return self._grid_ref is not None\n", "docstring": "Returns True if figure contains subplots, otherwise it contains a"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "    def _get_validator(self, prop):\n        from .validator_cache import ValidatorCache\n        return ValidatorCache.get_validator(self._path_str, prop)\n", "docstring": "from .validator_cache import ValidatorCache"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "    def __init__(self, plotly_name, **kwargs):\n        super(BaseTraceHierarchyType, self).__init__(plotly_name, **kwargs)\n", "docstring": "super(BaseTraceHierarchyType, self).__init__(plotly_name, **kwargs)"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "    def __init__(self, plotly_name, **kwargs):\n        super(BaseFrameHierarchyType, self).__init__(plotly_name, **kwargs)\n", "docstring": "super(BaseFrameHierarchyType, self).__init__(plotly_name, **kwargs)"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basedatatypes.py", "original_string": "    def _restyle_child(self, child, key_path_str, val):\n        # Note: Frames are not supported by FigureWidget, and updates are not\n        # propagated to parents\n        pass\n", "docstring": "Note: Frames are not supported by FigureWidget, and updates are not"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basewidget.py", "original_string": "    def _send_update_msg(\n        self, restyle_data, relayout_data, trace_indexes=None, source_view_id=None\n", "docstring": "self, restyle_data, relayout_data, trace_indexes=None, source_view_id=None"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basewidget.py", "original_string": "    def frames(self):\n        # Note: This property getter is identical to that of the superclass,\n        # but it must be included here because we're overriding the setter\n        # below.\n        return self._frame_objs\n", "docstring": "Note: This property getter is identical to that of the superclass,"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/basewidget.py", "original_string": "    def frames(self, new_frames):\n        if new_frames:\n            BaseFigureWidget._display_frames_error()\n", "docstring": "if new_frames:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tools.py", "original_string": "def mpl_to_plotly(fig, resize=False, strip_style=False, verbose=False):\n    \"\"\"Convert a matplotlib figure to plotly dictionary and send.\n    All available information about matplotlib visualizations are stored\n    within a matplotlib.figure.Figure object. You can create a plot in python\n    using matplotlib, store the figure object, and then pass this object to\n    the fig_to_plotly function. In the background, mplexporter is used to\n    crawl through the mpl figure object for appropriate information. This\n    information is then systematically sent to the PlotlyRenderer which\n    creates the JSON structure used to make plotly visualizations. Finally,\n    these dictionaries are sent to plotly and your browser should open up a\n    new tab for viewing! Optionally, if you're working in IPython, you can\n    set notebook=True and the PlotlyRenderer will call plotly.iplot instead\n    of plotly.plot to have the graph appear directly in the IPython notebook.\n    Note, this function gives the user access to a simple, one-line way to\n    render an mpl figure in plotly. If you need to trouble shoot, you can do\n    this step manually by NOT running this fuction and entereing the following:\n    ===========================================================================\n    from plotly.matplotlylib import mplexporter, PlotlyRenderer\n    # create an mpl figure and store it under a varialble 'fig'\n    renderer = PlotlyRenderer()\n    exporter = mplexporter.Exporter(renderer)\n    exporter.run(fig)\n    ===========================================================================\n    You can then inspect the JSON structures by accessing these:\n    renderer.layout -- a plotly layout dictionary\n    renderer.data -- a list of plotly data dictionaries\n    \"\"\"\n    matplotlylib = optional_imports.get_module(\"plotly.matplotlylib\")\n    if matplotlylib:\n        renderer = matplotlylib.PlotlyRenderer()\n        matplotlylib.Exporter(renderer).run(fig)\n        if resize:\n            renderer.resize()\n        if strip_style:\n            renderer.strip_style()\n        if verbose:\n            print(renderer.msg)\n        return renderer.plotly_fig\n    else:\n        warnings.warn(\n            \"To use Plotly's matplotlylib functionality, you'll need to have \"\n            \"matplotlib successfully installed with all of its dependencies. \"\n            \"You're getting this error because matplotlib or one of its \"\n            \"dependencies doesn't seem to be installed correctly.\"\n        )\n", "docstring": "Convert a matplotlib figure to plotly dictionary and send."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tools.py", "original_string": "def get_graph_obj(obj, obj_type=None):\n    \"\"\"Returns a new graph object.\n    OLD FUNCTION: this will *silently* strip out invalid pieces of the object.\n    NEW FUNCTION: no striping of invalid pieces anymore - only raises error\n        on unrecognized graph_objs\n    \"\"\"\n    # TODO: Deprecate or move. #283\n    from plotly.graph_objs import graph_objs\n    try:\n        cls = getattr(graph_objs, obj_type)\n    except (AttributeError, KeyError):\n        raise exceptions.PlotlyError(\n            \"'{}' is not a recognized graph_obj.\".format(obj_type)\n        )\n    return cls(obj)\n", "docstring": "Returns a new graph object."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def close(self, val):\n        self[\"close\"] = val\n", "docstring": "self[\"close\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def closesrc(self, val):\n        self[\"closesrc\"] = val\n", "docstring": "self[\"closesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def decreasing(self, val):\n        self[\"decreasing\"] = val\n", "docstring": "self[\"decreasing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def high(self, val):\n        self[\"high\"] = val\n", "docstring": "self[\"high\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def highsrc(self, val):\n        self[\"highsrc\"] = val\n", "docstring": "self[\"highsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def increasing(self, val):\n        self[\"increasing\"] = val\n", "docstring": "self[\"increasing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def low(self, val):\n        self[\"low\"] = val\n", "docstring": "self[\"low\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def lowsrc(self, val):\n        self[\"lowsrc\"] = val\n", "docstring": "self[\"lowsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def open(self, val):\n        self[\"open\"] = val\n", "docstring": "self[\"open\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def opensrc(self, val):\n        self[\"opensrc\"] = val\n", "docstring": "self[\"opensrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def whiskerwidth(self, val):\n        self[\"whiskerwidth\"] = val\n", "docstring": "self[\"whiskerwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def xperiod(self, val):\n        self[\"xperiod\"] = val\n", "docstring": "self[\"xperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def xperiod0(self, val):\n        self[\"xperiod0\"] = val\n", "docstring": "self[\"xperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def xperiodalignment(self, val):\n        self[\"xperiodalignment\"] = val\n", "docstring": "self[\"xperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_candlestick.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figurewidget.py", "original_string": "    def update_coloraxes(\n        self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs\n", "docstring": "self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figurewidget.py", "original_string": "    def update_geos(\n        self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs\n", "docstring": "self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figurewidget.py", "original_string": "    def update_mapboxes(\n        self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs\n", "docstring": "self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figurewidget.py", "original_string": "    def update_polars(\n        self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs\n", "docstring": "self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figurewidget.py", "original_string": "    def update_scenes(\n        self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs\n", "docstring": "self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figurewidget.py", "original_string": "    def update_ternaries(\n        self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs\n", "docstring": "self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figurewidget.py", "original_string": "    def update_xaxes(\n        self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs\n", "docstring": "self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figurewidget.py", "original_string": "    def update_annotations(\n        self, patch=None, selector=None, row=None, col=None, secondary_y=None, **kwargs\n", "docstring": "self, patch=None, selector=None, row=None, col=None, secondary_y=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figurewidget.py", "original_string": "    def update_layout_images(\n        self, patch=None, selector=None, row=None, col=None, secondary_y=None, **kwargs\n", "docstring": "self, patch=None, selector=None, row=None, col=None, secondary_y=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figurewidget.py", "original_string": "    def update_shapes(\n        self, patch=None, selector=None, row=None, col=None, secondary_y=None, **kwargs\n", "docstring": "self, patch=None, selector=None, row=None, col=None, secondary_y=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def featureidkey(self, val):\n        self[\"featureidkey\"] = val\n", "docstring": "self[\"featureidkey\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def geo(self, val):\n        self[\"geo\"] = val\n", "docstring": "self[\"geo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def geojson(self, val):\n        self[\"geojson\"] = val\n", "docstring": "self[\"geojson\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def locationmode(self, val):\n        self[\"locationmode\"] = val\n", "docstring": "self[\"locationmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def zauto(self, val):\n        self[\"zauto\"] = val\n", "docstring": "self[\"zauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def zmax(self, val):\n        self[\"zmax\"] = val\n", "docstring": "self[\"zmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def zmid(self, val):\n        self[\"zmid\"] = val\n", "docstring": "self[\"zmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def zmin(self, val):\n        self[\"zmin\"] = val\n", "docstring": "self[\"zmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choropleth.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def alignmentgroup(self, val):\n        self[\"alignmentgroup\"] = val\n", "docstring": "self[\"alignmentgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def bandwidth(self, val):\n        self[\"bandwidth\"] = val\n", "docstring": "self[\"bandwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def box(self, val):\n        self[\"box\"] = val\n", "docstring": "self[\"box\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def hoveron(self, val):\n        self[\"hoveron\"] = val\n", "docstring": "self[\"hoveron\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def jitter(self, val):\n        self[\"jitter\"] = val\n", "docstring": "self[\"jitter\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def meanline(self, val):\n        self[\"meanline\"] = val\n", "docstring": "self[\"meanline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def offsetgroup(self, val):\n        self[\"offsetgroup\"] = val\n", "docstring": "self[\"offsetgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def orientation(self, val):\n        self[\"orientation\"] = val\n", "docstring": "self[\"orientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def pointpos(self, val):\n        self[\"pointpos\"] = val\n", "docstring": "self[\"pointpos\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def points(self, val):\n        self[\"points\"] = val\n", "docstring": "self[\"points\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def scalegroup(self, val):\n        self[\"scalegroup\"] = val\n", "docstring": "self[\"scalegroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def scalemode(self, val):\n        self[\"scalemode\"] = val\n", "docstring": "self[\"scalemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def span(self, val):\n        self[\"span\"] = val\n", "docstring": "self[\"span\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def spanmode(self, val):\n        self[\"spanmode\"] = val\n", "docstring": "self[\"spanmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_violin.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def arrangement(self, val):\n        self[\"arrangement\"] = val\n", "docstring": "self[\"arrangement\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def link(self, val):\n        self[\"link\"] = val\n", "docstring": "self[\"link\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def node(self, val):\n        self[\"node\"] = val\n", "docstring": "self[\"node\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def orientation(self, val):\n        self[\"orientation\"] = val\n", "docstring": "self[\"orientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def valueformat(self, val):\n        self[\"valueformat\"] = val\n", "docstring": "self[\"valueformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def valuesuffix(self, val):\n        self[\"valuesuffix\"] = val\n", "docstring": "self[\"valuesuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sankey.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def caps(self, val):\n        self[\"caps\"] = val\n", "docstring": "self[\"caps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def contour(self, val):\n        self[\"contour\"] = val\n", "docstring": "self[\"contour\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def flatshading(self, val):\n        self[\"flatshading\"] = val\n", "docstring": "self[\"flatshading\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def isomax(self, val):\n        self[\"isomax\"] = val\n", "docstring": "self[\"isomax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def isomin(self, val):\n        self[\"isomin\"] = val\n", "docstring": "self[\"isomin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def lighting(self, val):\n        self[\"lighting\"] = val\n", "docstring": "self[\"lighting\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def lightposition(self, val):\n        self[\"lightposition\"] = val\n", "docstring": "self[\"lightposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def scene(self, val):\n        self[\"scene\"] = val\n", "docstring": "self[\"scene\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def slices(self, val):\n        self[\"slices\"] = val\n", "docstring": "self[\"slices\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def spaceframe(self, val):\n        self[\"spaceframe\"] = val\n", "docstring": "self[\"spaceframe\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def surface(self, val):\n        self[\"surface\"] = val\n", "docstring": "self[\"surface\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def valuehoverformat(self, val):\n        self[\"valuehoverformat\"] = val\n", "docstring": "self[\"valuehoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def valuesrc(self, val):\n        self[\"valuesrc\"] = val\n", "docstring": "self[\"valuesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def zhoverformat(self, val):\n        self[\"zhoverformat\"] = val\n", "docstring": "self[\"zhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_isosurface.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def alignmentgroup(self, val):\n        self[\"alignmentgroup\"] = val\n", "docstring": "self[\"alignmentgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def boxmean(self, val):\n        self[\"boxmean\"] = val\n", "docstring": "self[\"boxmean\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def boxpoints(self, val):\n        self[\"boxpoints\"] = val\n", "docstring": "self[\"boxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def dx(self, val):\n        self[\"dx\"] = val\n", "docstring": "self[\"dx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def dy(self, val):\n        self[\"dy\"] = val\n", "docstring": "self[\"dy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def hoveron(self, val):\n        self[\"hoveron\"] = val\n", "docstring": "self[\"hoveron\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def jitter(self, val):\n        self[\"jitter\"] = val\n", "docstring": "self[\"jitter\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def lowerfence(self, val):\n        self[\"lowerfence\"] = val\n", "docstring": "self[\"lowerfence\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def lowerfencesrc(self, val):\n        self[\"lowerfencesrc\"] = val\n", "docstring": "self[\"lowerfencesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def mean(self, val):\n        self[\"mean\"] = val\n", "docstring": "self[\"mean\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def meansrc(self, val):\n        self[\"meansrc\"] = val\n", "docstring": "self[\"meansrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def median(self, val):\n        self[\"median\"] = val\n", "docstring": "self[\"median\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def mediansrc(self, val):\n        self[\"mediansrc\"] = val\n", "docstring": "self[\"mediansrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def notched(self, val):\n        self[\"notched\"] = val\n", "docstring": "self[\"notched\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def notchspan(self, val):\n        self[\"notchspan\"] = val\n", "docstring": "self[\"notchspan\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def notchspansrc(self, val):\n        self[\"notchspansrc\"] = val\n", "docstring": "self[\"notchspansrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def notchwidth(self, val):\n        self[\"notchwidth\"] = val\n", "docstring": "self[\"notchwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def offsetgroup(self, val):\n        self[\"offsetgroup\"] = val\n", "docstring": "self[\"offsetgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def orientation(self, val):\n        self[\"orientation\"] = val\n", "docstring": "self[\"orientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def pointpos(self, val):\n        self[\"pointpos\"] = val\n", "docstring": "self[\"pointpos\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def q1(self, val):\n        self[\"q1\"] = val\n", "docstring": "self[\"q1\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def q1src(self, val):\n        self[\"q1src\"] = val\n", "docstring": "self[\"q1src\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def q3(self, val):\n        self[\"q3\"] = val\n", "docstring": "self[\"q3\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def q3src(self, val):\n        self[\"q3src\"] = val\n", "docstring": "self[\"q3src\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def quartilemethod(self, val):\n        self[\"quartilemethod\"] = val\n", "docstring": "self[\"quartilemethod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def sd(self, val):\n        self[\"sd\"] = val\n", "docstring": "self[\"sd\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def sdsrc(self, val):\n        self[\"sdsrc\"] = val\n", "docstring": "self[\"sdsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def upperfence(self, val):\n        self[\"upperfence\"] = val\n", "docstring": "self[\"upperfence\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def upperfencesrc(self, val):\n        self[\"upperfencesrc\"] = val\n", "docstring": "self[\"upperfencesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def whiskerwidth(self, val):\n        self[\"whiskerwidth\"] = val\n", "docstring": "self[\"whiskerwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def xperiod(self, val):\n        self[\"xperiod\"] = val\n", "docstring": "self[\"xperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def xperiod0(self, val):\n        self[\"xperiod0\"] = val\n", "docstring": "self[\"xperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def xperiodalignment(self, val):\n        self[\"xperiodalignment\"] = val\n", "docstring": "self[\"xperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def ycalendar(self, val):\n        self[\"ycalendar\"] = val\n", "docstring": "self[\"ycalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def yperiod(self, val):\n        self[\"yperiod\"] = val\n", "docstring": "self[\"yperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def yperiod0(self, val):\n        self[\"yperiod0\"] = val\n", "docstring": "self[\"yperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def yperiodalignment(self, val):\n        self[\"yperiodalignment\"] = val\n", "docstring": "self[\"yperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_box.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def below(self, val):\n        self[\"below\"] = val\n", "docstring": "self[\"below\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def lat(self, val):\n        self[\"lat\"] = val\n", "docstring": "self[\"lat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def latsrc(self, val):\n        self[\"latsrc\"] = val\n", "docstring": "self[\"latsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def lon(self, val):\n        self[\"lon\"] = val\n", "docstring": "self[\"lon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def lonsrc(self, val):\n        self[\"lonsrc\"] = val\n", "docstring": "self[\"lonsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def radius(self, val):\n        self[\"radius\"] = val\n", "docstring": "self[\"radius\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def radiussrc(self, val):\n        self[\"radiussrc\"] = val\n", "docstring": "self[\"radiussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def subplot(self, val):\n        self[\"subplot\"] = val\n", "docstring": "self[\"subplot\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def zauto(self, val):\n        self[\"zauto\"] = val\n", "docstring": "self[\"zauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def zmax(self, val):\n        self[\"zmax\"] = val\n", "docstring": "self[\"zmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def zmid(self, val):\n        self[\"zmid\"] = val\n", "docstring": "self[\"zmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def zmin(self, val):\n        self[\"zmin\"] = val\n", "docstring": "self[\"zmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_densitymapbox.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def connectgaps(self, val):\n        self[\"connectgaps\"] = val\n", "docstring": "self[\"connectgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def dx(self, val):\n        self[\"dx\"] = val\n", "docstring": "self[\"dx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def dy(self, val):\n        self[\"dy\"] = val\n", "docstring": "self[\"dy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def hoverongaps(self, val):\n        self[\"hoverongaps\"] = val\n", "docstring": "self[\"hoverongaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def transpose(self, val):\n        self[\"transpose\"] = val\n", "docstring": "self[\"transpose\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def xgap(self, val):\n        self[\"xgap\"] = val\n", "docstring": "self[\"xgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def xperiod(self, val):\n        self[\"xperiod\"] = val\n", "docstring": "self[\"xperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def xperiod0(self, val):\n        self[\"xperiod0\"] = val\n", "docstring": "self[\"xperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def xperiodalignment(self, val):\n        self[\"xperiodalignment\"] = val\n", "docstring": "self[\"xperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def xtype(self, val):\n        self[\"xtype\"] = val\n", "docstring": "self[\"xtype\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def ycalendar(self, val):\n        self[\"ycalendar\"] = val\n", "docstring": "self[\"ycalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def ygap(self, val):\n        self[\"ygap\"] = val\n", "docstring": "self[\"ygap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def yperiod(self, val):\n        self[\"yperiod\"] = val\n", "docstring": "self[\"yperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def yperiod0(self, val):\n        self[\"yperiod0\"] = val\n", "docstring": "self[\"yperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def yperiodalignment(self, val):\n        self[\"yperiodalignment\"] = val\n", "docstring": "self[\"yperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def ytype(self, val):\n        self[\"ytype\"] = val\n", "docstring": "self[\"ytype\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def zauto(self, val):\n        self[\"zauto\"] = val\n", "docstring": "self[\"zauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def zhoverformat(self, val):\n        self[\"zhoverformat\"] = val\n", "docstring": "self[\"zhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def zmax(self, val):\n        self[\"zmax\"] = val\n", "docstring": "self[\"zmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def zmid(self, val):\n        self[\"zmid\"] = val\n", "docstring": "self[\"zmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def zmin(self, val):\n        self[\"zmin\"] = val\n", "docstring": "self[\"zmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def zsmooth(self, val):\n        self[\"zsmooth\"] = val\n", "docstring": "self[\"zsmooth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmap.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def connectgaps(self, val):\n        self[\"connectgaps\"] = val\n", "docstring": "self[\"connectgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def error_x(self, val):\n        self[\"error_x\"] = val\n", "docstring": "self[\"error_x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def error_y(self, val):\n        self[\"error_y\"] = val\n", "docstring": "self[\"error_y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def error_z(self, val):\n        self[\"error_z\"] = val\n", "docstring": "self[\"error_z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def projection(self, val):\n        self[\"projection\"] = val\n", "docstring": "self[\"projection\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def scene(self, val):\n        self[\"scene\"] = val\n", "docstring": "self[\"scene\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def surfaceaxis(self, val):\n        self[\"surfaceaxis\"] = val\n", "docstring": "self[\"surfaceaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def surfacecolor(self, val):\n        self[\"surfacecolor\"] = val\n", "docstring": "self[\"surfacecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def ycalendar(self, val):\n        self[\"ycalendar\"] = val\n", "docstring": "self[\"ycalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def zcalendar(self, val):\n        self[\"zcalendar\"] = val\n", "docstring": "self[\"zcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def zhoverformat(self, val):\n        self[\"zhoverformat\"] = val\n", "docstring": "self[\"zhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter3d.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def a(self, val):\n        self[\"a\"] = val\n", "docstring": "self[\"a\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def asrc(self, val):\n        self[\"asrc\"] = val\n", "docstring": "self[\"asrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def bsrc(self, val):\n        self[\"bsrc\"] = val\n", "docstring": "self[\"bsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def c(self, val):\n        self[\"c\"] = val\n", "docstring": "self[\"c\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def cliponaxis(self, val):\n        self[\"cliponaxis\"] = val\n", "docstring": "self[\"cliponaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def connectgaps(self, val):\n        self[\"connectgaps\"] = val\n", "docstring": "self[\"connectgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def csrc(self, val):\n        self[\"csrc\"] = val\n", "docstring": "self[\"csrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def hoveron(self, val):\n        self[\"hoveron\"] = val\n", "docstring": "self[\"hoveron\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def subplot(self, val):\n        self[\"subplot\"] = val\n", "docstring": "self[\"subplot\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def sum(self, val):\n        self[\"sum\"] = val\n", "docstring": "self[\"sum\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterternary.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def anchor(self, val):\n        self[\"anchor\"] = val\n", "docstring": "self[\"anchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def lighting(self, val):\n        self[\"lighting\"] = val\n", "docstring": "self[\"lighting\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def lightposition(self, val):\n        self[\"lightposition\"] = val\n", "docstring": "self[\"lightposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def scene(self, val):\n        self[\"scene\"] = val\n", "docstring": "self[\"scene\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def u(self, val):\n        self[\"u\"] = val\n", "docstring": "self[\"u\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def uhoverformat(self, val):\n        self[\"uhoverformat\"] = val\n", "docstring": "self[\"uhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def usrc(self, val):\n        self[\"usrc\"] = val\n", "docstring": "self[\"usrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def v(self, val):\n        self[\"v\"] = val\n", "docstring": "self[\"v\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def vhoverformat(self, val):\n        self[\"vhoverformat\"] = val\n", "docstring": "self[\"vhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def vsrc(self, val):\n        self[\"vsrc\"] = val\n", "docstring": "self[\"vsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def w(self, val):\n        self[\"w\"] = val\n", "docstring": "self[\"w\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def whoverformat(self, val):\n        self[\"whoverformat\"] = val\n", "docstring": "self[\"whoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def wsrc(self, val):\n        self[\"wsrc\"] = val\n", "docstring": "self[\"wsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def zhoverformat(self, val):\n        self[\"zhoverformat\"] = val\n", "docstring": "self[\"zhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_cone.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def dimensions(self, val):\n        self[\"dimensions\"] = val\n", "docstring": "self[\"dimensions\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def dimensiondefaults(self, val):\n        self[\"dimensiondefaults\"] = val\n", "docstring": "self[\"dimensiondefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def labelangle(self, val):\n        self[\"labelangle\"] = val\n", "docstring": "self[\"labelangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def labelfont(self, val):\n        self[\"labelfont\"] = val\n", "docstring": "self[\"labelfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def labelside(self, val):\n        self[\"labelside\"] = val\n", "docstring": "self[\"labelside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def rangefont(self, val):\n        self[\"rangefont\"] = val\n", "docstring": "self[\"rangefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcoords.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def automargin(self, val):\n        self[\"automargin\"] = val\n", "docstring": "self[\"automargin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def direction(self, val):\n        self[\"direction\"] = val\n", "docstring": "self[\"direction\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def dlabel(self, val):\n        self[\"dlabel\"] = val\n", "docstring": "self[\"dlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def hole(self, val):\n        self[\"hole\"] = val\n", "docstring": "self[\"hole\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def insidetextfont(self, val):\n        self[\"insidetextfont\"] = val\n", "docstring": "self[\"insidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def insidetextorientation(self, val):\n        self[\"insidetextorientation\"] = val\n", "docstring": "self[\"insidetextorientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def label0(self, val):\n        self[\"label0\"] = val\n", "docstring": "self[\"label0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def labels(self, val):\n        self[\"labels\"] = val\n", "docstring": "self[\"labels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def labelssrc(self, val):\n        self[\"labelssrc\"] = val\n", "docstring": "self[\"labelssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def outsidetextfont(self, val):\n        self[\"outsidetextfont\"] = val\n", "docstring": "self[\"outsidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def pull(self, val):\n        self[\"pull\"] = val\n", "docstring": "self[\"pull\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def pullsrc(self, val):\n        self[\"pullsrc\"] = val\n", "docstring": "self[\"pullsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def rotation(self, val):\n        self[\"rotation\"] = val\n", "docstring": "self[\"rotation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def scalegroup(self, val):\n        self[\"scalegroup\"] = val\n", "docstring": "self[\"scalegroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def sort(self, val):\n        self[\"sort\"] = val\n", "docstring": "self[\"sort\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def textinfo(self, val):\n        self[\"textinfo\"] = val\n", "docstring": "self[\"textinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def titleposition(self, val):\n        self[\"titleposition\"] = val\n", "docstring": "self[\"titleposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pie.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def alignmentgroup(self, val):\n        self[\"alignmentgroup\"] = val\n", "docstring": "self[\"alignmentgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def autobinx(self, val):\n        self[\"autobinx\"] = val\n", "docstring": "self[\"autobinx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def autobiny(self, val):\n        self[\"autobiny\"] = val\n", "docstring": "self[\"autobiny\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def bingroup(self, val):\n        self[\"bingroup\"] = val\n", "docstring": "self[\"bingroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def cumulative(self, val):\n        self[\"cumulative\"] = val\n", "docstring": "self[\"cumulative\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def error_x(self, val):\n        self[\"error_x\"] = val\n", "docstring": "self[\"error_x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def error_y(self, val):\n        self[\"error_y\"] = val\n", "docstring": "self[\"error_y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def histfunc(self, val):\n        self[\"histfunc\"] = val\n", "docstring": "self[\"histfunc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def histnorm(self, val):\n        self[\"histnorm\"] = val\n", "docstring": "self[\"histnorm\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def nbinsx(self, val):\n        self[\"nbinsx\"] = val\n", "docstring": "self[\"nbinsx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def nbinsy(self, val):\n        self[\"nbinsy\"] = val\n", "docstring": "self[\"nbinsy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def offsetgroup(self, val):\n        self[\"offsetgroup\"] = val\n", "docstring": "self[\"offsetgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def orientation(self, val):\n        self[\"orientation\"] = val\n", "docstring": "self[\"orientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def xbins(self, val):\n        self[\"xbins\"] = val\n", "docstring": "self[\"xbins\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def ybins(self, val):\n        self[\"ybins\"] = val\n", "docstring": "self[\"ybins\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def ycalendar(self, val):\n        self[\"ycalendar\"] = val\n", "docstring": "self[\"ycalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def activeshape(self, val):\n        self[\"activeshape\"] = val\n", "docstring": "self[\"activeshape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def annotations(self, val):\n        self[\"annotations\"] = val\n", "docstring": "self[\"annotations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def annotationdefaults(self, val):\n        self[\"annotationdefaults\"] = val\n", "docstring": "self[\"annotationdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def autosize(self, val):\n        self[\"autosize\"] = val\n", "docstring": "self[\"autosize\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def bargap(self, val):\n        self[\"bargap\"] = val\n", "docstring": "self[\"bargap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def bargroupgap(self, val):\n        self[\"bargroupgap\"] = val\n", "docstring": "self[\"bargroupgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def barmode(self, val):\n        self[\"barmode\"] = val\n", "docstring": "self[\"barmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def barnorm(self, val):\n        self[\"barnorm\"] = val\n", "docstring": "self[\"barnorm\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def boxgap(self, val):\n        self[\"boxgap\"] = val\n", "docstring": "self[\"boxgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def boxgroupgap(self, val):\n        self[\"boxgroupgap\"] = val\n", "docstring": "self[\"boxgroupgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def boxmode(self, val):\n        self[\"boxmode\"] = val\n", "docstring": "self[\"boxmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def calendar(self, val):\n        self[\"calendar\"] = val\n", "docstring": "self[\"calendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def clickmode(self, val):\n        self[\"clickmode\"] = val\n", "docstring": "self[\"clickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def colorway(self, val):\n        self[\"colorway\"] = val\n", "docstring": "self[\"colorway\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def computed(self, val):\n        self[\"computed\"] = val\n", "docstring": "self[\"computed\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def datarevision(self, val):\n        self[\"datarevision\"] = val\n", "docstring": "self[\"datarevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def dragmode(self, val):\n        self[\"dragmode\"] = val\n", "docstring": "self[\"dragmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def editrevision(self, val):\n        self[\"editrevision\"] = val\n", "docstring": "self[\"editrevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def extendfunnelareacolors(self, val):\n        self[\"extendfunnelareacolors\"] = val\n", "docstring": "self[\"extendfunnelareacolors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def extendiciclecolors(self, val):\n        self[\"extendiciclecolors\"] = val\n", "docstring": "self[\"extendiciclecolors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def extendpiecolors(self, val):\n        self[\"extendpiecolors\"] = val\n", "docstring": "self[\"extendpiecolors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def extendsunburstcolors(self, val):\n        self[\"extendsunburstcolors\"] = val\n", "docstring": "self[\"extendsunburstcolors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def extendtreemapcolors(self, val):\n        self[\"extendtreemapcolors\"] = val\n", "docstring": "self[\"extendtreemapcolors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def funnelareacolorway(self, val):\n        self[\"funnelareacolorway\"] = val\n", "docstring": "self[\"funnelareacolorway\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def funnelgap(self, val):\n        self[\"funnelgap\"] = val\n", "docstring": "self[\"funnelgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def funnelgroupgap(self, val):\n        self[\"funnelgroupgap\"] = val\n", "docstring": "self[\"funnelgroupgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def funnelmode(self, val):\n        self[\"funnelmode\"] = val\n", "docstring": "self[\"funnelmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def geo(self, val):\n        self[\"geo\"] = val\n", "docstring": "self[\"geo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def grid(self, val):\n        self[\"grid\"] = val\n", "docstring": "self[\"grid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def height(self, val):\n        self[\"height\"] = val\n", "docstring": "self[\"height\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def hiddenlabels(self, val):\n        self[\"hiddenlabels\"] = val\n", "docstring": "self[\"hiddenlabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def hiddenlabelssrc(self, val):\n        self[\"hiddenlabelssrc\"] = val\n", "docstring": "self[\"hiddenlabelssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def hidesources(self, val):\n        self[\"hidesources\"] = val\n", "docstring": "self[\"hidesources\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def hoverdistance(self, val):\n        self[\"hoverdistance\"] = val\n", "docstring": "self[\"hoverdistance\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def hovermode(self, val):\n        self[\"hovermode\"] = val\n", "docstring": "self[\"hovermode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def iciclecolorway(self, val):\n        self[\"iciclecolorway\"] = val\n", "docstring": "self[\"iciclecolorway\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def images(self, val):\n        self[\"images\"] = val\n", "docstring": "self[\"images\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def imagedefaults(self, val):\n        self[\"imagedefaults\"] = val\n", "docstring": "self[\"imagedefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def legend(self, val):\n        self[\"legend\"] = val\n", "docstring": "self[\"legend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def mapbox(self, val):\n        self[\"mapbox\"] = val\n", "docstring": "self[\"mapbox\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def margin(self, val):\n        self[\"margin\"] = val\n", "docstring": "self[\"margin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def modebar(self, val):\n        self[\"modebar\"] = val\n", "docstring": "self[\"modebar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def newshape(self, val):\n        self[\"newshape\"] = val\n", "docstring": "self[\"newshape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def paper_bgcolor(self, val):\n        self[\"paper_bgcolor\"] = val\n", "docstring": "self[\"paper_bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def piecolorway(self, val):\n        self[\"piecolorway\"] = val\n", "docstring": "self[\"piecolorway\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def plot_bgcolor(self, val):\n        self[\"plot_bgcolor\"] = val\n", "docstring": "self[\"plot_bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def polar(self, val):\n        self[\"polar\"] = val\n", "docstring": "self[\"polar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def scene(self, val):\n        self[\"scene\"] = val\n", "docstring": "self[\"scene\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def selectdirection(self, val):\n        self[\"selectdirection\"] = val\n", "docstring": "self[\"selectdirection\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def selectionrevision(self, val):\n        self[\"selectionrevision\"] = val\n", "docstring": "self[\"selectionrevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def separators(self, val):\n        self[\"separators\"] = val\n", "docstring": "self[\"separators\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def shapes(self, val):\n        self[\"shapes\"] = val\n", "docstring": "self[\"shapes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def shapedefaults(self, val):\n        self[\"shapedefaults\"] = val\n", "docstring": "self[\"shapedefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def sliders(self, val):\n        self[\"sliders\"] = val\n", "docstring": "self[\"sliders\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def sliderdefaults(self, val):\n        self[\"sliderdefaults\"] = val\n", "docstring": "self[\"sliderdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def spikedistance(self, val):\n        self[\"spikedistance\"] = val\n", "docstring": "self[\"spikedistance\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def sunburstcolorway(self, val):\n        self[\"sunburstcolorway\"] = val\n", "docstring": "self[\"sunburstcolorway\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def template(self, val):\n        self[\"template\"] = val\n", "docstring": "self[\"template\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def ternary(self, val):\n        self[\"ternary\"] = val\n", "docstring": "self[\"ternary\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def transition(self, val):\n        self[\"transition\"] = val\n", "docstring": "self[\"transition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def treemapcolorway(self, val):\n        self[\"treemapcolorway\"] = val\n", "docstring": "self[\"treemapcolorway\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def uniformtext(self, val):\n        self[\"uniformtext\"] = val\n", "docstring": "self[\"uniformtext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def updatemenus(self, val):\n        self[\"updatemenus\"] = val\n", "docstring": "self[\"updatemenus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def updatemenudefaults(self, val):\n        self[\"updatemenudefaults\"] = val\n", "docstring": "self[\"updatemenudefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def violingap(self, val):\n        self[\"violingap\"] = val\n", "docstring": "self[\"violingap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def violingroupgap(self, val):\n        self[\"violingroupgap\"] = val\n", "docstring": "self[\"violingroupgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def violinmode(self, val):\n        self[\"violinmode\"] = val\n", "docstring": "self[\"violinmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def waterfallgap(self, val):\n        self[\"waterfallgap\"] = val\n", "docstring": "self[\"waterfallgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def waterfallgroupgap(self, val):\n        self[\"waterfallgroupgap\"] = val\n", "docstring": "self[\"waterfallgroupgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def waterfallmode(self, val):\n        self[\"waterfallmode\"] = val\n", "docstring": "self[\"waterfallmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_layout.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def autobinx(self, val):\n        self[\"autobinx\"] = val\n", "docstring": "self[\"autobinx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def autobiny(self, val):\n        self[\"autobiny\"] = val\n", "docstring": "self[\"autobiny\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def autocontour(self, val):\n        self[\"autocontour\"] = val\n", "docstring": "self[\"autocontour\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def bingroup(self, val):\n        self[\"bingroup\"] = val\n", "docstring": "self[\"bingroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def contours(self, val):\n        self[\"contours\"] = val\n", "docstring": "self[\"contours\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def histfunc(self, val):\n        self[\"histfunc\"] = val\n", "docstring": "self[\"histfunc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def histnorm(self, val):\n        self[\"histnorm\"] = val\n", "docstring": "self[\"histnorm\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def nbinsx(self, val):\n        self[\"nbinsx\"] = val\n", "docstring": "self[\"nbinsx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def nbinsy(self, val):\n        self[\"nbinsy\"] = val\n", "docstring": "self[\"nbinsy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def ncontours(self, val):\n        self[\"ncontours\"] = val\n", "docstring": "self[\"ncontours\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def xbingroup(self, val):\n        self[\"xbingroup\"] = val\n", "docstring": "self[\"xbingroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def xbins(self, val):\n        self[\"xbins\"] = val\n", "docstring": "self[\"xbins\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def ybingroup(self, val):\n        self[\"ybingroup\"] = val\n", "docstring": "self[\"ybingroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def ybins(self, val):\n        self[\"ybins\"] = val\n", "docstring": "self[\"ybins\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def ycalendar(self, val):\n        self[\"ycalendar\"] = val\n", "docstring": "self[\"ycalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def zauto(self, val):\n        self[\"zauto\"] = val\n", "docstring": "self[\"zauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def zhoverformat(self, val):\n        self[\"zhoverformat\"] = val\n", "docstring": "self[\"zhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def zmax(self, val):\n        self[\"zmax\"] = val\n", "docstring": "self[\"zmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def zmid(self, val):\n        self[\"zmid\"] = val\n", "docstring": "self[\"zmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def zmin(self, val):\n        self[\"zmin\"] = val\n", "docstring": "self[\"zmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2dcontour.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def close(self, val):\n        self[\"close\"] = val\n", "docstring": "self[\"close\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def closesrc(self, val):\n        self[\"closesrc\"] = val\n", "docstring": "self[\"closesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def decreasing(self, val):\n        self[\"decreasing\"] = val\n", "docstring": "self[\"decreasing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def high(self, val):\n        self[\"high\"] = val\n", "docstring": "self[\"high\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def highsrc(self, val):\n        self[\"highsrc\"] = val\n", "docstring": "self[\"highsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def increasing(self, val):\n        self[\"increasing\"] = val\n", "docstring": "self[\"increasing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def low(self, val):\n        self[\"low\"] = val\n", "docstring": "self[\"low\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def lowsrc(self, val):\n        self[\"lowsrc\"] = val\n", "docstring": "self[\"lowsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def open(self, val):\n        self[\"open\"] = val\n", "docstring": "self[\"open\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def opensrc(self, val):\n        self[\"opensrc\"] = val\n", "docstring": "self[\"opensrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def xperiod(self, val):\n        self[\"xperiod\"] = val\n", "docstring": "self[\"xperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def xperiod0(self, val):\n        self[\"xperiod0\"] = val\n", "docstring": "self[\"xperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def xperiodalignment(self, val):\n        self[\"xperiodalignment\"] = val\n", "docstring": "self[\"xperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_ohlc.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def colormodel(self, val):\n        self[\"colormodel\"] = val\n", "docstring": "self[\"colormodel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def dx(self, val):\n        self[\"dx\"] = val\n", "docstring": "self[\"dx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def dy(self, val):\n        self[\"dy\"] = val\n", "docstring": "self[\"dy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def source(self, val):\n        self[\"source\"] = val\n", "docstring": "self[\"source\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def zmax(self, val):\n        self[\"zmax\"] = val\n", "docstring": "self[\"zmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def zmin(self, val):\n        self[\"zmin\"] = val\n", "docstring": "self[\"zmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def zsmooth(self, val):\n        self[\"zsmooth\"] = val\n", "docstring": "self[\"zsmooth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_image.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def autocontour(self, val):\n        self[\"autocontour\"] = val\n", "docstring": "self[\"autocontour\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def connectgaps(self, val):\n        self[\"connectgaps\"] = val\n", "docstring": "self[\"connectgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def contours(self, val):\n        self[\"contours\"] = val\n", "docstring": "self[\"contours\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def dx(self, val):\n        self[\"dx\"] = val\n", "docstring": "self[\"dx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def dy(self, val):\n        self[\"dy\"] = val\n", "docstring": "self[\"dy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def hoverongaps(self, val):\n        self[\"hoverongaps\"] = val\n", "docstring": "self[\"hoverongaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def ncontours(self, val):\n        self[\"ncontours\"] = val\n", "docstring": "self[\"ncontours\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def transpose(self, val):\n        self[\"transpose\"] = val\n", "docstring": "self[\"transpose\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def xperiod(self, val):\n        self[\"xperiod\"] = val\n", "docstring": "self[\"xperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def xperiod0(self, val):\n        self[\"xperiod0\"] = val\n", "docstring": "self[\"xperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def xperiodalignment(self, val):\n        self[\"xperiodalignment\"] = val\n", "docstring": "self[\"xperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def xtype(self, val):\n        self[\"xtype\"] = val\n", "docstring": "self[\"xtype\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def ycalendar(self, val):\n        self[\"ycalendar\"] = val\n", "docstring": "self[\"ycalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def yperiod(self, val):\n        self[\"yperiod\"] = val\n", "docstring": "self[\"yperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def yperiod0(self, val):\n        self[\"yperiod0\"] = val\n", "docstring": "self[\"yperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def yperiodalignment(self, val):\n        self[\"yperiodalignment\"] = val\n", "docstring": "self[\"yperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def ytype(self, val):\n        self[\"ytype\"] = val\n", "docstring": "self[\"ytype\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def zauto(self, val):\n        self[\"zauto\"] = val\n", "docstring": "self[\"zauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def zhoverformat(self, val):\n        self[\"zhoverformat\"] = val\n", "docstring": "self[\"zhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def zmax(self, val):\n        self[\"zmax\"] = val\n", "docstring": "self[\"zmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def zmid(self, val):\n        self[\"zmid\"] = val\n", "docstring": "self[\"zmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def zmin(self, val):\n        self[\"zmin\"] = val\n", "docstring": "self[\"zmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contour.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def base(self, val):\n        self[\"base\"] = val\n", "docstring": "self[\"base\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def basesrc(self, val):\n        self[\"basesrc\"] = val\n", "docstring": "self[\"basesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def dr(self, val):\n        self[\"dr\"] = val\n", "docstring": "self[\"dr\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def dtheta(self, val):\n        self[\"dtheta\"] = val\n", "docstring": "self[\"dtheta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def offset(self, val):\n        self[\"offset\"] = val\n", "docstring": "self[\"offset\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def offsetsrc(self, val):\n        self[\"offsetsrc\"] = val\n", "docstring": "self[\"offsetsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def r(self, val):\n        self[\"r\"] = val\n", "docstring": "self[\"r\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def r0(self, val):\n        self[\"r0\"] = val\n", "docstring": "self[\"r0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def rsrc(self, val):\n        self[\"rsrc\"] = val\n", "docstring": "self[\"rsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def subplot(self, val):\n        self[\"subplot\"] = val\n", "docstring": "self[\"subplot\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def theta(self, val):\n        self[\"theta\"] = val\n", "docstring": "self[\"theta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def theta0(self, val):\n        self[\"theta0\"] = val\n", "docstring": "self[\"theta0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def thetasrc(self, val):\n        self[\"thetasrc\"] = val\n", "docstring": "self[\"thetasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def thetaunit(self, val):\n        self[\"thetaunit\"] = val\n", "docstring": "self[\"thetaunit\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_barpolar.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def alphahull(self, val):\n        self[\"alphahull\"] = val\n", "docstring": "self[\"alphahull\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def contour(self, val):\n        self[\"contour\"] = val\n", "docstring": "self[\"contour\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def delaunayaxis(self, val):\n        self[\"delaunayaxis\"] = val\n", "docstring": "self[\"delaunayaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def facecolor(self, val):\n        self[\"facecolor\"] = val\n", "docstring": "self[\"facecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def facecolorsrc(self, val):\n        self[\"facecolorsrc\"] = val\n", "docstring": "self[\"facecolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def flatshading(self, val):\n        self[\"flatshading\"] = val\n", "docstring": "self[\"flatshading\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def i(self, val):\n        self[\"i\"] = val\n", "docstring": "self[\"i\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def intensity(self, val):\n        self[\"intensity\"] = val\n", "docstring": "self[\"intensity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def intensitymode(self, val):\n        self[\"intensitymode\"] = val\n", "docstring": "self[\"intensitymode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def intensitysrc(self, val):\n        self[\"intensitysrc\"] = val\n", "docstring": "self[\"intensitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def isrc(self, val):\n        self[\"isrc\"] = val\n", "docstring": "self[\"isrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def j(self, val):\n        self[\"j\"] = val\n", "docstring": "self[\"j\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def jsrc(self, val):\n        self[\"jsrc\"] = val\n", "docstring": "self[\"jsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def k(self, val):\n        self[\"k\"] = val\n", "docstring": "self[\"k\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def ksrc(self, val):\n        self[\"ksrc\"] = val\n", "docstring": "self[\"ksrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def lighting(self, val):\n        self[\"lighting\"] = val\n", "docstring": "self[\"lighting\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def lightposition(self, val):\n        self[\"lightposition\"] = val\n", "docstring": "self[\"lightposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def scene(self, val):\n        self[\"scene\"] = val\n", "docstring": "self[\"scene\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def vertexcolor(self, val):\n        self[\"vertexcolor\"] = val\n", "docstring": "self[\"vertexcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def vertexcolorsrc(self, val):\n        self[\"vertexcolorsrc\"] = val\n", "docstring": "self[\"vertexcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def ycalendar(self, val):\n        self[\"ycalendar\"] = val\n", "docstring": "self[\"ycalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def zcalendar(self, val):\n        self[\"zcalendar\"] = val\n", "docstring": "self[\"zcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def zhoverformat(self, val):\n        self[\"zhoverformat\"] = val\n", "docstring": "self[\"zhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_mesh3d.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def cliponaxis(self, val):\n        self[\"cliponaxis\"] = val\n", "docstring": "self[\"cliponaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def connectgaps(self, val):\n        self[\"connectgaps\"] = val\n", "docstring": "self[\"connectgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def dx(self, val):\n        self[\"dx\"] = val\n", "docstring": "self[\"dx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def dy(self, val):\n        self[\"dy\"] = val\n", "docstring": "self[\"dy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def error_x(self, val):\n        self[\"error_x\"] = val\n", "docstring": "self[\"error_x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def error_y(self, val):\n        self[\"error_y\"] = val\n", "docstring": "self[\"error_y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def groupnorm(self, val):\n        self[\"groupnorm\"] = val\n", "docstring": "self[\"groupnorm\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def hoveron(self, val):\n        self[\"hoveron\"] = val\n", "docstring": "self[\"hoveron\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def orientation(self, val):\n        self[\"orientation\"] = val\n", "docstring": "self[\"orientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def stackgaps(self, val):\n        self[\"stackgaps\"] = val\n", "docstring": "self[\"stackgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def stackgroup(self, val):\n        self[\"stackgroup\"] = val\n", "docstring": "self[\"stackgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def xperiod(self, val):\n        self[\"xperiod\"] = val\n", "docstring": "self[\"xperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def xperiod0(self, val):\n        self[\"xperiod0\"] = val\n", "docstring": "self[\"xperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def xperiodalignment(self, val):\n        self[\"xperiodalignment\"] = val\n", "docstring": "self[\"xperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def ycalendar(self, val):\n        self[\"ycalendar\"] = val\n", "docstring": "self[\"ycalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def yperiod(self, val):\n        self[\"yperiod\"] = val\n", "docstring": "self[\"yperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def yperiod0(self, val):\n        self[\"yperiod0\"] = val\n", "docstring": "self[\"yperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def yperiodalignment(self, val):\n        self[\"yperiodalignment\"] = val\n", "docstring": "self[\"yperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatter.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def alignmentgroup(self, val):\n        self[\"alignmentgroup\"] = val\n", "docstring": "self[\"alignmentgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def base(self, val):\n        self[\"base\"] = val\n", "docstring": "self[\"base\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def basesrc(self, val):\n        self[\"basesrc\"] = val\n", "docstring": "self[\"basesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def cliponaxis(self, val):\n        self[\"cliponaxis\"] = val\n", "docstring": "self[\"cliponaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def constraintext(self, val):\n        self[\"constraintext\"] = val\n", "docstring": "self[\"constraintext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def dx(self, val):\n        self[\"dx\"] = val\n", "docstring": "self[\"dx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def dy(self, val):\n        self[\"dy\"] = val\n", "docstring": "self[\"dy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def error_x(self, val):\n        self[\"error_x\"] = val\n", "docstring": "self[\"error_x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def error_y(self, val):\n        self[\"error_y\"] = val\n", "docstring": "self[\"error_y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def insidetextanchor(self, val):\n        self[\"insidetextanchor\"] = val\n", "docstring": "self[\"insidetextanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def insidetextfont(self, val):\n        self[\"insidetextfont\"] = val\n", "docstring": "self[\"insidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def offset(self, val):\n        self[\"offset\"] = val\n", "docstring": "self[\"offset\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def offsetgroup(self, val):\n        self[\"offsetgroup\"] = val\n", "docstring": "self[\"offsetgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def offsetsrc(self, val):\n        self[\"offsetsrc\"] = val\n", "docstring": "self[\"offsetsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def orientation(self, val):\n        self[\"orientation\"] = val\n", "docstring": "self[\"orientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def outsidetextfont(self, val):\n        self[\"outsidetextfont\"] = val\n", "docstring": "self[\"outsidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def textangle(self, val):\n        self[\"textangle\"] = val\n", "docstring": "self[\"textangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def xperiod(self, val):\n        self[\"xperiod\"] = val\n", "docstring": "self[\"xperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def xperiod0(self, val):\n        self[\"xperiod0\"] = val\n", "docstring": "self[\"xperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def xperiodalignment(self, val):\n        self[\"xperiodalignment\"] = val\n", "docstring": "self[\"xperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def ycalendar(self, val):\n        self[\"ycalendar\"] = val\n", "docstring": "self[\"ycalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def yperiod(self, val):\n        self[\"yperiod\"] = val\n", "docstring": "self[\"yperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def yperiod0(self, val):\n        self[\"yperiod0\"] = val\n", "docstring": "self[\"yperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def yperiodalignment(self, val):\n        self[\"yperiodalignment\"] = val\n", "docstring": "self[\"yperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_bar.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_frame.py", "original_string": "    def baseframe(self, val):\n        self[\"baseframe\"] = val\n", "docstring": "self[\"baseframe\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_frame.py", "original_string": "    def data(self, val):\n        self[\"data\"] = val\n", "docstring": "self[\"data\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_frame.py", "original_string": "    def group(self, val):\n        self[\"group\"] = val\n", "docstring": "self[\"group\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_frame.py", "original_string": "    def layout(self, val):\n        self[\"layout\"] = val\n", "docstring": "self[\"layout\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_frame.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_frame.py", "original_string": "    def traces(self, val):\n        self[\"traces\"] = val\n", "docstring": "self[\"traces\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def connectgaps(self, val):\n        self[\"connectgaps\"] = val\n", "docstring": "self[\"connectgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def contours(self, val):\n        self[\"contours\"] = val\n", "docstring": "self[\"contours\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def hidesurface(self, val):\n        self[\"hidesurface\"] = val\n", "docstring": "self[\"hidesurface\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def lighting(self, val):\n        self[\"lighting\"] = val\n", "docstring": "self[\"lighting\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def lightposition(self, val):\n        self[\"lightposition\"] = val\n", "docstring": "self[\"lightposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def opacityscale(self, val):\n        self[\"opacityscale\"] = val\n", "docstring": "self[\"opacityscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def scene(self, val):\n        self[\"scene\"] = val\n", "docstring": "self[\"scene\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def surfacecolor(self, val):\n        self[\"surfacecolor\"] = val\n", "docstring": "self[\"surfacecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def surfacecolorsrc(self, val):\n        self[\"surfacecolorsrc\"] = val\n", "docstring": "self[\"surfacecolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def ycalendar(self, val):\n        self[\"ycalendar\"] = val\n", "docstring": "self[\"ycalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def zcalendar(self, val):\n        self[\"zcalendar\"] = val\n", "docstring": "self[\"zcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def zhoverformat(self, val):\n        self[\"zhoverformat\"] = val\n", "docstring": "self[\"zhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_surface.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def branchvalues(self, val):\n        self[\"branchvalues\"] = val\n", "docstring": "self[\"branchvalues\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def count(self, val):\n        self[\"count\"] = val\n", "docstring": "self[\"count\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def insidetextfont(self, val):\n        self[\"insidetextfont\"] = val\n", "docstring": "self[\"insidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def labels(self, val):\n        self[\"labels\"] = val\n", "docstring": "self[\"labels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def labelssrc(self, val):\n        self[\"labelssrc\"] = val\n", "docstring": "self[\"labelssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def level(self, val):\n        self[\"level\"] = val\n", "docstring": "self[\"level\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def maxdepth(self, val):\n        self[\"maxdepth\"] = val\n", "docstring": "self[\"maxdepth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def outsidetextfont(self, val):\n        self[\"outsidetextfont\"] = val\n", "docstring": "self[\"outsidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def parents(self, val):\n        self[\"parents\"] = val\n", "docstring": "self[\"parents\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def parentssrc(self, val):\n        self[\"parentssrc\"] = val\n", "docstring": "self[\"parentssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def pathbar(self, val):\n        self[\"pathbar\"] = val\n", "docstring": "self[\"pathbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def root(self, val):\n        self[\"root\"] = val\n", "docstring": "self[\"root\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def sort(self, val):\n        self[\"sort\"] = val\n", "docstring": "self[\"sort\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def textinfo(self, val):\n        self[\"textinfo\"] = val\n", "docstring": "self[\"textinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def tiling(self, val):\n        self[\"tiling\"] = val\n", "docstring": "self[\"tiling\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_treemap.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def alignmentgroup(self, val):\n        self[\"alignmentgroup\"] = val\n", "docstring": "self[\"alignmentgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def base(self, val):\n        self[\"base\"] = val\n", "docstring": "self[\"base\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def cliponaxis(self, val):\n        self[\"cliponaxis\"] = val\n", "docstring": "self[\"cliponaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def connector(self, val):\n        self[\"connector\"] = val\n", "docstring": "self[\"connector\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def constraintext(self, val):\n        self[\"constraintext\"] = val\n", "docstring": "self[\"constraintext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def decreasing(self, val):\n        self[\"decreasing\"] = val\n", "docstring": "self[\"decreasing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def dx(self, val):\n        self[\"dx\"] = val\n", "docstring": "self[\"dx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def dy(self, val):\n        self[\"dy\"] = val\n", "docstring": "self[\"dy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def increasing(self, val):\n        self[\"increasing\"] = val\n", "docstring": "self[\"increasing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def insidetextanchor(self, val):\n        self[\"insidetextanchor\"] = val\n", "docstring": "self[\"insidetextanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def insidetextfont(self, val):\n        self[\"insidetextfont\"] = val\n", "docstring": "self[\"insidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def measure(self, val):\n        self[\"measure\"] = val\n", "docstring": "self[\"measure\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def measuresrc(self, val):\n        self[\"measuresrc\"] = val\n", "docstring": "self[\"measuresrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def offset(self, val):\n        self[\"offset\"] = val\n", "docstring": "self[\"offset\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def offsetgroup(self, val):\n        self[\"offsetgroup\"] = val\n", "docstring": "self[\"offsetgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def offsetsrc(self, val):\n        self[\"offsetsrc\"] = val\n", "docstring": "self[\"offsetsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def orientation(self, val):\n        self[\"orientation\"] = val\n", "docstring": "self[\"orientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def outsidetextfont(self, val):\n        self[\"outsidetextfont\"] = val\n", "docstring": "self[\"outsidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def textangle(self, val):\n        self[\"textangle\"] = val\n", "docstring": "self[\"textangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def textinfo(self, val):\n        self[\"textinfo\"] = val\n", "docstring": "self[\"textinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def totals(self, val):\n        self[\"totals\"] = val\n", "docstring": "self[\"totals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def xperiod(self, val):\n        self[\"xperiod\"] = val\n", "docstring": "self[\"xperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def xperiod0(self, val):\n        self[\"xperiod0\"] = val\n", "docstring": "self[\"xperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def xperiodalignment(self, val):\n        self[\"xperiodalignment\"] = val\n", "docstring": "self[\"xperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def yperiod(self, val):\n        self[\"yperiod\"] = val\n", "docstring": "self[\"yperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def yperiod0(self, val):\n        self[\"yperiod0\"] = val\n", "docstring": "self[\"yperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def yperiodalignment(self, val):\n        self[\"yperiodalignment\"] = val\n", "docstring": "self[\"yperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_waterfall.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def a(self, val):\n        self[\"a\"] = val\n", "docstring": "self[\"a\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def asrc(self, val):\n        self[\"asrc\"] = val\n", "docstring": "self[\"asrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def bsrc(self, val):\n        self[\"bsrc\"] = val\n", "docstring": "self[\"bsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def carpet(self, val):\n        self[\"carpet\"] = val\n", "docstring": "self[\"carpet\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def connectgaps(self, val):\n        self[\"connectgaps\"] = val\n", "docstring": "self[\"connectgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def hoveron(self, val):\n        self[\"hoveron\"] = val\n", "docstring": "self[\"hoveron\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattercarpet.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def delta(self, val):\n        self[\"delta\"] = val\n", "docstring": "self[\"delta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def gauge(self, val):\n        self[\"gauge\"] = val\n", "docstring": "self[\"gauge\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def number(self, val):\n        self[\"number\"] = val\n", "docstring": "self[\"number\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_indicator.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def a(self, val):\n        self[\"a\"] = val\n", "docstring": "self[\"a\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def a0(self, val):\n        self[\"a0\"] = val\n", "docstring": "self[\"a0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def asrc(self, val):\n        self[\"asrc\"] = val\n", "docstring": "self[\"asrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def atype(self, val):\n        self[\"atype\"] = val\n", "docstring": "self[\"atype\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def autocontour(self, val):\n        self[\"autocontour\"] = val\n", "docstring": "self[\"autocontour\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def b0(self, val):\n        self[\"b0\"] = val\n", "docstring": "self[\"b0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def bsrc(self, val):\n        self[\"bsrc\"] = val\n", "docstring": "self[\"bsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def btype(self, val):\n        self[\"btype\"] = val\n", "docstring": "self[\"btype\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def carpet(self, val):\n        self[\"carpet\"] = val\n", "docstring": "self[\"carpet\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def contours(self, val):\n        self[\"contours\"] = val\n", "docstring": "self[\"contours\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def da(self, val):\n        self[\"da\"] = val\n", "docstring": "self[\"da\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def db(self, val):\n        self[\"db\"] = val\n", "docstring": "self[\"db\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def ncontours(self, val):\n        self[\"ncontours\"] = val\n", "docstring": "self[\"ncontours\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def transpose(self, val):\n        self[\"transpose\"] = val\n", "docstring": "self[\"transpose\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def zauto(self, val):\n        self[\"zauto\"] = val\n", "docstring": "self[\"zauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def zmax(self, val):\n        self[\"zmax\"] = val\n", "docstring": "self[\"zmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def zmid(self, val):\n        self[\"zmid\"] = val\n", "docstring": "self[\"zmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def zmin(self, val):\n        self[\"zmin\"] = val\n", "docstring": "self[\"zmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_contourcarpet.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def dx(self, val):\n        self[\"dx\"] = val\n", "docstring": "self[\"dx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def dy(self, val):\n        self[\"dy\"] = val\n", "docstring": "self[\"dy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def transpose(self, val):\n        self[\"transpose\"] = val\n", "docstring": "self[\"transpose\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def xtype(self, val):\n        self[\"xtype\"] = val\n", "docstring": "self[\"xtype\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def ytype(self, val):\n        self[\"ytype\"] = val\n", "docstring": "self[\"ytype\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def zauto(self, val):\n        self[\"zauto\"] = val\n", "docstring": "self[\"zauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def zmax(self, val):\n        self[\"zmax\"] = val\n", "docstring": "self[\"zmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def zmid(self, val):\n        self[\"zmid\"] = val\n", "docstring": "self[\"zmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def zmin(self, val):\n        self[\"zmin\"] = val\n", "docstring": "self[\"zmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def zsmooth(self, val):\n        self[\"zsmooth\"] = val\n", "docstring": "self[\"zsmooth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_heatmapgl.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def diagonal(self, val):\n        self[\"diagonal\"] = val\n", "docstring": "self[\"diagonal\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def dimensions(self, val):\n        self[\"dimensions\"] = val\n", "docstring": "self[\"dimensions\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def dimensiondefaults(self, val):\n        self[\"dimensiondefaults\"] = val\n", "docstring": "self[\"dimensiondefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def showlowerhalf(self, val):\n        self[\"showlowerhalf\"] = val\n", "docstring": "self[\"showlowerhalf\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def showupperhalf(self, val):\n        self[\"showupperhalf\"] = val\n", "docstring": "self[\"showupperhalf\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def xaxes(self, val):\n        self[\"xaxes\"] = val\n", "docstring": "self[\"xaxes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def yaxes(self, val):\n        self[\"yaxes\"] = val\n", "docstring": "self[\"yaxes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_splom.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def cells(self, val):\n        self[\"cells\"] = val\n", "docstring": "self[\"cells\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def columnorder(self, val):\n        self[\"columnorder\"] = val\n", "docstring": "self[\"columnorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def columnordersrc(self, val):\n        self[\"columnordersrc\"] = val\n", "docstring": "self[\"columnordersrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def columnwidth(self, val):\n        self[\"columnwidth\"] = val\n", "docstring": "self[\"columnwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def columnwidthsrc(self, val):\n        self[\"columnwidthsrc\"] = val\n", "docstring": "self[\"columnwidthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def header(self, val):\n        self[\"header\"] = val\n", "docstring": "self[\"header\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_table.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def below(self, val):\n        self[\"below\"] = val\n", "docstring": "self[\"below\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def connectgaps(self, val):\n        self[\"connectgaps\"] = val\n", "docstring": "self[\"connectgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def lat(self, val):\n        self[\"lat\"] = val\n", "docstring": "self[\"lat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def latsrc(self, val):\n        self[\"latsrc\"] = val\n", "docstring": "self[\"latsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def lon(self, val):\n        self[\"lon\"] = val\n", "docstring": "self[\"lon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def lonsrc(self, val):\n        self[\"lonsrc\"] = val\n", "docstring": "self[\"lonsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def subplot(self, val):\n        self[\"subplot\"] = val\n", "docstring": "self[\"subplot\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattermapbox.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def connectgaps(self, val):\n        self[\"connectgaps\"] = val\n", "docstring": "self[\"connectgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def featureidkey(self, val):\n        self[\"featureidkey\"] = val\n", "docstring": "self[\"featureidkey\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def geo(self, val):\n        self[\"geo\"] = val\n", "docstring": "self[\"geo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def geojson(self, val):\n        self[\"geojson\"] = val\n", "docstring": "self[\"geojson\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def lat(self, val):\n        self[\"lat\"] = val\n", "docstring": "self[\"lat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def latsrc(self, val):\n        self[\"latsrc\"] = val\n", "docstring": "self[\"latsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def locationmode(self, val):\n        self[\"locationmode\"] = val\n", "docstring": "self[\"locationmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def lon(self, val):\n        self[\"lon\"] = val\n", "docstring": "self[\"lon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def lonsrc(self, val):\n        self[\"lonsrc\"] = val\n", "docstring": "self[\"lonsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergeo.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def lighting(self, val):\n        self[\"lighting\"] = val\n", "docstring": "self[\"lighting\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def lightposition(self, val):\n        self[\"lightposition\"] = val\n", "docstring": "self[\"lightposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def maxdisplayed(self, val):\n        self[\"maxdisplayed\"] = val\n", "docstring": "self[\"maxdisplayed\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def scene(self, val):\n        self[\"scene\"] = val\n", "docstring": "self[\"scene\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def starts(self, val):\n        self[\"starts\"] = val\n", "docstring": "self[\"starts\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def u(self, val):\n        self[\"u\"] = val\n", "docstring": "self[\"u\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def uhoverformat(self, val):\n        self[\"uhoverformat\"] = val\n", "docstring": "self[\"uhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def usrc(self, val):\n        self[\"usrc\"] = val\n", "docstring": "self[\"usrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def v(self, val):\n        self[\"v\"] = val\n", "docstring": "self[\"v\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def vhoverformat(self, val):\n        self[\"vhoverformat\"] = val\n", "docstring": "self[\"vhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def vsrc(self, val):\n        self[\"vsrc\"] = val\n", "docstring": "self[\"vsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def w(self, val):\n        self[\"w\"] = val\n", "docstring": "self[\"w\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def whoverformat(self, val):\n        self[\"whoverformat\"] = val\n", "docstring": "self[\"whoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def wsrc(self, val):\n        self[\"wsrc\"] = val\n", "docstring": "self[\"wsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def zhoverformat(self, val):\n        self[\"zhoverformat\"] = val\n", "docstring": "self[\"zhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_streamtube.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def cliponaxis(self, val):\n        self[\"cliponaxis\"] = val\n", "docstring": "self[\"cliponaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def connectgaps(self, val):\n        self[\"connectgaps\"] = val\n", "docstring": "self[\"connectgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def dr(self, val):\n        self[\"dr\"] = val\n", "docstring": "self[\"dr\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def dtheta(self, val):\n        self[\"dtheta\"] = val\n", "docstring": "self[\"dtheta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def hoveron(self, val):\n        self[\"hoveron\"] = val\n", "docstring": "self[\"hoveron\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def r(self, val):\n        self[\"r\"] = val\n", "docstring": "self[\"r\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def r0(self, val):\n        self[\"r0\"] = val\n", "docstring": "self[\"r0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def rsrc(self, val):\n        self[\"rsrc\"] = val\n", "docstring": "self[\"rsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def subplot(self, val):\n        self[\"subplot\"] = val\n", "docstring": "self[\"subplot\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def theta(self, val):\n        self[\"theta\"] = val\n", "docstring": "self[\"theta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def theta0(self, val):\n        self[\"theta0\"] = val\n", "docstring": "self[\"theta0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def thetasrc(self, val):\n        self[\"thetasrc\"] = val\n", "docstring": "self[\"thetasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def thetaunit(self, val):\n        self[\"thetaunit\"] = val\n", "docstring": "self[\"thetaunit\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolar.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def aspectratio(self, val):\n        self[\"aspectratio\"] = val\n", "docstring": "self[\"aspectratio\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def baseratio(self, val):\n        self[\"baseratio\"] = val\n", "docstring": "self[\"baseratio\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def dlabel(self, val):\n        self[\"dlabel\"] = val\n", "docstring": "self[\"dlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def insidetextfont(self, val):\n        self[\"insidetextfont\"] = val\n", "docstring": "self[\"insidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def label0(self, val):\n        self[\"label0\"] = val\n", "docstring": "self[\"label0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def labels(self, val):\n        self[\"labels\"] = val\n", "docstring": "self[\"labels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def labelssrc(self, val):\n        self[\"labelssrc\"] = val\n", "docstring": "self[\"labelssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def scalegroup(self, val):\n        self[\"scalegroup\"] = val\n", "docstring": "self[\"scalegroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def textinfo(self, val):\n        self[\"textinfo\"] = val\n", "docstring": "self[\"textinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnelarea.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figure.py", "original_string": "    def update_coloraxes(\n        self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs\n", "docstring": "self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figure.py", "original_string": "    def update_geos(\n        self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs\n", "docstring": "self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figure.py", "original_string": "    def update_mapboxes(\n        self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs\n", "docstring": "self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figure.py", "original_string": "    def update_polars(\n        self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs\n", "docstring": "self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figure.py", "original_string": "    def update_scenes(\n        self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs\n", "docstring": "self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figure.py", "original_string": "    def update_ternaries(\n        self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs\n", "docstring": "self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figure.py", "original_string": "    def update_xaxes(\n        self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs\n", "docstring": "self, patch=None, selector=None, overwrite=False, row=None, col=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figure.py", "original_string": "    def update_annotations(\n        self, patch=None, selector=None, row=None, col=None, secondary_y=None, **kwargs\n", "docstring": "self, patch=None, selector=None, row=None, col=None, secondary_y=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figure.py", "original_string": "    def update_layout_images(\n        self, patch=None, selector=None, row=None, col=None, secondary_y=None, **kwargs\n", "docstring": "self, patch=None, selector=None, row=None, col=None, secondary_y=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_figure.py", "original_string": "    def update_shapes(\n        self, patch=None, selector=None, row=None, col=None, secondary_y=None, **kwargs\n", "docstring": "self, patch=None, selector=None, row=None, col=None, secondary_y=None, **kwargs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def indices(self, val):\n        self[\"indices\"] = val\n", "docstring": "self[\"indices\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def indicessrc(self, val):\n        self[\"indicessrc\"] = val\n", "docstring": "self[\"indicessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def xbounds(self, val):\n        self[\"xbounds\"] = val\n", "docstring": "self[\"xbounds\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def xboundssrc(self, val):\n        self[\"xboundssrc\"] = val\n", "docstring": "self[\"xboundssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def xy(self, val):\n        self[\"xy\"] = val\n", "docstring": "self[\"xy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def xysrc(self, val):\n        self[\"xysrc\"] = val\n", "docstring": "self[\"xysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def ybounds(self, val):\n        self[\"ybounds\"] = val\n", "docstring": "self[\"ybounds\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def yboundssrc(self, val):\n        self[\"yboundssrc\"] = val\n", "docstring": "self[\"yboundssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_pointcloud.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def caps(self, val):\n        self[\"caps\"] = val\n", "docstring": "self[\"caps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def contour(self, val):\n        self[\"contour\"] = val\n", "docstring": "self[\"contour\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def flatshading(self, val):\n        self[\"flatshading\"] = val\n", "docstring": "self[\"flatshading\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def isomax(self, val):\n        self[\"isomax\"] = val\n", "docstring": "self[\"isomax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def isomin(self, val):\n        self[\"isomin\"] = val\n", "docstring": "self[\"isomin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def lighting(self, val):\n        self[\"lighting\"] = val\n", "docstring": "self[\"lighting\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def lightposition(self, val):\n        self[\"lightposition\"] = val\n", "docstring": "self[\"lightposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def opacityscale(self, val):\n        self[\"opacityscale\"] = val\n", "docstring": "self[\"opacityscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def scene(self, val):\n        self[\"scene\"] = val\n", "docstring": "self[\"scene\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def slices(self, val):\n        self[\"slices\"] = val\n", "docstring": "self[\"slices\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def spaceframe(self, val):\n        self[\"spaceframe\"] = val\n", "docstring": "self[\"spaceframe\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def surface(self, val):\n        self[\"surface\"] = val\n", "docstring": "self[\"surface\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def valuehoverformat(self, val):\n        self[\"valuehoverformat\"] = val\n", "docstring": "self[\"valuehoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def valuesrc(self, val):\n        self[\"valuesrc\"] = val\n", "docstring": "self[\"valuesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def zhoverformat(self, val):\n        self[\"zhoverformat\"] = val\n", "docstring": "self[\"zhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_volume.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def alignmentgroup(self, val):\n        self[\"alignmentgroup\"] = val\n", "docstring": "self[\"alignmentgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def cliponaxis(self, val):\n        self[\"cliponaxis\"] = val\n", "docstring": "self[\"cliponaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def connector(self, val):\n        self[\"connector\"] = val\n", "docstring": "self[\"connector\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def constraintext(self, val):\n        self[\"constraintext\"] = val\n", "docstring": "self[\"constraintext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def dx(self, val):\n        self[\"dx\"] = val\n", "docstring": "self[\"dx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def dy(self, val):\n        self[\"dy\"] = val\n", "docstring": "self[\"dy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def insidetextanchor(self, val):\n        self[\"insidetextanchor\"] = val\n", "docstring": "self[\"insidetextanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def insidetextfont(self, val):\n        self[\"insidetextfont\"] = val\n", "docstring": "self[\"insidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def offset(self, val):\n        self[\"offset\"] = val\n", "docstring": "self[\"offset\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def offsetgroup(self, val):\n        self[\"offsetgroup\"] = val\n", "docstring": "self[\"offsetgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def orientation(self, val):\n        self[\"orientation\"] = val\n", "docstring": "self[\"orientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def outsidetextfont(self, val):\n        self[\"outsidetextfont\"] = val\n", "docstring": "self[\"outsidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def textangle(self, val):\n        self[\"textangle\"] = val\n", "docstring": "self[\"textangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def textinfo(self, val):\n        self[\"textinfo\"] = val\n", "docstring": "self[\"textinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def xperiod(self, val):\n        self[\"xperiod\"] = val\n", "docstring": "self[\"xperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def xperiod0(self, val):\n        self[\"xperiod0\"] = val\n", "docstring": "self[\"xperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def xperiodalignment(self, val):\n        self[\"xperiodalignment\"] = val\n", "docstring": "self[\"xperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def yperiod(self, val):\n        self[\"yperiod\"] = val\n", "docstring": "self[\"yperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def yperiod0(self, val):\n        self[\"yperiod0\"] = val\n", "docstring": "self[\"yperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def yperiodalignment(self, val):\n        self[\"yperiodalignment\"] = val\n", "docstring": "self[\"yperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def a(self, val):\n        self[\"a\"] = val\n", "docstring": "self[\"a\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def a0(self, val):\n        self[\"a0\"] = val\n", "docstring": "self[\"a0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def aaxis(self, val):\n        self[\"aaxis\"] = val\n", "docstring": "self[\"aaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def asrc(self, val):\n        self[\"asrc\"] = val\n", "docstring": "self[\"asrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def b0(self, val):\n        self[\"b0\"] = val\n", "docstring": "self[\"b0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def baxis(self, val):\n        self[\"baxis\"] = val\n", "docstring": "self[\"baxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def bsrc(self, val):\n        self[\"bsrc\"] = val\n", "docstring": "self[\"bsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def carpet(self, val):\n        self[\"carpet\"] = val\n", "docstring": "self[\"carpet\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def cheaterslope(self, val):\n        self[\"cheaterslope\"] = val\n", "docstring": "self[\"cheaterslope\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def da(self, val):\n        self[\"da\"] = val\n", "docstring": "self[\"da\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def db(self, val):\n        self[\"db\"] = val\n", "docstring": "self[\"db\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def connectgaps(self, val):\n        self[\"connectgaps\"] = val\n", "docstring": "self[\"connectgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def dx(self, val):\n        self[\"dx\"] = val\n", "docstring": "self[\"dx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def dy(self, val):\n        self[\"dy\"] = val\n", "docstring": "self[\"dy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def error_x(self, val):\n        self[\"error_x\"] = val\n", "docstring": "self[\"error_x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def error_y(self, val):\n        self[\"error_y\"] = val\n", "docstring": "self[\"error_y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def xperiod(self, val):\n        self[\"xperiod\"] = val\n", "docstring": "self[\"xperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def xperiod0(self, val):\n        self[\"xperiod0\"] = val\n", "docstring": "self[\"xperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def xperiodalignment(self, val):\n        self[\"xperiodalignment\"] = val\n", "docstring": "self[\"xperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def ycalendar(self, val):\n        self[\"ycalendar\"] = val\n", "docstring": "self[\"ycalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def yperiod(self, val):\n        self[\"yperiod\"] = val\n", "docstring": "self[\"yperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def yperiod0(self, val):\n        self[\"yperiod0\"] = val\n", "docstring": "self[\"yperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def yperiodalignment(self, val):\n        self[\"yperiodalignment\"] = val\n", "docstring": "self[\"yperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def branchvalues(self, val):\n        self[\"branchvalues\"] = val\n", "docstring": "self[\"branchvalues\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def count(self, val):\n        self[\"count\"] = val\n", "docstring": "self[\"count\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def insidetextfont(self, val):\n        self[\"insidetextfont\"] = val\n", "docstring": "self[\"insidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def labels(self, val):\n        self[\"labels\"] = val\n", "docstring": "self[\"labels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def labelssrc(self, val):\n        self[\"labelssrc\"] = val\n", "docstring": "self[\"labelssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def leaf(self, val):\n        self[\"leaf\"] = val\n", "docstring": "self[\"leaf\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def level(self, val):\n        self[\"level\"] = val\n", "docstring": "self[\"level\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def maxdepth(self, val):\n        self[\"maxdepth\"] = val\n", "docstring": "self[\"maxdepth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def outsidetextfont(self, val):\n        self[\"outsidetextfont\"] = val\n", "docstring": "self[\"outsidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def parents(self, val):\n        self[\"parents\"] = val\n", "docstring": "self[\"parents\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def parentssrc(self, val):\n        self[\"parentssrc\"] = val\n", "docstring": "self[\"parentssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def pathbar(self, val):\n        self[\"pathbar\"] = val\n", "docstring": "self[\"pathbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def root(self, val):\n        self[\"root\"] = val\n", "docstring": "self[\"root\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def sort(self, val):\n        self[\"sort\"] = val\n", "docstring": "self[\"sort\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def textinfo(self, val):\n        self[\"textinfo\"] = val\n", "docstring": "self[\"textinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def tiling(self, val):\n        self[\"tiling\"] = val\n", "docstring": "self[\"tiling\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def branchvalues(self, val):\n        self[\"branchvalues\"] = val\n", "docstring": "self[\"branchvalues\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def count(self, val):\n        self[\"count\"] = val\n", "docstring": "self[\"count\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def insidetextfont(self, val):\n        self[\"insidetextfont\"] = val\n", "docstring": "self[\"insidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def insidetextorientation(self, val):\n        self[\"insidetextorientation\"] = val\n", "docstring": "self[\"insidetextorientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def labels(self, val):\n        self[\"labels\"] = val\n", "docstring": "self[\"labels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def labelssrc(self, val):\n        self[\"labelssrc\"] = val\n", "docstring": "self[\"labelssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def leaf(self, val):\n        self[\"leaf\"] = val\n", "docstring": "self[\"leaf\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def level(self, val):\n        self[\"level\"] = val\n", "docstring": "self[\"level\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def maxdepth(self, val):\n        self[\"maxdepth\"] = val\n", "docstring": "self[\"maxdepth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def outsidetextfont(self, val):\n        self[\"outsidetextfont\"] = val\n", "docstring": "self[\"outsidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def parents(self, val):\n        self[\"parents\"] = val\n", "docstring": "self[\"parents\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def parentssrc(self, val):\n        self[\"parentssrc\"] = val\n", "docstring": "self[\"parentssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def root(self, val):\n        self[\"root\"] = val\n", "docstring": "self[\"root\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def rotation(self, val):\n        self[\"rotation\"] = val\n", "docstring": "self[\"rotation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def sort(self, val):\n        self[\"sort\"] = val\n", "docstring": "self[\"sort\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def textinfo(self, val):\n        self[\"textinfo\"] = val\n", "docstring": "self[\"textinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def below(self, val):\n        self[\"below\"] = val\n", "docstring": "self[\"below\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def featureidkey(self, val):\n        self[\"featureidkey\"] = val\n", "docstring": "self[\"featureidkey\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def geojson(self, val):\n        self[\"geojson\"] = val\n", "docstring": "self[\"geojson\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def subplot(self, val):\n        self[\"subplot\"] = val\n", "docstring": "self[\"subplot\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def zauto(self, val):\n        self[\"zauto\"] = val\n", "docstring": "self[\"zauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def zmax(self, val):\n        self[\"zmax\"] = val\n", "docstring": "self[\"zmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def zmid(self, val):\n        self[\"zmid\"] = val\n", "docstring": "self[\"zmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def zmin(self, val):\n        self[\"zmin\"] = val\n", "docstring": "self[\"zmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def autobinx(self, val):\n        self[\"autobinx\"] = val\n", "docstring": "self[\"autobinx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def autobiny(self, val):\n        self[\"autobiny\"] = val\n", "docstring": "self[\"autobiny\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def bingroup(self, val):\n        self[\"bingroup\"] = val\n", "docstring": "self[\"bingroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def histfunc(self, val):\n        self[\"histfunc\"] = val\n", "docstring": "self[\"histfunc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def histnorm(self, val):\n        self[\"histnorm\"] = val\n", "docstring": "self[\"histnorm\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def nbinsx(self, val):\n        self[\"nbinsx\"] = val\n", "docstring": "self[\"nbinsx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def nbinsy(self, val):\n        self[\"nbinsy\"] = val\n", "docstring": "self[\"nbinsy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def xbingroup(self, val):\n        self[\"xbingroup\"] = val\n", "docstring": "self[\"xbingroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def xbins(self, val):\n        self[\"xbins\"] = val\n", "docstring": "self[\"xbins\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def xgap(self, val):\n        self[\"xgap\"] = val\n", "docstring": "self[\"xgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def ybingroup(self, val):\n        self[\"ybingroup\"] = val\n", "docstring": "self[\"ybingroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def ybins(self, val):\n        self[\"ybins\"] = val\n", "docstring": "self[\"ybins\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def ycalendar(self, val):\n        self[\"ycalendar\"] = val\n", "docstring": "self[\"ycalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def ygap(self, val):\n        self[\"ygap\"] = val\n", "docstring": "self[\"ygap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def zauto(self, val):\n        self[\"zauto\"] = val\n", "docstring": "self[\"zauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def zhoverformat(self, val):\n        self[\"zhoverformat\"] = val\n", "docstring": "self[\"zhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def zmax(self, val):\n        self[\"zmax\"] = val\n", "docstring": "self[\"zmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def zmid(self, val):\n        self[\"zmid\"] = val\n", "docstring": "self[\"zmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def zmin(self, val):\n        self[\"zmin\"] = val\n", "docstring": "self[\"zmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def zsmooth(self, val):\n        self[\"zsmooth\"] = val\n", "docstring": "self[\"zsmooth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def connectgaps(self, val):\n        self[\"connectgaps\"] = val\n", "docstring": "self[\"connectgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def dr(self, val):\n        self[\"dr\"] = val\n", "docstring": "self[\"dr\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def dtheta(self, val):\n        self[\"dtheta\"] = val\n", "docstring": "self[\"dtheta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def r(self, val):\n        self[\"r\"] = val\n", "docstring": "self[\"r\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def r0(self, val):\n        self[\"r0\"] = val\n", "docstring": "self[\"r0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def rsrc(self, val):\n        self[\"rsrc\"] = val\n", "docstring": "self[\"rsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def subplot(self, val):\n        self[\"subplot\"] = val\n", "docstring": "self[\"subplot\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def theta(self, val):\n        self[\"theta\"] = val\n", "docstring": "self[\"theta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def theta0(self, val):\n        self[\"theta0\"] = val\n", "docstring": "self[\"theta0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def thetasrc(self, val):\n        self[\"thetasrc\"] = val\n", "docstring": "self[\"thetasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def thetaunit(self, val):\n        self[\"thetaunit\"] = val\n", "docstring": "self[\"thetaunit\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def arrangement(self, val):\n        self[\"arrangement\"] = val\n", "docstring": "self[\"arrangement\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def bundlecolors(self, val):\n        self[\"bundlecolors\"] = val\n", "docstring": "self[\"bundlecolors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def counts(self, val):\n        self[\"counts\"] = val\n", "docstring": "self[\"counts\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def countssrc(self, val):\n        self[\"countssrc\"] = val\n", "docstring": "self[\"countssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def dimensions(self, val):\n        self[\"dimensions\"] = val\n", "docstring": "self[\"dimensions\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def dimensiondefaults(self, val):\n        self[\"dimensiondefaults\"] = val\n", "docstring": "self[\"dimensiondefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def hoveron(self, val):\n        self[\"hoveron\"] = val\n", "docstring": "self[\"hoveron\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def labelfont(self, val):\n        self[\"labelfont\"] = val\n", "docstring": "self[\"labelfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def sortpaths(self, val):\n        self[\"sortpaths\"] = val\n", "docstring": "self[\"sortpaths\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_caps.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_caps.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_caps.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lighting.py", "original_string": "    def ambient(self, val):\n        self[\"ambient\"] = val\n", "docstring": "self[\"ambient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lighting.py", "original_string": "    def diffuse(self, val):\n        self[\"diffuse\"] = val\n", "docstring": "self[\"diffuse\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lighting.py", "original_string": "    def facenormalsepsilon(self, val):\n        self[\"facenormalsepsilon\"] = val\n", "docstring": "self[\"facenormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lighting.py", "original_string": "    def fresnel(self, val):\n        self[\"fresnel\"] = val\n", "docstring": "self[\"fresnel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lighting.py", "original_string": "    def roughness(self, val):\n        self[\"roughness\"] = val\n", "docstring": "self[\"roughness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lighting.py", "original_string": "    def specular(self, val):\n        self[\"specular\"] = val\n", "docstring": "self[\"specular\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lighting.py", "original_string": "    def vertexnormalsepsilon(self, val):\n        self[\"vertexnormalsepsilon\"] = val\n", "docstring": "self[\"vertexnormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_spaceframe.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_spaceframe.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_contour.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_contour.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_contour.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_surface.py", "original_string": "    def count(self, val):\n        self[\"count\"] = val\n", "docstring": "self[\"count\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_surface.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_surface.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_surface.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_slices.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_slices.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_slices.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lightposition.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lightposition.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lightposition.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/caps/_z.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/caps/_z.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/caps/_x.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/caps/_x.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/caps/_y.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/caps/_y.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_z.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_z.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_z.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_z.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_x.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_x.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_x.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_x.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_y.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_y.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_y.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_y.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def gradient(self, val):\n        self[\"gradient\"] = val\n", "docstring": "self[\"gradient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def maxdisplayed(self, val):\n        self[\"maxdisplayed\"] = val\n", "docstring": "self[\"maxdisplayed\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_line.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_line.py", "original_string": "    def smoothing(self, val):\n        self[\"smoothing\"] = val\n", "docstring": "self[\"smoothing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_gradient.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_gradient.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_gradient.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_gradient.py", "original_string": "    def typesrc(self, val):\n        self[\"typesrc\"] = val\n", "docstring": "self[\"typesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_line.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def copy_ystyle(self, val):\n        self[\"copy_ystyle\"] = val\n", "docstring": "self[\"copy_ystyle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_xbins.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_xbins.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_xbins.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_ybins.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_ybins.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_ybins.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lighting.py", "original_string": "    def ambient(self, val):\n        self[\"ambient\"] = val\n", "docstring": "self[\"ambient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lighting.py", "original_string": "    def diffuse(self, val):\n        self[\"diffuse\"] = val\n", "docstring": "self[\"diffuse\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lighting.py", "original_string": "    def facenormalsepsilon(self, val):\n        self[\"facenormalsepsilon\"] = val\n", "docstring": "self[\"facenormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lighting.py", "original_string": "    def fresnel(self, val):\n        self[\"fresnel\"] = val\n", "docstring": "self[\"fresnel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lighting.py", "original_string": "    def roughness(self, val):\n        self[\"roughness\"] = val\n", "docstring": "self[\"roughness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lighting.py", "original_string": "    def specular(self, val):\n        self[\"specular\"] = val\n", "docstring": "self[\"specular\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lighting.py", "original_string": "    def vertexnormalsepsilon(self, val):\n        self[\"vertexnormalsepsilon\"] = val\n", "docstring": "self[\"vertexnormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_contour.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_contour.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_contour.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lightposition.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lightposition.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lightposition.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def groups(self, val):\n        self[\"groups\"] = val\n", "docstring": "self[\"groups\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def labelsrc(self, val):\n        self[\"labelsrc\"] = val\n", "docstring": "self[\"labelsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def colorscales(self, val):\n        self[\"colorscales\"] = val\n", "docstring": "self[\"colorscales\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def colorscaledefaults(self, val):\n        self[\"colorscaledefaults\"] = val\n", "docstring": "self[\"colorscaledefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def labelsrc(self, val):\n        self[\"labelsrc\"] = val\n", "docstring": "self[\"labelsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def source(self, val):\n        self[\"source\"] = val\n", "docstring": "self[\"source\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def sourcesrc(self, val):\n        self[\"sourcesrc\"] = val\n", "docstring": "self[\"sourcesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def target(self, val):\n        self[\"target\"] = val\n", "docstring": "self[\"target\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def targetsrc(self, val):\n        self[\"targetsrc\"] = val\n", "docstring": "self[\"targetsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def valuesrc(self, val):\n        self[\"valuesrc\"] = val\n", "docstring": "self[\"valuesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_colorscale.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_colorscale.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_colorscale.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_colorscale.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_colorscale.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_colorscale.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_title.py", "original_string": "    def position(self, val):\n        self[\"position\"] = val\n", "docstring": "self[\"position\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_marker.py", "original_string": "    def colors(self, val):\n        self[\"colors\"] = val\n", "docstring": "self[\"colors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_marker.py", "original_string": "    def colorssrc(self, val):\n        self[\"colorssrc\"] = val\n", "docstring": "self[\"colorssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/title/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/title/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/title/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def format(self, val):\n        self[\"format\"] = val\n", "docstring": "self[\"format\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def formatsrc(self, val):\n        self[\"formatsrc\"] = val\n", "docstring": "self[\"formatsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def height(self, val):\n        self[\"height\"] = val\n", "docstring": "self[\"height\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def prefix(self, val):\n        self[\"prefix\"] = val\n", "docstring": "self[\"prefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def prefixsrc(self, val):\n        self[\"prefixsrc\"] = val\n", "docstring": "self[\"prefixsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def suffix(self, val):\n        self[\"suffix\"] = val\n", "docstring": "self[\"suffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def suffixsrc(self, val):\n        self[\"suffixsrc\"] = val\n", "docstring": "self[\"suffixsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def format(self, val):\n        self[\"format\"] = val\n", "docstring": "self[\"format\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def formatsrc(self, val):\n        self[\"formatsrc\"] = val\n", "docstring": "self[\"formatsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def height(self, val):\n        self[\"height\"] = val\n", "docstring": "self[\"height\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def prefix(self, val):\n        self[\"prefix\"] = val\n", "docstring": "self[\"prefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def prefixsrc(self, val):\n        self[\"prefixsrc\"] = val\n", "docstring": "self[\"prefixsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def suffix(self, val):\n        self[\"suffix\"] = val\n", "docstring": "self[\"suffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def suffixsrc(self, val):\n        self[\"suffixsrc\"] = val\n", "docstring": "self[\"suffixsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_fill.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_fill.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_fill.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_fill.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_xbins.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_xbins.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_xbins.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_ybins.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_ybins.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_ybins.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_cumulative.py", "original_string": "    def currentbin(self, val):\n        self[\"currentbin\"] = val\n", "docstring": "self[\"currentbin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_cumulative.py", "original_string": "    def direction(self, val):\n        self[\"direction\"] = val\n", "docstring": "self[\"direction\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_cumulative.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def copy_ystyle(self, val):\n        self[\"copy_ystyle\"] = val\n", "docstring": "self[\"copy_ystyle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def fgcolor(self, val):\n        self[\"fgcolor\"] = val\n", "docstring": "self[\"fgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def fgcolorsrc(self, val):\n        self[\"fgcolorsrc\"] = val\n", "docstring": "self[\"fgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def fgopacity(self, val):\n        self[\"fgopacity\"] = val\n", "docstring": "self[\"fgopacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def fillmode(self, val):\n        self[\"fillmode\"] = val\n", "docstring": "self[\"fillmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def shapesrc(self, val):\n        self[\"shapesrc\"] = val\n", "docstring": "self[\"shapesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def solidity(self, val):\n        self[\"solidity\"] = val\n", "docstring": "self[\"solidity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def soliditysrc(self, val):\n        self[\"soliditysrc\"] = val\n", "docstring": "self[\"soliditysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_outsidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_outsidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_outsidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_outsidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_outsidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_outsidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def colors(self, val):\n        self[\"colors\"] = val\n", "docstring": "self[\"colors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def colorssrc(self, val):\n        self[\"colorssrc\"] = val\n", "docstring": "self[\"colorssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_leaf.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_root.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_dimension.py", "original_string": "    def axis(self, val):\n        self[\"axis\"] = val\n", "docstring": "self[\"axis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_dimension.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_dimension.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_dimension.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_dimension.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_dimension.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_dimension.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_diagonal.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/dimension/_axis.py", "original_string": "    def matches(self, val):\n        self[\"matches\"] = val\n", "docstring": "self[\"matches\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/dimension/_axis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def xref(self, val):\n        self[\"xref\"] = val\n", "docstring": "self[\"xref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def yref(self, val):\n        self[\"yref\"] = val\n", "docstring": "self[\"yref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_ternary.py", "original_string": "    def aaxis(self, val):\n        self[\"aaxis\"] = val\n", "docstring": "self[\"aaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_ternary.py", "original_string": "    def baxis(self, val):\n        self[\"baxis\"] = val\n", "docstring": "self[\"baxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_ternary.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_ternary.py", "original_string": "    def caxis(self, val):\n        self[\"caxis\"] = val\n", "docstring": "self[\"caxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_ternary.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_ternary.py", "original_string": "    def sum(self, val):\n        self[\"sum\"] = val\n", "docstring": "self[\"sum\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_ternary.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_colorscale.py", "original_string": "    def diverging(self, val):\n        self[\"diverging\"] = val\n", "docstring": "self[\"diverging\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_colorscale.py", "original_string": "    def sequential(self, val):\n        self[\"sequential\"] = val\n", "docstring": "self[\"sequential\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_colorscale.py", "original_string": "    def sequentialminus(self, val):\n        self[\"sequentialminus\"] = val\n", "docstring": "self[\"sequentialminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_uniformtext.py", "original_string": "    def minsize(self, val):\n        self[\"minsize\"] = val\n", "docstring": "self[\"minsize\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_uniformtext.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def active(self, val):\n        self[\"active\"] = val\n", "docstring": "self[\"active\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def buttons(self, val):\n        self[\"buttons\"] = val\n", "docstring": "self[\"buttons\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def buttondefaults(self, val):\n        self[\"buttondefaults\"] = val\n", "docstring": "self[\"buttondefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def direction(self, val):\n        self[\"direction\"] = val\n", "docstring": "self[\"direction\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def showactive(self, val):\n        self[\"showactive\"] = val\n", "docstring": "self[\"showactive\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def annotations(self, val):\n        self[\"annotations\"] = val\n", "docstring": "self[\"annotations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def annotationdefaults(self, val):\n        self[\"annotationdefaults\"] = val\n", "docstring": "self[\"annotationdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def aspectmode(self, val):\n        self[\"aspectmode\"] = val\n", "docstring": "self[\"aspectmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def aspectratio(self, val):\n        self[\"aspectratio\"] = val\n", "docstring": "self[\"aspectratio\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def camera(self, val):\n        self[\"camera\"] = val\n", "docstring": "self[\"camera\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def dragmode(self, val):\n        self[\"dragmode\"] = val\n", "docstring": "self[\"dragmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def hovermode(self, val):\n        self[\"hovermode\"] = val\n", "docstring": "self[\"hovermode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def zaxis(self, val):\n        self[\"zaxis\"] = val\n", "docstring": "self[\"zaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def sizex(self, val):\n        self[\"sizex\"] = val\n", "docstring": "self[\"sizex\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def sizey(self, val):\n        self[\"sizey\"] = val\n", "docstring": "self[\"sizey\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def sizing(self, val):\n        self[\"sizing\"] = val\n", "docstring": "self[\"sizing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def source(self, val):\n        self[\"source\"] = val\n", "docstring": "self[\"source\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def xref(self, val):\n        self[\"xref\"] = val\n", "docstring": "self[\"xref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def yref(self, val):\n        self[\"yref\"] = val\n", "docstring": "self[\"yref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def activecolor(self, val):\n        self[\"activecolor\"] = val\n", "docstring": "self[\"activecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def add(self, val):\n        self[\"add\"] = val\n", "docstring": "self[\"add\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def addsrc(self, val):\n        self[\"addsrc\"] = val\n", "docstring": "self[\"addsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def orientation(self, val):\n        self[\"orientation\"] = val\n", "docstring": "self[\"orientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def remove(self, val):\n        self[\"remove\"] = val\n", "docstring": "self[\"remove\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def removesrc(self, val):\n        self[\"removesrc\"] = val\n", "docstring": "self[\"removesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_margin.py", "original_string": "    def autoexpand(self, val):\n        self[\"autoexpand\"] = val\n", "docstring": "self[\"autoexpand\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_margin.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_margin.py", "original_string": "    def l(self, val):\n        self[\"l\"] = val\n", "docstring": "self[\"l\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_margin.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_margin.py", "original_string": "    def r(self, val):\n        self[\"r\"] = val\n", "docstring": "self[\"r\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_margin.py", "original_string": "    def t(self, val):\n        self[\"t\"] = val\n", "docstring": "self[\"t\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def center(self, val):\n        self[\"center\"] = val\n", "docstring": "self[\"center\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def coastlinecolor(self, val):\n        self[\"coastlinecolor\"] = val\n", "docstring": "self[\"coastlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def coastlinewidth(self, val):\n        self[\"coastlinewidth\"] = val\n", "docstring": "self[\"coastlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def countrycolor(self, val):\n        self[\"countrycolor\"] = val\n", "docstring": "self[\"countrycolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def countrywidth(self, val):\n        self[\"countrywidth\"] = val\n", "docstring": "self[\"countrywidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def fitbounds(self, val):\n        self[\"fitbounds\"] = val\n", "docstring": "self[\"fitbounds\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def framecolor(self, val):\n        self[\"framecolor\"] = val\n", "docstring": "self[\"framecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def framewidth(self, val):\n        self[\"framewidth\"] = val\n", "docstring": "self[\"framewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def lakecolor(self, val):\n        self[\"lakecolor\"] = val\n", "docstring": "self[\"lakecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def landcolor(self, val):\n        self[\"landcolor\"] = val\n", "docstring": "self[\"landcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def lataxis(self, val):\n        self[\"lataxis\"] = val\n", "docstring": "self[\"lataxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def lonaxis(self, val):\n        self[\"lonaxis\"] = val\n", "docstring": "self[\"lonaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def oceancolor(self, val):\n        self[\"oceancolor\"] = val\n", "docstring": "self[\"oceancolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def projection(self, val):\n        self[\"projection\"] = val\n", "docstring": "self[\"projection\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def resolution(self, val):\n        self[\"resolution\"] = val\n", "docstring": "self[\"resolution\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def rivercolor(self, val):\n        self[\"rivercolor\"] = val\n", "docstring": "self[\"rivercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def riverwidth(self, val):\n        self[\"riverwidth\"] = val\n", "docstring": "self[\"riverwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def scope(self, val):\n        self[\"scope\"] = val\n", "docstring": "self[\"scope\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showcoastlines(self, val):\n        self[\"showcoastlines\"] = val\n", "docstring": "self[\"showcoastlines\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showcountries(self, val):\n        self[\"showcountries\"] = val\n", "docstring": "self[\"showcountries\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showframe(self, val):\n        self[\"showframe\"] = val\n", "docstring": "self[\"showframe\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showlakes(self, val):\n        self[\"showlakes\"] = val\n", "docstring": "self[\"showlakes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showland(self, val):\n        self[\"showland\"] = val\n", "docstring": "self[\"showland\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showocean(self, val):\n        self[\"showocean\"] = val\n", "docstring": "self[\"showocean\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showrivers(self, val):\n        self[\"showrivers\"] = val\n", "docstring": "self[\"showrivers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showsubunits(self, val):\n        self[\"showsubunits\"] = val\n", "docstring": "self[\"showsubunits\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def subunitcolor(self, val):\n        self[\"subunitcolor\"] = val\n", "docstring": "self[\"subunitcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def subunitwidth(self, val):\n        self[\"subunitwidth\"] = val\n", "docstring": "self[\"subunitwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_newshape.py", "original_string": "    def drawdirection(self, val):\n        self[\"drawdirection\"] = val\n", "docstring": "self[\"drawdirection\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_newshape.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_newshape.py", "original_string": "    def fillrule(self, val):\n        self[\"fillrule\"] = val\n", "docstring": "self[\"fillrule\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_newshape.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_newshape.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_newshape.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def accesstoken(self, val):\n        self[\"accesstoken\"] = val\n", "docstring": "self[\"accesstoken\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def bearing(self, val):\n        self[\"bearing\"] = val\n", "docstring": "self[\"bearing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def center(self, val):\n        self[\"center\"] = val\n", "docstring": "self[\"center\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def layers(self, val):\n        self[\"layers\"] = val\n", "docstring": "self[\"layers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def layerdefaults(self, val):\n        self[\"layerdefaults\"] = val\n", "docstring": "self[\"layerdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def pitch(self, val):\n        self[\"pitch\"] = val\n", "docstring": "self[\"pitch\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def style(self, val):\n        self[\"style\"] = val\n", "docstring": "self[\"style\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def zoom(self, val):\n        self[\"zoom\"] = val\n", "docstring": "self[\"zoom\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def arrowcolor(self, val):\n        self[\"arrowcolor\"] = val\n", "docstring": "self[\"arrowcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def arrowhead(self, val):\n        self[\"arrowhead\"] = val\n", "docstring": "self[\"arrowhead\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def arrowside(self, val):\n        self[\"arrowside\"] = val\n", "docstring": "self[\"arrowside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def arrowsize(self, val):\n        self[\"arrowsize\"] = val\n", "docstring": "self[\"arrowsize\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def arrowwidth(self, val):\n        self[\"arrowwidth\"] = val\n", "docstring": "self[\"arrowwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def ax(self, val):\n        self[\"ax\"] = val\n", "docstring": "self[\"ax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def axref(self, val):\n        self[\"axref\"] = val\n", "docstring": "self[\"axref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def ay(self, val):\n        self[\"ay\"] = val\n", "docstring": "self[\"ay\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def ayref(self, val):\n        self[\"ayref\"] = val\n", "docstring": "self[\"ayref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def borderpad(self, val):\n        self[\"borderpad\"] = val\n", "docstring": "self[\"borderpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def captureevents(self, val):\n        self[\"captureevents\"] = val\n", "docstring": "self[\"captureevents\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def clicktoshow(self, val):\n        self[\"clicktoshow\"] = val\n", "docstring": "self[\"clicktoshow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def height(self, val):\n        self[\"height\"] = val\n", "docstring": "self[\"height\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def showarrow(self, val):\n        self[\"showarrow\"] = val\n", "docstring": "self[\"showarrow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def standoff(self, val):\n        self[\"standoff\"] = val\n", "docstring": "self[\"standoff\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def startarrowhead(self, val):\n        self[\"startarrowhead\"] = val\n", "docstring": "self[\"startarrowhead\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def startarrowsize(self, val):\n        self[\"startarrowsize\"] = val\n", "docstring": "self[\"startarrowsize\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def startstandoff(self, val):\n        self[\"startstandoff\"] = val\n", "docstring": "self[\"startstandoff\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def textangle(self, val):\n        self[\"textangle\"] = val\n", "docstring": "self[\"textangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def valign(self, val):\n        self[\"valign\"] = val\n", "docstring": "self[\"valign\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def xclick(self, val):\n        self[\"xclick\"] = val\n", "docstring": "self[\"xclick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def xref(self, val):\n        self[\"xref\"] = val\n", "docstring": "self[\"xref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def xshift(self, val):\n        self[\"xshift\"] = val\n", "docstring": "self[\"xshift\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def yclick(self, val):\n        self[\"yclick\"] = val\n", "docstring": "self[\"yclick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def yref(self, val):\n        self[\"yref\"] = val\n", "docstring": "self[\"yref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def yshift(self, val):\n        self[\"yshift\"] = val\n", "docstring": "self[\"yshift\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_template.py", "original_string": "    def data(self, val):\n        self[\"data\"] = val\n", "docstring": "self[\"data\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_template.py", "original_string": "    def layout(self, val):\n        self[\"layout\"] = val\n", "docstring": "self[\"layout\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def active(self, val):\n        self[\"active\"] = val\n", "docstring": "self[\"active\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def activebgcolor(self, val):\n        self[\"activebgcolor\"] = val\n", "docstring": "self[\"activebgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def currentvalue(self, val):\n        self[\"currentvalue\"] = val\n", "docstring": "self[\"currentvalue\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def minorticklen(self, val):\n        self[\"minorticklen\"] = val\n", "docstring": "self[\"minorticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def steps(self, val):\n        self[\"steps\"] = val\n", "docstring": "self[\"steps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def stepdefaults(self, val):\n        self[\"stepdefaults\"] = val\n", "docstring": "self[\"stepdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def transition(self, val):\n        self[\"transition\"] = val\n", "docstring": "self[\"transition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def columns(self, val):\n        self[\"columns\"] = val\n", "docstring": "self[\"columns\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def roworder(self, val):\n        self[\"roworder\"] = val\n", "docstring": "self[\"roworder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def rows(self, val):\n        self[\"rows\"] = val\n", "docstring": "self[\"rows\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def subplots(self, val):\n        self[\"subplots\"] = val\n", "docstring": "self[\"subplots\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def xaxes(self, val):\n        self[\"xaxes\"] = val\n", "docstring": "self[\"xaxes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def xgap(self, val):\n        self[\"xgap\"] = val\n", "docstring": "self[\"xgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def xside(self, val):\n        self[\"xside\"] = val\n", "docstring": "self[\"xside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def yaxes(self, val):\n        self[\"yaxes\"] = val\n", "docstring": "self[\"yaxes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def ygap(self, val):\n        self[\"ygap\"] = val\n", "docstring": "self[\"ygap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def yside(self, val):\n        self[\"yside\"] = val\n", "docstring": "self[\"yside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_transition.py", "original_string": "    def duration(self, val):\n        self[\"duration\"] = val\n", "docstring": "self[\"duration\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_transition.py", "original_string": "    def easing(self, val):\n        self[\"easing\"] = val\n", "docstring": "self[\"easing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_transition.py", "original_string": "    def ordering(self, val):\n        self[\"ordering\"] = val\n", "docstring": "self[\"ordering\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def editable(self, val):\n        self[\"editable\"] = val\n", "docstring": "self[\"editable\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def fillrule(self, val):\n        self[\"fillrule\"] = val\n", "docstring": "self[\"fillrule\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def path(self, val):\n        self[\"path\"] = val\n", "docstring": "self[\"path\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def x1(self, val):\n        self[\"x1\"] = val\n", "docstring": "self[\"x1\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def xref(self, val):\n        self[\"xref\"] = val\n", "docstring": "self[\"xref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def xsizemode(self, val):\n        self[\"xsizemode\"] = val\n", "docstring": "self[\"xsizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def y1(self, val):\n        self[\"y1\"] = val\n", "docstring": "self[\"y1\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def yref(self, val):\n        self[\"yref\"] = val\n", "docstring": "self[\"yref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def ysizemode(self, val):\n        self[\"ysizemode\"] = val\n", "docstring": "self[\"ysizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def anchor(self, val):\n        self[\"anchor\"] = val\n", "docstring": "self[\"anchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def automargin(self, val):\n        self[\"automargin\"] = val\n", "docstring": "self[\"automargin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def calendar(self, val):\n        self[\"calendar\"] = val\n", "docstring": "self[\"calendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def constrain(self, val):\n        self[\"constrain\"] = val\n", "docstring": "self[\"constrain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def constraintoward(self, val):\n        self[\"constraintoward\"] = val\n", "docstring": "self[\"constraintoward\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def dividercolor(self, val):\n        self[\"dividercolor\"] = val\n", "docstring": "self[\"dividercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def dividerwidth(self, val):\n        self[\"dividerwidth\"] = val\n", "docstring": "self[\"dividerwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def fixedrange(self, val):\n        self[\"fixedrange\"] = val\n", "docstring": "self[\"fixedrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def matches(self, val):\n        self[\"matches\"] = val\n", "docstring": "self[\"matches\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def mirror(self, val):\n        self[\"mirror\"] = val\n", "docstring": "self[\"mirror\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def overlaying(self, val):\n        self[\"overlaying\"] = val\n", "docstring": "self[\"overlaying\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def position(self, val):\n        self[\"position\"] = val\n", "docstring": "self[\"position\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def rangebreaks(self, val):\n        self[\"rangebreaks\"] = val\n", "docstring": "self[\"rangebreaks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def rangebreakdefaults(self, val):\n        self[\"rangebreakdefaults\"] = val\n", "docstring": "self[\"rangebreakdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def scaleanchor(self, val):\n        self[\"scaleanchor\"] = val\n", "docstring": "self[\"scaleanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def scaleratio(self, val):\n        self[\"scaleratio\"] = val\n", "docstring": "self[\"scaleratio\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showdividers(self, val):\n        self[\"showdividers\"] = val\n", "docstring": "self[\"showdividers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showspikes(self, val):\n        self[\"showspikes\"] = val\n", "docstring": "self[\"showspikes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def spikecolor(self, val):\n        self[\"spikecolor\"] = val\n", "docstring": "self[\"spikecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def spikedash(self, val):\n        self[\"spikedash\"] = val\n", "docstring": "self[\"spikedash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def spikemode(self, val):\n        self[\"spikemode\"] = val\n", "docstring": "self[\"spikemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def spikesnap(self, val):\n        self[\"spikesnap\"] = val\n", "docstring": "self[\"spikesnap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def spikethickness(self, val):\n        self[\"spikethickness\"] = val\n", "docstring": "self[\"spikethickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticklabelmode(self, val):\n        self[\"ticklabelmode\"] = val\n", "docstring": "self[\"ticklabelmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickson(self, val):\n        self[\"tickson\"] = val\n", "docstring": "self[\"tickson\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def zeroline(self, val):\n        self[\"zeroline\"] = val\n", "docstring": "self[\"zeroline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def zerolinecolor(self, val):\n        self[\"zerolinecolor\"] = val\n", "docstring": "self[\"zerolinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def zerolinewidth(self, val):\n        self[\"zerolinewidth\"] = val\n", "docstring": "self[\"zerolinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def angularaxis(self, val):\n        self[\"angularaxis\"] = val\n", "docstring": "self[\"angularaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def bargap(self, val):\n        self[\"bargap\"] = val\n", "docstring": "self[\"bargap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def barmode(self, val):\n        self[\"barmode\"] = val\n", "docstring": "self[\"barmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def gridshape(self, val):\n        self[\"gridshape\"] = val\n", "docstring": "self[\"gridshape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def hole(self, val):\n        self[\"hole\"] = val\n", "docstring": "self[\"hole\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def radialaxis(self, val):\n        self[\"radialaxis\"] = val\n", "docstring": "self[\"radialaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def sector(self, val):\n        self[\"sector\"] = val\n", "docstring": "self[\"sector\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def itemclick(self, val):\n        self[\"itemclick\"] = val\n", "docstring": "self[\"itemclick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def itemdoubleclick(self, val):\n        self[\"itemdoubleclick\"] = val\n", "docstring": "self[\"itemdoubleclick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def itemsizing(self, val):\n        self[\"itemsizing\"] = val\n", "docstring": "self[\"itemsizing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def itemwidth(self, val):\n        self[\"itemwidth\"] = val\n", "docstring": "self[\"itemwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def orientation(self, val):\n        self[\"orientation\"] = val\n", "docstring": "self[\"orientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def tracegroupgap(self, val):\n        self[\"tracegroupgap\"] = val\n", "docstring": "self[\"tracegroupgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def traceorder(self, val):\n        self[\"traceorder\"] = val\n", "docstring": "self[\"traceorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def valign(self, val):\n        self[\"valign\"] = val\n", "docstring": "self[\"valign\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_activeshape.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_activeshape.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def anchor(self, val):\n        self[\"anchor\"] = val\n", "docstring": "self[\"anchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def automargin(self, val):\n        self[\"automargin\"] = val\n", "docstring": "self[\"automargin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def calendar(self, val):\n        self[\"calendar\"] = val\n", "docstring": "self[\"calendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def constrain(self, val):\n        self[\"constrain\"] = val\n", "docstring": "self[\"constrain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def constraintoward(self, val):\n        self[\"constraintoward\"] = val\n", "docstring": "self[\"constraintoward\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def dividercolor(self, val):\n        self[\"dividercolor\"] = val\n", "docstring": "self[\"dividercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def dividerwidth(self, val):\n        self[\"dividerwidth\"] = val\n", "docstring": "self[\"dividerwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def fixedrange(self, val):\n        self[\"fixedrange\"] = val\n", "docstring": "self[\"fixedrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def matches(self, val):\n        self[\"matches\"] = val\n", "docstring": "self[\"matches\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def mirror(self, val):\n        self[\"mirror\"] = val\n", "docstring": "self[\"mirror\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def overlaying(self, val):\n        self[\"overlaying\"] = val\n", "docstring": "self[\"overlaying\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def position(self, val):\n        self[\"position\"] = val\n", "docstring": "self[\"position\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def rangebreaks(self, val):\n        self[\"rangebreaks\"] = val\n", "docstring": "self[\"rangebreaks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def rangebreakdefaults(self, val):\n        self[\"rangebreakdefaults\"] = val\n", "docstring": "self[\"rangebreakdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def rangeselector(self, val):\n        self[\"rangeselector\"] = val\n", "docstring": "self[\"rangeselector\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def rangeslider(self, val):\n        self[\"rangeslider\"] = val\n", "docstring": "self[\"rangeslider\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def scaleanchor(self, val):\n        self[\"scaleanchor\"] = val\n", "docstring": "self[\"scaleanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def scaleratio(self, val):\n        self[\"scaleratio\"] = val\n", "docstring": "self[\"scaleratio\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showdividers(self, val):\n        self[\"showdividers\"] = val\n", "docstring": "self[\"showdividers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showspikes(self, val):\n        self[\"showspikes\"] = val\n", "docstring": "self[\"showspikes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def spikecolor(self, val):\n        self[\"spikecolor\"] = val\n", "docstring": "self[\"spikecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def spikedash(self, val):\n        self[\"spikedash\"] = val\n", "docstring": "self[\"spikedash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def spikemode(self, val):\n        self[\"spikemode\"] = val\n", "docstring": "self[\"spikemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def spikesnap(self, val):\n        self[\"spikesnap\"] = val\n", "docstring": "self[\"spikesnap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def spikethickness(self, val):\n        self[\"spikethickness\"] = val\n", "docstring": "self[\"spikethickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticklabelmode(self, val):\n        self[\"ticklabelmode\"] = val\n", "docstring": "self[\"ticklabelmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickson(self, val):\n        self[\"tickson\"] = val\n", "docstring": "self[\"tickson\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def zeroline(self, val):\n        self[\"zeroline\"] = val\n", "docstring": "self[\"zeroline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def zerolinecolor(self, val):\n        self[\"zerolinecolor\"] = val\n", "docstring": "self[\"zerolinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def zerolinewidth(self, val):\n        self[\"zerolinewidth\"] = val\n", "docstring": "self[\"zerolinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/grid/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/grid/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/newshape/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/newshape/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/newshape/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def backgroundcolor(self, val):\n        self[\"backgroundcolor\"] = val\n", "docstring": "self[\"backgroundcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def calendar(self, val):\n        self[\"calendar\"] = val\n", "docstring": "self[\"calendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def mirror(self, val):\n        self[\"mirror\"] = val\n", "docstring": "self[\"mirror\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showaxeslabels(self, val):\n        self[\"showaxeslabels\"] = val\n", "docstring": "self[\"showaxeslabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showbackground(self, val):\n        self[\"showbackground\"] = val\n", "docstring": "self[\"showbackground\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showspikes(self, val):\n        self[\"showspikes\"] = val\n", "docstring": "self[\"showspikes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def spikecolor(self, val):\n        self[\"spikecolor\"] = val\n", "docstring": "self[\"spikecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def spikesides(self, val):\n        self[\"spikesides\"] = val\n", "docstring": "self[\"spikesides\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def spikethickness(self, val):\n        self[\"spikethickness\"] = val\n", "docstring": "self[\"spikethickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def zeroline(self, val):\n        self[\"zeroline\"] = val\n", "docstring": "self[\"zeroline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def zerolinecolor(self, val):\n        self[\"zerolinecolor\"] = val\n", "docstring": "self[\"zerolinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def zerolinewidth(self, val):\n        self[\"zerolinewidth\"] = val\n", "docstring": "self[\"zerolinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_aspectratio.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_aspectratio.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_aspectratio.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_camera.py", "original_string": "    def center(self, val):\n        self[\"center\"] = val\n", "docstring": "self[\"center\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_camera.py", "original_string": "    def eye(self, val):\n        self[\"eye\"] = val\n", "docstring": "self[\"eye\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_camera.py", "original_string": "    def projection(self, val):\n        self[\"projection\"] = val\n", "docstring": "self[\"projection\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_camera.py", "original_string": "    def up(self, val):\n        self[\"up\"] = val\n", "docstring": "self[\"up\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def arrowcolor(self, val):\n        self[\"arrowcolor\"] = val\n", "docstring": "self[\"arrowcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def arrowhead(self, val):\n        self[\"arrowhead\"] = val\n", "docstring": "self[\"arrowhead\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def arrowside(self, val):\n        self[\"arrowside\"] = val\n", "docstring": "self[\"arrowside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def arrowsize(self, val):\n        self[\"arrowsize\"] = val\n", "docstring": "self[\"arrowsize\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def arrowwidth(self, val):\n        self[\"arrowwidth\"] = val\n", "docstring": "self[\"arrowwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def ax(self, val):\n        self[\"ax\"] = val\n", "docstring": "self[\"ax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def ay(self, val):\n        self[\"ay\"] = val\n", "docstring": "self[\"ay\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def borderpad(self, val):\n        self[\"borderpad\"] = val\n", "docstring": "self[\"borderpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def captureevents(self, val):\n        self[\"captureevents\"] = val\n", "docstring": "self[\"captureevents\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def height(self, val):\n        self[\"height\"] = val\n", "docstring": "self[\"height\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def showarrow(self, val):\n        self[\"showarrow\"] = val\n", "docstring": "self[\"showarrow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def standoff(self, val):\n        self[\"standoff\"] = val\n", "docstring": "self[\"standoff\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def startarrowhead(self, val):\n        self[\"startarrowhead\"] = val\n", "docstring": "self[\"startarrowhead\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def startarrowsize(self, val):\n        self[\"startarrowsize\"] = val\n", "docstring": "self[\"startarrowsize\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def startstandoff(self, val):\n        self[\"startstandoff\"] = val\n", "docstring": "self[\"startstandoff\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def textangle(self, val):\n        self[\"textangle\"] = val\n", "docstring": "self[\"textangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def valign(self, val):\n        self[\"valign\"] = val\n", "docstring": "self[\"valign\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def xshift(self, val):\n        self[\"xshift\"] = val\n", "docstring": "self[\"xshift\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def yshift(self, val):\n        self[\"yshift\"] = val\n", "docstring": "self[\"yshift\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def backgroundcolor(self, val):\n        self[\"backgroundcolor\"] = val\n", "docstring": "self[\"backgroundcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def calendar(self, val):\n        self[\"calendar\"] = val\n", "docstring": "self[\"calendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def mirror(self, val):\n        self[\"mirror\"] = val\n", "docstring": "self[\"mirror\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showaxeslabels(self, val):\n        self[\"showaxeslabels\"] = val\n", "docstring": "self[\"showaxeslabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showbackground(self, val):\n        self[\"showbackground\"] = val\n", "docstring": "self[\"showbackground\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showspikes(self, val):\n        self[\"showspikes\"] = val\n", "docstring": "self[\"showspikes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def spikecolor(self, val):\n        self[\"spikecolor\"] = val\n", "docstring": "self[\"spikecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def spikesides(self, val):\n        self[\"spikesides\"] = val\n", "docstring": "self[\"spikesides\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def spikethickness(self, val):\n        self[\"spikethickness\"] = val\n", "docstring": "self[\"spikethickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def zeroline(self, val):\n        self[\"zeroline\"] = val\n", "docstring": "self[\"zeroline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def zerolinecolor(self, val):\n        self[\"zerolinecolor\"] = val\n", "docstring": "self[\"zerolinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def zerolinewidth(self, val):\n        self[\"zerolinewidth\"] = val\n", "docstring": "self[\"zerolinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def backgroundcolor(self, val):\n        self[\"backgroundcolor\"] = val\n", "docstring": "self[\"backgroundcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def calendar(self, val):\n        self[\"calendar\"] = val\n", "docstring": "self[\"calendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def mirror(self, val):\n        self[\"mirror\"] = val\n", "docstring": "self[\"mirror\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showaxeslabels(self, val):\n        self[\"showaxeslabels\"] = val\n", "docstring": "self[\"showaxeslabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showbackground(self, val):\n        self[\"showbackground\"] = val\n", "docstring": "self[\"showbackground\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showspikes(self, val):\n        self[\"showspikes\"] = val\n", "docstring": "self[\"showspikes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def spikecolor(self, val):\n        self[\"spikecolor\"] = val\n", "docstring": "self[\"spikecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def spikesides(self, val):\n        self[\"spikesides\"] = val\n", "docstring": "self[\"spikesides\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def spikethickness(self, val):\n        self[\"spikethickness\"] = val\n", "docstring": "self[\"spikethickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def zeroline(self, val):\n        self[\"zeroline\"] = val\n", "docstring": "self[\"zeroline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def zerolinecolor(self, val):\n        self[\"zerolinecolor\"] = val\n", "docstring": "self[\"zerolinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def zerolinewidth(self, val):\n        self[\"zerolinewidth\"] = val\n", "docstring": "self[\"zerolinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_projection.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_up.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_up.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_up.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_center.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_center.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_center.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_eye.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_eye.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_eye.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def angle(self, val):\n        self[\"angle\"] = val\n", "docstring": "self[\"angle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def calendar(self, val):\n        self[\"calendar\"] = val\n", "docstring": "self[\"calendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def direction(self, val):\n        self[\"direction\"] = val\n", "docstring": "self[\"direction\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def period(self, val):\n        self[\"period\"] = val\n", "docstring": "self[\"period\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def rotation(self, val):\n        self[\"rotation\"] = val\n", "docstring": "self[\"rotation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def thetaunit(self, val):\n        self[\"thetaunit\"] = val\n", "docstring": "self[\"thetaunit\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_pad.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_pad.py", "original_string": "    def l(self, val):\n        self[\"l\"] = val\n", "docstring": "self[\"l\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_pad.py", "original_string": "    def r(self, val):\n        self[\"r\"] = val\n", "docstring": "self[\"r\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_pad.py", "original_string": "    def t(self, val):\n        self[\"t\"] = val\n", "docstring": "self[\"t\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def args(self, val):\n        self[\"args\"] = val\n", "docstring": "self[\"args\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def args2(self, val):\n        self[\"args2\"] = val\n", "docstring": "self[\"args2\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def execute(self, val):\n        self[\"execute\"] = val\n", "docstring": "self[\"execute\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def method(self, val):\n        self[\"method\"] = val\n", "docstring": "self[\"method\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def barpolar(self, val):\n        self[\"barpolar\"] = val\n", "docstring": "self[\"barpolar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def bar(self, val):\n        self[\"bar\"] = val\n", "docstring": "self[\"bar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def box(self, val):\n        self[\"box\"] = val\n", "docstring": "self[\"box\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def candlestick(self, val):\n        self[\"candlestick\"] = val\n", "docstring": "self[\"candlestick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def carpet(self, val):\n        self[\"carpet\"] = val\n", "docstring": "self[\"carpet\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def choroplethmapbox(self, val):\n        self[\"choroplethmapbox\"] = val\n", "docstring": "self[\"choroplethmapbox\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def choropleth(self, val):\n        self[\"choropleth\"] = val\n", "docstring": "self[\"choropleth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def cone(self, val):\n        self[\"cone\"] = val\n", "docstring": "self[\"cone\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def contourcarpet(self, val):\n        self[\"contourcarpet\"] = val\n", "docstring": "self[\"contourcarpet\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def contour(self, val):\n        self[\"contour\"] = val\n", "docstring": "self[\"contour\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def densitymapbox(self, val):\n        self[\"densitymapbox\"] = val\n", "docstring": "self[\"densitymapbox\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def funnelarea(self, val):\n        self[\"funnelarea\"] = val\n", "docstring": "self[\"funnelarea\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def funnel(self, val):\n        self[\"funnel\"] = val\n", "docstring": "self[\"funnel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def heatmapgl(self, val):\n        self[\"heatmapgl\"] = val\n", "docstring": "self[\"heatmapgl\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def heatmap(self, val):\n        self[\"heatmap\"] = val\n", "docstring": "self[\"heatmap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def histogram2dcontour(self, val):\n        self[\"histogram2dcontour\"] = val\n", "docstring": "self[\"histogram2dcontour\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def histogram2d(self, val):\n        self[\"histogram2d\"] = val\n", "docstring": "self[\"histogram2d\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def histogram(self, val):\n        self[\"histogram\"] = val\n", "docstring": "self[\"histogram\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def icicle(self, val):\n        self[\"icicle\"] = val\n", "docstring": "self[\"icicle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def image(self, val):\n        self[\"image\"] = val\n", "docstring": "self[\"image\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def indicator(self, val):\n        self[\"indicator\"] = val\n", "docstring": "self[\"indicator\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def isosurface(self, val):\n        self[\"isosurface\"] = val\n", "docstring": "self[\"isosurface\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def mesh3d(self, val):\n        self[\"mesh3d\"] = val\n", "docstring": "self[\"mesh3d\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def ohlc(self, val):\n        self[\"ohlc\"] = val\n", "docstring": "self[\"ohlc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def parcats(self, val):\n        self[\"parcats\"] = val\n", "docstring": "self[\"parcats\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def parcoords(self, val):\n        self[\"parcoords\"] = val\n", "docstring": "self[\"parcoords\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def pie(self, val):\n        self[\"pie\"] = val\n", "docstring": "self[\"pie\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def pointcloud(self, val):\n        self[\"pointcloud\"] = val\n", "docstring": "self[\"pointcloud\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def sankey(self, val):\n        self[\"sankey\"] = val\n", "docstring": "self[\"sankey\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scatter3d(self, val):\n        self[\"scatter3d\"] = val\n", "docstring": "self[\"scatter3d\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scattercarpet(self, val):\n        self[\"scattercarpet\"] = val\n", "docstring": "self[\"scattercarpet\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scattergeo(self, val):\n        self[\"scattergeo\"] = val\n", "docstring": "self[\"scattergeo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scattergl(self, val):\n        self[\"scattergl\"] = val\n", "docstring": "self[\"scattergl\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scattermapbox(self, val):\n        self[\"scattermapbox\"] = val\n", "docstring": "self[\"scattermapbox\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scatterpolargl(self, val):\n        self[\"scatterpolargl\"] = val\n", "docstring": "self[\"scatterpolargl\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scatterpolar(self, val):\n        self[\"scatterpolar\"] = val\n", "docstring": "self[\"scatterpolar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scatter(self, val):\n        self[\"scatter\"] = val\n", "docstring": "self[\"scatter\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scatterternary(self, val):\n        self[\"scatterternary\"] = val\n", "docstring": "self[\"scatterternary\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def splom(self, val):\n        self[\"splom\"] = val\n", "docstring": "self[\"splom\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def streamtube(self, val):\n        self[\"streamtube\"] = val\n", "docstring": "self[\"streamtube\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def sunburst(self, val):\n        self[\"sunburst\"] = val\n", "docstring": "self[\"sunburst\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def surface(self, val):\n        self[\"surface\"] = val\n", "docstring": "self[\"surface\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def table(self, val):\n        self[\"table\"] = val\n", "docstring": "self[\"table\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def treemap(self, val):\n        self[\"treemap\"] = val\n", "docstring": "self[\"treemap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def violin(self, val):\n        self[\"violin\"] = val\n", "docstring": "self[\"violin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def volume(self, val):\n        self[\"volume\"] = val\n", "docstring": "self[\"volume\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def waterfall(self, val):\n        self[\"waterfall\"] = val\n", "docstring": "self[\"waterfall\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def below(self, val):\n        self[\"below\"] = val\n", "docstring": "self[\"below\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def circle(self, val):\n        self[\"circle\"] = val\n", "docstring": "self[\"circle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def coordinates(self, val):\n        self[\"coordinates\"] = val\n", "docstring": "self[\"coordinates\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def maxzoom(self, val):\n        self[\"maxzoom\"] = val\n", "docstring": "self[\"maxzoom\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def minzoom(self, val):\n        self[\"minzoom\"] = val\n", "docstring": "self[\"minzoom\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def source(self, val):\n        self[\"source\"] = val\n", "docstring": "self[\"source\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def sourceattribution(self, val):\n        self[\"sourceattribution\"] = val\n", "docstring": "self[\"sourceattribution\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def sourcelayer(self, val):\n        self[\"sourcelayer\"] = val\n", "docstring": "self[\"sourcelayer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def sourcetype(self, val):\n        self[\"sourcetype\"] = val\n", "docstring": "self[\"sourcetype\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_center.py", "original_string": "    def lat(self, val):\n        self[\"lat\"] = val\n", "docstring": "self[\"lat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_center.py", "original_string": "    def lon(self, val):\n        self[\"lon\"] = val\n", "docstring": "self[\"lon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_fill.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_line.py", "original_string": "    def dashsrc(self, val):\n        self[\"dashsrc\"] = val\n", "docstring": "self[\"dashsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_circle.py", "original_string": "    def radius(self, val):\n        self[\"radius\"] = val\n", "docstring": "self[\"radius\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_symbol.py", "original_string": "    def icon(self, val):\n        self[\"icon\"] = val\n", "docstring": "self[\"icon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_symbol.py", "original_string": "    def iconsize(self, val):\n        self[\"iconsize\"] = val\n", "docstring": "self[\"iconsize\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_symbol.py", "original_string": "    def placement(self, val):\n        self[\"placement\"] = val\n", "docstring": "self[\"placement\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_symbol.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_symbol.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_symbol.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/symbol/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/symbol/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/symbol/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_title.py", "original_string": "    def standoff(self, val):\n        self[\"standoff\"] = val\n", "docstring": "self[\"standoff\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_rangebreak.py", "original_string": "    def bounds(self, val):\n        self[\"bounds\"] = val\n", "docstring": "self[\"bounds\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_rangebreak.py", "original_string": "    def dvalue(self, val):\n        self[\"dvalue\"] = val\n", "docstring": "self[\"dvalue\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_rangebreak.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_rangebreak.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_rangebreak.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_rangebreak.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_rangebreak.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lataxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lataxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lataxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lataxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lataxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lataxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lonaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lonaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lonaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lonaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lonaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lonaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_projection.py", "original_string": "    def parallels(self, val):\n        self[\"parallels\"] = val\n", "docstring": "self[\"parallels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_projection.py", "original_string": "    def rotation(self, val):\n        self[\"rotation\"] = val\n", "docstring": "self[\"rotation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_projection.py", "original_string": "    def scale(self, val):\n        self[\"scale\"] = val\n", "docstring": "self[\"scale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_projection.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_center.py", "original_string": "    def lat(self, val):\n        self[\"lat\"] = val\n", "docstring": "self[\"lat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_center.py", "original_string": "    def lon(self, val):\n        self[\"lon\"] = val\n", "docstring": "self[\"lon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/projection/_rotation.py", "original_string": "    def lat(self, val):\n        self[\"lat\"] = val\n", "docstring": "self[\"lat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/projection/_rotation.py", "original_string": "    def lon(self, val):\n        self[\"lon\"] = val\n", "docstring": "self[\"lon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/projection/_rotation.py", "original_string": "    def roll(self, val):\n        self[\"roll\"] = val\n", "docstring": "self[\"roll\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/shape/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/shape/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/shape/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/title/_pad.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/title/_pad.py", "original_string": "    def l(self, val):\n        self[\"l\"] = val\n", "docstring": "self[\"l\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/title/_pad.py", "original_string": "    def r(self, val):\n        self[\"r\"] = val\n", "docstring": "self[\"r\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/title/_pad.py", "original_string": "    def t(self, val):\n        self[\"t\"] = val\n", "docstring": "self[\"t\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_pad.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_pad.py", "original_string": "    def l(self, val):\n        self[\"l\"] = val\n", "docstring": "self[\"l\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_pad.py", "original_string": "    def r(self, val):\n        self[\"r\"] = val\n", "docstring": "self[\"r\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_pad.py", "original_string": "    def t(self, val):\n        self[\"t\"] = val\n", "docstring": "self[\"t\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def args(self, val):\n        self[\"args\"] = val\n", "docstring": "self[\"args\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def execute(self, val):\n        self[\"execute\"] = val\n", "docstring": "self[\"execute\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def method(self, val):\n        self[\"method\"] = val\n", "docstring": "self[\"method\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_transition.py", "original_string": "    def duration(self, val):\n        self[\"duration\"] = val\n", "docstring": "self[\"duration\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_transition.py", "original_string": "    def easing(self, val):\n        self[\"easing\"] = val\n", "docstring": "self[\"easing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_currentvalue.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_currentvalue.py", "original_string": "    def offset(self, val):\n        self[\"offset\"] = val\n", "docstring": "self[\"offset\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_currentvalue.py", "original_string": "    def prefix(self, val):\n        self[\"prefix\"] = val\n", "docstring": "self[\"prefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_currentvalue.py", "original_string": "    def suffix(self, val):\n        self[\"suffix\"] = val\n", "docstring": "self[\"suffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_currentvalue.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_currentvalue.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/currentvalue/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/currentvalue/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/currentvalue/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def activecolor(self, val):\n        self[\"activecolor\"] = val\n", "docstring": "self[\"activecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def buttons(self, val):\n        self[\"buttons\"] = val\n", "docstring": "self[\"buttons\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def buttondefaults(self, val):\n        self[\"buttondefaults\"] = val\n", "docstring": "self[\"buttondefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_title.py", "original_string": "    def standoff(self, val):\n        self[\"standoff\"] = val\n", "docstring": "self[\"standoff\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangebreak.py", "original_string": "    def bounds(self, val):\n        self[\"bounds\"] = val\n", "docstring": "self[\"bounds\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangebreak.py", "original_string": "    def dvalue(self, val):\n        self[\"dvalue\"] = val\n", "docstring": "self[\"dvalue\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangebreak.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangebreak.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangebreak.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangebreak.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangebreak.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeslider/_yaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeslider/_yaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_button.py", "original_string": "    def count(self, val):\n        self[\"count\"] = val\n", "docstring": "self[\"count\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_button.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_button.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_button.py", "original_string": "    def step(self, val):\n        self[\"step\"] = val\n", "docstring": "self[\"step\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_button.py", "original_string": "    def stepmode(self, val):\n        self[\"stepmode\"] = val\n", "docstring": "self[\"stepmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_button.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_button.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def min(self, val):\n        self[\"min\"] = val\n", "docstring": "self[\"min\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def min(self, val):\n        self[\"min\"] = val\n", "docstring": "self[\"min\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def min(self, val):\n        self[\"min\"] = val\n", "docstring": "self[\"min\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_outsidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_outsidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_outsidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_outsidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_outsidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_outsidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_title.py", "original_string": "    def position(self, val):\n        self[\"position\"] = val\n", "docstring": "self[\"position\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_marker.py", "original_string": "    def colors(self, val):\n        self[\"colors\"] = val\n", "docstring": "self[\"colors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_marker.py", "original_string": "    def colorssrc(self, val):\n        self[\"colorssrc\"] = val\n", "docstring": "self[\"colorssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/title/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/title/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/title/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_outsidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_outsidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_outsidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_outsidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_outsidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_outsidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_connector.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_connector.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_connector.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/connector/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/connector/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/connector/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def copy_zstyle(self, val):\n        self[\"copy_zstyle\"] = val\n", "docstring": "self[\"copy_zstyle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_projection.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_projection.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_projection.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def copy_zstyle(self, val):\n        self[\"copy_zstyle\"] = val\n", "docstring": "self[\"copy_zstyle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_z.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_z.py", "original_string": "    def scale(self, val):\n        self[\"scale\"] = val\n", "docstring": "self[\"scale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_z.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_x.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_x.py", "original_string": "    def scale(self, val):\n        self[\"scale\"] = val\n", "docstring": "self[\"scale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_x.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_y.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_y.py", "original_string": "    def scale(self, val):\n        self[\"scale\"] = val\n", "docstring": "self[\"scale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_y.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_decreasing.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_increasing.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def split(self, val):\n        self[\"split\"] = val\n", "docstring": "self[\"split\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/increasing/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/increasing/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/increasing/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/decreasing/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/decreasing/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/decreasing/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_rangefont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_rangefont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_rangefont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def constraintrange(self, val):\n        self[\"constraintrange\"] = val\n", "docstring": "self[\"constraintrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def multiselect(self, val):\n        self[\"multiselect\"] = val\n", "docstring": "self[\"multiselect\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_labelfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_labelfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_labelfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def gradient(self, val):\n        self[\"gradient\"] = val\n", "docstring": "self[\"gradient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_gradient.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_gradient.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_gradient.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_gradient.py", "original_string": "    def typesrc(self, val):\n        self[\"typesrc\"] = val\n", "docstring": "self[\"typesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_marker.py", "original_string": "    def blend(self, val):\n        self[\"blend\"] = val\n", "docstring": "self[\"blend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_marker.py", "original_string": "    def border(self, val):\n        self[\"border\"] = val\n", "docstring": "self[\"border\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_marker.py", "original_string": "    def sizemax(self, val):\n        self[\"sizemax\"] = val\n", "docstring": "self[\"sizemax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/marker/_border.py", "original_string": "    def arearatio(self, val):\n        self[\"arearatio\"] = val\n", "docstring": "self[\"arearatio\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/marker/_border.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_box.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_box.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_box.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_box.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_marker.py", "original_string": "    def outliercolor(self, val):\n        self[\"outliercolor\"] = val\n", "docstring": "self[\"outliercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_meanline.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_meanline.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_meanline.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/box/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/box/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/marker/_line.py", "original_string": "    def outliercolor(self, val):\n        self[\"outliercolor\"] = val\n", "docstring": "self[\"outliercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/marker/_line.py", "original_string": "    def outlierwidth(self, val):\n        self[\"outlierwidth\"] = val\n", "docstring": "self[\"outlierwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_xbins.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_xbins.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_xbins.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_ybins.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_ybins.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_ybins.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_line.py", "original_string": "    def smoothing(self, val):\n        self[\"smoothing\"] = val\n", "docstring": "self[\"smoothing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def coloring(self, val):\n        self[\"coloring\"] = val\n", "docstring": "self[\"coloring\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def labelfont(self, val):\n        self[\"labelfont\"] = val\n", "docstring": "self[\"labelfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def labelformat(self, val):\n        self[\"labelformat\"] = val\n", "docstring": "self[\"labelformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def operation(self, val):\n        self[\"operation\"] = val\n", "docstring": "self[\"operation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def showlabels(self, val):\n        self[\"showlabels\"] = val\n", "docstring": "self[\"showlabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def showlines(self, val):\n        self[\"showlines\"] = val\n", "docstring": "self[\"showlines\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/contours/_labelfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/contours/_labelfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/contours/_labelfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_line.py", "original_string": "    def smoothing(self, val):\n        self[\"smoothing\"] = val\n", "docstring": "self[\"smoothing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def coloring(self, val):\n        self[\"coloring\"] = val\n", "docstring": "self[\"coloring\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def labelfont(self, val):\n        self[\"labelfont\"] = val\n", "docstring": "self[\"labelfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def labelformat(self, val):\n        self[\"labelformat\"] = val\n", "docstring": "self[\"labelformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def operation(self, val):\n        self[\"operation\"] = val\n", "docstring": "self[\"operation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def showlabels(self, val):\n        self[\"showlabels\"] = val\n", "docstring": "self[\"showlabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def showlines(self, val):\n        self[\"showlines\"] = val\n", "docstring": "self[\"showlines\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/contours/_labelfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/contours/_labelfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/contours/_labelfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_title.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def axis(self, val):\n        self[\"axis\"] = val\n", "docstring": "self[\"axis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def bar(self, val):\n        self[\"bar\"] = val\n", "docstring": "self[\"bar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def steps(self, val):\n        self[\"steps\"] = val\n", "docstring": "self[\"steps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def stepdefaults(self, val):\n        self[\"stepdefaults\"] = val\n", "docstring": "self[\"stepdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def threshold(self, val):\n        self[\"threshold\"] = val\n", "docstring": "self[\"threshold\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_number.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_number.py", "original_string": "    def prefix(self, val):\n        self[\"prefix\"] = val\n", "docstring": "self[\"prefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_number.py", "original_string": "    def suffix(self, val):\n        self[\"suffix\"] = val\n", "docstring": "self[\"suffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_number.py", "original_string": "    def valueformat(self, val):\n        self[\"valueformat\"] = val\n", "docstring": "self[\"valueformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_delta.py", "original_string": "    def decreasing(self, val):\n        self[\"decreasing\"] = val\n", "docstring": "self[\"decreasing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_delta.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_delta.py", "original_string": "    def increasing(self, val):\n        self[\"increasing\"] = val\n", "docstring": "self[\"increasing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_delta.py", "original_string": "    def position(self, val):\n        self[\"position\"] = val\n", "docstring": "self[\"position\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_delta.py", "original_string": "    def reference(self, val):\n        self[\"reference\"] = val\n", "docstring": "self[\"reference\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_delta.py", "original_string": "    def relative(self, val):\n        self[\"relative\"] = val\n", "docstring": "self[\"relative\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_delta.py", "original_string": "    def valueformat(self, val):\n        self[\"valueformat\"] = val\n", "docstring": "self[\"valueformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_step.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_step.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_step.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_step.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_step.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_step.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_bar.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_bar.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_bar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_threshold.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_threshold.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_threshold.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/step/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/step/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/threshold/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/threshold/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/bar/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/bar/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/number/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/number/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/number/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/delta/_decreasing.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/delta/_decreasing.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/delta/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/delta/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/delta/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/delta/_increasing.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/delta/_increasing.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_outsidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_outsidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_outsidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_outsidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_outsidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_outsidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_pathbar.py", "original_string": "    def edgeshape(self, val):\n        self[\"edgeshape\"] = val\n", "docstring": "self[\"edgeshape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_pathbar.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_pathbar.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_pathbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_pathbar.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def colors(self, val):\n        self[\"colors\"] = val\n", "docstring": "self[\"colors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def colorssrc(self, val):\n        self[\"colorssrc\"] = val\n", "docstring": "self[\"colorssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def depthfade(self, val):\n        self[\"depthfade\"] = val\n", "docstring": "self[\"depthfade\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_tiling.py", "original_string": "    def flip(self, val):\n        self[\"flip\"] = val\n", "docstring": "self[\"flip\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_tiling.py", "original_string": "    def packing(self, val):\n        self[\"packing\"] = val\n", "docstring": "self[\"packing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_tiling.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_tiling.py", "original_string": "    def squarifyratio(self, val):\n        self[\"squarifyratio\"] = val\n", "docstring": "self[\"squarifyratio\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_root.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_pad.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_pad.py", "original_string": "    def l(self, val):\n        self[\"l\"] = val\n", "docstring": "self[\"l\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_pad.py", "original_string": "    def r(self, val):\n        self[\"r\"] = val\n", "docstring": "self[\"r\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_pad.py", "original_string": "    def t(self, val):\n        self[\"t\"] = val\n", "docstring": "self[\"t\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/pathbar/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/pathbar/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/pathbar/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/pathbar/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/pathbar/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/pathbar/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lighting.py", "original_string": "    def ambient(self, val):\n        self[\"ambient\"] = val\n", "docstring": "self[\"ambient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lighting.py", "original_string": "    def diffuse(self, val):\n        self[\"diffuse\"] = val\n", "docstring": "self[\"diffuse\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lighting.py", "original_string": "    def facenormalsepsilon(self, val):\n        self[\"facenormalsepsilon\"] = val\n", "docstring": "self[\"facenormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lighting.py", "original_string": "    def fresnel(self, val):\n        self[\"fresnel\"] = val\n", "docstring": "self[\"fresnel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lighting.py", "original_string": "    def roughness(self, val):\n        self[\"roughness\"] = val\n", "docstring": "self[\"roughness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lighting.py", "original_string": "    def specular(self, val):\n        self[\"specular\"] = val\n", "docstring": "self[\"specular\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lighting.py", "original_string": "    def vertexnormalsepsilon(self, val):\n        self[\"vertexnormalsepsilon\"] = val\n", "docstring": "self[\"vertexnormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lightposition.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lightposition.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lightposition.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_marker.py", "original_string": "    def outliercolor(self, val):\n        self[\"outliercolor\"] = val\n", "docstring": "self[\"outliercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/marker/_line.py", "original_string": "    def outliercolor(self, val):\n        self[\"outliercolor\"] = val\n", "docstring": "self[\"outliercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/marker/_line.py", "original_string": "    def outlierwidth(self, val):\n        self[\"outlierwidth\"] = val\n", "docstring": "self[\"outlierwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lighting.py", "original_string": "    def ambient(self, val):\n        self[\"ambient\"] = val\n", "docstring": "self[\"ambient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lighting.py", "original_string": "    def diffuse(self, val):\n        self[\"diffuse\"] = val\n", "docstring": "self[\"diffuse\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lighting.py", "original_string": "    def fresnel(self, val):\n        self[\"fresnel\"] = val\n", "docstring": "self[\"fresnel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lighting.py", "original_string": "    def roughness(self, val):\n        self[\"roughness\"] = val\n", "docstring": "self[\"roughness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lighting.py", "original_string": "    def specular(self, val):\n        self[\"specular\"] = val\n", "docstring": "self[\"specular\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_contours.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_contours.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_contours.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lightposition.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lightposition.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lightposition.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def highlight(self, val):\n        self[\"highlight\"] = val\n", "docstring": "self[\"highlight\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def highlightcolor(self, val):\n        self[\"highlightcolor\"] = val\n", "docstring": "self[\"highlightcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def highlightwidth(self, val):\n        self[\"highlightwidth\"] = val\n", "docstring": "self[\"highlightwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def project(self, val):\n        self[\"project\"] = val\n", "docstring": "self[\"project\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def usecolormap(self, val):\n        self[\"usecolormap\"] = val\n", "docstring": "self[\"usecolormap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def highlight(self, val):\n        self[\"highlight\"] = val\n", "docstring": "self[\"highlight\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def highlightcolor(self, val):\n        self[\"highlightcolor\"] = val\n", "docstring": "self[\"highlightcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def highlightwidth(self, val):\n        self[\"highlightwidth\"] = val\n", "docstring": "self[\"highlightwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def project(self, val):\n        self[\"project\"] = val\n", "docstring": "self[\"project\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def usecolormap(self, val):\n        self[\"usecolormap\"] = val\n", "docstring": "self[\"usecolormap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def highlight(self, val):\n        self[\"highlight\"] = val\n", "docstring": "self[\"highlight\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def highlightcolor(self, val):\n        self[\"highlightcolor\"] = val\n", "docstring": "self[\"highlightcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def highlightwidth(self, val):\n        self[\"highlightwidth\"] = val\n", "docstring": "self[\"highlightwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def project(self, val):\n        self[\"project\"] = val\n", "docstring": "self[\"project\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def usecolormap(self, val):\n        self[\"usecolormap\"] = val\n", "docstring": "self[\"usecolormap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/z/_project.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/z/_project.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/z/_project.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/x/_project.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/x/_project.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/x/_project.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/y/_project.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/y/_project.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/y/_project.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_line.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_outsidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_outsidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_outsidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_outsidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_outsidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_outsidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_pathbar.py", "original_string": "    def edgeshape(self, val):\n        self[\"edgeshape\"] = val\n", "docstring": "self[\"edgeshape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_pathbar.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_pathbar.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_pathbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_pathbar.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def colors(self, val):\n        self[\"colors\"] = val\n", "docstring": "self[\"colors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def colorssrc(self, val):\n        self[\"colorssrc\"] = val\n", "docstring": "self[\"colorssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_leaf.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_tiling.py", "original_string": "    def flip(self, val):\n        self[\"flip\"] = val\n", "docstring": "self[\"flip\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_tiling.py", "original_string": "    def orientation(self, val):\n        self[\"orientation\"] = val\n", "docstring": "self[\"orientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_tiling.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_root.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/pathbar/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/pathbar/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/pathbar/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/pathbar/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/pathbar/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/pathbar/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_outsidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_outsidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_outsidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_outsidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_outsidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_outsidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def copy_ystyle(self, val):\n        self[\"copy_ystyle\"] = val\n", "docstring": "self[\"copy_ystyle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def fgcolor(self, val):\n        self[\"fgcolor\"] = val\n", "docstring": "self[\"fgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def fgcolorsrc(self, val):\n        self[\"fgcolorsrc\"] = val\n", "docstring": "self[\"fgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def fgopacity(self, val):\n        self[\"fgopacity\"] = val\n", "docstring": "self[\"fgopacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def fillmode(self, val):\n        self[\"fillmode\"] = val\n", "docstring": "self[\"fillmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def shapesrc(self, val):\n        self[\"shapesrc\"] = val\n", "docstring": "self[\"shapesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def solidity(self, val):\n        self[\"solidity\"] = val\n", "docstring": "self[\"solidity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def soliditysrc(self, val):\n        self[\"soliditysrc\"] = val\n", "docstring": "self[\"soliditysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_caps.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_caps.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_caps.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lighting.py", "original_string": "    def ambient(self, val):\n        self[\"ambient\"] = val\n", "docstring": "self[\"ambient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lighting.py", "original_string": "    def diffuse(self, val):\n        self[\"diffuse\"] = val\n", "docstring": "self[\"diffuse\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lighting.py", "original_string": "    def facenormalsepsilon(self, val):\n        self[\"facenormalsepsilon\"] = val\n", "docstring": "self[\"facenormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lighting.py", "original_string": "    def fresnel(self, val):\n        self[\"fresnel\"] = val\n", "docstring": "self[\"fresnel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lighting.py", "original_string": "    def roughness(self, val):\n        self[\"roughness\"] = val\n", "docstring": "self[\"roughness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lighting.py", "original_string": "    def specular(self, val):\n        self[\"specular\"] = val\n", "docstring": "self[\"specular\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lighting.py", "original_string": "    def vertexnormalsepsilon(self, val):\n        self[\"vertexnormalsepsilon\"] = val\n", "docstring": "self[\"vertexnormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_spaceframe.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_spaceframe.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_contour.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_contour.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_contour.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_surface.py", "original_string": "    def count(self, val):\n        self[\"count\"] = val\n", "docstring": "self[\"count\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_surface.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_surface.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_surface.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_slices.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_slices.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_slices.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lightposition.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lightposition.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lightposition.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/caps/_z.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/caps/_z.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/caps/_x.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/caps/_x.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/caps/_y.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/caps/_y.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_z.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_z.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_z.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_z.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_x.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_x.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_x.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_x.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_y.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_y.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_y.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_y.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_decreasing.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_decreasing.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_increasing.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_increasing.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def split(self, val):\n        self[\"split\"] = val\n", "docstring": "self[\"split\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/increasing/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/increasing/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/decreasing/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/decreasing/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lighting.py", "original_string": "    def ambient(self, val):\n        self[\"ambient\"] = val\n", "docstring": "self[\"ambient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lighting.py", "original_string": "    def diffuse(self, val):\n        self[\"diffuse\"] = val\n", "docstring": "self[\"diffuse\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lighting.py", "original_string": "    def facenormalsepsilon(self, val):\n        self[\"facenormalsepsilon\"] = val\n", "docstring": "self[\"facenormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lighting.py", "original_string": "    def fresnel(self, val):\n        self[\"fresnel\"] = val\n", "docstring": "self[\"fresnel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lighting.py", "original_string": "    def roughness(self, val):\n        self[\"roughness\"] = val\n", "docstring": "self[\"roughness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lighting.py", "original_string": "    def specular(self, val):\n        self[\"specular\"] = val\n", "docstring": "self[\"specular\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lighting.py", "original_string": "    def vertexnormalsepsilon(self, val):\n        self[\"vertexnormalsepsilon\"] = val\n", "docstring": "self[\"vertexnormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_starts.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_starts.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_starts.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_starts.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_starts.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_starts.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lightposition.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lightposition.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lightposition.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def gradient(self, val):\n        self[\"gradient\"] = val\n", "docstring": "self[\"gradient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def maxdisplayed(self, val):\n        self[\"maxdisplayed\"] = val\n", "docstring": "self[\"maxdisplayed\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
