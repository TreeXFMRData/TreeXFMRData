{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def textinfo(self, val):\n        self[\"textinfo\"] = val\n", "docstring": "self[\"textinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def xperiod(self, val):\n        self[\"xperiod\"] = val\n", "docstring": "self[\"xperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def xperiod0(self, val):\n        self[\"xperiod0\"] = val\n", "docstring": "self[\"xperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def xperiodalignment(self, val):\n        self[\"xperiodalignment\"] = val\n", "docstring": "self[\"xperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def yperiod(self, val):\n        self[\"yperiod\"] = val\n", "docstring": "self[\"yperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def yperiod0(self, val):\n        self[\"yperiod0\"] = val\n", "docstring": "self[\"yperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def yperiodalignment(self, val):\n        self[\"yperiodalignment\"] = val\n", "docstring": "self[\"yperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_funnel.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def a(self, val):\n        self[\"a\"] = val\n", "docstring": "self[\"a\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def a0(self, val):\n        self[\"a0\"] = val\n", "docstring": "self[\"a0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def aaxis(self, val):\n        self[\"aaxis\"] = val\n", "docstring": "self[\"aaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def asrc(self, val):\n        self[\"asrc\"] = val\n", "docstring": "self[\"asrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def b0(self, val):\n        self[\"b0\"] = val\n", "docstring": "self[\"b0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def baxis(self, val):\n        self[\"baxis\"] = val\n", "docstring": "self[\"baxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def bsrc(self, val):\n        self[\"bsrc\"] = val\n", "docstring": "self[\"bsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def carpet(self, val):\n        self[\"carpet\"] = val\n", "docstring": "self[\"carpet\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def cheaterslope(self, val):\n        self[\"cheaterslope\"] = val\n", "docstring": "self[\"cheaterslope\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def da(self, val):\n        self[\"da\"] = val\n", "docstring": "self[\"da\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def db(self, val):\n        self[\"db\"] = val\n", "docstring": "self[\"db\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_carpet.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def connectgaps(self, val):\n        self[\"connectgaps\"] = val\n", "docstring": "self[\"connectgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def dx(self, val):\n        self[\"dx\"] = val\n", "docstring": "self[\"dx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def dy(self, val):\n        self[\"dy\"] = val\n", "docstring": "self[\"dy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def error_x(self, val):\n        self[\"error_x\"] = val\n", "docstring": "self[\"error_x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def error_y(self, val):\n        self[\"error_y\"] = val\n", "docstring": "self[\"error_y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def xperiod(self, val):\n        self[\"xperiod\"] = val\n", "docstring": "self[\"xperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def xperiod0(self, val):\n        self[\"xperiod0\"] = val\n", "docstring": "self[\"xperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def xperiodalignment(self, val):\n        self[\"xperiodalignment\"] = val\n", "docstring": "self[\"xperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def ycalendar(self, val):\n        self[\"ycalendar\"] = val\n", "docstring": "self[\"ycalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def yperiod(self, val):\n        self[\"yperiod\"] = val\n", "docstring": "self[\"yperiod\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def yperiod0(self, val):\n        self[\"yperiod0\"] = val\n", "docstring": "self[\"yperiod0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def yperiodalignment(self, val):\n        self[\"yperiodalignment\"] = val\n", "docstring": "self[\"yperiodalignment\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scattergl.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def branchvalues(self, val):\n        self[\"branchvalues\"] = val\n", "docstring": "self[\"branchvalues\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def count(self, val):\n        self[\"count\"] = val\n", "docstring": "self[\"count\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def insidetextfont(self, val):\n        self[\"insidetextfont\"] = val\n", "docstring": "self[\"insidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def labels(self, val):\n        self[\"labels\"] = val\n", "docstring": "self[\"labels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def labelssrc(self, val):\n        self[\"labelssrc\"] = val\n", "docstring": "self[\"labelssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def leaf(self, val):\n        self[\"leaf\"] = val\n", "docstring": "self[\"leaf\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def level(self, val):\n        self[\"level\"] = val\n", "docstring": "self[\"level\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def maxdepth(self, val):\n        self[\"maxdepth\"] = val\n", "docstring": "self[\"maxdepth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def outsidetextfont(self, val):\n        self[\"outsidetextfont\"] = val\n", "docstring": "self[\"outsidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def parents(self, val):\n        self[\"parents\"] = val\n", "docstring": "self[\"parents\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def parentssrc(self, val):\n        self[\"parentssrc\"] = val\n", "docstring": "self[\"parentssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def pathbar(self, val):\n        self[\"pathbar\"] = val\n", "docstring": "self[\"pathbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def root(self, val):\n        self[\"root\"] = val\n", "docstring": "self[\"root\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def sort(self, val):\n        self[\"sort\"] = val\n", "docstring": "self[\"sort\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def textinfo(self, val):\n        self[\"textinfo\"] = val\n", "docstring": "self[\"textinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def tiling(self, val):\n        self[\"tiling\"] = val\n", "docstring": "self[\"tiling\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_icicle.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def branchvalues(self, val):\n        self[\"branchvalues\"] = val\n", "docstring": "self[\"branchvalues\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def count(self, val):\n        self[\"count\"] = val\n", "docstring": "self[\"count\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def insidetextfont(self, val):\n        self[\"insidetextfont\"] = val\n", "docstring": "self[\"insidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def insidetextorientation(self, val):\n        self[\"insidetextorientation\"] = val\n", "docstring": "self[\"insidetextorientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def labels(self, val):\n        self[\"labels\"] = val\n", "docstring": "self[\"labels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def labelssrc(self, val):\n        self[\"labelssrc\"] = val\n", "docstring": "self[\"labelssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def leaf(self, val):\n        self[\"leaf\"] = val\n", "docstring": "self[\"leaf\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def level(self, val):\n        self[\"level\"] = val\n", "docstring": "self[\"level\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def maxdepth(self, val):\n        self[\"maxdepth\"] = val\n", "docstring": "self[\"maxdepth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def outsidetextfont(self, val):\n        self[\"outsidetextfont\"] = val\n", "docstring": "self[\"outsidetextfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def parents(self, val):\n        self[\"parents\"] = val\n", "docstring": "self[\"parents\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def parentssrc(self, val):\n        self[\"parentssrc\"] = val\n", "docstring": "self[\"parentssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def root(self, val):\n        self[\"root\"] = val\n", "docstring": "self[\"root\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def rotation(self, val):\n        self[\"rotation\"] = val\n", "docstring": "self[\"rotation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def sort(self, val):\n        self[\"sort\"] = val\n", "docstring": "self[\"sort\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def textinfo(self, val):\n        self[\"textinfo\"] = val\n", "docstring": "self[\"textinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_sunburst.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def below(self, val):\n        self[\"below\"] = val\n", "docstring": "self[\"below\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def featureidkey(self, val):\n        self[\"featureidkey\"] = val\n", "docstring": "self[\"featureidkey\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def geojson(self, val):\n        self[\"geojson\"] = val\n", "docstring": "self[\"geojson\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def subplot(self, val):\n        self[\"subplot\"] = val\n", "docstring": "self[\"subplot\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def zauto(self, val):\n        self[\"zauto\"] = val\n", "docstring": "self[\"zauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def zmax(self, val):\n        self[\"zmax\"] = val\n", "docstring": "self[\"zmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def zmid(self, val):\n        self[\"zmid\"] = val\n", "docstring": "self[\"zmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def zmin(self, val):\n        self[\"zmin\"] = val\n", "docstring": "self[\"zmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_choroplethmapbox.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def autobinx(self, val):\n        self[\"autobinx\"] = val\n", "docstring": "self[\"autobinx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def autobiny(self, val):\n        self[\"autobiny\"] = val\n", "docstring": "self[\"autobiny\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def bingroup(self, val):\n        self[\"bingroup\"] = val\n", "docstring": "self[\"bingroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def histfunc(self, val):\n        self[\"histfunc\"] = val\n", "docstring": "self[\"histfunc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def histnorm(self, val):\n        self[\"histnorm\"] = val\n", "docstring": "self[\"histnorm\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def nbinsx(self, val):\n        self[\"nbinsx\"] = val\n", "docstring": "self[\"nbinsx\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def nbinsy(self, val):\n        self[\"nbinsy\"] = val\n", "docstring": "self[\"nbinsy\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def xbingroup(self, val):\n        self[\"xbingroup\"] = val\n", "docstring": "self[\"xbingroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def xbins(self, val):\n        self[\"xbins\"] = val\n", "docstring": "self[\"xbins\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def xcalendar(self, val):\n        self[\"xcalendar\"] = val\n", "docstring": "self[\"xcalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def xgap(self, val):\n        self[\"xgap\"] = val\n", "docstring": "self[\"xgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def xhoverformat(self, val):\n        self[\"xhoverformat\"] = val\n", "docstring": "self[\"xhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def ybingroup(self, val):\n        self[\"ybingroup\"] = val\n", "docstring": "self[\"ybingroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def ybins(self, val):\n        self[\"ybins\"] = val\n", "docstring": "self[\"ybins\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def ycalendar(self, val):\n        self[\"ycalendar\"] = val\n", "docstring": "self[\"ycalendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def ygap(self, val):\n        self[\"ygap\"] = val\n", "docstring": "self[\"ygap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def yhoverformat(self, val):\n        self[\"yhoverformat\"] = val\n", "docstring": "self[\"yhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def zauto(self, val):\n        self[\"zauto\"] = val\n", "docstring": "self[\"zauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def zhoverformat(self, val):\n        self[\"zhoverformat\"] = val\n", "docstring": "self[\"zhoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def zmax(self, val):\n        self[\"zmax\"] = val\n", "docstring": "self[\"zmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def zmid(self, val):\n        self[\"zmid\"] = val\n", "docstring": "self[\"zmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def zmin(self, val):\n        self[\"zmin\"] = val\n", "docstring": "self[\"zmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def zsmooth(self, val):\n        self[\"zsmooth\"] = val\n", "docstring": "self[\"zsmooth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_histogram2d.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def connectgaps(self, val):\n        self[\"connectgaps\"] = val\n", "docstring": "self[\"connectgaps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def dr(self, val):\n        self[\"dr\"] = val\n", "docstring": "self[\"dr\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def dtheta(self, val):\n        self[\"dtheta\"] = val\n", "docstring": "self[\"dtheta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def hoverinfosrc(self, val):\n        self[\"hoverinfosrc\"] = val\n", "docstring": "self[\"hoverinfosrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def hovertextsrc(self, val):\n        self[\"hovertextsrc\"] = val\n", "docstring": "self[\"hovertextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def ids(self, val):\n        self[\"ids\"] = val\n", "docstring": "self[\"ids\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def idssrc(self, val):\n        self[\"idssrc\"] = val\n", "docstring": "self[\"idssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def legendgroup(self, val):\n        self[\"legendgroup\"] = val\n", "docstring": "self[\"legendgroup\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def legendrank(self, val):\n        self[\"legendrank\"] = val\n", "docstring": "self[\"legendrank\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def r(self, val):\n        self[\"r\"] = val\n", "docstring": "self[\"r\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def r0(self, val):\n        self[\"r0\"] = val\n", "docstring": "self[\"r0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def rsrc(self, val):\n        self[\"rsrc\"] = val\n", "docstring": "self[\"rsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def selected(self, val):\n        self[\"selected\"] = val\n", "docstring": "self[\"selected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def selectedpoints(self, val):\n        self[\"selectedpoints\"] = val\n", "docstring": "self[\"selectedpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def showlegend(self, val):\n        self[\"showlegend\"] = val\n", "docstring": "self[\"showlegend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def subplot(self, val):\n        self[\"subplot\"] = val\n", "docstring": "self[\"subplot\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def textpositionsrc(self, val):\n        self[\"textpositionsrc\"] = val\n", "docstring": "self[\"textpositionsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def textsrc(self, val):\n        self[\"textsrc\"] = val\n", "docstring": "self[\"textsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def texttemplate(self, val):\n        self[\"texttemplate\"] = val\n", "docstring": "self[\"texttemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def texttemplatesrc(self, val):\n        self[\"texttemplatesrc\"] = val\n", "docstring": "self[\"texttemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def theta(self, val):\n        self[\"theta\"] = val\n", "docstring": "self[\"theta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def theta0(self, val):\n        self[\"theta0\"] = val\n", "docstring": "self[\"theta0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def thetasrc(self, val):\n        self[\"thetasrc\"] = val\n", "docstring": "self[\"thetasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def thetaunit(self, val):\n        self[\"thetaunit\"] = val\n", "docstring": "self[\"thetaunit\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def unselected(self, val):\n        self[\"unselected\"] = val\n", "docstring": "self[\"unselected\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_scatterpolargl.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def arrangement(self, val):\n        self[\"arrangement\"] = val\n", "docstring": "self[\"arrangement\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def bundlecolors(self, val):\n        self[\"bundlecolors\"] = val\n", "docstring": "self[\"bundlecolors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def counts(self, val):\n        self[\"counts\"] = val\n", "docstring": "self[\"counts\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def countssrc(self, val):\n        self[\"countssrc\"] = val\n", "docstring": "self[\"countssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def dimensions(self, val):\n        self[\"dimensions\"] = val\n", "docstring": "self[\"dimensions\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def dimensiondefaults(self, val):\n        self[\"dimensiondefaults\"] = val\n", "docstring": "self[\"dimensiondefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def hoveron(self, val):\n        self[\"hoveron\"] = val\n", "docstring": "self[\"hoveron\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def labelfont(self, val):\n        self[\"labelfont\"] = val\n", "docstring": "self[\"labelfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def legendgrouptitle(self, val):\n        self[\"legendgrouptitle\"] = val\n", "docstring": "self[\"legendgrouptitle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def meta(self, val):\n        self[\"meta\"] = val\n", "docstring": "self[\"meta\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def metasrc(self, val):\n        self[\"metasrc\"] = val\n", "docstring": "self[\"metasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def sortpaths(self, val):\n        self[\"sortpaths\"] = val\n", "docstring": "self[\"sortpaths\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def stream(self, val):\n        self[\"stream\"] = val\n", "docstring": "self[\"stream\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def uid(self, val):\n        self[\"uid\"] = val\n", "docstring": "self[\"uid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/_parcats.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_caps.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_caps.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_caps.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lighting.py", "original_string": "    def ambient(self, val):\n        self[\"ambient\"] = val\n", "docstring": "self[\"ambient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lighting.py", "original_string": "    def diffuse(self, val):\n        self[\"diffuse\"] = val\n", "docstring": "self[\"diffuse\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lighting.py", "original_string": "    def facenormalsepsilon(self, val):\n        self[\"facenormalsepsilon\"] = val\n", "docstring": "self[\"facenormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lighting.py", "original_string": "    def fresnel(self, val):\n        self[\"fresnel\"] = val\n", "docstring": "self[\"fresnel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lighting.py", "original_string": "    def roughness(self, val):\n        self[\"roughness\"] = val\n", "docstring": "self[\"roughness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lighting.py", "original_string": "    def specular(self, val):\n        self[\"specular\"] = val\n", "docstring": "self[\"specular\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lighting.py", "original_string": "    def vertexnormalsepsilon(self, val):\n        self[\"vertexnormalsepsilon\"] = val\n", "docstring": "self[\"vertexnormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_spaceframe.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_spaceframe.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_contour.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_contour.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_contour.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_surface.py", "original_string": "    def count(self, val):\n        self[\"count\"] = val\n", "docstring": "self[\"count\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_surface.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_surface.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_surface.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_slices.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_slices.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_slices.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lightposition.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lightposition.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_lightposition.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/caps/_z.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/caps/_z.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/caps/_x.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/caps/_x.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/caps/_y.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/caps/_y.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_z.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_z.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_z.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_z.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_x.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_x.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_x.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_x.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_y.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_y.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_y.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/isosurface/slices/_y.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/image/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmap/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def gradient(self, val):\n        self[\"gradient\"] = val\n", "docstring": "self[\"gradient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def maxdisplayed(self, val):\n        self[\"maxdisplayed\"] = val\n", "docstring": "self[\"maxdisplayed\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_line.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_line.py", "original_string": "    def smoothing(self, val):\n        self[\"smoothing\"] = val\n", "docstring": "self[\"smoothing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_gradient.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_gradient.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_gradient.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_gradient.py", "original_string": "    def typesrc(self, val):\n        self[\"typesrc\"] = val\n", "docstring": "self[\"typesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterternary/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_y.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_line.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def copy_ystyle(self, val):\n        self[\"copy_ystyle\"] = val\n", "docstring": "self[\"copy_ystyle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/_error_x.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergl/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/densitymapbox/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_xbins.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_xbins.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_xbins.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_ybins.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_ybins.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_ybins.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2d/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lighting.py", "original_string": "    def ambient(self, val):\n        self[\"ambient\"] = val\n", "docstring": "self[\"ambient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lighting.py", "original_string": "    def diffuse(self, val):\n        self[\"diffuse\"] = val\n", "docstring": "self[\"diffuse\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lighting.py", "original_string": "    def facenormalsepsilon(self, val):\n        self[\"facenormalsepsilon\"] = val\n", "docstring": "self[\"facenormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lighting.py", "original_string": "    def fresnel(self, val):\n        self[\"fresnel\"] = val\n", "docstring": "self[\"fresnel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lighting.py", "original_string": "    def roughness(self, val):\n        self[\"roughness\"] = val\n", "docstring": "self[\"roughness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lighting.py", "original_string": "    def specular(self, val):\n        self[\"specular\"] = val\n", "docstring": "self[\"specular\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lighting.py", "original_string": "    def vertexnormalsepsilon(self, val):\n        self[\"vertexnormalsepsilon\"] = val\n", "docstring": "self[\"vertexnormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_contour.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_contour.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_contour.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lightposition.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lightposition.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_lightposition.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/mesh3d/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def groups(self, val):\n        self[\"groups\"] = val\n", "docstring": "self[\"groups\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def labelsrc(self, val):\n        self[\"labelsrc\"] = val\n", "docstring": "self[\"labelsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_node.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def colorscales(self, val):\n        self[\"colorscales\"] = val\n", "docstring": "self[\"colorscales\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def colorscaledefaults(self, val):\n        self[\"colorscaledefaults\"] = val\n", "docstring": "self[\"colorscaledefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def customdata(self, val):\n        self[\"customdata\"] = val\n", "docstring": "self[\"customdata\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def customdatasrc(self, val):\n        self[\"customdatasrc\"] = val\n", "docstring": "self[\"customdatasrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def hoverinfo(self, val):\n        self[\"hoverinfo\"] = val\n", "docstring": "self[\"hoverinfo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def hovertemplatesrc(self, val):\n        self[\"hovertemplatesrc\"] = val\n", "docstring": "self[\"hovertemplatesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def labelsrc(self, val):\n        self[\"labelsrc\"] = val\n", "docstring": "self[\"labelsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def source(self, val):\n        self[\"source\"] = val\n", "docstring": "self[\"source\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def sourcesrc(self, val):\n        self[\"sourcesrc\"] = val\n", "docstring": "self[\"sourcesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def target(self, val):\n        self[\"target\"] = val\n", "docstring": "self[\"target\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def targetsrc(self, val):\n        self[\"targetsrc\"] = val\n", "docstring": "self[\"targetsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_link.py", "original_string": "    def valuesrc(self, val):\n        self[\"valuesrc\"] = val\n", "docstring": "self[\"valuesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/node/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_colorscale.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_colorscale.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_colorscale.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_colorscale.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_colorscale.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_colorscale.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sankey/link/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_title.py", "original_string": "    def position(self, val):\n        self[\"position\"] = val\n", "docstring": "self[\"position\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_marker.py", "original_string": "    def colors(self, val):\n        self[\"colors\"] = val\n", "docstring": "self[\"colors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_marker.py", "original_string": "    def colorssrc(self, val):\n        self[\"colorssrc\"] = val\n", "docstring": "self[\"colorssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/title/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/title/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/title/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnelarea/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def format(self, val):\n        self[\"format\"] = val\n", "docstring": "self[\"format\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def formatsrc(self, val):\n        self[\"formatsrc\"] = val\n", "docstring": "self[\"formatsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def height(self, val):\n        self[\"height\"] = val\n", "docstring": "self[\"height\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def prefix(self, val):\n        self[\"prefix\"] = val\n", "docstring": "self[\"prefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def prefixsrc(self, val):\n        self[\"prefixsrc\"] = val\n", "docstring": "self[\"prefixsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def suffix(self, val):\n        self[\"suffix\"] = val\n", "docstring": "self[\"suffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def suffixsrc(self, val):\n        self[\"suffixsrc\"] = val\n", "docstring": "self[\"suffixsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_cells.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def format(self, val):\n        self[\"format\"] = val\n", "docstring": "self[\"format\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def formatsrc(self, val):\n        self[\"formatsrc\"] = val\n", "docstring": "self[\"formatsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def height(self, val):\n        self[\"height\"] = val\n", "docstring": "self[\"height\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def prefix(self, val):\n        self[\"prefix\"] = val\n", "docstring": "self[\"prefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def prefixsrc(self, val):\n        self[\"prefixsrc\"] = val\n", "docstring": "self[\"prefixsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def suffix(self, val):\n        self[\"suffix\"] = val\n", "docstring": "self[\"suffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def suffixsrc(self, val):\n        self[\"suffixsrc\"] = val\n", "docstring": "self[\"suffixsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_header.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_fill.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_fill.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/cells/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_fill.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_fill.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/table/header/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_y.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_xbins.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_xbins.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_xbins.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_ybins.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_ybins.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_ybins.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_cumulative.py", "original_string": "    def currentbin(self, val):\n        self[\"currentbin\"] = val\n", "docstring": "self[\"currentbin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_cumulative.py", "original_string": "    def direction(self, val):\n        self[\"direction\"] = val\n", "docstring": "self[\"direction\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_cumulative.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def copy_ystyle(self, val):\n        self[\"copy_ystyle\"] = val\n", "docstring": "self[\"copy_ystyle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/_error_x.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def fgcolor(self, val):\n        self[\"fgcolor\"] = val\n", "docstring": "self[\"fgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def fgcolorsrc(self, val):\n        self[\"fgcolorsrc\"] = val\n", "docstring": "self[\"fgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def fgopacity(self, val):\n        self[\"fgopacity\"] = val\n", "docstring": "self[\"fgopacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def fillmode(self, val):\n        self[\"fillmode\"] = val\n", "docstring": "self[\"fillmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def shapesrc(self, val):\n        self[\"shapesrc\"] = val\n", "docstring": "self[\"shapesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def solidity(self, val):\n        self[\"solidity\"] = val\n", "docstring": "self[\"solidity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_pattern.py", "original_string": "    def soliditysrc(self, val):\n        self[\"soliditysrc\"] = val\n", "docstring": "self[\"soliditysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_outsidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_outsidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_outsidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_outsidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_outsidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_outsidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def colors(self, val):\n        self[\"colors\"] = val\n", "docstring": "self[\"colors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def colorssrc(self, val):\n        self[\"colorssrc\"] = val\n", "docstring": "self[\"colorssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_leaf.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_root.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/sunburst/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_dimension.py", "original_string": "    def axis(self, val):\n        self[\"axis\"] = val\n", "docstring": "self[\"axis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_dimension.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_dimension.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_dimension.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_dimension.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_dimension.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_dimension.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_diagonal.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/dimension/_axis.py", "original_string": "    def matches(self, val):\n        self[\"matches\"] = val\n", "docstring": "self[\"matches\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/dimension/_axis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/splom/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_coloraxis.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def xref(self, val):\n        self[\"xref\"] = val\n", "docstring": "self[\"xref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_title.py", "original_string": "    def yref(self, val):\n        self[\"yref\"] = val\n", "docstring": "self[\"yref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_ternary.py", "original_string": "    def aaxis(self, val):\n        self[\"aaxis\"] = val\n", "docstring": "self[\"aaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_ternary.py", "original_string": "    def baxis(self, val):\n        self[\"baxis\"] = val\n", "docstring": "self[\"baxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_ternary.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_ternary.py", "original_string": "    def caxis(self, val):\n        self[\"caxis\"] = val\n", "docstring": "self[\"caxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_ternary.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_ternary.py", "original_string": "    def sum(self, val):\n        self[\"sum\"] = val\n", "docstring": "self[\"sum\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_ternary.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_colorscale.py", "original_string": "    def diverging(self, val):\n        self[\"diverging\"] = val\n", "docstring": "self[\"diverging\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_colorscale.py", "original_string": "    def sequential(self, val):\n        self[\"sequential\"] = val\n", "docstring": "self[\"sequential\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_colorscale.py", "original_string": "    def sequentialminus(self, val):\n        self[\"sequentialminus\"] = val\n", "docstring": "self[\"sequentialminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_uniformtext.py", "original_string": "    def minsize(self, val):\n        self[\"minsize\"] = val\n", "docstring": "self[\"minsize\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_uniformtext.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def active(self, val):\n        self[\"active\"] = val\n", "docstring": "self[\"active\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def buttons(self, val):\n        self[\"buttons\"] = val\n", "docstring": "self[\"buttons\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def buttondefaults(self, val):\n        self[\"buttondefaults\"] = val\n", "docstring": "self[\"buttondefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def direction(self, val):\n        self[\"direction\"] = val\n", "docstring": "self[\"direction\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def showactive(self, val):\n        self[\"showactive\"] = val\n", "docstring": "self[\"showactive\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_updatemenu.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def annotations(self, val):\n        self[\"annotations\"] = val\n", "docstring": "self[\"annotations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def annotationdefaults(self, val):\n        self[\"annotationdefaults\"] = val\n", "docstring": "self[\"annotationdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def aspectmode(self, val):\n        self[\"aspectmode\"] = val\n", "docstring": "self[\"aspectmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def aspectratio(self, val):\n        self[\"aspectratio\"] = val\n", "docstring": "self[\"aspectratio\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def camera(self, val):\n        self[\"camera\"] = val\n", "docstring": "self[\"camera\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def dragmode(self, val):\n        self[\"dragmode\"] = val\n", "docstring": "self[\"dragmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def hovermode(self, val):\n        self[\"hovermode\"] = val\n", "docstring": "self[\"hovermode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def xaxis(self, val):\n        self[\"xaxis\"] = val\n", "docstring": "self[\"xaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_scene.py", "original_string": "    def zaxis(self, val):\n        self[\"zaxis\"] = val\n", "docstring": "self[\"zaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def sizex(self, val):\n        self[\"sizex\"] = val\n", "docstring": "self[\"sizex\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def sizey(self, val):\n        self[\"sizey\"] = val\n", "docstring": "self[\"sizey\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def sizing(self, val):\n        self[\"sizing\"] = val\n", "docstring": "self[\"sizing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def source(self, val):\n        self[\"source\"] = val\n", "docstring": "self[\"source\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def xref(self, val):\n        self[\"xref\"] = val\n", "docstring": "self[\"xref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_image.py", "original_string": "    def yref(self, val):\n        self[\"yref\"] = val\n", "docstring": "self[\"yref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def activecolor(self, val):\n        self[\"activecolor\"] = val\n", "docstring": "self[\"activecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def add(self, val):\n        self[\"add\"] = val\n", "docstring": "self[\"add\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def addsrc(self, val):\n        self[\"addsrc\"] = val\n", "docstring": "self[\"addsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def orientation(self, val):\n        self[\"orientation\"] = val\n", "docstring": "self[\"orientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def remove(self, val):\n        self[\"remove\"] = val\n", "docstring": "self[\"remove\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def removesrc(self, val):\n        self[\"removesrc\"] = val\n", "docstring": "self[\"removesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_modebar.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_margin.py", "original_string": "    def autoexpand(self, val):\n        self[\"autoexpand\"] = val\n", "docstring": "self[\"autoexpand\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_margin.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_margin.py", "original_string": "    def l(self, val):\n        self[\"l\"] = val\n", "docstring": "self[\"l\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_margin.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_margin.py", "original_string": "    def r(self, val):\n        self[\"r\"] = val\n", "docstring": "self[\"r\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_margin.py", "original_string": "    def t(self, val):\n        self[\"t\"] = val\n", "docstring": "self[\"t\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def center(self, val):\n        self[\"center\"] = val\n", "docstring": "self[\"center\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def coastlinecolor(self, val):\n        self[\"coastlinecolor\"] = val\n", "docstring": "self[\"coastlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def coastlinewidth(self, val):\n        self[\"coastlinewidth\"] = val\n", "docstring": "self[\"coastlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def countrycolor(self, val):\n        self[\"countrycolor\"] = val\n", "docstring": "self[\"countrycolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def countrywidth(self, val):\n        self[\"countrywidth\"] = val\n", "docstring": "self[\"countrywidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def fitbounds(self, val):\n        self[\"fitbounds\"] = val\n", "docstring": "self[\"fitbounds\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def framecolor(self, val):\n        self[\"framecolor\"] = val\n", "docstring": "self[\"framecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def framewidth(self, val):\n        self[\"framewidth\"] = val\n", "docstring": "self[\"framewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def lakecolor(self, val):\n        self[\"lakecolor\"] = val\n", "docstring": "self[\"lakecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def landcolor(self, val):\n        self[\"landcolor\"] = val\n", "docstring": "self[\"landcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def lataxis(self, val):\n        self[\"lataxis\"] = val\n", "docstring": "self[\"lataxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def lonaxis(self, val):\n        self[\"lonaxis\"] = val\n", "docstring": "self[\"lonaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def oceancolor(self, val):\n        self[\"oceancolor\"] = val\n", "docstring": "self[\"oceancolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def projection(self, val):\n        self[\"projection\"] = val\n", "docstring": "self[\"projection\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def resolution(self, val):\n        self[\"resolution\"] = val\n", "docstring": "self[\"resolution\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def rivercolor(self, val):\n        self[\"rivercolor\"] = val\n", "docstring": "self[\"rivercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def riverwidth(self, val):\n        self[\"riverwidth\"] = val\n", "docstring": "self[\"riverwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def scope(self, val):\n        self[\"scope\"] = val\n", "docstring": "self[\"scope\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showcoastlines(self, val):\n        self[\"showcoastlines\"] = val\n", "docstring": "self[\"showcoastlines\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showcountries(self, val):\n        self[\"showcountries\"] = val\n", "docstring": "self[\"showcountries\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showframe(self, val):\n        self[\"showframe\"] = val\n", "docstring": "self[\"showframe\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showlakes(self, val):\n        self[\"showlakes\"] = val\n", "docstring": "self[\"showlakes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showland(self, val):\n        self[\"showland\"] = val\n", "docstring": "self[\"showland\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showocean(self, val):\n        self[\"showocean\"] = val\n", "docstring": "self[\"showocean\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showrivers(self, val):\n        self[\"showrivers\"] = val\n", "docstring": "self[\"showrivers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def showsubunits(self, val):\n        self[\"showsubunits\"] = val\n", "docstring": "self[\"showsubunits\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def subunitcolor(self, val):\n        self[\"subunitcolor\"] = val\n", "docstring": "self[\"subunitcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def subunitwidth(self, val):\n        self[\"subunitwidth\"] = val\n", "docstring": "self[\"subunitwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_geo.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_newshape.py", "original_string": "    def drawdirection(self, val):\n        self[\"drawdirection\"] = val\n", "docstring": "self[\"drawdirection\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_newshape.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_newshape.py", "original_string": "    def fillrule(self, val):\n        self[\"fillrule\"] = val\n", "docstring": "self[\"fillrule\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_newshape.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_newshape.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_newshape.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def accesstoken(self, val):\n        self[\"accesstoken\"] = val\n", "docstring": "self[\"accesstoken\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def bearing(self, val):\n        self[\"bearing\"] = val\n", "docstring": "self[\"bearing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def center(self, val):\n        self[\"center\"] = val\n", "docstring": "self[\"center\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def layers(self, val):\n        self[\"layers\"] = val\n", "docstring": "self[\"layers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def layerdefaults(self, val):\n        self[\"layerdefaults\"] = val\n", "docstring": "self[\"layerdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def pitch(self, val):\n        self[\"pitch\"] = val\n", "docstring": "self[\"pitch\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def style(self, val):\n        self[\"style\"] = val\n", "docstring": "self[\"style\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_mapbox.py", "original_string": "    def zoom(self, val):\n        self[\"zoom\"] = val\n", "docstring": "self[\"zoom\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def arrowcolor(self, val):\n        self[\"arrowcolor\"] = val\n", "docstring": "self[\"arrowcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def arrowhead(self, val):\n        self[\"arrowhead\"] = val\n", "docstring": "self[\"arrowhead\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def arrowside(self, val):\n        self[\"arrowside\"] = val\n", "docstring": "self[\"arrowside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def arrowsize(self, val):\n        self[\"arrowsize\"] = val\n", "docstring": "self[\"arrowsize\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def arrowwidth(self, val):\n        self[\"arrowwidth\"] = val\n", "docstring": "self[\"arrowwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def ax(self, val):\n        self[\"ax\"] = val\n", "docstring": "self[\"ax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def axref(self, val):\n        self[\"axref\"] = val\n", "docstring": "self[\"axref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def ay(self, val):\n        self[\"ay\"] = val\n", "docstring": "self[\"ay\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def ayref(self, val):\n        self[\"ayref\"] = val\n", "docstring": "self[\"ayref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def borderpad(self, val):\n        self[\"borderpad\"] = val\n", "docstring": "self[\"borderpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def captureevents(self, val):\n        self[\"captureevents\"] = val\n", "docstring": "self[\"captureevents\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def clicktoshow(self, val):\n        self[\"clicktoshow\"] = val\n", "docstring": "self[\"clicktoshow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def height(self, val):\n        self[\"height\"] = val\n", "docstring": "self[\"height\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def showarrow(self, val):\n        self[\"showarrow\"] = val\n", "docstring": "self[\"showarrow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def standoff(self, val):\n        self[\"standoff\"] = val\n", "docstring": "self[\"standoff\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def startarrowhead(self, val):\n        self[\"startarrowhead\"] = val\n", "docstring": "self[\"startarrowhead\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def startarrowsize(self, val):\n        self[\"startarrowsize\"] = val\n", "docstring": "self[\"startarrowsize\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def startstandoff(self, val):\n        self[\"startstandoff\"] = val\n", "docstring": "self[\"startstandoff\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def textangle(self, val):\n        self[\"textangle\"] = val\n", "docstring": "self[\"textangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def valign(self, val):\n        self[\"valign\"] = val\n", "docstring": "self[\"valign\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def xclick(self, val):\n        self[\"xclick\"] = val\n", "docstring": "self[\"xclick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def xref(self, val):\n        self[\"xref\"] = val\n", "docstring": "self[\"xref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def xshift(self, val):\n        self[\"xshift\"] = val\n", "docstring": "self[\"xshift\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def yclick(self, val):\n        self[\"yclick\"] = val\n", "docstring": "self[\"yclick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def yref(self, val):\n        self[\"yref\"] = val\n", "docstring": "self[\"yref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_annotation.py", "original_string": "    def yshift(self, val):\n        self[\"yshift\"] = val\n", "docstring": "self[\"yshift\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_template.py", "original_string": "    def data(self, val):\n        self[\"data\"] = val\n", "docstring": "self[\"data\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_template.py", "original_string": "    def layout(self, val):\n        self[\"layout\"] = val\n", "docstring": "self[\"layout\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def active(self, val):\n        self[\"active\"] = val\n", "docstring": "self[\"active\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def activebgcolor(self, val):\n        self[\"activebgcolor\"] = val\n", "docstring": "self[\"activebgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def currentvalue(self, val):\n        self[\"currentvalue\"] = val\n", "docstring": "self[\"currentvalue\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def minorticklen(self, val):\n        self[\"minorticklen\"] = val\n", "docstring": "self[\"minorticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def steps(self, val):\n        self[\"steps\"] = val\n", "docstring": "self[\"steps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def stepdefaults(self, val):\n        self[\"stepdefaults\"] = val\n", "docstring": "self[\"stepdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def transition(self, val):\n        self[\"transition\"] = val\n", "docstring": "self[\"transition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_slider.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def columns(self, val):\n        self[\"columns\"] = val\n", "docstring": "self[\"columns\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def roworder(self, val):\n        self[\"roworder\"] = val\n", "docstring": "self[\"roworder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def rows(self, val):\n        self[\"rows\"] = val\n", "docstring": "self[\"rows\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def subplots(self, val):\n        self[\"subplots\"] = val\n", "docstring": "self[\"subplots\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def xaxes(self, val):\n        self[\"xaxes\"] = val\n", "docstring": "self[\"xaxes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def xgap(self, val):\n        self[\"xgap\"] = val\n", "docstring": "self[\"xgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def xside(self, val):\n        self[\"xside\"] = val\n", "docstring": "self[\"xside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def yaxes(self, val):\n        self[\"yaxes\"] = val\n", "docstring": "self[\"yaxes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def ygap(self, val):\n        self[\"ygap\"] = val\n", "docstring": "self[\"ygap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_grid.py", "original_string": "    def yside(self, val):\n        self[\"yside\"] = val\n", "docstring": "self[\"yside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_transition.py", "original_string": "    def duration(self, val):\n        self[\"duration\"] = val\n", "docstring": "self[\"duration\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_transition.py", "original_string": "    def easing(self, val):\n        self[\"easing\"] = val\n", "docstring": "self[\"easing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_transition.py", "original_string": "    def ordering(self, val):\n        self[\"ordering\"] = val\n", "docstring": "self[\"ordering\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def editable(self, val):\n        self[\"editable\"] = val\n", "docstring": "self[\"editable\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def fillrule(self, val):\n        self[\"fillrule\"] = val\n", "docstring": "self[\"fillrule\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def path(self, val):\n        self[\"path\"] = val\n", "docstring": "self[\"path\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def x0(self, val):\n        self[\"x0\"] = val\n", "docstring": "self[\"x0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def x1(self, val):\n        self[\"x1\"] = val\n", "docstring": "self[\"x1\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def xref(self, val):\n        self[\"xref\"] = val\n", "docstring": "self[\"xref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def xsizemode(self, val):\n        self[\"xsizemode\"] = val\n", "docstring": "self[\"xsizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def y0(self, val):\n        self[\"y0\"] = val\n", "docstring": "self[\"y0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def y1(self, val):\n        self[\"y1\"] = val\n", "docstring": "self[\"y1\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def yref(self, val):\n        self[\"yref\"] = val\n", "docstring": "self[\"yref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_shape.py", "original_string": "    def ysizemode(self, val):\n        self[\"ysizemode\"] = val\n", "docstring": "self[\"ysizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def anchor(self, val):\n        self[\"anchor\"] = val\n", "docstring": "self[\"anchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def automargin(self, val):\n        self[\"automargin\"] = val\n", "docstring": "self[\"automargin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def calendar(self, val):\n        self[\"calendar\"] = val\n", "docstring": "self[\"calendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def constrain(self, val):\n        self[\"constrain\"] = val\n", "docstring": "self[\"constrain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def constraintoward(self, val):\n        self[\"constraintoward\"] = val\n", "docstring": "self[\"constraintoward\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def dividercolor(self, val):\n        self[\"dividercolor\"] = val\n", "docstring": "self[\"dividercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def dividerwidth(self, val):\n        self[\"dividerwidth\"] = val\n", "docstring": "self[\"dividerwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def fixedrange(self, val):\n        self[\"fixedrange\"] = val\n", "docstring": "self[\"fixedrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def matches(self, val):\n        self[\"matches\"] = val\n", "docstring": "self[\"matches\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def mirror(self, val):\n        self[\"mirror\"] = val\n", "docstring": "self[\"mirror\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def overlaying(self, val):\n        self[\"overlaying\"] = val\n", "docstring": "self[\"overlaying\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def position(self, val):\n        self[\"position\"] = val\n", "docstring": "self[\"position\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def rangebreaks(self, val):\n        self[\"rangebreaks\"] = val\n", "docstring": "self[\"rangebreaks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def rangebreakdefaults(self, val):\n        self[\"rangebreakdefaults\"] = val\n", "docstring": "self[\"rangebreakdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def scaleanchor(self, val):\n        self[\"scaleanchor\"] = val\n", "docstring": "self[\"scaleanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def scaleratio(self, val):\n        self[\"scaleratio\"] = val\n", "docstring": "self[\"scaleratio\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showdividers(self, val):\n        self[\"showdividers\"] = val\n", "docstring": "self[\"showdividers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showspikes(self, val):\n        self[\"showspikes\"] = val\n", "docstring": "self[\"showspikes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def spikecolor(self, val):\n        self[\"spikecolor\"] = val\n", "docstring": "self[\"spikecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def spikedash(self, val):\n        self[\"spikedash\"] = val\n", "docstring": "self[\"spikedash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def spikemode(self, val):\n        self[\"spikemode\"] = val\n", "docstring": "self[\"spikemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def spikesnap(self, val):\n        self[\"spikesnap\"] = val\n", "docstring": "self[\"spikesnap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def spikethickness(self, val):\n        self[\"spikethickness\"] = val\n", "docstring": "self[\"spikethickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticklabelmode(self, val):\n        self[\"ticklabelmode\"] = val\n", "docstring": "self[\"ticklabelmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickson(self, val):\n        self[\"tickson\"] = val\n", "docstring": "self[\"tickson\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def zeroline(self, val):\n        self[\"zeroline\"] = val\n", "docstring": "self[\"zeroline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def zerolinecolor(self, val):\n        self[\"zerolinecolor\"] = val\n", "docstring": "self[\"zerolinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_yaxis.py", "original_string": "    def zerolinewidth(self, val):\n        self[\"zerolinewidth\"] = val\n", "docstring": "self[\"zerolinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def angularaxis(self, val):\n        self[\"angularaxis\"] = val\n", "docstring": "self[\"angularaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def bargap(self, val):\n        self[\"bargap\"] = val\n", "docstring": "self[\"bargap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def barmode(self, val):\n        self[\"barmode\"] = val\n", "docstring": "self[\"barmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def gridshape(self, val):\n        self[\"gridshape\"] = val\n", "docstring": "self[\"gridshape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def hole(self, val):\n        self[\"hole\"] = val\n", "docstring": "self[\"hole\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def radialaxis(self, val):\n        self[\"radialaxis\"] = val\n", "docstring": "self[\"radialaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def sector(self, val):\n        self[\"sector\"] = val\n", "docstring": "self[\"sector\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_polar.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def itemclick(self, val):\n        self[\"itemclick\"] = val\n", "docstring": "self[\"itemclick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def itemdoubleclick(self, val):\n        self[\"itemdoubleclick\"] = val\n", "docstring": "self[\"itemdoubleclick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def itemsizing(self, val):\n        self[\"itemsizing\"] = val\n", "docstring": "self[\"itemsizing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def itemwidth(self, val):\n        self[\"itemwidth\"] = val\n", "docstring": "self[\"itemwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def orientation(self, val):\n        self[\"orientation\"] = val\n", "docstring": "self[\"orientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def tracegroupgap(self, val):\n        self[\"tracegroupgap\"] = val\n", "docstring": "self[\"tracegroupgap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def traceorder(self, val):\n        self[\"traceorder\"] = val\n", "docstring": "self[\"traceorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def valign(self, val):\n        self[\"valign\"] = val\n", "docstring": "self[\"valign\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_legend.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_activeshape.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_activeshape.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def anchor(self, val):\n        self[\"anchor\"] = val\n", "docstring": "self[\"anchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def automargin(self, val):\n        self[\"automargin\"] = val\n", "docstring": "self[\"automargin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def calendar(self, val):\n        self[\"calendar\"] = val\n", "docstring": "self[\"calendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def constrain(self, val):\n        self[\"constrain\"] = val\n", "docstring": "self[\"constrain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def constraintoward(self, val):\n        self[\"constraintoward\"] = val\n", "docstring": "self[\"constraintoward\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def dividercolor(self, val):\n        self[\"dividercolor\"] = val\n", "docstring": "self[\"dividercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def dividerwidth(self, val):\n        self[\"dividerwidth\"] = val\n", "docstring": "self[\"dividerwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def domain(self, val):\n        self[\"domain\"] = val\n", "docstring": "self[\"domain\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def fixedrange(self, val):\n        self[\"fixedrange\"] = val\n", "docstring": "self[\"fixedrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def matches(self, val):\n        self[\"matches\"] = val\n", "docstring": "self[\"matches\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def mirror(self, val):\n        self[\"mirror\"] = val\n", "docstring": "self[\"mirror\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def overlaying(self, val):\n        self[\"overlaying\"] = val\n", "docstring": "self[\"overlaying\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def position(self, val):\n        self[\"position\"] = val\n", "docstring": "self[\"position\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def rangebreaks(self, val):\n        self[\"rangebreaks\"] = val\n", "docstring": "self[\"rangebreaks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def rangebreakdefaults(self, val):\n        self[\"rangebreakdefaults\"] = val\n", "docstring": "self[\"rangebreakdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def rangeselector(self, val):\n        self[\"rangeselector\"] = val\n", "docstring": "self[\"rangeselector\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def rangeslider(self, val):\n        self[\"rangeslider\"] = val\n", "docstring": "self[\"rangeslider\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def scaleanchor(self, val):\n        self[\"scaleanchor\"] = val\n", "docstring": "self[\"scaleanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def scaleratio(self, val):\n        self[\"scaleratio\"] = val\n", "docstring": "self[\"scaleratio\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showdividers(self, val):\n        self[\"showdividers\"] = val\n", "docstring": "self[\"showdividers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showspikes(self, val):\n        self[\"showspikes\"] = val\n", "docstring": "self[\"showspikes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def spikecolor(self, val):\n        self[\"spikecolor\"] = val\n", "docstring": "self[\"spikecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def spikedash(self, val):\n        self[\"spikedash\"] = val\n", "docstring": "self[\"spikedash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def spikemode(self, val):\n        self[\"spikemode\"] = val\n", "docstring": "self[\"spikemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def spikesnap(self, val):\n        self[\"spikesnap\"] = val\n", "docstring": "self[\"spikesnap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def spikethickness(self, val):\n        self[\"spikethickness\"] = val\n", "docstring": "self[\"spikethickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticklabelmode(self, val):\n        self[\"ticklabelmode\"] = val\n", "docstring": "self[\"ticklabelmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickson(self, val):\n        self[\"tickson\"] = val\n", "docstring": "self[\"tickson\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def zeroline(self, val):\n        self[\"zeroline\"] = val\n", "docstring": "self[\"zeroline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def zerolinecolor(self, val):\n        self[\"zerolinecolor\"] = val\n", "docstring": "self[\"zerolinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/_xaxis.py", "original_string": "    def zerolinewidth(self, val):\n        self[\"zerolinewidth\"] = val\n", "docstring": "self[\"zerolinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/grid/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/grid/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/newshape/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/newshape/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/newshape/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def backgroundcolor(self, val):\n        self[\"backgroundcolor\"] = val\n", "docstring": "self[\"backgroundcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def calendar(self, val):\n        self[\"calendar\"] = val\n", "docstring": "self[\"calendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def mirror(self, val):\n        self[\"mirror\"] = val\n", "docstring": "self[\"mirror\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showaxeslabels(self, val):\n        self[\"showaxeslabels\"] = val\n", "docstring": "self[\"showaxeslabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showbackground(self, val):\n        self[\"showbackground\"] = val\n", "docstring": "self[\"showbackground\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showspikes(self, val):\n        self[\"showspikes\"] = val\n", "docstring": "self[\"showspikes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def spikecolor(self, val):\n        self[\"spikecolor\"] = val\n", "docstring": "self[\"spikecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def spikesides(self, val):\n        self[\"spikesides\"] = val\n", "docstring": "self[\"spikesides\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def spikethickness(self, val):\n        self[\"spikethickness\"] = val\n", "docstring": "self[\"spikethickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def zeroline(self, val):\n        self[\"zeroline\"] = val\n", "docstring": "self[\"zeroline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def zerolinecolor(self, val):\n        self[\"zerolinecolor\"] = val\n", "docstring": "self[\"zerolinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_zaxis.py", "original_string": "    def zerolinewidth(self, val):\n        self[\"zerolinewidth\"] = val\n", "docstring": "self[\"zerolinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_aspectratio.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_aspectratio.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_aspectratio.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_camera.py", "original_string": "    def center(self, val):\n        self[\"center\"] = val\n", "docstring": "self[\"center\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_camera.py", "original_string": "    def eye(self, val):\n        self[\"eye\"] = val\n", "docstring": "self[\"eye\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_camera.py", "original_string": "    def projection(self, val):\n        self[\"projection\"] = val\n", "docstring": "self[\"projection\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_camera.py", "original_string": "    def up(self, val):\n        self[\"up\"] = val\n", "docstring": "self[\"up\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def arrowcolor(self, val):\n        self[\"arrowcolor\"] = val\n", "docstring": "self[\"arrowcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def arrowhead(self, val):\n        self[\"arrowhead\"] = val\n", "docstring": "self[\"arrowhead\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def arrowside(self, val):\n        self[\"arrowside\"] = val\n", "docstring": "self[\"arrowside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def arrowsize(self, val):\n        self[\"arrowsize\"] = val\n", "docstring": "self[\"arrowsize\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def arrowwidth(self, val):\n        self[\"arrowwidth\"] = val\n", "docstring": "self[\"arrowwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def ax(self, val):\n        self[\"ax\"] = val\n", "docstring": "self[\"ax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def ay(self, val):\n        self[\"ay\"] = val\n", "docstring": "self[\"ay\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def borderpad(self, val):\n        self[\"borderpad\"] = val\n", "docstring": "self[\"borderpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def captureevents(self, val):\n        self[\"captureevents\"] = val\n", "docstring": "self[\"captureevents\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def height(self, val):\n        self[\"height\"] = val\n", "docstring": "self[\"height\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def hoverlabel(self, val):\n        self[\"hoverlabel\"] = val\n", "docstring": "self[\"hoverlabel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def hovertext(self, val):\n        self[\"hovertext\"] = val\n", "docstring": "self[\"hovertext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def showarrow(self, val):\n        self[\"showarrow\"] = val\n", "docstring": "self[\"showarrow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def standoff(self, val):\n        self[\"standoff\"] = val\n", "docstring": "self[\"standoff\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def startarrowhead(self, val):\n        self[\"startarrowhead\"] = val\n", "docstring": "self[\"startarrowhead\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def startarrowsize(self, val):\n        self[\"startarrowsize\"] = val\n", "docstring": "self[\"startarrowsize\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def startstandoff(self, val):\n        self[\"startstandoff\"] = val\n", "docstring": "self[\"startstandoff\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def textangle(self, val):\n        self[\"textangle\"] = val\n", "docstring": "self[\"textangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def valign(self, val):\n        self[\"valign\"] = val\n", "docstring": "self[\"valign\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def xshift(self, val):\n        self[\"xshift\"] = val\n", "docstring": "self[\"xshift\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def yshift(self, val):\n        self[\"yshift\"] = val\n", "docstring": "self[\"yshift\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_annotation.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def backgroundcolor(self, val):\n        self[\"backgroundcolor\"] = val\n", "docstring": "self[\"backgroundcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def calendar(self, val):\n        self[\"calendar\"] = val\n", "docstring": "self[\"calendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def mirror(self, val):\n        self[\"mirror\"] = val\n", "docstring": "self[\"mirror\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showaxeslabels(self, val):\n        self[\"showaxeslabels\"] = val\n", "docstring": "self[\"showaxeslabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showbackground(self, val):\n        self[\"showbackground\"] = val\n", "docstring": "self[\"showbackground\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showspikes(self, val):\n        self[\"showspikes\"] = val\n", "docstring": "self[\"showspikes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def spikecolor(self, val):\n        self[\"spikecolor\"] = val\n", "docstring": "self[\"spikecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def spikesides(self, val):\n        self[\"spikesides\"] = val\n", "docstring": "self[\"spikesides\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def spikethickness(self, val):\n        self[\"spikethickness\"] = val\n", "docstring": "self[\"spikethickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def zeroline(self, val):\n        self[\"zeroline\"] = val\n", "docstring": "self[\"zeroline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def zerolinecolor(self, val):\n        self[\"zerolinecolor\"] = val\n", "docstring": "self[\"zerolinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_yaxis.py", "original_string": "    def zerolinewidth(self, val):\n        self[\"zerolinewidth\"] = val\n", "docstring": "self[\"zerolinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def backgroundcolor(self, val):\n        self[\"backgroundcolor\"] = val\n", "docstring": "self[\"backgroundcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def calendar(self, val):\n        self[\"calendar\"] = val\n", "docstring": "self[\"calendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def mirror(self, val):\n        self[\"mirror\"] = val\n", "docstring": "self[\"mirror\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showaxeslabels(self, val):\n        self[\"showaxeslabels\"] = val\n", "docstring": "self[\"showaxeslabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showbackground(self, val):\n        self[\"showbackground\"] = val\n", "docstring": "self[\"showbackground\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showspikes(self, val):\n        self[\"showspikes\"] = val\n", "docstring": "self[\"showspikes\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def spikecolor(self, val):\n        self[\"spikecolor\"] = val\n", "docstring": "self[\"spikecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def spikesides(self, val):\n        self[\"spikesides\"] = val\n", "docstring": "self[\"spikesides\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def spikethickness(self, val):\n        self[\"spikethickness\"] = val\n", "docstring": "self[\"spikethickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def zeroline(self, val):\n        self[\"zeroline\"] = val\n", "docstring": "self[\"zeroline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def zerolinecolor(self, val):\n        self[\"zerolinecolor\"] = val\n", "docstring": "self[\"zerolinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/_xaxis.py", "original_string": "    def zerolinewidth(self, val):\n        self[\"zerolinewidth\"] = val\n", "docstring": "self[\"zerolinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_projection.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_up.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_up.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_up.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_center.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_center.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_center.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_eye.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_eye.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/camera/_eye.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/yaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/annotation/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/xaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/scene/zaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def angle(self, val):\n        self[\"angle\"] = val\n", "docstring": "self[\"angle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def calendar(self, val):\n        self[\"calendar\"] = val\n", "docstring": "self[\"calendar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_radialaxis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def direction(self, val):\n        self[\"direction\"] = val\n", "docstring": "self[\"direction\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def period(self, val):\n        self[\"period\"] = val\n", "docstring": "self[\"period\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def rotation(self, val):\n        self[\"rotation\"] = val\n", "docstring": "self[\"rotation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def thetaunit(self, val):\n        self[\"thetaunit\"] = val\n", "docstring": "self[\"thetaunit\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_angularaxis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/angularaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/polar/radialaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_pad.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_pad.py", "original_string": "    def l(self, val):\n        self[\"l\"] = val\n", "docstring": "self[\"l\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_pad.py", "original_string": "    def r(self, val):\n        self[\"r\"] = val\n", "docstring": "self[\"r\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_pad.py", "original_string": "    def t(self, val):\n        self[\"t\"] = val\n", "docstring": "self[\"t\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def args(self, val):\n        self[\"args\"] = val\n", "docstring": "self[\"args\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def args2(self, val):\n        self[\"args2\"] = val\n", "docstring": "self[\"args2\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def execute(self, val):\n        self[\"execute\"] = val\n", "docstring": "self[\"execute\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def method(self, val):\n        self[\"method\"] = val\n", "docstring": "self[\"method\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/updatemenu/_button.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def barpolar(self, val):\n        self[\"barpolar\"] = val\n", "docstring": "self[\"barpolar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def bar(self, val):\n        self[\"bar\"] = val\n", "docstring": "self[\"bar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def box(self, val):\n        self[\"box\"] = val\n", "docstring": "self[\"box\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def candlestick(self, val):\n        self[\"candlestick\"] = val\n", "docstring": "self[\"candlestick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def carpet(self, val):\n        self[\"carpet\"] = val\n", "docstring": "self[\"carpet\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def choroplethmapbox(self, val):\n        self[\"choroplethmapbox\"] = val\n", "docstring": "self[\"choroplethmapbox\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def choropleth(self, val):\n        self[\"choropleth\"] = val\n", "docstring": "self[\"choropleth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def cone(self, val):\n        self[\"cone\"] = val\n", "docstring": "self[\"cone\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def contourcarpet(self, val):\n        self[\"contourcarpet\"] = val\n", "docstring": "self[\"contourcarpet\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def contour(self, val):\n        self[\"contour\"] = val\n", "docstring": "self[\"contour\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def densitymapbox(self, val):\n        self[\"densitymapbox\"] = val\n", "docstring": "self[\"densitymapbox\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def funnelarea(self, val):\n        self[\"funnelarea\"] = val\n", "docstring": "self[\"funnelarea\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def funnel(self, val):\n        self[\"funnel\"] = val\n", "docstring": "self[\"funnel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def heatmapgl(self, val):\n        self[\"heatmapgl\"] = val\n", "docstring": "self[\"heatmapgl\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def heatmap(self, val):\n        self[\"heatmap\"] = val\n", "docstring": "self[\"heatmap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def histogram2dcontour(self, val):\n        self[\"histogram2dcontour\"] = val\n", "docstring": "self[\"histogram2dcontour\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def histogram2d(self, val):\n        self[\"histogram2d\"] = val\n", "docstring": "self[\"histogram2d\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def histogram(self, val):\n        self[\"histogram\"] = val\n", "docstring": "self[\"histogram\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def icicle(self, val):\n        self[\"icicle\"] = val\n", "docstring": "self[\"icicle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def image(self, val):\n        self[\"image\"] = val\n", "docstring": "self[\"image\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def indicator(self, val):\n        self[\"indicator\"] = val\n", "docstring": "self[\"indicator\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def isosurface(self, val):\n        self[\"isosurface\"] = val\n", "docstring": "self[\"isosurface\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def mesh3d(self, val):\n        self[\"mesh3d\"] = val\n", "docstring": "self[\"mesh3d\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def ohlc(self, val):\n        self[\"ohlc\"] = val\n", "docstring": "self[\"ohlc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def parcats(self, val):\n        self[\"parcats\"] = val\n", "docstring": "self[\"parcats\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def parcoords(self, val):\n        self[\"parcoords\"] = val\n", "docstring": "self[\"parcoords\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def pie(self, val):\n        self[\"pie\"] = val\n", "docstring": "self[\"pie\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def pointcloud(self, val):\n        self[\"pointcloud\"] = val\n", "docstring": "self[\"pointcloud\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def sankey(self, val):\n        self[\"sankey\"] = val\n", "docstring": "self[\"sankey\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scatter3d(self, val):\n        self[\"scatter3d\"] = val\n", "docstring": "self[\"scatter3d\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scattercarpet(self, val):\n        self[\"scattercarpet\"] = val\n", "docstring": "self[\"scattercarpet\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scattergeo(self, val):\n        self[\"scattergeo\"] = val\n", "docstring": "self[\"scattergeo\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scattergl(self, val):\n        self[\"scattergl\"] = val\n", "docstring": "self[\"scattergl\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scattermapbox(self, val):\n        self[\"scattermapbox\"] = val\n", "docstring": "self[\"scattermapbox\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scatterpolargl(self, val):\n        self[\"scatterpolargl\"] = val\n", "docstring": "self[\"scatterpolargl\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scatterpolar(self, val):\n        self[\"scatterpolar\"] = val\n", "docstring": "self[\"scatterpolar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scatter(self, val):\n        self[\"scatter\"] = val\n", "docstring": "self[\"scatter\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def scatterternary(self, val):\n        self[\"scatterternary\"] = val\n", "docstring": "self[\"scatterternary\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def splom(self, val):\n        self[\"splom\"] = val\n", "docstring": "self[\"splom\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def streamtube(self, val):\n        self[\"streamtube\"] = val\n", "docstring": "self[\"streamtube\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def sunburst(self, val):\n        self[\"sunburst\"] = val\n", "docstring": "self[\"sunburst\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def surface(self, val):\n        self[\"surface\"] = val\n", "docstring": "self[\"surface\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def table(self, val):\n        self[\"table\"] = val\n", "docstring": "self[\"table\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def treemap(self, val):\n        self[\"treemap\"] = val\n", "docstring": "self[\"treemap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def violin(self, val):\n        self[\"violin\"] = val\n", "docstring": "self[\"violin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def volume(self, val):\n        self[\"volume\"] = val\n", "docstring": "self[\"volume\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/template/_data.py", "original_string": "    def waterfall(self, val):\n        self[\"waterfall\"] = val\n", "docstring": "self[\"waterfall\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def below(self, val):\n        self[\"below\"] = val\n", "docstring": "self[\"below\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def circle(self, val):\n        self[\"circle\"] = val\n", "docstring": "self[\"circle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def coordinates(self, val):\n        self[\"coordinates\"] = val\n", "docstring": "self[\"coordinates\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def maxzoom(self, val):\n        self[\"maxzoom\"] = val\n", "docstring": "self[\"maxzoom\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def minzoom(self, val):\n        self[\"minzoom\"] = val\n", "docstring": "self[\"minzoom\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def source(self, val):\n        self[\"source\"] = val\n", "docstring": "self[\"source\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def sourceattribution(self, val):\n        self[\"sourceattribution\"] = val\n", "docstring": "self[\"sourceattribution\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def sourcelayer(self, val):\n        self[\"sourcelayer\"] = val\n", "docstring": "self[\"sourcelayer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def sourcetype(self, val):\n        self[\"sourcetype\"] = val\n", "docstring": "self[\"sourcetype\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_layer.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_center.py", "original_string": "    def lat(self, val):\n        self[\"lat\"] = val\n", "docstring": "self[\"lat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_center.py", "original_string": "    def lon(self, val):\n        self[\"lon\"] = val\n", "docstring": "self[\"lon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_fill.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_line.py", "original_string": "    def dashsrc(self, val):\n        self[\"dashsrc\"] = val\n", "docstring": "self[\"dashsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_circle.py", "original_string": "    def radius(self, val):\n        self[\"radius\"] = val\n", "docstring": "self[\"radius\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_symbol.py", "original_string": "    def icon(self, val):\n        self[\"icon\"] = val\n", "docstring": "self[\"icon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_symbol.py", "original_string": "    def iconsize(self, val):\n        self[\"iconsize\"] = val\n", "docstring": "self[\"iconsize\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_symbol.py", "original_string": "    def placement(self, val):\n        self[\"placement\"] = val\n", "docstring": "self[\"placement\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_symbol.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_symbol.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/_symbol.py", "original_string": "    def textposition(self, val):\n        self[\"textposition\"] = val\n", "docstring": "self[\"textposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/symbol/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/symbol/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/mapbox/layer/symbol/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_title.py", "original_string": "    def standoff(self, val):\n        self[\"standoff\"] = val\n", "docstring": "self[\"standoff\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_rangebreak.py", "original_string": "    def bounds(self, val):\n        self[\"bounds\"] = val\n", "docstring": "self[\"bounds\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_rangebreak.py", "original_string": "    def dvalue(self, val):\n        self[\"dvalue\"] = val\n", "docstring": "self[\"dvalue\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_rangebreak.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_rangebreak.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_rangebreak.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_rangebreak.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_rangebreak.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/yaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lataxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lataxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lataxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lataxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lataxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lataxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lonaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lonaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lonaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lonaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lonaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_lonaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_projection.py", "original_string": "    def parallels(self, val):\n        self[\"parallels\"] = val\n", "docstring": "self[\"parallels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_projection.py", "original_string": "    def rotation(self, val):\n        self[\"rotation\"] = val\n", "docstring": "self[\"rotation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_projection.py", "original_string": "    def scale(self, val):\n        self[\"scale\"] = val\n", "docstring": "self[\"scale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_projection.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_center.py", "original_string": "    def lat(self, val):\n        self[\"lat\"] = val\n", "docstring": "self[\"lat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_center.py", "original_string": "    def lon(self, val):\n        self[\"lon\"] = val\n", "docstring": "self[\"lon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/projection/_rotation.py", "original_string": "    def lat(self, val):\n        self[\"lat\"] = val\n", "docstring": "self[\"lat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/projection/_rotation.py", "original_string": "    def lon(self, val):\n        self[\"lon\"] = val\n", "docstring": "self[\"lon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/geo/projection/_rotation.py", "original_string": "    def roll(self, val):\n        self[\"roll\"] = val\n", "docstring": "self[\"roll\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/legend/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/annotation/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/shape/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/shape/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/shape/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/title/_pad.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/title/_pad.py", "original_string": "    def l(self, val):\n        self[\"l\"] = val\n", "docstring": "self[\"l\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/title/_pad.py", "original_string": "    def r(self, val):\n        self[\"r\"] = val\n", "docstring": "self[\"r\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/title/_pad.py", "original_string": "    def t(self, val):\n        self[\"t\"] = val\n", "docstring": "self[\"t\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_pad.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_pad.py", "original_string": "    def l(self, val):\n        self[\"l\"] = val\n", "docstring": "self[\"l\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_pad.py", "original_string": "    def r(self, val):\n        self[\"r\"] = val\n", "docstring": "self[\"r\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_pad.py", "original_string": "    def t(self, val):\n        self[\"t\"] = val\n", "docstring": "self[\"t\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def args(self, val):\n        self[\"args\"] = val\n", "docstring": "self[\"args\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def execute(self, val):\n        self[\"execute\"] = val\n", "docstring": "self[\"execute\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def method(self, val):\n        self[\"method\"] = val\n", "docstring": "self[\"method\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_step.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_transition.py", "original_string": "    def duration(self, val):\n        self[\"duration\"] = val\n", "docstring": "self[\"duration\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_transition.py", "original_string": "    def easing(self, val):\n        self[\"easing\"] = val\n", "docstring": "self[\"easing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_currentvalue.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_currentvalue.py", "original_string": "    def offset(self, val):\n        self[\"offset\"] = val\n", "docstring": "self[\"offset\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_currentvalue.py", "original_string": "    def prefix(self, val):\n        self[\"prefix\"] = val\n", "docstring": "self[\"prefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_currentvalue.py", "original_string": "    def suffix(self, val):\n        self[\"suffix\"] = val\n", "docstring": "self[\"suffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_currentvalue.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/_currentvalue.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/currentvalue/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/currentvalue/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/slider/currentvalue/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/coloraxis/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def activecolor(self, val):\n        self[\"activecolor\"] = val\n", "docstring": "self[\"activecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def buttons(self, val):\n        self[\"buttons\"] = val\n", "docstring": "self[\"buttons\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def buttondefaults(self, val):\n        self[\"buttondefaults\"] = val\n", "docstring": "self[\"buttondefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeselector.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_title.py", "original_string": "    def standoff(self, val):\n        self[\"standoff\"] = val\n", "docstring": "self[\"standoff\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangebreak.py", "original_string": "    def bounds(self, val):\n        self[\"bounds\"] = val\n", "docstring": "self[\"bounds\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangebreak.py", "original_string": "    def dvalue(self, val):\n        self[\"dvalue\"] = val\n", "docstring": "self[\"dvalue\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangebreak.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangebreak.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangebreak.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangebreak.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangebreak.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/_rangeslider.py", "original_string": "    def yaxis(self, val):\n        self[\"yaxis\"] = val\n", "docstring": "self[\"yaxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeslider/_yaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeslider/_yaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_button.py", "original_string": "    def count(self, val):\n        self[\"count\"] = val\n", "docstring": "self[\"count\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_button.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_button.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_button.py", "original_string": "    def step(self, val):\n        self[\"step\"] = val\n", "docstring": "self[\"step\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_button.py", "original_string": "    def stepmode(self, val):\n        self[\"stepmode\"] = val\n", "docstring": "self[\"stepmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_button.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/rangeselector/_button.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/xaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def min(self, val):\n        self[\"min\"] = val\n", "docstring": "self[\"min\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_aaxis.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def min(self, val):\n        self[\"min\"] = val\n", "docstring": "self[\"min\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_caxis.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def hoverformat(self, val):\n        self[\"hoverformat\"] = val\n", "docstring": "self[\"hoverformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def layer(self, val):\n        self[\"layer\"] = val\n", "docstring": "self[\"layer\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def min(self, val):\n        self[\"min\"] = val\n", "docstring": "self[\"min\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_baxis.py", "original_string": "    def uirevision(self, val):\n        self[\"uirevision\"] = val\n", "docstring": "self[\"uirevision\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/aaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/baxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/layout/ternary/caxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_outsidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_outsidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_outsidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_outsidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_outsidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_outsidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_title.py", "original_string": "    def position(self, val):\n        self[\"position\"] = val\n", "docstring": "self[\"position\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_marker.py", "original_string": "    def colors(self, val):\n        self[\"colors\"] = val\n", "docstring": "self[\"colors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_marker.py", "original_string": "    def colorssrc(self, val):\n        self[\"colorssrc\"] = val\n", "docstring": "self[\"colorssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/title/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/title/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/title/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pie/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_outsidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_outsidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_outsidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_outsidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_outsidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_outsidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_connector.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_connector.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_connector.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/connector/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/connector/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/connector/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/funnel/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def copy_zstyle(self, val):\n        self[\"copy_zstyle\"] = val\n", "docstring": "self[\"copy_zstyle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_y.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_projection.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_projection.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_projection.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_z.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def copy_zstyle(self, val):\n        self[\"copy_zstyle\"] = val\n", "docstring": "self[\"copy_zstyle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/_error_x.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_z.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_z.py", "original_string": "    def scale(self, val):\n        self[\"scale\"] = val\n", "docstring": "self[\"scale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_z.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_x.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_x.py", "original_string": "    def scale(self, val):\n        self[\"scale\"] = val\n", "docstring": "self[\"scale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_x.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_y.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_y.py", "original_string": "    def scale(self, val):\n        self[\"scale\"] = val\n", "docstring": "self[\"scale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/projection/_y.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter3d/line/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_decreasing.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_increasing.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/_hoverlabel.py", "original_string": "    def split(self, val):\n        self[\"split\"] = val\n", "docstring": "self[\"split\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/increasing/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/increasing/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/increasing/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/decreasing/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/decreasing/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/ohlc/decreasing/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_rangefont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_rangefont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_rangefont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def constraintrange(self, val):\n        self[\"constraintrange\"] = val\n", "docstring": "self[\"constraintrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def multiselect(self, val):\n        self[\"multiselect\"] = val\n", "docstring": "self[\"multiselect\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_dimension.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_line.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_labelfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_labelfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_labelfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcoords/line/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def gradient(self, val):\n        self[\"gradient\"] = val\n", "docstring": "self[\"gradient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_gradient.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_gradient.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_gradient.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_gradient.py", "original_string": "    def typesrc(self, val):\n        self[\"typesrc\"] = val\n", "docstring": "self[\"typesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattergeo/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_marker.py", "original_string": "    def blend(self, val):\n        self[\"blend\"] = val\n", "docstring": "self[\"blend\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_marker.py", "original_string": "    def border(self, val):\n        self[\"border\"] = val\n", "docstring": "self[\"border\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_marker.py", "original_string": "    def sizemax(self, val):\n        self[\"sizemax\"] = val\n", "docstring": "self[\"sizemax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/marker/_border.py", "original_string": "    def arearatio(self, val):\n        self[\"arearatio\"] = val\n", "docstring": "self[\"arearatio\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/pointcloud/marker/_border.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_box.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_box.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_box.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_box.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_marker.py", "original_string": "    def outliercolor(self, val):\n        self[\"outliercolor\"] = val\n", "docstring": "self[\"outliercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_meanline.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_meanline.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/_meanline.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/box/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/box/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/marker/_line.py", "original_string": "    def outliercolor(self, val):\n        self[\"outliercolor\"] = val\n", "docstring": "self[\"outliercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/marker/_line.py", "original_string": "    def outlierwidth(self, val):\n        self[\"outlierwidth\"] = val\n", "docstring": "self[\"outlierwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/violin/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_xbins.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_xbins.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_xbins.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_ybins.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_ybins.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_ybins.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_line.py", "original_string": "    def smoothing(self, val):\n        self[\"smoothing\"] = val\n", "docstring": "self[\"smoothing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def coloring(self, val):\n        self[\"coloring\"] = val\n", "docstring": "self[\"coloring\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def labelfont(self, val):\n        self[\"labelfont\"] = val\n", "docstring": "self[\"labelfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def labelformat(self, val):\n        self[\"labelformat\"] = val\n", "docstring": "self[\"labelformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def operation(self, val):\n        self[\"operation\"] = val\n", "docstring": "self[\"operation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def showlabels(self, val):\n        self[\"showlabels\"] = val\n", "docstring": "self[\"showlabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def showlines(self, val):\n        self[\"showlines\"] = val\n", "docstring": "self[\"showlines\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_contours.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/contours/_labelfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/contours/_labelfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/histogram2dcontour/contours/_labelfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_line.py", "original_string": "    def smoothing(self, val):\n        self[\"smoothing\"] = val\n", "docstring": "self[\"smoothing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def coloring(self, val):\n        self[\"coloring\"] = val\n", "docstring": "self[\"coloring\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def labelfont(self, val):\n        self[\"labelfont\"] = val\n", "docstring": "self[\"labelfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def labelformat(self, val):\n        self[\"labelformat\"] = val\n", "docstring": "self[\"labelformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def operation(self, val):\n        self[\"operation\"] = val\n", "docstring": "self[\"operation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def showlabels(self, val):\n        self[\"showlabels\"] = val\n", "docstring": "self[\"showlabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def showlines(self, val):\n        self[\"showlines\"] = val\n", "docstring": "self[\"showlines\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_contours.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/contours/_labelfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/contours/_labelfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contour/contours/_labelfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_title.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def axis(self, val):\n        self[\"axis\"] = val\n", "docstring": "self[\"axis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def bar(self, val):\n        self[\"bar\"] = val\n", "docstring": "self[\"bar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def steps(self, val):\n        self[\"steps\"] = val\n", "docstring": "self[\"steps\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def stepdefaults(self, val):\n        self[\"stepdefaults\"] = val\n", "docstring": "self[\"stepdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_gauge.py", "original_string": "    def threshold(self, val):\n        self[\"threshold\"] = val\n", "docstring": "self[\"threshold\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_number.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_number.py", "original_string": "    def prefix(self, val):\n        self[\"prefix\"] = val\n", "docstring": "self[\"prefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_number.py", "original_string": "    def suffix(self, val):\n        self[\"suffix\"] = val\n", "docstring": "self[\"suffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_number.py", "original_string": "    def valueformat(self, val):\n        self[\"valueformat\"] = val\n", "docstring": "self[\"valueformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_delta.py", "original_string": "    def decreasing(self, val):\n        self[\"decreasing\"] = val\n", "docstring": "self[\"decreasing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_delta.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_delta.py", "original_string": "    def increasing(self, val):\n        self[\"increasing\"] = val\n", "docstring": "self[\"increasing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_delta.py", "original_string": "    def position(self, val):\n        self[\"position\"] = val\n", "docstring": "self[\"position\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_delta.py", "original_string": "    def reference(self, val):\n        self[\"reference\"] = val\n", "docstring": "self[\"reference\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_delta.py", "original_string": "    def relative(self, val):\n        self[\"relative\"] = val\n", "docstring": "self[\"relative\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_delta.py", "original_string": "    def valueformat(self, val):\n        self[\"valueformat\"] = val\n", "docstring": "self[\"valueformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_step.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_step.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_step.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_step.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_step.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_step.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_bar.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_bar.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_bar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_axis.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_threshold.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_threshold.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/_threshold.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/axis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/step/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/step/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/threshold/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/threshold/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/bar/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/gauge/bar/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/number/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/number/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/number/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/delta/_decreasing.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/delta/_decreasing.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/delta/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/delta/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/delta/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/delta/_increasing.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/delta/_increasing.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/indicator/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_outsidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_outsidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_outsidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_outsidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_outsidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_outsidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_pathbar.py", "original_string": "    def edgeshape(self, val):\n        self[\"edgeshape\"] = val\n", "docstring": "self[\"edgeshape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_pathbar.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_pathbar.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_pathbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_pathbar.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def colors(self, val):\n        self[\"colors\"] = val\n", "docstring": "self[\"colors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def colorssrc(self, val):\n        self[\"colorssrc\"] = val\n", "docstring": "self[\"colorssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def depthfade(self, val):\n        self[\"depthfade\"] = val\n", "docstring": "self[\"depthfade\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_tiling.py", "original_string": "    def flip(self, val):\n        self[\"flip\"] = val\n", "docstring": "self[\"flip\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_tiling.py", "original_string": "    def packing(self, val):\n        self[\"packing\"] = val\n", "docstring": "self[\"packing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_tiling.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_tiling.py", "original_string": "    def squarifyratio(self, val):\n        self[\"squarifyratio\"] = val\n", "docstring": "self[\"squarifyratio\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_root.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_pad.py", "original_string": "    def b(self, val):\n        self[\"b\"] = val\n", "docstring": "self[\"b\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_pad.py", "original_string": "    def l(self, val):\n        self[\"l\"] = val\n", "docstring": "self[\"l\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_pad.py", "original_string": "    def r(self, val):\n        self[\"r\"] = val\n", "docstring": "self[\"r\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_pad.py", "original_string": "    def t(self, val):\n        self[\"t\"] = val\n", "docstring": "self[\"t\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/pathbar/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/pathbar/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/pathbar/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/pathbar/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/pathbar/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/treemap/pathbar/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/heatmapgl/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lighting.py", "original_string": "    def ambient(self, val):\n        self[\"ambient\"] = val\n", "docstring": "self[\"ambient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lighting.py", "original_string": "    def diffuse(self, val):\n        self[\"diffuse\"] = val\n", "docstring": "self[\"diffuse\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lighting.py", "original_string": "    def facenormalsepsilon(self, val):\n        self[\"facenormalsepsilon\"] = val\n", "docstring": "self[\"facenormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lighting.py", "original_string": "    def fresnel(self, val):\n        self[\"fresnel\"] = val\n", "docstring": "self[\"fresnel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lighting.py", "original_string": "    def roughness(self, val):\n        self[\"roughness\"] = val\n", "docstring": "self[\"roughness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lighting.py", "original_string": "    def specular(self, val):\n        self[\"specular\"] = val\n", "docstring": "self[\"specular\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lighting.py", "original_string": "    def vertexnormalsepsilon(self, val):\n        self[\"vertexnormalsepsilon\"] = val\n", "docstring": "self[\"vertexnormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lightposition.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lightposition.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_lightposition.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/cone/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_marker.py", "original_string": "    def outliercolor(self, val):\n        self[\"outliercolor\"] = val\n", "docstring": "self[\"outliercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/marker/_line.py", "original_string": "    def outliercolor(self, val):\n        self[\"outliercolor\"] = val\n", "docstring": "self[\"outliercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/marker/_line.py", "original_string": "    def outlierwidth(self, val):\n        self[\"outlierwidth\"] = val\n", "docstring": "self[\"outlierwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/box/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lighting.py", "original_string": "    def ambient(self, val):\n        self[\"ambient\"] = val\n", "docstring": "self[\"ambient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lighting.py", "original_string": "    def diffuse(self, val):\n        self[\"diffuse\"] = val\n", "docstring": "self[\"diffuse\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lighting.py", "original_string": "    def fresnel(self, val):\n        self[\"fresnel\"] = val\n", "docstring": "self[\"fresnel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lighting.py", "original_string": "    def roughness(self, val):\n        self[\"roughness\"] = val\n", "docstring": "self[\"roughness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lighting.py", "original_string": "    def specular(self, val):\n        self[\"specular\"] = val\n", "docstring": "self[\"specular\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_contours.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_contours.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_contours.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lightposition.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lightposition.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_lightposition.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def highlight(self, val):\n        self[\"highlight\"] = val\n", "docstring": "self[\"highlight\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def highlightcolor(self, val):\n        self[\"highlightcolor\"] = val\n", "docstring": "self[\"highlightcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def highlightwidth(self, val):\n        self[\"highlightwidth\"] = val\n", "docstring": "self[\"highlightwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def project(self, val):\n        self[\"project\"] = val\n", "docstring": "self[\"project\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def usecolormap(self, val):\n        self[\"usecolormap\"] = val\n", "docstring": "self[\"usecolormap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_z.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def highlight(self, val):\n        self[\"highlight\"] = val\n", "docstring": "self[\"highlight\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def highlightcolor(self, val):\n        self[\"highlightcolor\"] = val\n", "docstring": "self[\"highlightcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def highlightwidth(self, val):\n        self[\"highlightwidth\"] = val\n", "docstring": "self[\"highlightwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def project(self, val):\n        self[\"project\"] = val\n", "docstring": "self[\"project\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def usecolormap(self, val):\n        self[\"usecolormap\"] = val\n", "docstring": "self[\"usecolormap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_x.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def highlight(self, val):\n        self[\"highlight\"] = val\n", "docstring": "self[\"highlight\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def highlightcolor(self, val):\n        self[\"highlightcolor\"] = val\n", "docstring": "self[\"highlightcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def highlightwidth(self, val):\n        self[\"highlightwidth\"] = val\n", "docstring": "self[\"highlightwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def project(self, val):\n        self[\"project\"] = val\n", "docstring": "self[\"project\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def usecolormap(self, val):\n        self[\"usecolormap\"] = val\n", "docstring": "self[\"usecolormap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/_y.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/z/_project.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/z/_project.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/z/_project.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/x/_project.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/x/_project.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/x/_project.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/y/_project.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/y/_project.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/surface/contours/y/_project.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_line.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolargl/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_outsidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_outsidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_outsidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_outsidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_outsidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_outsidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_pathbar.py", "original_string": "    def edgeshape(self, val):\n        self[\"edgeshape\"] = val\n", "docstring": "self[\"edgeshape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_pathbar.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_pathbar.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_pathbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_pathbar.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def colors(self, val):\n        self[\"colors\"] = val\n", "docstring": "self[\"colors\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def colorssrc(self, val):\n        self[\"colorssrc\"] = val\n", "docstring": "self[\"colorssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_leaf.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_tiling.py", "original_string": "    def flip(self, val):\n        self[\"flip\"] = val\n", "docstring": "self[\"flip\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_tiling.py", "original_string": "    def orientation(self, val):\n        self[\"orientation\"] = val\n", "docstring": "self[\"orientation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_tiling.py", "original_string": "    def pad(self, val):\n        self[\"pad\"] = val\n", "docstring": "self[\"pad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_root.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/pathbar/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/pathbar/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/pathbar/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/pathbar/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/pathbar/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/icicle/pathbar/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_outsidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_outsidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_outsidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_outsidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_outsidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_outsidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_y.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def copy_ystyle(self, val):\n        self[\"copy_ystyle\"] = val\n", "docstring": "self[\"copy_ystyle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_error_x.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def fgcolor(self, val):\n        self[\"fgcolor\"] = val\n", "docstring": "self[\"fgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def fgcolorsrc(self, val):\n        self[\"fgcolorsrc\"] = val\n", "docstring": "self[\"fgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def fgopacity(self, val):\n        self[\"fgopacity\"] = val\n", "docstring": "self[\"fgopacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def fillmode(self, val):\n        self[\"fillmode\"] = val\n", "docstring": "self[\"fillmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def shapesrc(self, val):\n        self[\"shapesrc\"] = val\n", "docstring": "self[\"shapesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def solidity(self, val):\n        self[\"solidity\"] = val\n", "docstring": "self[\"solidity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_pattern.py", "original_string": "    def soliditysrc(self, val):\n        self[\"soliditysrc\"] = val\n", "docstring": "self[\"soliditysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/bar/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_caps.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_caps.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_caps.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lighting.py", "original_string": "    def ambient(self, val):\n        self[\"ambient\"] = val\n", "docstring": "self[\"ambient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lighting.py", "original_string": "    def diffuse(self, val):\n        self[\"diffuse\"] = val\n", "docstring": "self[\"diffuse\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lighting.py", "original_string": "    def facenormalsepsilon(self, val):\n        self[\"facenormalsepsilon\"] = val\n", "docstring": "self[\"facenormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lighting.py", "original_string": "    def fresnel(self, val):\n        self[\"fresnel\"] = val\n", "docstring": "self[\"fresnel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lighting.py", "original_string": "    def roughness(self, val):\n        self[\"roughness\"] = val\n", "docstring": "self[\"roughness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lighting.py", "original_string": "    def specular(self, val):\n        self[\"specular\"] = val\n", "docstring": "self[\"specular\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lighting.py", "original_string": "    def vertexnormalsepsilon(self, val):\n        self[\"vertexnormalsepsilon\"] = val\n", "docstring": "self[\"vertexnormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_spaceframe.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_spaceframe.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_contour.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_contour.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_contour.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_surface.py", "original_string": "    def count(self, val):\n        self[\"count\"] = val\n", "docstring": "self[\"count\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_surface.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_surface.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_surface.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_slices.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_slices.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_slices.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lightposition.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lightposition.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_lightposition.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/caps/_z.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/caps/_z.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/caps/_x.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/caps/_x.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/caps/_y.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/caps/_y.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_z.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_z.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_z.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_z.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_x.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_x.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_x.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_x.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_y.py", "original_string": "    def fill(self, val):\n        self[\"fill\"] = val\n", "docstring": "self[\"fill\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_y.py", "original_string": "    def locations(self, val):\n        self[\"locations\"] = val\n", "docstring": "self[\"locations\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_y.py", "original_string": "    def locationssrc(self, val):\n        self[\"locationssrc\"] = val\n", "docstring": "self[\"locationssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/volume/slices/_y.py", "original_string": "    def show(self, val):\n        self[\"show\"] = val\n", "docstring": "self[\"show\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_decreasing.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_decreasing.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_increasing.py", "original_string": "    def fillcolor(self, val):\n        self[\"fillcolor\"] = val\n", "docstring": "self[\"fillcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_increasing.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/_hoverlabel.py", "original_string": "    def split(self, val):\n        self[\"split\"] = val\n", "docstring": "self[\"split\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/increasing/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/increasing/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/decreasing/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/candlestick/decreasing/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lighting.py", "original_string": "    def ambient(self, val):\n        self[\"ambient\"] = val\n", "docstring": "self[\"ambient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lighting.py", "original_string": "    def diffuse(self, val):\n        self[\"diffuse\"] = val\n", "docstring": "self[\"diffuse\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lighting.py", "original_string": "    def facenormalsepsilon(self, val):\n        self[\"facenormalsepsilon\"] = val\n", "docstring": "self[\"facenormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lighting.py", "original_string": "    def fresnel(self, val):\n        self[\"fresnel\"] = val\n", "docstring": "self[\"fresnel\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lighting.py", "original_string": "    def roughness(self, val):\n        self[\"roughness\"] = val\n", "docstring": "self[\"roughness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lighting.py", "original_string": "    def specular(self, val):\n        self[\"specular\"] = val\n", "docstring": "self[\"specular\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lighting.py", "original_string": "    def vertexnormalsepsilon(self, val):\n        self[\"vertexnormalsepsilon\"] = val\n", "docstring": "self[\"vertexnormalsepsilon\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_starts.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_starts.py", "original_string": "    def xsrc(self, val):\n        self[\"xsrc\"] = val\n", "docstring": "self[\"xsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_starts.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_starts.py", "original_string": "    def ysrc(self, val):\n        self[\"ysrc\"] = val\n", "docstring": "self[\"ysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_starts.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_starts.py", "original_string": "    def zsrc(self, val):\n        self[\"zsrc\"] = val\n", "docstring": "self[\"zsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lightposition.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lightposition.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_lightposition.py", "original_string": "    def z(self, val):\n        self[\"z\"] = val\n", "docstring": "self[\"z\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/streamtube/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def gradient(self, val):\n        self[\"gradient\"] = val\n", "docstring": "self[\"gradient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def maxdisplayed(self, val):\n        self[\"maxdisplayed\"] = val\n", "docstring": "self[\"maxdisplayed\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_line.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_line.py", "original_string": "    def smoothing(self, val):\n        self[\"smoothing\"] = val\n", "docstring": "self[\"smoothing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_gradient.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_gradient.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_gradient.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_gradient.py", "original_string": "    def typesrc(self, val):\n        self[\"typesrc\"] = val\n", "docstring": "self[\"typesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattercarpet/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def allowoverlap(self, val):\n        self[\"allowoverlap\"] = val\n", "docstring": "self[\"allowoverlap\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def angle(self, val):\n        self[\"angle\"] = val\n", "docstring": "self[\"angle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def anglesrc(self, val):\n        self[\"anglesrc\"] = val\n", "docstring": "self[\"anglesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scattermapbox/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_y.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_y.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_y.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_y.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_y.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_y.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_y.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_y.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_y.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_y.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_y.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_y.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_y.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_y.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def gradient(self, val):\n        self[\"gradient\"] = val\n", "docstring": "self[\"gradient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def maxdisplayed(self, val):\n        self[\"maxdisplayed\"] = val\n", "docstring": "self[\"maxdisplayed\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_line.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_line.py", "original_string": "    def simplify(self, val):\n        self[\"simplify\"] = val\n", "docstring": "self[\"simplify\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_line.py", "original_string": "    def smoothing(self, val):\n        self[\"smoothing\"] = val\n", "docstring": "self[\"smoothing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def array(self, val):\n        self[\"array\"] = val\n", "docstring": "self[\"array\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def arrayminus(self, val):\n        self[\"arrayminus\"] = val\n", "docstring": "self[\"arrayminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def arrayminussrc(self, val):\n        self[\"arrayminussrc\"] = val\n", "docstring": "self[\"arrayminussrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def arraysrc(self, val):\n        self[\"arraysrc\"] = val\n", "docstring": "self[\"arraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def copy_ystyle(self, val):\n        self[\"copy_ystyle\"] = val\n", "docstring": "self[\"copy_ystyle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def symmetric(self, val):\n        self[\"symmetric\"] = val\n", "docstring": "self[\"symmetric\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def traceref(self, val):\n        self[\"traceref\"] = val\n", "docstring": "self[\"traceref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def tracerefminus(self, val):\n        self[\"tracerefminus\"] = val\n", "docstring": "self[\"tracerefminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def valueminus(self, val):\n        self[\"valueminus\"] = val\n", "docstring": "self[\"valueminus\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/_error_x.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_gradient.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_gradient.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_gradient.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_gradient.py", "original_string": "    def typesrc(self, val):\n        self[\"typesrc\"] = val\n", "docstring": "self[\"typesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatter/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_line.py", "original_string": "    def smoothing(self, val):\n        self[\"smoothing\"] = val\n", "docstring": "self[\"smoothing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_contours.py", "original_string": "    def coloring(self, val):\n        self[\"coloring\"] = val\n", "docstring": "self[\"coloring\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_contours.py", "original_string": "    def end(self, val):\n        self[\"end\"] = val\n", "docstring": "self[\"end\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_contours.py", "original_string": "    def labelfont(self, val):\n        self[\"labelfont\"] = val\n", "docstring": "self[\"labelfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_contours.py", "original_string": "    def labelformat(self, val):\n        self[\"labelformat\"] = val\n", "docstring": "self[\"labelformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_contours.py", "original_string": "    def operation(self, val):\n        self[\"operation\"] = val\n", "docstring": "self[\"operation\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_contours.py", "original_string": "    def showlabels(self, val):\n        self[\"showlabels\"] = val\n", "docstring": "self[\"showlabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_contours.py", "original_string": "    def showlines(self, val):\n        self[\"showlines\"] = val\n", "docstring": "self[\"showlines\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_contours.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_contours.py", "original_string": "    def start(self, val):\n        self[\"start\"] = val\n", "docstring": "self[\"start\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_contours.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_contours.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/contours/_labelfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/contours/_labelfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/contourcarpet/contours/_labelfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choroplethmapbox/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def gradient(self, val):\n        self[\"gradient\"] = val\n", "docstring": "self[\"gradient\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def maxdisplayed(self, val):\n        self[\"maxdisplayed\"] = val\n", "docstring": "self[\"maxdisplayed\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def sizemin(self, val):\n        self[\"sizemin\"] = val\n", "docstring": "self[\"sizemin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def sizemode(self, val):\n        self[\"sizemode\"] = val\n", "docstring": "self[\"sizemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def sizeref(self, val):\n        self[\"sizeref\"] = val\n", "docstring": "self[\"sizeref\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def symbol(self, val):\n        self[\"symbol\"] = val\n", "docstring": "self[\"symbol\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_marker.py", "original_string": "    def symbolsrc(self, val):\n        self[\"symbolsrc\"] = val\n", "docstring": "self[\"symbolsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_line.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_line.py", "original_string": "    def smoothing(self, val):\n        self[\"smoothing\"] = val\n", "docstring": "self[\"smoothing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/unselected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/selected/_marker.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_gradient.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_gradient.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_gradient.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_gradient.py", "original_string": "    def typesrc(self, val):\n        self[\"typesrc\"] = val\n", "docstring": "self[\"typesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/scatterpolar/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/choropleth/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def arraydtick(self, val):\n        self[\"arraydtick\"] = val\n", "docstring": "self[\"arraydtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def arraytick0(self, val):\n        self[\"arraytick0\"] = val\n", "docstring": "self[\"arraytick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def cheatertype(self, val):\n        self[\"cheatertype\"] = val\n", "docstring": "self[\"cheatertype\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def endline(self, val):\n        self[\"endline\"] = val\n", "docstring": "self[\"endline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def endlinecolor(self, val):\n        self[\"endlinecolor\"] = val\n", "docstring": "self[\"endlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def endlinewidth(self, val):\n        self[\"endlinewidth\"] = val\n", "docstring": "self[\"endlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def fixedrange(self, val):\n        self[\"fixedrange\"] = val\n", "docstring": "self[\"fixedrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def labelpadding(self, val):\n        self[\"labelpadding\"] = val\n", "docstring": "self[\"labelpadding\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def labelprefix(self, val):\n        self[\"labelprefix\"] = val\n", "docstring": "self[\"labelprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def labelsuffix(self, val):\n        self[\"labelsuffix\"] = val\n", "docstring": "self[\"labelsuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def minorgridcolor(self, val):\n        self[\"minorgridcolor\"] = val\n", "docstring": "self[\"minorgridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def minorgridcount(self, val):\n        self[\"minorgridcount\"] = val\n", "docstring": "self[\"minorgridcount\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def minorgridwidth(self, val):\n        self[\"minorgridwidth\"] = val\n", "docstring": "self[\"minorgridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def smoothing(self, val):\n        self[\"smoothing\"] = val\n", "docstring": "self[\"smoothing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def startline(self, val):\n        self[\"startline\"] = val\n", "docstring": "self[\"startline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def startlinecolor(self, val):\n        self[\"startlinecolor\"] = val\n", "docstring": "self[\"startlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def startlinewidth(self, val):\n        self[\"startlinewidth\"] = val\n", "docstring": "self[\"startlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def titleoffset(self, val):\n        self[\"titleoffset\"] = val\n", "docstring": "self[\"titleoffset\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_aaxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def arraydtick(self, val):\n        self[\"arraydtick\"] = val\n", "docstring": "self[\"arraydtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def arraytick0(self, val):\n        self[\"arraytick0\"] = val\n", "docstring": "self[\"arraytick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def autorange(self, val):\n        self[\"autorange\"] = val\n", "docstring": "self[\"autorange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def autotypenumbers(self, val):\n        self[\"autotypenumbers\"] = val\n", "docstring": "self[\"autotypenumbers\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def cheatertype(self, val):\n        self[\"cheatertype\"] = val\n", "docstring": "self[\"cheatertype\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def endline(self, val):\n        self[\"endline\"] = val\n", "docstring": "self[\"endline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def endlinecolor(self, val):\n        self[\"endlinecolor\"] = val\n", "docstring": "self[\"endlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def endlinewidth(self, val):\n        self[\"endlinewidth\"] = val\n", "docstring": "self[\"endlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def fixedrange(self, val):\n        self[\"fixedrange\"] = val\n", "docstring": "self[\"fixedrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def gridcolor(self, val):\n        self[\"gridcolor\"] = val\n", "docstring": "self[\"gridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def gridwidth(self, val):\n        self[\"gridwidth\"] = val\n", "docstring": "self[\"gridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def labelpadding(self, val):\n        self[\"labelpadding\"] = val\n", "docstring": "self[\"labelpadding\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def labelprefix(self, val):\n        self[\"labelprefix\"] = val\n", "docstring": "self[\"labelprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def labelsuffix(self, val):\n        self[\"labelsuffix\"] = val\n", "docstring": "self[\"labelsuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def linecolor(self, val):\n        self[\"linecolor\"] = val\n", "docstring": "self[\"linecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def linewidth(self, val):\n        self[\"linewidth\"] = val\n", "docstring": "self[\"linewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def minorgridcolor(self, val):\n        self[\"minorgridcolor\"] = val\n", "docstring": "self[\"minorgridcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def minorgridcount(self, val):\n        self[\"minorgridcount\"] = val\n", "docstring": "self[\"minorgridcount\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def minorgridwidth(self, val):\n        self[\"minorgridwidth\"] = val\n", "docstring": "self[\"minorgridwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def range(self, val):\n        self[\"range\"] = val\n", "docstring": "self[\"range\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def rangemode(self, val):\n        self[\"rangemode\"] = val\n", "docstring": "self[\"rangemode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def showgrid(self, val):\n        self[\"showgrid\"] = val\n", "docstring": "self[\"showgrid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def showline(self, val):\n        self[\"showline\"] = val\n", "docstring": "self[\"showline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def smoothing(self, val):\n        self[\"smoothing\"] = val\n", "docstring": "self[\"smoothing\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def startline(self, val):\n        self[\"startline\"] = val\n", "docstring": "self[\"startline\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def startlinecolor(self, val):\n        self[\"startlinecolor\"] = val\n", "docstring": "self[\"startlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def startlinewidth(self, val):\n        self[\"startlinewidth\"] = val\n", "docstring": "self[\"startlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def titleoffset(self, val):\n        self[\"titleoffset\"] = val\n", "docstring": "self[\"titleoffset\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/_baxis.py", "original_string": "    def type(self, val):\n        self[\"type\"] = val\n", "docstring": "self[\"type\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/aaxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/aaxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/aaxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/aaxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/aaxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/aaxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/aaxis/_title.py", "original_string": "    def offset(self, val):\n        self[\"offset\"] = val\n", "docstring": "self[\"offset\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/aaxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/aaxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/aaxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/aaxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/aaxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/aaxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/aaxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/baxis/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/baxis/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/baxis/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/baxis/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/baxis/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/baxis/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/baxis/_title.py", "original_string": "    def offset(self, val):\n        self[\"offset\"] = val\n", "docstring": "self[\"offset\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/baxis/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/baxis/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/baxis/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/baxis/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/baxis/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/baxis/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/carpet/baxis/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_dimension.py", "original_string": "    def categoryarray(self, val):\n        self[\"categoryarray\"] = val\n", "docstring": "self[\"categoryarray\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_dimension.py", "original_string": "    def categoryarraysrc(self, val):\n        self[\"categoryarraysrc\"] = val\n", "docstring": "self[\"categoryarraysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_dimension.py", "original_string": "    def categoryorder(self, val):\n        self[\"categoryorder\"] = val\n", "docstring": "self[\"categoryorder\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_dimension.py", "original_string": "    def displayindex(self, val):\n        self[\"displayindex\"] = val\n", "docstring": "self[\"displayindex\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_dimension.py", "original_string": "    def label(self, val):\n        self[\"label\"] = val\n", "docstring": "self[\"label\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_dimension.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_dimension.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_dimension.py", "original_string": "    def values(self, val):\n        self[\"values\"] = val\n", "docstring": "self[\"values\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_dimension.py", "original_string": "    def valuessrc(self, val):\n        self[\"valuessrc\"] = val\n", "docstring": "self[\"valuessrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_dimension.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_line.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_line.py", "original_string": "    def hovertemplate(self, val):\n        self[\"hovertemplate\"] = val\n", "docstring": "self[\"hovertemplate\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_line.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_line.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_labelfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_labelfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_labelfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_domain.py", "original_string": "    def column(self, val):\n        self[\"column\"] = val\n", "docstring": "self[\"column\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_domain.py", "original_string": "    def row(self, val):\n        self[\"row\"] = val\n", "docstring": "self[\"row\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_domain.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/_domain.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/parcats/line/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_selected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_selected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def colorbar(self, val):\n        self[\"colorbar\"] = val\n", "docstring": "self[\"colorbar\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def opacitysrc(self, val):\n        self[\"opacitysrc\"] = val\n", "docstring": "self[\"opacitysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def pattern(self, val):\n        self[\"pattern\"] = val\n", "docstring": "self[\"pattern\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_marker.py", "original_string": "    def showscale(self, val):\n        self[\"showscale\"] = val\n", "docstring": "self[\"showscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_unselected.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_unselected.py", "original_string": "    def textfont(self, val):\n        self[\"textfont\"] = val\n", "docstring": "self[\"textfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/unselected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/unselected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/unselected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/selected/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/selected/_marker.py", "original_string": "    def opacity(self, val):\n        self[\"opacity\"] = val\n", "docstring": "self[\"opacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/selected/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_pattern.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_pattern.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_pattern.py", "original_string": "    def fgcolor(self, val):\n        self[\"fgcolor\"] = val\n", "docstring": "self[\"fgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_pattern.py", "original_string": "    def fgcolorsrc(self, val):\n        self[\"fgcolorsrc\"] = val\n", "docstring": "self[\"fgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_pattern.py", "original_string": "    def fgopacity(self, val):\n        self[\"fgopacity\"] = val\n", "docstring": "self[\"fgopacity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_pattern.py", "original_string": "    def fillmode(self, val):\n        self[\"fillmode\"] = val\n", "docstring": "self[\"fillmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_pattern.py", "original_string": "    def shape(self, val):\n        self[\"shape\"] = val\n", "docstring": "self[\"shape\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_pattern.py", "original_string": "    def shapesrc(self, val):\n        self[\"shapesrc\"] = val\n", "docstring": "self[\"shapesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_pattern.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_pattern.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_pattern.py", "original_string": "    def solidity(self, val):\n        self[\"solidity\"] = val\n", "docstring": "self[\"solidity\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_pattern.py", "original_string": "    def soliditysrc(self, val):\n        self[\"soliditysrc\"] = val\n", "docstring": "self[\"soliditysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_line.py", "original_string": "    def autocolorscale(self, val):\n        self[\"autocolorscale\"] = val\n", "docstring": "self[\"autocolorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_line.py", "original_string": "    def cauto(self, val):\n        self[\"cauto\"] = val\n", "docstring": "self[\"cauto\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_line.py", "original_string": "    def cmax(self, val):\n        self[\"cmax\"] = val\n", "docstring": "self[\"cmax\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_line.py", "original_string": "    def cmid(self, val):\n        self[\"cmid\"] = val\n", "docstring": "self[\"cmid\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_line.py", "original_string": "    def cmin(self, val):\n        self[\"cmin\"] = val\n", "docstring": "self[\"cmin\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_line.py", "original_string": "    def coloraxis(self, val):\n        self[\"coloraxis\"] = val\n", "docstring": "self[\"coloraxis\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_line.py", "original_string": "    def colorscale(self, val):\n        self[\"colorscale\"] = val\n", "docstring": "self[\"colorscale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_line.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_line.py", "original_string": "    def reversescale(self, val):\n        self[\"reversescale\"] = val\n", "docstring": "self[\"reversescale\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_line.py", "original_string": "    def widthsrc(self, val):\n        self[\"widthsrc\"] = val\n", "docstring": "self[\"widthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def borderwidth(self, val):\n        self[\"borderwidth\"] = val\n", "docstring": "self[\"borderwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def dtick(self, val):\n        self[\"dtick\"] = val\n", "docstring": "self[\"dtick\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def exponentformat(self, val):\n        self[\"exponentformat\"] = val\n", "docstring": "self[\"exponentformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def len(self, val):\n        self[\"len\"] = val\n", "docstring": "self[\"len\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def lenmode(self, val):\n        self[\"lenmode\"] = val\n", "docstring": "self[\"lenmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def minexponent(self, val):\n        self[\"minexponent\"] = val\n", "docstring": "self[\"minexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def nticks(self, val):\n        self[\"nticks\"] = val\n", "docstring": "self[\"nticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def outlinecolor(self, val):\n        self[\"outlinecolor\"] = val\n", "docstring": "self[\"outlinecolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def outlinewidth(self, val):\n        self[\"outlinewidth\"] = val\n", "docstring": "self[\"outlinewidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def separatethousands(self, val):\n        self[\"separatethousands\"] = val\n", "docstring": "self[\"separatethousands\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def showexponent(self, val):\n        self[\"showexponent\"] = val\n", "docstring": "self[\"showexponent\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def showticklabels(self, val):\n        self[\"showticklabels\"] = val\n", "docstring": "self[\"showticklabels\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def showtickprefix(self, val):\n        self[\"showtickprefix\"] = val\n", "docstring": "self[\"showtickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def showticksuffix(self, val):\n        self[\"showticksuffix\"] = val\n", "docstring": "self[\"showticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def thickness(self, val):\n        self[\"thickness\"] = val\n", "docstring": "self[\"thickness\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def thicknessmode(self, val):\n        self[\"thicknessmode\"] = val\n", "docstring": "self[\"thicknessmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def tick0(self, val):\n        self[\"tick0\"] = val\n", "docstring": "self[\"tick0\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def tickangle(self, val):\n        self[\"tickangle\"] = val\n", "docstring": "self[\"tickangle\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def tickcolor(self, val):\n        self[\"tickcolor\"] = val\n", "docstring": "self[\"tickcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def tickfont(self, val):\n        self[\"tickfont\"] = val\n", "docstring": "self[\"tickfont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def tickformat(self, val):\n        self[\"tickformat\"] = val\n", "docstring": "self[\"tickformat\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def tickformatstops(self, val):\n        self[\"tickformatstops\"] = val\n", "docstring": "self[\"tickformatstops\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def tickformatstopdefaults(self, val):\n        self[\"tickformatstopdefaults\"] = val\n", "docstring": "self[\"tickformatstopdefaults\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def ticklabeloverflow(self, val):\n        self[\"ticklabeloverflow\"] = val\n", "docstring": "self[\"ticklabeloverflow\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def ticklabelposition(self, val):\n        self[\"ticklabelposition\"] = val\n", "docstring": "self[\"ticklabelposition\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def ticklen(self, val):\n        self[\"ticklen\"] = val\n", "docstring": "self[\"ticklen\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def tickmode(self, val):\n        self[\"tickmode\"] = val\n", "docstring": "self[\"tickmode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def tickprefix(self, val):\n        self[\"tickprefix\"] = val\n", "docstring": "self[\"tickprefix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def ticks(self, val):\n        self[\"ticks\"] = val\n", "docstring": "self[\"ticks\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def ticksuffix(self, val):\n        self[\"ticksuffix\"] = val\n", "docstring": "self[\"ticksuffix\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def ticktext(self, val):\n        self[\"ticktext\"] = val\n", "docstring": "self[\"ticktext\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def ticktextsrc(self, val):\n        self[\"ticktextsrc\"] = val\n", "docstring": "self[\"ticktextsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def tickvals(self, val):\n        self[\"tickvals\"] = val\n", "docstring": "self[\"tickvals\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def tickvalssrc(self, val):\n        self[\"tickvalssrc\"] = val\n", "docstring": "self[\"tickvalssrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def tickwidth(self, val):\n        self[\"tickwidth\"] = val\n", "docstring": "self[\"tickwidth\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def title(self, val):\n        self[\"title\"] = val\n", "docstring": "self[\"title\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def titlefont(self, val):\n        self[\"titlefont\"] = val\n", "docstring": "self[\"titlefont\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def titleside(self, val):\n        self[\"titleside\"] = val\n", "docstring": "self[\"titleside\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def x(self, val):\n        self[\"x\"] = val\n", "docstring": "self[\"x\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def xanchor(self, val):\n        self[\"xanchor\"] = val\n", "docstring": "self[\"xanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def xpad(self, val):\n        self[\"xpad\"] = val\n", "docstring": "self[\"xpad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def y(self, val):\n        self[\"y\"] = val\n", "docstring": "self[\"y\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def yanchor(self, val):\n        self[\"yanchor\"] = val\n", "docstring": "self[\"yanchor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/_colorbar.py", "original_string": "    def ypad(self, val):\n        self[\"ypad\"] = val\n", "docstring": "self[\"ypad\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/colorbar/_tickformatstop.py", "original_string": "    def dtickrange(self, val):\n        self[\"dtickrange\"] = val\n", "docstring": "self[\"dtickrange\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/colorbar/_tickformatstop.py", "original_string": "    def enabled(self, val):\n        self[\"enabled\"] = val\n", "docstring": "self[\"enabled\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/colorbar/_tickformatstop.py", "original_string": "    def name(self, val):\n        self[\"name\"] = val\n", "docstring": "self[\"name\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/colorbar/_tickformatstop.py", "original_string": "    def templateitemname(self, val):\n        self[\"templateitemname\"] = val\n", "docstring": "self[\"templateitemname\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/colorbar/_tickformatstop.py", "original_string": "    def value(self, val):\n        self[\"value\"] = val\n", "docstring": "self[\"value\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/colorbar/_title.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/colorbar/_title.py", "original_string": "    def side(self, val):\n        self[\"side\"] = val\n", "docstring": "self[\"side\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/colorbar/_title.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/colorbar/_tickfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/colorbar/_tickfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/colorbar/_tickfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/colorbar/title/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/colorbar/title/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/barpolar/marker/colorbar/title/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_outsidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_outsidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_outsidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_outsidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_outsidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_outsidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_legendgrouptitle.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_legendgrouptitle.py", "original_string": "    def text(self, val):\n        self[\"text\"] = val\n", "docstring": "self[\"text\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_decreasing.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_stream.py", "original_string": "    def maxpoints(self, val):\n        self[\"maxpoints\"] = val\n", "docstring": "self[\"maxpoints\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_stream.py", "original_string": "    def token(self, val):\n        self[\"token\"] = val\n", "docstring": "self[\"token\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_increasing.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_textfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_textfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_textfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_textfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_textfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_textfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_hoverlabel.py", "original_string": "    def align(self, val):\n        self[\"align\"] = val\n", "docstring": "self[\"align\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_hoverlabel.py", "original_string": "    def alignsrc(self, val):\n        self[\"alignsrc\"] = val\n", "docstring": "self[\"alignsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_hoverlabel.py", "original_string": "    def bgcolor(self, val):\n        self[\"bgcolor\"] = val\n", "docstring": "self[\"bgcolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_hoverlabel.py", "original_string": "    def bgcolorsrc(self, val):\n        self[\"bgcolorsrc\"] = val\n", "docstring": "self[\"bgcolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_hoverlabel.py", "original_string": "    def bordercolor(self, val):\n        self[\"bordercolor\"] = val\n", "docstring": "self[\"bordercolor\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_hoverlabel.py", "original_string": "    def bordercolorsrc(self, val):\n        self[\"bordercolorsrc\"] = val\n", "docstring": "self[\"bordercolorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_hoverlabel.py", "original_string": "    def font(self, val):\n        self[\"font\"] = val\n", "docstring": "self[\"font\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_hoverlabel.py", "original_string": "    def namelength(self, val):\n        self[\"namelength\"] = val\n", "docstring": "self[\"namelength\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_hoverlabel.py", "original_string": "    def namelengthsrc(self, val):\n        self[\"namelengthsrc\"] = val\n", "docstring": "self[\"namelengthsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_totals.py", "original_string": "    def marker(self, val):\n        self[\"marker\"] = val\n", "docstring": "self[\"marker\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_connector.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_connector.py", "original_string": "    def mode(self, val):\n        self[\"mode\"] = val\n", "docstring": "self[\"mode\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_connector.py", "original_string": "    def visible(self, val):\n        self[\"visible\"] = val\n", "docstring": "self[\"visible\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_insidetextfont.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_insidetextfont.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_insidetextfont.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_insidetextfont.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_insidetextfont.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/_insidetextfont.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/totals/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/totals/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/totals/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/totals/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/legendgrouptitle/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/legendgrouptitle/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/legendgrouptitle/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/connector/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/connector/_line.py", "original_string": "    def dash(self, val):\n        self[\"dash\"] = val\n", "docstring": "self[\"dash\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/connector/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/hoverlabel/_font.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/hoverlabel/_font.py", "original_string": "    def colorsrc(self, val):\n        self[\"colorsrc\"] = val\n", "docstring": "self[\"colorsrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/hoverlabel/_font.py", "original_string": "    def family(self, val):\n        self[\"family\"] = val\n", "docstring": "self[\"family\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/hoverlabel/_font.py", "original_string": "    def familysrc(self, val):\n        self[\"familysrc\"] = val\n", "docstring": "self[\"familysrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/hoverlabel/_font.py", "original_string": "    def size(self, val):\n        self[\"size\"] = val\n", "docstring": "self[\"size\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/hoverlabel/_font.py", "original_string": "    def sizesrc(self, val):\n        self[\"sizesrc\"] = val\n", "docstring": "self[\"sizesrc\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/increasing/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/increasing/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/increasing/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/increasing/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/decreasing/_marker.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/decreasing/_marker.py", "original_string": "    def line(self, val):\n        self[\"line\"] = val\n", "docstring": "self[\"line\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/decreasing/marker/_line.py", "original_string": "    def color(self, val):\n        self[\"color\"] = val\n", "docstring": "self[\"color\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/graph_objs/waterfall/decreasing/marker/_line.py", "original_string": "    def width(self, val):\n        self[\"width\"] = val\n", "docstring": "self[\"width\"] = val"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_renderers.py", "original_string": "    def __delitem__(self, key):\n        # Remove template\n        del self._renderers[key]\n        # Check if we need to remove it as the default\n        if self._default == key:\n            self._default = None\n", "docstring": "Remove template"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_renderers.py", "original_string": "    def default(self, value):\n        # Handle None\n        if not value:\n            # _default_name should always be a string so we can do\n            # pio.renderers.default.split('+')\n            self._default_name = \"\"\n            self._default_renderers = []\n            return\n        # Store defaults name and list of renderer(s)\n        renderer_names = self._validate_coerce_renderers(value)\n        self._default_name = value\n        self._default_renderers = [self[name] for name in renderer_names]\n        # Register renderers for activation before their next use\n        self._to_activate = list(self._default_renderers)\n", "docstring": "Handle None"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_renderers.py", "original_string": "    def render_on_display(self, val):\n        self._render_on_display = bool(val)\n", "docstring": "self._render_on_display = bool(val)"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_renderers.py", "original_string": "    def __repr__(self):\n        return \"\"\"\\\n", "docstring": "return \"\"\"\\"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_templates.py", "original_string": "    def __init__(self):\n        # Initialize properties dict\n        self._templates = {}\n        # Initialize built-in templates\n        default_templates = [\n            \"ggplot2\",\n            \"seaborn\",\n            \"simple_white\",\n            \"plotly\",\n            \"plotly_white\",\n            \"plotly_dark\",\n            \"presentation\",\n            \"xgridoff\",\n            \"ygridoff\",\n            \"gridon\",\n            \"none\",\n        ]\n        for template_name in default_templates:\n            self._templates[template_name] = Lazy\n        self._validator = None\n        self._default = None\n", "docstring": "Initialize properties dict"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_templates.py", "original_string": "    def default(self, value):\n        # Validate value\n        # Could be a Template object, the key of a registered template,\n        # Or a string containing the names of multiple templates joined on\n        # '+' characters\n        self._validate(value)\n        self._default = value\n", "docstring": "Validate value"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_base_renderers.py", "original_string": "    def __hash__(self):\n        # Constructor args fully define uniqueness\n        return hash(repr(self))\n", "docstring": "Constructor args fully define uniqueness"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_orca.py", "original_string": "    def __init__(self):\n        # Initialize properties dict\n        self._props = {}\n        # Compute absolute path to the 'plotly/package_data/' directory\n        root_dir = os.path.dirname(os.path.abspath(plotly.__file__))\n        self.package_dir = os.path.join(root_dir, \"package_data\")\n        # Load pre-existing configuration\n        self.reload(warn=False)\n        # Compute constants\n        plotlyjs = os.path.join(self.package_dir, \"plotly.min.js\")\n        self._constants = {\n            \"plotlyjs\": plotlyjs,\n            \"config_file\": os.path.join(PLOTLY_DIR, \".orca\"),\n        }\n", "docstring": "Initialize properties dict"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_orca.py", "original_string": "    def server_url(self, val):\n        if val is None:\n            self._props.pop(\"server_url\", None)\n            return\n        if not isinstance(val, str):\n            raise ValueError(\n                \"\"\"\n", "docstring": "if val is None:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_orca.py", "original_string": "    def port(self, val):\n        if val is None:\n            self._props.pop(\"port\", None)\n            return\n        if not isinstance(val, int):\n            raise ValueError(\n                \"\"\"\n", "docstring": "if val is None:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_orca.py", "original_string": "    def executable(self, val):\n        if val is None:\n            self._props.pop(\"executable\", None)\n        else:\n            if not isinstance(val, string_types):\n                raise ValueError(\n                    \"\"\"\n", "docstring": "if val is None:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_orca.py", "original_string": "    def timeout(self, val):\n        if val is None:\n            self._props.pop(\"timeout\", None)\n        else:\n            if not isinstance(val, (int, float)):\n                raise ValueError(\n                    \"\"\"\n", "docstring": "if val is None:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_orca.py", "original_string": "    def default_width(self, val):\n        if val is None:\n            self._props.pop(\"default_width\", None)\n            return\n        if not isinstance(val, int):\n            raise ValueError(\n                \"\"\"\n", "docstring": "if val is None:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_orca.py", "original_string": "    def default_height(self, val):\n        if val is None:\n            self._props.pop(\"default_height\", None)\n            return\n        if not isinstance(val, int):\n            raise ValueError(\n                \"\"\"\n", "docstring": "if val is None:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_orca.py", "original_string": "    def default_format(self, val):\n        if val is None:\n            self._props.pop(\"default_format\", None)\n            return\n        val = validate_coerce_format(val)\n        self._props[\"default_format\"] = val\n", "docstring": "if val is None:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_orca.py", "original_string": "    def default_scale(self, val):\n        if val is None:\n            self._props.pop(\"default_scale\", None)\n            return\n        if not isinstance(val, (int, float)):\n            raise ValueError(\n                \"\"\"\n", "docstring": "if val is None:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_orca.py", "original_string": "    def topojson(self, val):\n        if val is None:\n            self._props.pop(\"topojson\", None)\n        else:\n            if not isinstance(val, string_types):\n                raise ValueError(\n                    \"\"\"\n", "docstring": "if val is None:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_orca.py", "original_string": "    def mathjax(self, val):\n        if val is None:\n            self._props.pop(\"mathjax\", None)\n        else:\n            if not isinstance(val, string_types):\n                raise ValueError(\n                    \"\"\"\n", "docstring": "if val is None:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_orca.py", "original_string": "    def mapbox_access_token(self, val):\n        if val is None:\n            self._props.pop(\"mapbox_access_token\", None)\n        else:\n            if not isinstance(val, string_types):\n                raise ValueError(\n                    \"\"\"\n", "docstring": "if val is None:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_orca.py", "original_string": "def cleanup():\n    shutdown_server()\n", "docstring": "shutdown_server()"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_orca.py", "original_string": "def write_image(\n    fig, file, format=None, scale=None, width=None, height=None, validate=True\n", "docstring": "fig, file, format=None, scale=None, width=None, height=None, validate=True"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/io/_sg_scraper.py", "original_string": "def plotly_sg_scraper(block, block_vars, gallery_conf, **kwargs):\n    \"\"\"Scrape Plotly figures for galleries of examples using\n    sphinx-gallery.\n    Examples should use ``plotly.io.show()`` to display the figure with\n    the custom sphinx_gallery renderer.\n    Since the sphinx_gallery renderer generates both html and static png\n    files, we simply crawl these files and give them the appropriate path.\n    Parameters\n    ----------\n    block : tuple\n        A tuple containing the (label, content, line_number) of the block.\n    block_vars : dict\n        Dict of block variables.\n    gallery_conf : dict\n        Contains the configuration of Sphinx-Gallery\n    **kwargs : dict\n        Additional keyword arguments to pass to\n        :meth:`~matplotlib.figure.Figure.savefig`, e.g. ``format='svg'``.\n        The ``format`` kwarg in particular is used to set the file extension\n        of the output file (currently only 'png' and 'svg' are supported).\n    Returns\n    -------\n    rst : str\n        The ReSTructuredText that will be rendered to HTML containing\n        the images.\n    Notes\n    -----\n    Add this function to the image scrapers\n    \"\"\"\n    examples_dir = os.path.dirname(block_vars[\"src_file\"])\n    pngs = sorted(glob(os.path.join(examples_dir, \"*.png\")))\n    htmls = sorted(glob(os.path.join(examples_dir, \"*.html\")))\n    image_path_iterator = block_vars[\"image_path_iterator\"]\n    image_names = list()\n    seen = set()\n    for html, png in zip(htmls, pngs):\n        if png not in seen:\n            seen |= set(png)\n            this_image_path_png = next(image_path_iterator)\n            this_image_path_html = os.path.splitext(this_image_path_png)[0] + \".html\"\n            image_names.append(this_image_path_html)\n            shutil.move(png, this_image_path_png)\n            shutil.move(html, this_image_path_html)\n    # Use the `figure_rst` helper function to generate rST for image files\n    return figure_rst(image_names, gallery_conf[\"src_dir\"])\n", "docstring": "Scrape Plotly figures for galleries of examples using"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/figure_factory/_candlestick.py", "original_string": "    def __init__(self, open, high, low, close, dates, **kwargs):\n        self.open = open\n        self.high = high\n        self.low = low\n        self.close = close\n        if dates is not None:\n            self.x = dates\n        else:\n            self.x = [x for x in range(len(self.open))]\n        self.get_candle_increase()\n", "docstring": "self.open = open"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/figure_factory/_gantt.py", "original_string": "def gantt(\n    chart,\n    colors,\n    title,\n    bar_width,\n    showgrid_x,\n    showgrid_y,\n    height,\n    width,\n    tasks=None,\n    task_names=None,\n    data=None,\n    group_tasks=False,\n    show_hover_fill=True,\n    show_colorbar=True,\n", "docstring": "chart,"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/figure_factory/_streamline.py", "original_string": "    def __init__(self, x, y, u, v, density, angle, arrow_scale, **kwargs):\n        self.x = np.array(x)\n        self.y = np.array(y)\n        self.u = np.array(u)\n        self.v = np.array(v)\n        self.angle = angle\n        self.arrow_scale = arrow_scale\n        self.density = int(30 * density)  # Scale similarly to other functions\n        self.delta_x = self.x[1] - self.x[0]\n        self.delta_y = self.y[1] - self.y[0]\n        self.val_x = self.x\n        self.val_y = self.y\n        # Set up spacing\n        self.blank = np.zeros((self.density, self.density))\n        self.spacing_x = len(self.x) / float(self.density - 1)\n        self.spacing_y = len(self.y) / float(self.density - 1)\n        self.trajectories = []\n        # Rescale speed onto axes-coordinates\n        self.u = self.u / (self.x[-1] - self.x[0])\n        self.v = self.v / (self.y[-1] - self.y[0])\n        self.speed = np.sqrt(self.u ** 2 + self.v ** 2)\n        # Rescale u and v for integrations.\n        self.u *= len(self.x)\n        self.v *= len(self.y)\n        self.st_x = []\n        self.st_y = []\n        self.get_streamlines()\n        streamline_x, streamline_y = self.sum_streamlines()\n        arrows_x, arrows_y = self.get_streamline_arrows()\n", "docstring": "self.x = np.array(x)"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/figure_factory/_streamline.py", "original_string": "        def f(xi, yi):\n            dt_ds = 1.0 / self.value_at(self.speed, xi, yi)\n            ui = self.value_at(self.u, xi, yi)\n            vi = self.value_at(self.v, xi, yi)\n            return ui * dt_ds, vi * dt_ds\n", "docstring": "dt_ds = 1.0 / self.value_at(self.speed, xi, yi)"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/figure_factory/_ternary_contour.py", "original_string": "def _polygon_area(x, y):\n    return 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1)))\n", "docstring": "return 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1)))"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/figure_factory/_ternary_contour.py", "original_string": "def _add_outer_contour(\n    all_contours,\n    all_values,\n    all_areas,\n    all_colors,\n    values,\n    val_outer,\n    v_min,\n    v_max,\n    colors,\n    color_min,\n    color_max,\n", "docstring": "all_contours,"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/figure_factory/_hexbin_mapbox.py", "original_string": "def _compute_wgs84_hexbin(\n    lat=None,\n    lon=None,\n    lat_range=None,\n    lon_range=None,\n    color=None,\n    nx=None,\n    agg_func=None,\n    min_count=None,\n", "docstring": "lat=None,"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/figure_factory/_ohlc.py", "original_string": "    def __init__(self, open, high, low, close, dates, **kwargs):\n        self.open = open\n        self.high = high\n        self.low = low\n        self.close = close\n        self.empty = [None] * len(open)\n        self.dates = dates\n        self.all_x = []\n        self.all_y = []\n        self.increase_x = []\n        self.increase_y = []\n        self.decrease_x = []\n        self.decrease_y = []\n        self.get_all_xy()\n        self.separate_increase_decrease()\n", "docstring": "self.open = open"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/figure_factory/_annotated_heatmap.py", "original_string": "def to_rgb_color_list(color_str, default):\n    if \"rgb\" in color_str:\n        return [int(v) for v in color_str.strip(\"rgb()\").split(\",\")]\n    elif \"#\" in color_str:\n        return clrs.hex_to_rgb(color_str)\n    else:\n        return default\n", "docstring": "if \"rgb\" in color_str:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/figure_factory/_scatterplot.py", "original_string": "def scatterplot_dict(\n    dataframe,\n    headers,\n    diag,\n    size,\n    height,\n    width,\n    title,\n    index,\n    index_vals,\n    endpts,\n    colormap,\n    colormap_type,\n    **kwargs\n", "docstring": "dataframe,"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/express/imshow_utils.py", "original_string": "def intensity_range(image, range_values=\"image\", clip_negative=False):\n    \"\"\"Return image intensity range (min, max) based on desired value type.\n    Parameters\n    ----------\n    image : array\n        Input image.\n    range_values : str or 2-tuple, optional\n        The image intensity range is configured by this parameter.\n        The possible values for this parameter are enumerated below.\n        'image'\n            Return image min/max as the range.\n        'dtype'\n            Return min/max of the image's dtype as the range.\n        dtype-name\n            Return intensity range based on desired `dtype`. Must be valid key\n            in `DTYPE_RANGE`. Note: `image` is ignored for this range type.\n        2-tuple\n            Return `range_values` as min/max intensities. Note that there's no\n            reason to use this function if you just want to specify the\n            intensity range explicitly. This option is included for functions\n            that use `intensity_range` to support all desired range types.\n    clip_negative : bool, optional\n        If True, clip the negative range (i.e. return 0 for min intensity)\n        even if the image dtype allows negative values.\n    \"\"\"\n    if range_values == \"dtype\":\n        range_values = image.dtype.type\n    if range_values == \"image\":\n        i_min = np.min(image)\n        i_max = np.max(image)\n    elif range_values in DTYPE_RANGE:\n        i_min, i_max = DTYPE_RANGE[range_values]\n        if clip_negative:\n            i_min = 0\n    else:\n        i_min, i_max = range_values\n    return i_min, i_max\n", "docstring": "Return image intensity range (min, max) based on desired value type."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/express/_core.py", "original_string": "def _isinstance_listlike(x):\n    \"\"\"Returns True if x is an iterable which can be transformed into a pandas Series,\n    False for the other types of possible values of a `hover_data` dict.\n    A tuple of length 2 is a special case corresponding to a (format, data) tuple.\n    \"\"\"\n    if (\n        isinstance(x, str)\n        or (isinstance(x, tuple) and len(x) == 2)\n        or isinstance(x, bool)\n        or x is None\n    ):\n        return False\n    else:\n        return True\n", "docstring": "Returns True if x is an iterable which can be transformed into a pandas Series,"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/offline/offline.py", "original_string": "def _build_mathjax_script(url):\n    return '<script src=\"{url}?config=TeX-AMS-MML_SVG\"></script>'.format(url=url)\n", "docstring": "return '<script src=\"{url}?config=TeX-AMS-MML_SVG\"></script>'.format(url=url)"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/offline/offline.py", "original_string": "def plot(\n    figure_or_data,\n    show_link=False,\n    link_text=\"Export to plot.ly\",\n    validate=True,\n    output_type=\"file\",\n    include_plotlyjs=True,\n    filename=\"temp-plot.html\",\n    auto_open=True,\n    image=None,\n    image_filename=\"plot_image\",\n    image_width=800,\n    image_height=600,\n    config=None,\n    include_mathjax=False,\n    auto_play=True,\n    animation_opts=None,\n", "docstring": "figure_or_data,"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_orca/test_sg_scraper.py", "original_string": "def setup():\n    # Reset orca state\n    plotly.io.orca.config.restore_defaults(reset_server=False)\n", "docstring": "Reset orca state"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_orca/test_to_image.py", "original_string": "def setup():\n    # Reset orca state\n    pio.orca.config.restore_defaults(reset_server=False)\n    # Clear out temp images dir\n    shutil.rmtree(tmp_dir, ignore_errors=True)\n    os.mkdir(tmp_dir)\n    # Make failed directory\n    if not os.path.exists(failed_dir):\n        os.mkdir(failed_dir)\n", "docstring": "Reset orca state"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_orca/test_to_image.py", "original_string": "def test_write_image_string(fig1, format):\n    # Build file paths\n    file_name = \"fig1.\" + format\n    file_path = tmp_dir + file_name\n    pio.write_image(\n        fig1,\n        os.path.join(tmp_dir, file_name),\n        format=format,\n        width=700,\n        height=500,\n        engine=\"orca\",\n    )\n    with open(file_path, \"rb\") as f:\n        written_bytes = f.read()\n    with open(os.path.join(images_dir, file_name), \"rb\") as f:\n        expected_bytes = f.read()\n    assert written_bytes == expected_bytes\n", "docstring": "Build file paths"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_orca/test_to_image.py", "original_string": "def test_write_image_string_format_inference(fig1, format):\n    # Build file paths\n    file_name = \"fig1.\" + format\n    file_path = os.path.join(tmp_dir, file_name)\n    # Use file extension to infer image type.\n    pio.write_image(\n        fig1, os.path.join(tmp_dir, file_name), width=700, height=500, engine=\"orca\"\n    )\n    with open(file_path, \"rb\") as f:\n        written_bytes = f.read()\n    with open(os.path.join(images_dir, file_name), \"rb\") as f:\n        expected_bytes = f.read()\n    assert written_bytes == expected_bytes\n", "docstring": "Build file paths"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_orca/test_to_image.py", "original_string": "def test_write_image_string_bad_extension_failure(fig1):\n    # Bad extension\n    file_path = os.path.join(tmp_dir, \"fig1.bogus\")\n    # Use file extension to infer image type.\n    with pytest.raises(ValueError) as err:\n        pio.write_image(fig1, file_path, engine=\"orca\")\n    assert \"must be specified as one of the following\" in str(err.value)\n", "docstring": "Bad extension"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_orca/test_to_image.py", "original_string": "def test_invalid_figure_json():\n    # Do image export\n    bad_fig = {\"foo\": \"bar\"}\n    with pytest.raises(ValueError) as err:\n        pio.to_image(bad_fig, format=\"png\", engine=\"orca\")\n    assert \"Invalid\" in str(err.value)\n    with pytest.raises(ValueError) as err:\n        pio.to_image(bad_fig, format=\"png\", validate=False, engine=\"orca\")\n    assert \"The image request was rejected by the orca conversion utility\" in str(\n        err.value\n    )\n    assert \"400: invalid or malformed request syntax\" in str(err.value)\n", "docstring": "Do image export"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_orca/test_orca_server.py", "original_string": "def setup():\n    # Set problematic environment variables\n    os.environ[\"NODE_OPTIONS\"] = \"--max-old-space-size=4096\"\n    os.environ[\"ELECTRON_RUN_AS_NODE\"] = \"1\"\n    # Reset orca state\n    pio.orca.reset_status()\n    pio.orca.config.restore_defaults()\n", "docstring": "Set problematic environment variables"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_subplots/test_make_subplots.py", "original_string": "    def test_subplot_titles_numpy_array(self):\n        # Pass numpy array\n        expected = tls.make_subplots(\n            insets=[{\"cell\": (1, 1), \"l\": 0.7, \"b\": 0.3}], subplot_titles=(\"\", \"Inset\")\n        )\n        fig = tls.make_subplots(\n            insets=[{\"cell\": (1, 1), \"l\": 0.7, \"b\": 0.3}],\n            subplot_titles=np.array([\"\", \"Inset\"]),\n        )\n        self.assertEqual(fig, expected)\n", "docstring": "Pass numpy array"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_autoshapes/test_annotated_shapes.py", "original_string": "def test_default_annotation_positions(multi_plot_fixture):\n    # default position is (inside) top right\n    multi_plot_fixture.add_hrect(row=2, col=2, y0=1, y1=8, annotation_text=\"A\")\n    multi_plot_fixture.add_vline(row=2, col=1, x=4, annotation_text=\"B\")\n    # if position on {h,v}rect lacks inside/outside specifier it defaults to inside\n    multi_plot_fixture.add_vrect(\n        row=1, col=2, x0=3, x1=6, annotation_text=\"C\", annotation_position=\"bottom left\"\n    )\n    ret = len(multi_plot_fixture.layout.annotations) == 3\n    for sh, d in zip(\n        multi_plot_fixture.layout.annotations,\n        [\n            {\n                \"text\": \"A\",\n                \"x\": 1,\n                \"y\": 8,\n                \"xanchor\": \"right\",\n                \"yanchor\": \"top\",\n                \"xref\": \"x4 domain\",\n                \"yref\": \"y4\",\n            },\n            {\n                \"text\": \"B\",\n                \"x\": 4,\n                \"y\": 1,\n                \"xanchor\": \"left\",\n                \"yanchor\": \"top\",\n                \"xref\": \"x3\",\n                \"yref\": \"y3 domain\",\n            },\n            {\n                \"text\": \"C\",\n                \"x\": 3,\n                \"y\": 0,\n                \"xanchor\": \"left\",\n                \"yanchor\": \"bottom\",\n                \"xref\": \"x2\",\n                \"yref\": \"y2 domain\",\n            },\n        ],\n    ):\n        ret &= _cmp_partial_dict(sh, d)\n    assert ret\n", "docstring": "default position is (inside) top right"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_utils/test_utils.py", "original_string": "    def test_encode_as_plotly(self):\n        # should *fail* when object doesn't have `to_plotly_json` attribute\n        objs_without_attr = [1, \"one\", set([\"a\", \"set\"]), {\"a\": \"dict\"}, [\"a\", \"list\"]]\n        for obj in objs_without_attr:\n            self.assertRaises(\n                utils.NotEncodable, utils.PlotlyJSONEncoder.encode_as_plotly, obj\n            )\n        # should return without exception when obj has `to_plotly_josn` attr\n        expected_res = \"wedidit\"\n        class ObjWithAttr(object):\n            def to_plotly_json(self):\n                return expected_res\n        res = utils.PlotlyJSONEncoder.encode_as_plotly(ObjWithAttr())\n        self.assertEqual(res, expected_res)\n", "docstring": "should *fail* when object doesn't have `to_plotly_json` attribute"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_utils/test_utils.py", "original_string": "    def test_encode_as_pandas(self):\n        # should *fail* on things that are not specific pandas objects\n        not_pandas = [\"giraffe\", 6, float(\"nan\"), [\"a\", \"list\"]]\n        for obj in not_pandas:\n            self.assertRaises(\n                utils.NotEncodable, utils.PlotlyJSONEncoder.encode_as_pandas, obj\n            )\n        # should succeed when we've got specific pandas thingies\n        res = utils.PlotlyJSONEncoder.encode_as_pandas(pd.NaT)\n        self.assertTrue(res is None)\n", "docstring": "should *fail* on things that are not specific pandas objects"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_utils/test_utils.py", "original_string": "    def test_encode_as_datetime(self):\n        # should succeed with 'utcoffset', 'isoformat' and '__sub__' attrs\n        res = utils.PlotlyJSONEncoder.encode_as_datetime(datetime.datetime(2013, 10, 1))\n        self.assertEqual(res, \"2013-10-01T00:00:00\")\n", "docstring": "should succeed with 'utcoffset', 'isoformat' and '__sub__' attrs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_utils/test_utils.py", "original_string": "    def test_encode_as_datetime_with_localized_tz(self):\n        # should convert tzinfo to utc. Note that in october, we're in EDT!\n        # therefore the 4 hour difference is correct.\n        naive_datetime = datetime.datetime(2013, 10, 1)\n        aware_datetime = pytz.timezone(\"US/Eastern\").localize(naive_datetime)\n        res = utils.PlotlyJSONEncoder.encode_as_datetime(aware_datetime)\n        self.assertEqual(res, \"2013-10-01T00:00:00-04:00\")\n", "docstring": "should convert tzinfo to utc. Note that in october, we're in EDT!"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_utils/test_utils.py", "original_string": "    def test_encode_as_decimal(self):\n        # should work with decimal values\n        res = utils.PlotlyJSONEncoder.encode_as_decimal(decimal.Decimal(1.023452))\n        self.assertAlmostEqual(res, 1.023452)  # Checks upto 7 decimal places\n        self.assertIsInstance(res, float)\n", "docstring": "should work with decimal values"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_utils/test_utils.py", "original_string": "    def test_fast_track_finite_arrays(self):\n        # if NaN or Infinity is found in the json dump\n        # of a figure, it is decoded and re-encoded to replace these values\n        # with null. This test checks that NaN and Infinity values are\n        # indeed converted to null, and that the encoding of figures\n        # without inf or nan is faster (because we can avoid decoding\n        # and reencoding).\n        z = np.random.randn(100, 100)\n        x = np.arange(100.0)\n        fig_1 = go.Figure(go.Heatmap(z=z, x=x))\n        t1 = time()\n        json_str_1 = _json.dumps(fig_1, cls=utils.PlotlyJSONEncoder)\n        t2 = time()\n        x[0] = np.nan\n        x[1] = np.inf\n        fig_2 = go.Figure(go.Heatmap(z=z, x=x))\n        t3 = time()\n        json_str_2 = _json.dumps(fig_2, cls=utils.PlotlyJSONEncoder)\n        t4 = time()\n        assert t2 - t1 < t4 - t3\n        assert \"null\" in json_str_2\n        assert \"NaN\" not in json_str_2\n        assert \"Infinity\" not in json_str_2\n        x = np.arange(100.0)\n        fig_3 = go.Figure(go.Heatmap(z=z, x=x))\n        fig_3.update_layout(title_text=\"Infinity\")\n        t5 = time()\n        json_str_3 = _json.dumps(fig_3, cls=utils.PlotlyJSONEncoder)\n        t6 = time()\n        assert t2 - t1 < t6 - t5\n        assert \"Infinity\" in json_str_3\n", "docstring": "if NaN or Infinity is found in the json dump"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_utils/test_utils.py", "original_string": "    def test_numpy_integer_import(self):\n        # should generate a figure with subplots of array and not throw a ValueError\n        import numpy as np\n        import plotly.graph_objects as go\n        from plotly.subplots import make_subplots\n        indices_rows = np.array([1], dtype=np.int)\n        indices_cols = np.array([1], dtype=np.int)\n        fig = make_subplots(rows=1, cols=1)\n        fig.add_trace(go.Scatter(y=[1]), row=indices_rows[0], col=indices_cols[0])\n        data_path = (\"data\", 0, \"y\")\n        value = get_by_path(fig, data_path)\n        expected_value = (1,)\n        self.assertEqual(value, expected_value)\n", "docstring": "should generate a figure with subplots of array and not throw a ValueError"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_tools/test_figure_factory.py", "original_string": "    def test_unequal_xy_length(self):\n        # check: PlotlyError if x and y are not the same length\n        kwargs = {\"x\": [1, 2], \"y\": [1], \"u\": [1, 2], \"v\": [1, 2]}\n        self.assertRaises(PlotlyError, ff.create_quiver, **kwargs)\n", "docstring": "check: PlotlyError if x and y are not the same length"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_tools/test_figure_factory.py", "original_string": "    def test_wrong_arrow_scale(self):\n        # check: ValueError if arrow_scale is <= 0\n        kwargs = {\"x\": [1, 2], \"y\": [1, 2], \"u\": [1, 2], \"v\": [1, 2], \"arrow_scale\": -1}\n        self.assertRaises(ValueError, ff.create_quiver, **kwargs)\n        kwargs = {\"x\": [1, 2], \"y\": [1, 2], \"u\": [1, 2], \"v\": [1, 2], \"arrow_scale\": 0}\n        self.assertRaises(ValueError, ff.create_quiver, **kwargs)\n", "docstring": "check: ValueError if arrow_scale is <= 0"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_tools/test_figure_factory.py", "original_string": "    def test_more_kwargs(self):\n        # we should be able to create 2 arrows and change the arrow_scale,\n        # angle, and arrow using create_quiver\n        quiver = ff.create_quiver(\n            x=[1, 2],\n            y=[1, 2],\n            u=[math.cos(1), math.cos(2)],\n            v=[math.sin(1), math.sin(2)],\n            arrow_scale=0.4,\n            angle=math.pi / 6,\n            line=graph_objs.scatter.Line(color=\"purple\", width=3),\n        )\n        expected_quiver = {\n            \"data\": [\n                {\n                    \"line\": {\"color\": \"purple\", \"width\": 3},\n                    \"mode\": \"lines\",\n                    \"type\": \"scatter\",\n                    \"x\": [\n                        1,\n                        1.0540302305868139,\n                        None,\n                        2,\n                        1.9583853163452858,\n                        None,\n                        1.052143029378767,\n                        1.0540302305868139,\n                        1.0184841899864512,\n                        None,\n                        1.9909870141679737,\n                        1.9583853163452858,\n                        1.9546151170949464,\n                        None,\n                    ],\n                    \"y\": [\n                        1,\n                        1.0841470984807897,\n                        None,\n                        2,\n                        2.0909297426825684,\n                        None,\n                        1.044191642387781,\n                        1.0841470984807897,\n                        1.0658037346225067,\n                        None,\n                        2.0677536925644366,\n                        2.0909297426825684,\n                        2.051107819102551,\n                        None,\n                    ],\n                }\n            ],\n            \"layout\": {\"hovermode\": \"closest\"},\n        }\n        self.assert_fig_equal(quiver[\"data\"][0], expected_quiver[\"data\"][0])\n        self.assert_fig_equal(quiver[\"layout\"], expected_quiver[\"layout\"])\n", "docstring": "we should be able to create 2 arrows and change the arrow_scale,"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_tools/test_figure_factory.py", "original_string": "    def test_unequal_ohlc_length(self):\n        # check: PlotlyError if open, high, low, close are not the same length\n        # for TraceFactory.create_ohlc and TraceFactory.create_candlestick\n        kwargs = {\n            \"open\": [1],\n            \"high\": [1, 3],\n            \"low\": [1, 2],\n            \"close\": [1, 2],\n            \"direction\": [\"increasing\"],\n        }\n        self.assertRaises(PlotlyError, ff.create_ohlc, **kwargs)\n        self.assertRaises(PlotlyError, ff.create_candlestick, **kwargs)\n        kwargs = {\n            \"open\": [1, 2],\n            \"high\": [1, 2, 3],\n            \"low\": [1, 2],\n            \"close\": [1, 2],\n            \"direction\": [\"decreasing\"],\n        }\n        self.assertRaises(PlotlyError, ff.create_ohlc, **kwargs)\n        self.assertRaises(PlotlyError, ff.create_candlestick, **kwargs)\n        kwargs = {\"open\": [1, 2], \"high\": [2, 3], \"low\": [0], \"close\": [1, 3]}\n        self.assertRaises(PlotlyError, ff.create_ohlc, **kwargs)\n        self.assertRaises(PlotlyError, ff.create_candlestick, **kwargs)\n        kwargs = {\"open\": [1, 2], \"high\": [2, 3], \"low\": [1, 2], \"close\": [1]}\n        self.assertRaises(PlotlyError, ff.create_ohlc, **kwargs)\n        self.assertRaises(PlotlyError, ff.create_candlestick, **kwargs)\n", "docstring": "check: PlotlyError if open, high, low, close are not the same length"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_tools/test_figure_factory.py", "original_string": "    def test_high_highest_value(self):\n        # check: PlotlyError if the \"high\" value is less than the corresponding\n        # open, low, or close value because if the \"high\" value is not the\n        # highest (or equal) then the data may have been entered incorrectly.\n        kwargs = {\"open\": [2, 3], \"high\": [4, 2], \"low\": [1, 1], \"close\": [1, 2]}\n        self.assertRaisesRegexp(\n            PlotlyError,\n            \"Oops! Looks like some of \"\n            \"your high values are less \"\n            \"the corresponding open, \"\n            \"low, or close values. \"\n            \"Double check that your data \"\n            \"is entered in O-H-L-C order\",\n            ff.create_ohlc,\n            **kwargs\n        )\n        self.assertRaisesRegexp(\n            PlotlyError,\n            \"Oops! Looks like some of \"\n            \"your high values are less \"\n            \"the corresponding open, \"\n            \"low, or close values. \"\n            \"Double check that your data \"\n            \"is entered in O-H-L-C order\",\n            ff.create_candlestick,\n            **kwargs\n        )\n", "docstring": "check: PlotlyError if the \"high\" value is less than the corresponding"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_tools/test_figure_factory.py", "original_string": "    def test_one_ohlc(self):\n        # This should create one \"increase\" (i.e. close > open) ohlc stick\n        ohlc = ff.create_ohlc(open=[33.0], high=[33.2], low=[32.7], close=[33.1])\n        expected_ohlc = {\n            \"layout\": {\"hovermode\": \"closest\", \"xaxis\": {\"zeroline\": False}},\n            \"data\": [\n                {\n                    \"y\": [33.0, 33.0, 33.2, 32.7, 33.1, 33.1, None],\n                    \"line\": {\"width\": 1, \"color\": \"#3D9970\"},\n                    \"showlegend\": False,\n                    \"name\": \"Increasing\",\n                    \"text\": [\"Open\", \"Open\", \"High\", \"Low\", \"Close\", \"Close\", \"\"],\n                    \"mode\": \"lines\",\n                    \"type\": \"scatter\",\n                    \"x\": [-0.2, 0, 0, 0, 0, 0.2, None],\n                },\n                {\n                    \"y\": [],\n                    \"line\": {\"width\": 1, \"color\": \"#FF4136\"},\n                    \"showlegend\": False,\n                    \"name\": \"Decreasing\",\n                    \"text\": (),\n                    \"mode\": \"lines\",\n                    \"type\": \"scatter\",\n                    \"x\": [],\n                },\n            ],\n        }\n        self.assert_fig_equal(\n            ohlc[\"data\"][0], expected_ohlc[\"data\"][0], ignore=[\"uid\", \"text\"]\n        )\n        self.assert_fig_equal(\n            ohlc[\"data\"][1], expected_ohlc[\"data\"][1], ignore=[\"uid\", \"text\"]\n        )\n        self.assert_fig_equal(ohlc[\"layout\"], expected_ohlc[\"layout\"])\n", "docstring": "This should create one \"increase\" (i.e. close > open) ohlc stick"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_tools/test_figure_factory.py", "original_string": "    def test_one_ohlc_decrease(self):\n        # This should create one \"increase\" (i.e. close > open) ohlc stick\n        ohlc_decr = ff.create_ohlc(\n            open=[33.0], high=[33.2], low=[30.7], close=[31.1], direction=\"decreasing\"\n        )\n        expected_ohlc_decr = {\n            \"data\": [\n                {\n                    \"line\": {\"color\": \"#FF4136\", \"width\": 1},\n                    \"mode\": \"lines\",\n                    \"name\": \"Decreasing\",\n                    \"showlegend\": False,\n                    \"text\": [\"Open\", \"Open\", \"High\", \"Low\", \"Close\", \"Close\", \"\"],\n                    \"type\": \"scatter\",\n                    \"x\": [-0.2, 0, 0, 0, 0, 0.2, None],\n                    \"y\": [33.0, 33.0, 33.2, 30.7, 31.1, 31.1, None],\n                }\n            ],\n            \"layout\": {\"hovermode\": \"closest\", \"xaxis\": {\"zeroline\": False}},\n        }\n        self.assert_fig_equal(ohlc_decr[\"data\"][0], expected_ohlc_decr[\"data\"][0])\n        self.assert_fig_equal(ohlc_decr[\"layout\"], expected_ohlc_decr[\"layout\"])\n", "docstring": "This should create one \"increase\" (i.e. close > open) ohlc stick"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_tools/test_figure_factory.py", "original_string": "    def test_one_candlestick(self):\n        # This should create one \"increase\" (i.e. close > open) candlestick\n        can_inc = ff.create_candlestick(\n            open=[33.0], high=[33.2], low=[32.7], close=[33.1]\n        )\n        exp_can_inc = {\n            \"data\": [\n                {\n                    \"boxpoints\": False,\n                    \"fillcolor\": \"#3D9970\",\n                    \"line\": {\"color\": \"#3D9970\"},\n                    \"name\": \"Increasing\",\n                    \"showlegend\": False,\n                    \"type\": \"box\",\n                    \"whiskerwidth\": 0,\n                    \"x\": [0, 0, 0, 0, 0, 0],\n                    \"y\": [32.7, 33.0, 33.1, 33.1, 33.1, 33.2],\n                },\n                {\n                    \"boxpoints\": False,\n                    \"fillcolor\": \"#ff4136\",\n                    \"line\": {\"color\": \"#ff4136\"},\n                    \"name\": \"Decreasing\",\n                    \"showlegend\": False,\n                    \"type\": \"box\",\n                    \"whiskerwidth\": 0,\n                    \"x\": [],\n                    \"y\": [],\n                },\n            ],\n            \"layout\": {},\n        }\n        self.assert_fig_equal(can_inc[\"data\"][0], exp_can_inc[\"data\"][0])\n        self.assert_fig_equal(can_inc[\"layout\"], exp_can_inc[\"layout\"])\n", "docstring": "This should create one \"increase\" (i.e. close > open) candlestick"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_tools/test_figure_factory.py", "original_string": "    def test_unequal_z_text_size(self):\n        # check: PlotlyError if z and text are not the same dimensions\n        kwargs = {\"z\": [[1, 2], [1, 2]], \"annotation_text\": [[1, 2, 3], [1]]}\n        self.assertRaises(PlotlyError, ff.create_annotated_heatmap, **kwargs)\n        kwargs = {\"z\": [[1], [1]], \"annotation_text\": [[1], [1], [1]]}\n        self.assertRaises(PlotlyError, ff.create_annotated_heatmap, **kwargs)\n", "docstring": "check: PlotlyError if z and text are not the same dimensions"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_tools/test_figure_factory.py", "original_string": "    def test_incorrect_y_size(self):\n        # check: PlotlyError if y is the wrong size\n        kwargs = {\"z\": [[1, 2], [1, 2]], \"y\": [1, 2, 3]}\n        self.assertRaises(PlotlyError, ff.create_annotated_heatmap, **kwargs)\n", "docstring": "check: PlotlyError if y is the wrong size"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_tools/test_figure_factory.py", "original_string": "    def test_fontcolor_input(self):\n        # check: ValueError if fontcolor input is incorrect\n        kwargs = {\n            \"table_text\": [[\"one\", \"two\"], [1, 2], [1, 2], [1, 2]],\n            \"fontcolor\": \"#000000\",\n        }\n        self.assertRaises(ValueError, ff.create_table, **kwargs)\n        kwargs = {\n            \"table_text\": [[\"one\", \"two\"], [1, 2], [1, 2], [1, 2]],\n            \"fontcolor\": [\"red\", \"blue\"],\n        }\n        self.assertRaises(ValueError, ff.create_table, **kwargs)\n", "docstring": "check: ValueError if fontcolor input is incorrect"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_tools/test_figure_factory.py", "original_string": "    def test_validate_gantt(self):\n        # validate the basic gantt inputs\n        df = [\n            {\n                \"Task\": \"Job A\",\n                \"Start\": \"2009-02-01\",\n                \"Finish\": \"2009-08-30\",\n                \"Complete\": \"a\",\n            }\n        ]\n        pattern2 = (\n            \"In order to use an indexing column and assign colors to \"\n            \"the values of the index, you must choose an actual \"\n            \"column name in the dataframe or key if a list of \"\n            \"dictionaries is being used.\"\n        )\n        self.assertRaisesRegexp(\n            PlotlyError, pattern2, ff.create_gantt, df, index_col=\"foo\"\n        )\n        df = \"foo\"\n        pattern3 = \"You must input either a dataframe or a list of \" \"dictionaries.\"\n        self.assertRaisesRegexp(PlotlyError, pattern3, ff.create_gantt, df)\n        df = []\n        pattern4 = \"Your list is empty. It must contain at least one \" \"dictionary.\"\n        self.assertRaisesRegexp(PlotlyError, pattern4, ff.create_gantt, df)\n        df = [\"foo\"]\n        pattern5 = \"Your list must only include dictionaries.\"\n        self.assertRaisesRegexp(PlotlyError, pattern5, ff.create_gantt, df)\n", "docstring": "validate the basic gantt inputs"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_tools/test_figure_factory.py", "original_string": "    def test_validate_2D_density(self):\n        # validate that x and y contain only numbers\n        x = [1, 2]\n        y = [\"a\", 2]\n        pattern = \"All elements of your 'x' and 'y' lists must be numbers.\"\n        self.assertRaisesRegexp(PlotlyError, pattern, ff.create_2d_density, x, y)\n        # validate that x and y are the same length\n        x2 = [1]\n        y2 = [1, 2]\n        pattern2 = \"Both lists 'x' and 'y' must be the same length.\"\n        self.assertRaisesRegexp(PlotlyError, pattern2, ff.create_2d_density, x2, y2)\n", "docstring": "validate that x and y contain only numbers"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_wrong_curve_type(self):\n        # check: PlotlyError (and specific message) is raised if curve_type is\n        # not 'kde' or 'normal'\n        kwargs = {\n            \"hist_data\": [[1, 2, 3]],\n            \"group_labels\": [\"group\"],\n            \"curve_type\": \"curve\",\n        }\n        self.assertRaisesRegexp(\n            PlotlyError,\n            \"curve_type must be defined as \" \"'kde' or 'normal'\",\n            ff.create_distplot,\n            **kwargs\n        )\n", "docstring": "check: PlotlyError (and specific message) is raised if curve_type is"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_simple_distplot_prob(self):\n        # we should be able to create a single distplot with a simple dataset\n        # and default kwargs\n        dp = ff.create_distplot(\n            hist_data=[[1, 2, 2, 3]], group_labels=[\"distplot\"], histnorm=\"probability\"\n        )\n        expected_dp_layout = {\n            \"barmode\": \"overlay\",\n            \"hovermode\": \"closest\",\n            \"legend\": {\"traceorder\": \"reversed\"},\n            \"xaxis\": {\"anchor\": \"y2\", \"domain\": [0.0, 1.0], \"zeroline\": False},\n            \"yaxis\": {\"anchor\": \"free\", \"domain\": [0.35, 1], \"position\": 0.0},\n            \"yaxis2\": {\n                \"anchor\": \"x\",\n                \"domain\": [0, 0.25],\n                \"dtick\": 1,\n                \"showticklabels\": False,\n            },\n        }\n        self.assert_fig_equal(dp[\"layout\"], expected_dp_layout)\n        expected_dp_data_hist = {\n            \"autobinx\": False,\n            \"histnorm\": \"probability\",\n            \"legendgroup\": \"distplot\",\n            \"marker\": {\"color\": \"rgb(31, 119, 180)\"},\n            \"name\": \"distplot\",\n            \"opacity\": 0.7,\n            \"type\": \"histogram\",\n            \"x\": [1, 2, 2, 3],\n            \"xaxis\": \"x\",\n            \"xbins\": {\"end\": 3.0, \"size\": 1.0, \"start\": 1.0},\n            \"yaxis\": \"y\",\n        }\n        self.assert_fig_equal(dp[\"data\"][0], expected_dp_data_hist)\n        expected_dp_data_rug = {\n            \"legendgroup\": \"distplot\",\n            \"marker\": {\"color\": \"rgb(31, 119, 180)\", \"symbol\": \"line-ns-open\"},\n            \"mode\": \"markers\",\n            \"name\": \"distplot\",\n            \"showlegend\": False,\n            \"type\": \"scatter\",\n            \"x\": [1, 2, 2, 3],\n            \"xaxis\": \"x\",\n            \"y\": [\"distplot\", \"distplot\", \"distplot\", \"distplot\"],\n            \"yaxis\": \"y2\",\n        }\n        self.assert_fig_equal(dp[\"data\"][2], expected_dp_data_rug)\n", "docstring": "we should be able to create a single distplot with a simple dataset"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_wrong_arrow_scale(self):\n        # check for ValueError if arrow_scale is <= 0\n        kwargs = {\n            \"x\": [0, 2],\n            \"y\": [0, 2],\n            \"u\": [[-1, -5], [-1, -5]],\n            \"v\": [[1, 1], [-3, -3]],\n            \"arrow_scale\": 0,\n        }\n        self.assertRaises(ValueError, ff.create_streamline, **kwargs)\n", "docstring": "check for ValueError if arrow_scale is <= 0"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_uneven_x(self):\n        # check for PlotlyError if x is not evenly spaced\n        kwargs = {\n            \"x\": [0, 2, 7, 9],\n            \"y\": [0, 2, 4, 6],\n            \"u\": [[-1, -5], [-1, -5]],\n            \"v\": [[1, 1], [-3, -3]],\n        }\n        self.assertRaises(PlotlyError, ff.create_streamline, **kwargs)\n", "docstring": "check for PlotlyError if x is not evenly spaced"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_unequal_length_xy(self):\n        # check for PlotlyError if u and v are not the same length\n        kwargs = {\n            \"x\": [0, 2, 4, 6],\n            \"y\": [1.5, 2, 3.5],\n            \"u\": [[-1, -5], [-1, -5]],\n            \"v\": [[1, 1], [-3, -3]],\n        }\n        self.assertRaises(PlotlyError, ff.create_streamline, **kwargs)\n", "docstring": "check for PlotlyError if u and v are not the same length"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_vmin_and_vmax(self):\n        # check if vmin is greater than or equal to vmax\n        u = np.linspace(0, 2, 2)\n        v = np.linspace(0, 2, 2)\n        u, v = np.meshgrid(u, v)\n        u = u.flatten()\n        v = v.flatten()\n        x = u\n        y = v\n        z = u * v\n        points2D = np.vstack([u, v]).T\n        tri = Delaunay(points2D)\n        simplices = tri.simplices\n        pattern = (\n            \"Incorrect relation between vmin and vmax. The vmin value cannot \"\n            \"be bigger than or equal to the value of vmax.\"\n        )\n        self.assertRaisesRegexp(\n            PlotlyError, pattern, ff.create_trisurf, x, y, z, simplices\n        )\n", "docstring": "check if vmin is greater than or equal to vmax"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_dataframe_input(self):\n        # check: dataframe is imported\n        df = \"foo\"\n        pattern = (\n            \"Dataframe not inputed. Please use a pandas dataframe to produce \"\n            \"a scatterplot matrix.\"\n        )\n        self.assertRaisesRegexp(PlotlyError, pattern, ff.create_scatterplotmatrix, df)\n", "docstring": "check: dataframe is imported"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_valid_diag_choice(self):\n        # make sure that the diagonal param is valid\n        df = pd.DataFrame([[1, 2, 3], [4, 5, 6]])\n        self.assertRaises(PlotlyError, ff.create_scatterplotmatrix, df, diag=\"foo\")\n", "docstring": "make sure that the diagonal param is valid"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_valid_index_choice(self):\n        # check: index is a column name\n        df = pd.DataFrame([[1, 2], [3, 4]], columns=[\"apple\", \"pear\"])\n        pattern = (\n            \"Make sure you set the index input variable to one of the column \"\n            \"names of your dataframe.\"\n        )\n        self.assertRaisesRegexp(\n            PlotlyError, pattern, ff.create_scatterplotmatrix, df, index=\"grape\"\n        )\n", "docstring": "check: index is a column name"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_same_data_in_index(self):\n        # check: either all numbers or strings in index column\n        df = pd.DataFrame([[\"a\", 2], [3, 4]], columns=[\"apple\", \"pear\"])\n        pattern = (\n            \"Error in indexing column. Make sure all entries of each column \"\n            \"are all numbers or all strings.\"\n        )\n        self.assertRaisesRegexp(\n            PlotlyError, pattern, ff.create_scatterplotmatrix, df, index=\"apple\"\n        )\n        df = pd.DataFrame([[1, 2], [\"a\", 4]], columns=[\"apple\", \"pear\"])\n        self.assertRaisesRegexp(\n            PlotlyError, pattern, ff.create_scatterplotmatrix, df, index=\"apple\"\n        )\n", "docstring": "check: either all numbers or strings in index column"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_valid_endpts(self):\n        # check: the endpts is a list or a tuple\n        df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=[\"a\", \"b\", \"c\"])\n        pattern = (\n            \"The intervals_endpts argument must be a list or tuple of a \"\n            \"sequence of increasing numbers.\"\n        )\n        self.assertRaisesRegexp(\n            PlotlyError,\n            pattern,\n            ff.create_scatterplotmatrix,\n            df,\n            index=\"a\",\n            colormap=\"Hot\",\n            endpts=\"foo\",\n        )\n        # check: the endpts are a list of numbers\n        self.assertRaisesRegexp(\n            PlotlyError,\n            pattern,\n            ff.create_scatterplotmatrix,\n            df,\n            index=\"a\",\n            colormap=\"Hot\",\n            endpts=[\"a\"],\n        )\n        # check: endpts is a list of INCREASING numbers\n        self.assertRaisesRegexp(\n            PlotlyError,\n            pattern,\n            ff.create_scatterplotmatrix,\n            df,\n            index=\"a\",\n            colormap=\"Hot\",\n            endpts=[2, 1],\n        )\n", "docstring": "check: the endpts is a list or a tuple"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_df_dataframe(self):\n        # validate dataframe has correct column names\n        df1 = pd.DataFrame([[2, \"Apple\"]], columns=[\"Numbers\", \"Fruit\"])\n        self.assertRaises(PlotlyError, ff.create_gantt, df1)\n", "docstring": "validate dataframe has correct column names"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_colors_validation(self):\n        # check: colors is in an acceptable form\n        data = [1, 5, 8]\n        pattern = (\n            \"Whoops! The elements in your rgb colors tuples cannot \" \"exceed 255.0.\"\n        )\n        self.assertRaisesRegexp(\n            PlotlyError, pattern, ff.create_violin, data, colors=\"rgb(300, 2, 3)\"\n        )\n        self.assertRaisesRegexp(\n            PlotlyError, pattern, ff.create_violin, data, colors=[\"rgb(300, 2, 3)\"]\n        )\n        self.assertRaisesRegexp(\n            PlotlyError,\n            pattern,\n            ff.create_violin,\n            data,\n            colors={\"apple\": \"rgb(300, 2, 3)\"},\n        )\n        pattern2 = \"Whoops! The elements in your colors tuples cannot \" \"exceed 1.0.\"\n        self.assertRaisesRegexp(\n            PlotlyError, pattern2, ff.create_violin, data, colors=(1.1, 1, 1)\n        )\n        self.assertRaisesRegexp(\n            PlotlyError, pattern2, ff.create_violin, data, colors=[(1.1, 1, 1)]\n        )\n        self.assertRaisesRegexp(\n            PlotlyError, pattern2, ff.create_violin, data, colors={\"apple\": (1.1, 1, 1)}\n        )\n        # check: if valid string color is inputted\n        self.assertRaises(PlotlyError, ff.create_violin, data, colors=\"foo\")\n", "docstring": "check: colors is in an acceptable form"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_data_as_list(self):\n        # check: data is a non empty list of numbers\n        data = []\n        pattern = (\n            \"If data is a list, it must be nonempty and contain \"\n            \"either numbers or dictionaries.\"\n        )\n        self.assertRaisesRegexp(PlotlyError, pattern, ff.create_violin, data)\n        data = [1, \"foo\"]\n        pattern2 = \"If data is a list, it must contain only numbers.\"\n        self.assertRaisesRegexp(PlotlyError, pattern2, ff.create_violin, data)\n", "docstring": "check: data is a non empty list of numbers"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_colors_dict(self):\n        # check: if colorscale is True, make sure colors is not a dictionary\n        data = pd.DataFrame([[\"apple\", 2], [\"pear\", 4]], columns=[\"a\", \"b\"])\n        pattern = (\n            \"The colors param cannot be a dictionary if you are \" \"using a colorscale.\"\n        )\n        self.assertRaisesRegexp(\n            PlotlyError,\n            pattern,\n            ff.create_violin,\n            data,\n            data_header=\"b\",\n            group_header=\"a\",\n            use_colorscale=True,\n            colors={\"a\": \"rgb(1, 2, 3)\"},\n        )\n        # check: colors contains all group names as keys\n        pattern2 = (\n            \"If colors is a dictionary, all the group names must \"\n            \"appear as keys in colors.\"\n        )\n        self.assertRaisesRegexp(\n            PlotlyError,\n            pattern2,\n            ff.create_violin,\n            data,\n            data_header=\"b\",\n            group_header=\"a\",\n            use_colorscale=False,\n            colors={\"a\": \"rgb(1, 2, 3)\"},\n        )\n", "docstring": "check: if colorscale is True, make sure colors is not a dictionary"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_figure_factory/test_figure_factory.py", "original_string": "    def test_group_stats(self):\n        # check: group_stats is a dictionary\n        data = pd.DataFrame([[\"apple\", 2], [\"pear\", 4]], columns=[\"a\", \"b\"])\n        pattern = \"Your group_stats param must be a dictionary.\"\n        self.assertRaisesRegexp(\n            PlotlyError,\n            pattern,\n            ff.create_violin,\n            data,\n            data_header=\"b\",\n            group_header=\"a\",\n            use_colorscale=True,\n            colors=[\"rgb(1, 2, 3)\", \"rgb(4, 5, 6)\"],\n            group_stats=1,\n        )\n        # check: all groups are represented as keys in group_stats\n        pattern2 = (\n            \"All values/groups in the index column must be \"\n            \"represented as a key in group_stats.\"\n        )\n        self.assertRaisesRegexp(\n            PlotlyError,\n            pattern2,\n            ff.create_violin,\n            data,\n            data_header=\"b\",\n            group_header=\"a\",\n            use_colorscale=True,\n            colors=[\"rgb(1, 2, 3)\", \"rgb(4, 5, 6)\"],\n            group_stats={\"apple\": 1},\n        )\n", "docstring": "check: group_stats is a dictionary"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_px/test_imshow.py", "original_string": "def test_rgb_uint8(binary_string):\n    fig = px.imshow(img_rgb, binary_string=binary_string)\n    assert fig.data[0][\"zmax\"] is None\n", "docstring": "fig = px.imshow(img_rgb, binary_string=binary_string)"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_px/test_px_wide.py", "original_string": "def test_wide_mode_external(px_fn, orientation, style):\n    # here we test this feature \"black box\" style by calling actual PX functions and\n    # inspecting the figure... this is important but clunky, and is mostly a smoke test\n    # allowing us to do more \"white box\" testing below\n    if px_fn != px.funnel:\n        x, y = (\"y\", \"x\") if orientation == \"h\" else (\"x\", \"y\")\n    else:\n        x, y = (\"y\", \"x\") if orientation != \"v\" else (\"x\", \"y\")\n    xaxis, yaxis = x + \"axis\", y + \"axis\"\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if style == \"implicit\":\n        fig = px_fn(df, orientation=orientation)\n    if px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]:\n        if style == \"explicit\":\n            fig = px_fn(**{\"data_frame\": df, y: list(df.columns), x: df.index})\n        assert len(fig.data) == 3\n        assert list(fig.data[0][x]) == [11, 12, 13]\n        assert list(fig.data[0][y]) == [1, 2, 3]\n        assert list(fig.data[1][x]) == [11, 12, 13]\n        assert list(fig.data[1][y]) == [4, 5, 6]\n        assert fig.layout[xaxis].title.text == \"index\"\n        assert fig.layout[yaxis].title.text == \"value\"\n        assert fig.layout.legend.title.text == \"variable\"\n    if px_fn in [px.density_heatmap]:\n        if style == \"explicit\":\n            fig = px_fn(**{\"data_frame\": df, y: list(df.columns), x: df.index})\n        assert len(fig.data) == 1\n        assert list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13]\n        assert list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        assert fig.layout[xaxis].title.text == \"index\"\n        assert fig.layout[yaxis].title.text == \"value\"\n    if px_fn in [px.violin, px.box, px.strip]:\n        if style == \"explicit\":\n            fig = px_fn(**{\"data_frame\": df, y: list(df.columns)})\n        assert len(fig.data) == 1\n        assert list(fig.data[0][x]) == [\"a\"] * 3 + [\"b\"] * 3 + [\"c\"] * 3\n        assert list(fig.data[0][y]) == list(range(1, 10))\n        assert fig.layout[yaxis].title.text == \"value\"\n        assert fig.layout[xaxis].title.text == \"variable\"\n    if px_fn in [px.histogram]:\n        if style == \"explicit\":\n            fig = px_fn(**{\"data_frame\": df, x: list(df.columns)})\n        assert len(fig.data) == 3\n        assert list(fig.data[1][x]) == [4, 5, 6]\n        assert fig.layout.legend.title.text == \"variable\"\n        assert fig.layout[xaxis].title.text == \"value\"\n", "docstring": "here we test this feature \"black box\" style by calling actual PX functions and"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_px/test_px_input.py", "original_string": "def test_build_df_from_lists():\n    # Just lists\n    args = dict(x=[1, 2, 3], y=[2, 3, 4], color=[1, 3, 9])\n    output = {key: key for key in args}\n    df = pd.DataFrame(args)\n    args[\"data_frame\"] = None\n    out = build_dataframe(args, go.Scatter)\n    assert_frame_equal(df.sort_index(axis=1), out[\"data_frame\"].sort_index(axis=1))\n    out.pop(\"data_frame\")\n    assert out == output\n    # Arrays\n    args = dict(x=np.array([1, 2, 3]), y=np.array([2, 3, 4]), color=[1, 3, 9])\n    output = {key: key for key in args}\n    df = pd.DataFrame(args)\n    args[\"data_frame\"] = None\n    out = build_dataframe(args, go.Scatter)\n    assert_frame_equal(df.sort_index(axis=1), out[\"data_frame\"].sort_index(axis=1))\n    out.pop(\"data_frame\")\n    assert out == output\n", "docstring": "Just lists"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_px/test_px_functions.py", "original_string": "def _compare_figures(go_trace, px_fig):\n    \"\"\"Compare a figure created with a go trace and a figure created with\n    a px function call. Check that all values inside the go Figure are the\n    same in the px figure (which sets more parameters).\n    \"\"\"\n    go_fig = go.Figure(go_trace)\n    go_fig = go_fig.to_plotly_json()\n    px_fig = px_fig.to_plotly_json()\n    del go_fig[\"layout\"][\"template\"]\n    del px_fig[\"layout\"][\"template\"]\n    for key in go_fig[\"data\"][0]:\n        assert_array_equal(go_fig[\"data\"][0][key], px_fig[\"data\"][0][key])\n    for key in go_fig[\"layout\"]:\n        assert go_fig[\"layout\"][key] == px_fig[\"layout\"][key]\n", "docstring": "Compare a figure created with a go trace and a figure created with"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py", "original_string": "def make_writeable_mocks():\n    \"\"\"Produce some mocks which we will use for testing the `write_image()` function.\n    These mocks should be passed as the `file=` argument to `write_image()`.\n    The tests should verify that the method specified in the `active_write_function`\n    attribute is called once, and that scope.transform is called with the `format=`\n    argument specified by the `.expected_format` attribute.\n    In total we provide two mocks: one for a writable file descriptor, and other for a\n    pathlib.Path object.\n    \"\"\"\n    # Part 1: A mock for a file descriptor\n    # ------------------------------------\n    mock_file_descriptor = Mock()\n    # A file descriptor has no write_bytes method, unlike a pathlib Path.\n    del mock_file_descriptor.write_bytes\n    # The expected write method for a file descriptor is .write\n    mock_file_descriptor.active_write_function = mock_file_descriptor.write\n    # Since there is no filename, there should be no format detected.\n    mock_file_descriptor.expected_format = None\n    # Part 2: A mock for a pathlib path\n    # ---------------------------------\n    mock_pathlib_path = Mock(spec=Path)\n    # A pathlib Path object has no write method, unlike a file descriptor.\n    del mock_pathlib_path.write\n    # The expected write method for a pathlib Path is .write_bytes\n    mock_pathlib_path.active_write_function = mock_pathlib_path.write_bytes\n    # Mock a path with PNG suffix\n    mock_pathlib_path.suffix = \".png\"\n    mock_pathlib_path.expected_format = \"png\"\n    return mock_file_descriptor, mock_pathlib_path\n", "docstring": "Produce some mocks which we will use for testing the `write_image()` function."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py", "original_string": "def mocked_scope():\n    # Code to acquire resource, e.g.:\n    scope_mock = Mock()\n    original_scope = pio._kaleido.scope\n    pio._kaleido.scope = scope_mock\n    try:\n        yield scope_mock\n    finally:\n        pio._kaleido.scope = original_scope\n", "docstring": "Code to acquire resource, e.g.:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_offline/test_offline.py", "original_string": "    def tearDown(self):\n        # Some offline tests produce an html file. Make sure we clean up :)\n        try:\n            os.remove(os.path.join(here, \"temp-plot.html\"))\n            # Some tests that produce temp-plot.html\n            # also produce plotly.min.js\n            os.remove(os.path.join(here, \"plotly.min.js\"))\n        except OSError:\n            pass\n", "docstring": "Some offline tests produce an html file. Make sure we clean up :)"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_offline/test_offline.py", "original_string": "    def _read_html(self, file_url):\n        \"\"\" Read and return the HTML contents from a file_url\n        in the form e.g. file:///Users/chriddyp/Repos/plotly.py/plotly-temp.html\n        \"\"\"\n        with open(file_url.replace(\"file://\", \"\").replace(\" \", \"\")) as f:\n            return f.read()\n", "docstring": "Read and return the HTML contents from a file_url"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_offline/test_offline.py", "original_string": "    def test_including_plotlyjs_truthy_html(self):\n        # For backwards compatibility all truthy values that aren't otherwise\n        # recognized are considered true\n        for include_plotlyjs in [True, 34, \"non-empty-str\"]:\n            html = self._read_html(\n                plotly.offline.plot(\n                    fig,\n                    include_plotlyjs=include_plotlyjs,\n                    output_type=\"file\",\n                    filename=html_filename,\n                    auto_open=False,\n                )\n            )\n            self.assertIn(plotly_config_script, html)\n            self.assertIn(PLOTLYJS, html)\n            self.assertNotIn(cdn_script, html)\n            self.assertNotIn(directory_script, html)\n", "docstring": "For backwards compatibility all truthy values that aren't otherwise"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_offline/test_offline.py", "original_string": "    def test_including_plotlyjs_false_html(self):\n        # For backwards compatibility all truthy values that aren't otherwise\n        # recognized are considered true\n        for include_plotlyjs in [False, 0, \"\"]:\n            html = self._read_html(\n                plotly.offline.plot(\n                    fig,\n                    include_plotlyjs=include_plotlyjs,\n                    output_type=\"file\",\n                    filename=html_filename,\n                    auto_open=False,\n                )\n            )\n            self.assertNotIn(plotly_config_script, html)\n            self.assertNotIn(PLOTLYJS, html)\n            self.assertNotIn(cdn_script, html)\n            self.assertNotIn(directory_script, html)\n", "docstring": "For backwards compatibility all truthy values that aren't otherwise"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_subplots/test_make_subplots.py", "original_string": "    def test_subplot_titles_2x1(self):\n        # make a title for each subplot when the layout is 2 rows and 1 column\n        expected = Figure(\n            data=Data(),\n            layout=Layout(\n                annotations=Annotations(\n                    [\n                        Annotation(\n                            x=0.5,\n                            y=1.0,\n                            xref=\"paper\",\n                            yref=\"paper\",\n                            text=\"Title 1\",\n                            showarrow=False,\n                            font=Font(size=16),\n                            xanchor=\"center\",\n                            yanchor=\"bottom\",\n                        ),\n                        Annotation(\n                            x=0.5,\n                            y=0.375,\n                            xref=\"paper\",\n                            yref=\"paper\",\n                            text=\"Title 2\",\n                            showarrow=False,\n                            font=Font(size=16),\n                            xanchor=\"center\",\n                            yanchor=\"bottom\",\n                        ),\n                    ]\n                ),\n                xaxis1=XAxis(domain=[0.0, 1.0], anchor=\"y\"),\n                xaxis2=XAxis(domain=[0.0, 1.0], anchor=\"y2\"),\n                yaxis1=YAxis(domain=[0.625, 1.0], anchor=\"x\"),\n                yaxis2=YAxis(domain=[0.0, 0.375], anchor=\"x2\"),\n            ),\n        )\n        fig = tls.make_subplots(rows=2, subplot_titles=(\"Title 1\", \"Title 2\"))\n        self.assertEqual(fig.to_plotly_json(), expected.to_plotly_json())\n", "docstring": "make a title for each subplot when the layout is 2 rows and 1 column"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_subplots/test_make_subplots.py", "original_string": "    def test_subplot_titles_shared_axes_rows_columns(self):\n        # make a title for each subplot when the layout is 1 row and 3 columns\n        expected = Figure(\n            data=Data(),\n            layout={\n                \"annotations\": [\n                    {\n                        \"font\": {\"size\": 16},\n                        \"showarrow\": False,\n                        \"text\": \"Title 1\",\n                        \"x\": 0.225,\n                        \"xanchor\": \"center\",\n                        \"xref\": \"paper\",\n                        \"y\": 1.0,\n                        \"yanchor\": \"bottom\",\n                        \"yref\": \"paper\",\n                    },\n                    {\n                        \"font\": {\"size\": 16},\n                        \"showarrow\": False,\n                        \"text\": \"Title 2\",\n                        \"x\": 0.775,\n                        \"xanchor\": \"center\",\n                        \"xref\": \"paper\",\n                        \"y\": 1.0,\n                        \"yanchor\": \"bottom\",\n                        \"yref\": \"paper\",\n                    },\n                    {\n                        \"font\": {\"size\": 16},\n                        \"showarrow\": False,\n                        \"text\": \"Title 3\",\n                        \"x\": 0.225,\n                        \"xanchor\": \"center\",\n                        \"xref\": \"paper\",\n                        \"y\": 0.375,\n                        \"yanchor\": \"bottom\",\n                        \"yref\": \"paper\",\n                    },\n                    {\n                        \"font\": {\"size\": 16},\n                        \"showarrow\": False,\n                        \"text\": \"Title 4\",\n                        \"x\": 0.775,\n                        \"xanchor\": \"center\",\n                        \"xref\": \"paper\",\n                        \"y\": 0.375,\n                        \"yanchor\": \"bottom\",\n                        \"yref\": \"paper\",\n                    },\n                ],\n                \"xaxis\": {\"anchor\": \"y\", \"domain\": [0.0, 0.45]},\n                \"xaxis2\": {\"anchor\": \"y2\", \"domain\": [0.55, 1.0], \"matches\": \"x\"},\n                \"xaxis3\": {\"anchor\": \"y3\", \"domain\": [0.0, 0.45]},\n                \"xaxis4\": {\"anchor\": \"y4\", \"domain\": [0.55, 1.0], \"matches\": \"x3\"},\n                \"yaxis\": {\"anchor\": \"x\", \"domain\": [0.625, 1.0], \"matches\": \"y3\"},\n                \"yaxis2\": {\"anchor\": \"x2\", \"domain\": [0.625, 1.0], \"matches\": \"y4\"},\n                \"yaxis3\": {\"anchor\": \"x3\", \"domain\": [0.0, 0.375]},\n                \"yaxis4\": {\"anchor\": \"x4\", \"domain\": [0.0, 0.375]},\n            },\n        )\n        fig = tls.make_subplots(\n            rows=2,\n            cols=2,\n            subplot_titles=(\"Title 1\", \"Title 2\", \"Title 3\", \"Title 4\"),\n            shared_xaxes=\"rows\",\n            shared_yaxes=\"columns\",\n        )\n        self.assertEqual(fig.to_plotly_json(), expected.to_plotly_json())\n", "docstring": "make a title for each subplot when the layout is 1 row and 3 columns"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_subplots/test_make_subplots.py", "original_string": "    def test_subplot_titles_insets(self):\n        # This should make a title for the inset plot\n        # and no title for the main plot.\n        expected = Figure(\n            data=Data(),\n            layout=Layout(\n                annotations=Annotations(\n                    [\n                        Annotation(\n                            x=0.85,\n                            y=1.0,\n                            xref=\"paper\",\n                            yref=\"paper\",\n                            text=\"Inset\",\n                            showarrow=False,\n                            font=Font(size=16),\n                            xanchor=\"center\",\n                            yanchor=\"bottom\",\n                        )\n                    ]\n                ),\n                xaxis1=XAxis(domain=[0.0, 1.0], anchor=\"y\"),\n                xaxis2=XAxis(domain=[0.7, 1.0], anchor=\"y2\"),\n                yaxis1=YAxis(domain=[0.0, 1.0], anchor=\"x\"),\n                yaxis2=YAxis(domain=[0.3, 1.0], anchor=\"x2\"),\n            ),\n        )\n        fig = tls.make_subplots(\n            insets=[{\"cell\": (1, 1), \"l\": 0.7, \"b\": 0.3}], subplot_titles=(\"\", \"Inset\")\n        )\n        self.assertEqual(fig, expected)\n", "docstring": "This should make a title for the inset plot"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_subplots/test_make_subplots.py", "original_string": "    def test_subplot_titles_empty(self):\n        # Pass empty array\n        expected = tls.make_subplots(insets=[{\"cell\": (1, 1), \"l\": 0.7, \"b\": 0.3}])\n        fig = tls.make_subplots(\n            insets=[{\"cell\": (1, 1), \"l\": 0.7, \"b\": 0.3}], subplot_titles=[]\n        )\n        self.assertEqual(fig, expected)\n", "docstring": "Pass empty array"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_add_traces.py", "original_string": "    def setUp(self):\n        # Construct initial scatter object\n        self.figure = go.Figure(\n            data=[\n                go.Scatter(y=[3, 2, 1], marker={\"color\": \"green\"}),\n                go.Bar(y=[3, 2, 1, 0, -1], marker={\"opacity\": 0.5}),\n            ],\n            layout={\"xaxis\": {\"range\": [-1, 4]}},\n            frames=[go.Frame(layout={\"yaxis\": {\"title\": \"f1\"}})],\n        )\n        # Mock out the message method\n        self.figure._send_addTraces_msg = MagicMock()\n", "docstring": "Construct initial scatter object"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_add_traces.py", "original_string": "    def test_add_traces(self):\n        # Add two traces\n        self.figure.add_traces(\n            [\n                go.Sankey(arrangement=\"snap\"),\n                go.Histogram2dContour(line={\"color\": \"cyan\"}),\n            ]\n        )\n        # Check access properties\n        self.assertEqual(self.figure.data[-2].type, \"sankey\")\n        self.assertEqual(self.figure.data[-2].arrangement, \"snap\")\n        self.assertEqual(self.figure.data[-1].type, \"histogram2dcontour\")\n        self.assertEqual(self.figure.data[-1].line.color, \"cyan\")\n        # Check message\n        new_uid1 = self.figure.data[-2].uid\n        new_uid2 = self.figure.data[-1].uid\n        self.figure._send_addTraces_msg.assert_called_once_with(\n            [\n                {\"type\": \"sankey\", \"arrangement\": \"snap\"},\n                {\"type\": \"histogram2dcontour\", \"line\": {\"color\": \"cyan\"}},\n            ]\n        )\n", "docstring": "Add two traces"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_add_traces.py", "original_string": "def test_add_trace_no_exclude_empty_subplots():\n    # Add traces\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[5, 1, 2]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[2, 1, -7]), row=2, col=2)\n    # Add traces with exclude_empty_subplots set to true and make sure this\n    # even adds to traces that don't already have data\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[0, 1, -1]), row=\"all\", col=\"all\")\n    assert len(fig.data) == 6\n    assert fig.data[2][\"xaxis\"] == \"x\" and fig.data[2][\"yaxis\"] == \"y\"\n    assert fig.data[3][\"xaxis\"] == \"x2\" and fig.data[3][\"yaxis\"] == \"y2\"\n    assert fig.data[4][\"xaxis\"] == \"x3\" and fig.data[4][\"yaxis\"] == \"y3\"\n    assert fig.data[5][\"xaxis\"] == \"x4\" and fig.data[5][\"yaxis\"] == \"y4\"\n", "docstring": "Add traces"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_on_change.py", "original_string": "    def setUp(self):\n        # Construct initial scatter object\n        self.figure = go.Figure(\n            data=[\n                go.Scatter(y=[3, 2, 1], marker={\"color\": \"green\"}),\n                go.Bar(y=[3, 2, 1, 0, -1], marker={\"opacity\": 0.5}),\n            ],\n            layout={\"xaxis\": {\"range\": [-1, 4]}, \"width\": 1000},\n            frames=[go.Frame(layout={\"yaxis\": {\"title\": \"f1\"}})],\n        )\n", "docstring": "Construct initial scatter object"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_on_change.py", "original_string": "    def test_single_prop_callback_on_assignment(self):\n        # Install callbacks on 'x', and 'y' property of first trace\n        fn_x = MagicMock()\n        fn_y = MagicMock()\n        self.figure.data[0].on_change(fn_x, \"x\")\n        self.figure.data[0].on_change(fn_y, \"y\")\n        # Setting x and y on second trace does not trigger callback\n        self.figure.data[1].x = [1, 2, 3]\n        self.figure.data[1].y = [1, 2, 3]\n        self.assertFalse(fn_x.called)\n        self.assertFalse(fn_y.called)\n        # Set x on first trace\n        self.figure.data[0].x = [10, 20, 30]\n        fn_x.assert_called_once_with(self.figure.data[0], (10, 20, 30))\n        self.assertFalse(fn_y.called)\n        # Set y on first trace\n        self.figure.data[0].y = [11, 22, 33]\n        fn_y.assert_called_once_with(self.figure.data[0], (11, 22, 33))\n", "docstring": "Install callbacks on 'x', and 'y' property of first trace"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_on_change.py", "original_string": "    def test_prop_callback_nested_arrays(self):\n        # Initialize updatemenus and buttons\n        self.figure.layout.updatemenus = [{}, {}, {}]\n        self.figure.layout.updatemenus[2].buttons = [{}, {}]\n        self.figure.layout.updatemenus[2].buttons[1].label = \"button 1\"\n        self.figure.layout.updatemenus[2].buttons[1].method = \"relayout\"\n        # Register method callback\n        fn_button = MagicMock()\n        fn_layout = MagicMock()\n        self.figure.layout.updatemenus[2].buttons[1].on_change(fn_button, \"method\")\n        self.figure.layout.on_change(fn_layout, \"updatemenus[2].buttons[1].method\")\n        # Update button method\n        self.figure.layout.updatemenus[2].buttons[1].method = \"restyle\"\n        # Check that both callbacks are called once\n        fn_button.assert_called_once_with(\n            self.figure.layout.updatemenus[2].buttons[1], \"restyle\"\n        )\n        fn_layout.assert_called_once_with(self.figure.layout, \"restyle\")\n", "docstring": "Initialize updatemenus and buttons"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_on_change.py", "original_string": "    def test_callback_on_plotly_restyle(self):\n        # Register callback if either 'x' or 'y' changes on first trace\n        fn = MagicMock()\n        self.figure.data[0].on_change(fn, \"x\", \"y\")\n        # Perform assignment on one of pthe properties\n        self.figure.plotly_restyle(\n            {\"x\": [[11, 22, 33], [1, 11, 111]]}, trace_indexes=[0, 1]\n        )\n        # Check function called once with new value of x and old value of y\n        fn.assert_called_once_with(self.figure.data[0], (11, 22, 33), (3, 2, 1))\n", "docstring": "Register callback if either 'x' or 'y' changes on first trace"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_batch_animate.py", "original_string": "    def setUp(self):\n        # Construct initial scatter object\n        self.figure = go.Figure(\n            data=[\n                go.Scatter(y=[3, 2, 1], marker={\"color\": \"green\"}),\n                go.Bar(y=[3, 2, 1, 0, -1], marker={\"opacity\": 0.5}),\n            ],\n            layout={\"xaxis\": {\"range\": [-1, 4]}},\n            frames=[go.Frame(layout={\"yaxis\": {\"title\": \"f1\"}})],\n        )\n        # Mock out the message method\n        self.figure._send_animate_msg = MagicMock()\n", "docstring": "Construct initial scatter object"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_plotly_restyle.py", "original_string": "    def setUp(self):\n        # Construct with mocked _send_restyle_msg method\n        self.figure = go.Figure(\n            data=[\n                go.Scatter(),\n                go.Bar(),\n                go.Parcoords(dimensions=[{}, {\"label\": \"dim 2\"}, {}]),\n            ]\n        )\n        # Mock out the message method\n        self.figure._send_restyle_msg = MagicMock()\n", "docstring": "Construct with mocked _send_restyle_msg method"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_plotly_restyle.py", "original_string": "    def test_property_assignment_nested(self):\n        # Set scatter marker color\n        self.figure.data[0].marker.color = \"green\"\n        self.figure._send_restyle_msg.assert_called_once_with(\n            {\"marker.color\": [\"green\"]}, trace_indexes=0\n        )\n", "docstring": "Set scatter marker color"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_plotly_restyle.py", "original_string": "    def test_plotly_restyle_toplevel(self):\n        # Set bar marker\n        self.figure.plotly_restyle({\"marker\": {\"color\": \"green\"}}, trace_indexes=1)\n        self.figure._send_restyle_msg.assert_called_once_with(\n            {\"marker\": {\"color\": \"green\"}}, trace_indexes=[1]\n        )\n", "docstring": "Set bar marker"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_plotly_restyle.py", "original_string": "    def test_plotly_restyle_nested_array(self):\n        # Set parcoords dimension\n        self.figure.plotly_restyle({\"dimensions[0].label\": \"dim 1\"}, trace_indexes=2)\n        self.figure._send_restyle_msg.assert_called_once_with(\n            {\"dimensions[0].label\": \"dim 1\"}, trace_indexes=[2]\n        )\n", "docstring": "Set parcoords dimension"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_plotly_update.py", "original_string": "    def setUp(self):\n        # Construct initial scatter object\n        self.figure = go.Figure(\n            data=[\n                go.Scatter(y=[3, 2, 1], marker={\"color\": \"green\"}),\n                go.Bar(y=[3, 2, 1, 0, -1], marker={\"opacity\": 0.5}),\n            ],\n            layout={\"xaxis\": {\"range\": [-1, 4]}},\n            frames=[go.Frame(layout={\"yaxis\": {\"title\": \"f1\"}})],\n        )\n        # Mock out the message method\n        self.figure._send_update_msg = MagicMock()\n", "docstring": "Construct initial scatter object"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_plotly_relayout.py", "original_string": "    def setUp(self):\n        # Construct with mocked _send_relayout_msg method\n        self.figure = go.Figure(layout={\"xaxis\": {\"range\": [-1, 4]}})\n        # Mock out the message method\n        self.figure._send_relayout_msg = MagicMock()\n", "docstring": "Construct with mocked _send_relayout_msg method"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_plotly_relayout.py", "original_string": "    def test_property_assignment_nested_array(self):\n        # Initialize images\n        self.figure.layout.updatemenus = [\n            {},\n            go.layout.Updatemenu(\n                buttons=[{}, {}, go.layout.updatemenu.Button(method=\"relayout\")]\n            ),\n            {},\n        ]\n        self.figure._send_relayout_msg.assert_called_once_with(\n            {\"updatemenus\": [{}, {\"buttons\": [{}, {}, {\"method\": \"relayout\"}]}, {}]}\n        )\n        # Reset mock and perform property assignment\n        self.figure._send_relayout_msg = MagicMock()\n        self.figure.layout.updatemenus[1].buttons[0].method = \"restyle\"\n        self.figure._send_relayout_msg.assert_called_once_with(\n            {\"updatemenus.1.buttons.0.method\": \"restyle\"}\n        )\n", "docstring": "Initialize images"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_plotly_relayout.py", "original_string": "    def test_plotly_relayout_nested_subplot2(self):\n        # Initialize xaxis2\n        self.figure.layout.xaxis2 = {\"range\": [0, 1]}\n        self.figure._send_relayout_msg.assert_called_once_with(\n            {\"xaxis2\": {\"range\": [0, 1]}}\n        )\n        # Reset mock and perform property assignment\n        self.figure._send_relayout_msg = MagicMock()\n        self.figure.plotly_relayout({\"xaxis2.title.font.family\": \"courier\"})\n        self.figure._send_relayout_msg.assert_called_once_with(\n            {\"xaxis2.title.font.family\": \"courier\"}\n        )\n", "docstring": "Initialize xaxis2"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_move_delete_traces.py", "original_string": "    def setUp(self):\n        # Construct initial scatter object\n        self.figure = go.Figure(\n            data=[\n                go.Scatter(y=[3, 2, 1], marker={\"color\": \"green\"}),\n                go.Bar(y=[3, 2, 1, 0, -1], marker={\"opacity\": 0.5}),\n                go.Sankey(arrangement=\"snap\"),\n            ]\n        )\n        # Mock out the message methods\n        self.figure._send_moveTraces_msg = MagicMock()\n        self.figure._send_deleteTraces_msg = MagicMock()\n", "docstring": "Construct initial scatter object"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_move_delete_traces.py", "original_string": "    def test_move_traces_cycle(self):\n        # Cycle traces forward\n        traces = self.figure.data\n        self.figure.data = [traces[2], traces[0], traces[1]]\n        # Check messages\n        self.figure._send_moveTraces_msg.assert_called_once_with([0, 1, 2], [1, 2, 0])\n        self.assertFalse(self.figure._send_deleteTraces_msg.called)\n", "docstring": "Cycle traces forward"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_move_delete_traces.py", "original_string": "    def test_delete_multiple_traces(self):\n        # Delete middle trace\n        traces = self.figure.data\n        self.figure.data = [traces[1]]\n        # Check messages\n        self.figure._send_deleteTraces_msg.assert_called_once_with([0, 2])\n        self.assertFalse(self.figure._send_moveTraces_msg.called)\n", "docstring": "Delete middle trace"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_figure_messages/test_move_delete_traces.py", "original_string": "    def test_move_and_delete_traces(self):\n        # Delete middle trace\n        traces = self.figure.data\n        self.figure.data = [traces[2], traces[0]]\n        # Check messages\n        self.figure._send_deleteTraces_msg.assert_called_once_with([1])\n        self.figure._send_moveTraces_msg.assert_called_once_with([0, 1], [1, 0])\n", "docstring": "Delete middle trace"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_colors/test_colors.py", "original_string": "    def test_validate_colors(self):\n        # test string input\n        color_string = \"foo\"\n        pattern = (\n            \"If your colors variable is a string, it must be a \"\n            \"Plotly scale, an rgb color or a hex color.\"\n        )\n        self.assertRaisesRegexp(\n            PlotlyError, pattern, colors.validate_colors, color_string\n        )\n        # test rgb color\n        color_string2 = \"rgb(265, 0, 0)\"\n        pattern2 = (\n            \"Whoops! The elements in your rgb colors tuples cannot \" \"exceed 255.0.\"\n        )\n        self.assertRaisesRegexp(\n            PlotlyError, pattern2, colors.validate_colors, color_string2\n        )\n        # test tuple color\n        color_tuple = (1, 1, 2)\n        pattern3 = \"Whoops! The elements in your colors tuples cannot \" \"exceed 1.0.\"\n        self.assertRaisesRegexp(\n            PlotlyError, pattern3, colors.validate_colors, color_tuple\n        )\n", "docstring": "test string input"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_colors/test_colors.py", "original_string": "    def test_convert_dict_colors_to_same_type(self):\n        # test colortype\n        color_dict = dict(apple=\"rgb(1, 1, 1)\")\n        colortype = 2\n        pattern = \"You must select either rgb or tuple for your colortype \" \"variable.\"\n        self.assertRaisesRegexp(\n            PlotlyError,\n            pattern,\n            colors.convert_dict_colors_to_same_type,\n            color_dict,\n            colortype,\n        )\n", "docstring": "test colortype"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_colors/test_colors.py", "original_string": "    def test_make_colorscale(self):\n        # test minimum colors length\n        color_list = [(0, 0, 0)]\n        pattern = \"You must input a list of colors that has at least two colors.\"\n        self.assertRaisesRegexp(\n            PlotlyError, pattern, colors.make_colorscale, color_list\n        )\n        # test length of colors and scale\n        color_list2 = [(0, 0, 0), (1, 1, 1)]\n        scale = [0]\n        pattern2 = \"The length of colors and scale must be the same.\"\n        self.assertRaisesRegexp(\n            PlotlyError, pattern2, colors.make_colorscale, color_list2, scale\n        )\n", "docstring": "test minimum colors length"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_errors/test_dict_path_errors.py", "original_string": "def error_substr(s, r):\n    \"\"\" remove a part of the error message we don't want to compare \"\"\"\n    return s.replace(r, \"\")\n", "docstring": "remove a part of the error message we don't want to compare \n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_errors/test_dict_path_errors.py", "original_string": "def test_raises_on_bad_dot_property(some_fig):\n    # Check . property lookup errors can be detected when path used as key to\n    # go.Figure\n    raised = False\n    try:\n        x2000 = some_fig[\"layout.shapes[1].x2000\"]\n    except KeyError as e:\n        raised = True\n        assert (\n            e.args[0].find(\n                \"\"\"Bad property path:\n", "docstring": "Check . property lookup errors can be detected when path used as key to"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_errors/test_dict_path_errors.py", "original_string": "def test_raises_on_bad_ancestor_dot_property(some_fig):\n    # Check . property lookup errors but not on the last part of the path\n    raised = False\n    try:\n        x2000 = some_fig[\"layout.shapa[1].x2000\"]\n    except KeyError as e:\n        raised = True\n        assert (\n            e.args[0].find(\n                \"\"\"Bad property path:\n", "docstring": "Check . property lookup errors but not on the last part of the path"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_errors/test_dict_path_errors.py", "original_string": "def test_raises_on_bad_indexed_underscore_property(some_fig):\n    # The way these tests work is first the error is raised without using\n    # underscores to get the Exception we expect, then the string showing the\n    # bad property path is removed (because it will not match the string\n    # returned when the same error is thrown using underscores).\n    # Then the error is thrown using underscores and the Exceptions are\n    # compared, but we adjust the expected bad property error because it will be\n    # different when underscores are used.\n    # finds bad part when using the path as a key to figure and throws the error\n    # for the last good property it found in the path\n    raised = False\n    try:\n        # get the error without using a path-like key, we compare with this error\n        some_fig.data[0].line[\"colr\"] = \"blue\"\n    except ValueError as e_correct:\n        raised = True\n        # remove \"Bad property path:\n        e_correct_substr = error_substr(\n            e_correct.args[0],\n            \"\"\"\n", "docstring": "The way these tests work is first the error is raised without using"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_errors/test_dict_path_errors.py", "original_string": "def test_describes_subscripting_error(some_fig):\n    # This test works like test_raises_on_bad_indexed_underscore_property but\n    # removes the error raised because the property does not support\n    # subscripting.\n    # Note that, to raise the error, we try to access the value rather than\n    # assign something to it. We have to do this, because Plotly.py tries to\n    # access the value to see if it is valid, so the error raised has to do with\n    # subscripting and not assignment (even though we are trying to assign it a\n    # value).\n    raised = False\n    try:\n        # some_fig.update_traces(text_yo=\"hey\") but without using underscores\n        some_fig.data[0].text[\"yo\"]\n    except TypeError as e:\n        raised = True\n        e_correct_substr = e.args[0]\n    assert raised\n    raised = False\n    try:\n        some_fig.update_traces(text_yo=\"hey\")\n    except ValueError as e:\n        raised = True\n        print(e.args[0])\n        e_substr = error_substr(\n            e.args[0],\n            \"\"\"\n", "docstring": "This test works like test_raises_on_bad_indexed_underscore_property but"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_errors/test_dict_path_errors.py", "original_string": "def test_described_subscript_error_on_type_error(some_fig):\n    # The above tests for subscripting errors did not test for when we attempt\n    # to subscript an object that is not None, such as a string or a number.\n    # These do that.\n    raised = False\n    try:\n        # Trying to address with a key an object that doesn't support it (as we\n        # do below) reports an error listing what are valid assignments to the\n        # object, like when we try and assign a number to something that expects as string.\n        some_fig[\"layout_template_layout_plot_bgcolor\"] = 1\n    except ValueError as e:\n        raised = True\n        # Trim off the beginning of the error string because it is related to\n        # trying to assign a number to something expecting a string, whereas\n        # below the error will be due to trying to subscript something that\n        # doesn't support it. But the list of valid properties should be shown\n        # for both errors and this is what we extract.\n        # Trimmed like this because this string is different in Python2 than\n        # Python3\n        e_correct_substr = e.args[0]\n        start_at = e_correct_substr.find(\"    The 'plot_bgcolor'\")\n        e_correct_substr = e_correct_substr[start_at:]\n        e_correct_substr += \"\"\"\n", "docstring": "The above tests for subscripting errors did not test for when we attempt"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_errors/test_dict_path_errors.py", "original_string": "def test_subscript_error_exception_types(some_fig):\n    # Assert that these raise the expected error types\n    # when width is None\n    with pytest.raises(ValueError):\n        some_fig.update_layout(width_yo=100)\n    with pytest.raises(KeyError):\n        yo = some_fig[\"layout_width_yo\"]\n    some_fig.update_layout(width=100)\n    # when width is specified\n    with pytest.raises(ValueError):\n        some_fig.update_layout(width_yo=100)\n    with pytest.raises(KeyError):\n        yo = some_fig[\"layout_width_yo\"]\n", "docstring": "Assert that these raise the expected error types"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_errors/test_dict_path_errors.py", "original_string": "def test_trailing_underscore_errors(some_fig):\n    # get error string but alter it to form the final expected string\n    def _raise_bad_property_path_form():\n        some_fig.update_layout(title_text_bogus=\"hi\")\n    def _raise_bad_property_path_real():\n        some_fig.update_layout(title_text_=\"hi\")\n    correct_err_str = form_error_string(\n        _raise_bad_property_path_form,\n        ValueError,\n        [\n            (\n                \"Property does not support subscripting\",\n                \"Property does not support subscripting and path has trailing underscores\",\n            ),\n            (\"text_bogus\", \"text_\"),\n            (\"^^^^\", \"^^^^^\"),\n        ],\n    )\n    # no need to replace ^^^^^ because bogus and text_ are same length\n    check_error_string(_raise_bad_property_path_real, ValueError, correct_err_str, [])\n", "docstring": "get error string but alter it to form the final expected string"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_errors/test_dict_path_errors.py", "original_string": "def test_solo_underscore_errors(some_fig):\n    # get error string but alter it to form the final expected string\n    def _raise_bad_property_path_form():\n        some_fig.update_layout(bogus=\"hi\")\n    def _raise_bad_property_path_real():\n        some_fig.update_layout(_=\"hi\")\n    correct_err_str = form_error_string(\n        _raise_bad_property_path_form,\n        ValueError,\n        [\n            (\"bogus\", \"_\"),\n            (\"bogus\", \"_\"),\n            (\"^^^^^\", \"^\"),\n            ('Did you mean \"boxgap\"', 'Did you mean \"geo\"'),\n            ('Did you mean \"boxgap\"', 'Did you mean \"geo\"'),\n        ],\n    )\n    check_error_string(_raise_bad_property_path_real, ValueError, correct_err_str, [])\n", "docstring": "get error string but alter it to form the final expected string"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_errors/test_dict_path_errors.py", "original_string": "def test_leading_underscore_errors_dots_and_subscripts(some_fig):\n    # get error string but alter it to form the final expected string\n    some_fig.add_annotation(text=\"hi\")\n    def _raise_bad_property_path_form():\n        some_fig[\"layout.annotations[0].bogus_family\"] = \"hi\"\n    def _raise_bad_property_path_real():\n        some_fig[\"layout.annotations[0]._font_family\"] = \"hi\"\n    correct_err_str = form_error_string(\n        _raise_bad_property_path_form,\n        ValueError,\n        [(\"bogus\", \"_font\"), (\"bogus\", \"_font\"), (\"^^^^^\", \"^^^^^\")],\n    )\n    check_error_string(_raise_bad_property_path_real, ValueError, correct_err_str, [])\n", "docstring": "get error string but alter it to form the final expected string"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_errors/test_dict_path_errors.py", "original_string": "def test_repeated_underscore_errors_dots_and_subscripts(some_fig):\n    # get error string but alter it to form the final expected string\n    some_fig.add_annotation(text=\"hi\")\n    def _raise_bad_property_path_form():\n        some_fig[\"layout.annotations[0].font_bogusey\"] = \"hi\"\n    def _raise_bad_property_path_real():\n        some_fig[\"layout.annotations[0].font__family\"] = \"hi\"\n    correct_err_str = form_error_string(\n        _raise_bad_property_path_form,\n        ValueError,\n        [\n            (\"bogusey\", \"_family\"),\n            (\"bogusey\", \"_family\"),\n            ('Did you mean \"color\"?', 'Did you mean \"family\"?'),\n            ('Did you mean \"color\"?', 'Did you mean \"family\"?'),\n        ],\n    )\n    check_error_string(_raise_bad_property_path_real, ValueError, correct_err_str, [])\n", "docstring": "get error string but alter it to form the final expected string"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_utils/test_utils.py", "original_string": "    def test_get_by_path(self):\n        # should be able to traverse into a nested dict/list with key array\n        figure = {\"data\": [{}, {\"marker\": {\"color\": [\"red\", \"blue\"]}}]}\n        path = (\"data\", 1, \"marker\", \"color\")\n        value = get_by_path(figure, path)\n        expected_value = [\"red\", \"blue\"]\n        self.assertEqual(value, expected_value)\n", "docstring": "should be able to traverse into a nested dict/list with key array"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_layout_subplots.py", "original_string": "    def setUp(self):\n        # Construct initial scatter object\n        self.layout = go.Layout()\n        pio.templates.default = None\n", "docstring": "Construct initial scatter object"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_layout_subplots.py", "original_string": "    def test_initial_access_subplots(self):\n        # It should be possible to access base subplots initially\n        self.assertEqual(self.layout.xaxis, go.layout.XAxis())\n        self.assertEqual(self.layout.yaxis, go.layout.YAxis())\n        self.assertEqual(self.layout[\"geo\"], go.layout.Geo())\n        self.assertEqual(self.layout.scene, go.layout.Scene())\n        self.assertEqual(self.layout.mapbox, go.layout.Mapbox())\n        self.assertEqual(self.layout.polar, go.layout.Polar())\n        # Subplot ids of 1 should be mapped to the same object as the base\n        # subplot. Notice we're using assertIs not assertEqual here\n        self.assertIs(self.layout.xaxis, self.layout.xaxis1)\n        self.assertIs(self.layout.yaxis, self.layout.yaxis1)\n        self.assertIs(self.layout.geo, self.layout.geo1)\n        self.assertIs(self.layout.scene, self.layout.scene1)\n        self.assertIs(self.layout.mapbox, self.layout.mapbox1)\n        self.assertIs(self.layout.polar, self.layout.polar1)\n", "docstring": "It should be possible to access base subplots initially"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_layout_subplots.py", "original_string": "    def test_assign_subplot2(self):\n        # Init xaxis2\n        self.layout.xaxis2 = go.layout.XAxis()\n        # Properties are initially None\n        self.assertIsNone(self.layout.xaxis2.range)\n        # Set range\n        xrange = [0, 1]\n        self.layout.xaxis2.range = [0, 1]\n        self.assertEqual(self.layout.xaxis2.range, tuple(xrange))\n        # Make sure range isn't shared with xaxis, or xaxis1\n        self.assertIsNone(self.layout.xaxis.range)\n        self.assertIsNone(self.layout.xaxis1.range)\n", "docstring": "Init xaxis2"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_property_assignment.py", "original_string": "    def setUp(self):\n        # Construct initial scatter object\n        self.scatter = go.Scatter(name=\"scatter A\")\n        # Assert initial state\n        d1, d2 = strip_dict_params(\n            self.scatter, {\"type\": \"scatter\", \"name\": \"scatter A\"}\n        )\n        assert d1 == d2\n        # Construct expected results\n        self.expected_toplevel = {\n            \"type\": \"scatter\",\n            \"name\": \"scatter A\",\n            \"fillcolor\": \"green\",\n        }\n        self.expected_nested = {\n            \"type\": \"scatter\",\n            \"name\": \"scatter A\",\n            \"marker\": {\"colorbar\": {\"title\": {\"font\": {\"family\": \"courier\"}}}},\n        }\n        self.expected_nested_error_x = {\n            \"type\": \"scatter\",\n            \"name\": \"scatter A\",\n            \"error_x\": {\"type\": \"percent\"},\n        }\n", "docstring": "Construct initial scatter object"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_property_assignment.py", "original_string": "    def setUp(self):\n        # Construct initial scatter object\n        self.scatter = go.Scatter(name=\"scatter A\")\n        # Assert initial state\n        d1, d2 = strip_dict_params(\n            self.scatter, {\"type\": \"scatter\", \"name\": \"scatter A\"}\n        )\n        assert d1 == d2\n        # Construct expected results\n        self.expected_toplevel = {\n            \"type\": \"scatter\",\n            \"name\": \"scatter A\",\n            \"marker\": {\"color\": \"yellow\", \"size\": 10},\n        }\n        self.expected_nested = {\n            \"type\": \"scatter\",\n            \"name\": \"scatter A\",\n            \"marker\": {\"colorbar\": {\"bgcolor\": \"yellow\", \"thickness\": 5}},\n        }\n", "docstring": "Construct initial scatter object"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_property_assignment.py", "original_string": "    def test_toplevel(self):\n        # Initialize scatter\n        scatter = go.Scatter(\n            name=\"scatter A\",\n            y=[3, 2, 4],\n            marker={\"colorbar\": {\"title\": {\"font\": {\"family\": \"courier\"}}}},\n        )\n        expected = {\n            \"type\": \"scatter\",\n            \"name\": \"scatter A\",\n            \"y\": [3, 2, 4],\n            \"marker\": {\"colorbar\": {\"title\": {\"font\": {\"family\": \"courier\"}}}},\n        }\n        d1, d2 = strip_dict_params(scatter, expected)\n        assert d1 == d2\n        # Set property not defined to None\n        scatter.x = None\n        d1, d2 = strip_dict_params(scatter, expected)\n        assert d1 == d2\n        scatter[\"line.width\"] = None\n        d1, d2 = strip_dict_params(scatter, expected)\n        assert d1 == d2\n        # Set defined property to None\n        scatter.y = None\n        expected.pop(\"y\")\n        d1, d2 = strip_dict_params(scatter, expected)\n        assert d1 == d2\n        # Set compound properties to None\n        scatter[(\"marker\", \"colorbar\", \"title\", \"font\")] = None\n        expected[\"marker\"][\"colorbar\"][\"title\"].pop(\"font\")\n        d1, d2 = strip_dict_params(scatter, expected)\n        assert d1 == d2\n        scatter.marker = None\n        expected.pop(\"marker\")\n        d1, d2 = strip_dict_params(scatter, expected)\n        assert d1 == d2\n", "docstring": "Initialize scatter"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_property_assignment.py", "original_string": "    def setUp(self):\n        # Construct initial scatter object\n        self.parcoords = go.Parcoords(name=\"parcoords A\")\n        # Assert initial state\n        d1, d2 = strip_dict_params(\n            self.parcoords, {\"type\": \"parcoords\", \"name\": \"parcoords A\"}\n        )\n        assert d1 == d2\n        # Construct expected results\n        self.expected_toplevel = {\n            \"type\": \"parcoords\",\n            \"name\": \"parcoords A\",\n            \"dimensions\": [\n                {\"values\": [2, 3, 1], \"visible\": True},\n                {\"values\": [1, 2, 3], \"label\": \"dim1\"},\n            ],\n        }\n        self.layout = go.Layout()\n        self.expected_layout1 = {\"updatemenus\": [{}, {\"font\": {\"family\": \"courier\"}}]}\n        self.expected_layout2 = {\n            \"updatemenus\": [{}, {\"buttons\": [{}, {}, {\"method\": \"restyle\"}]}]\n        }\n", "docstring": "Construct initial scatter object"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_property_assignment.py", "original_string": "    def test_assign_double_nested_update_array(self):\n        # Initialize empty updatemenus\n        self.layout.updatemenus = [{}, {}]\n        # Initialize empty buttons in updatemenu[1]\n        self.layout.updatemenus[1].buttons = [{}, {}, {}]\n        # Update\n        self.layout.update(\n            updatemenus=[{}, {\"buttons\": [{}, {}, {\"method\": \"restyle\"}]}]\n        )\n        # Check\n        self.assertEqual(self.layout.updatemenus[1].buttons[2].method, \"restyle\")\n        d1, d2 = strip_dict_params(self.layout, self.expected_layout2)\n        assert d1 == d2\n", "docstring": "Initialize empty updatemenus"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_graph_objs.py", "original_string": "    def test_old_class_names(self):\n        # these were all defined at one point, we want to maintain backwards\n        # compat, so we basically just create a checkpoint with this test.\n        for class_name in OLD_CLASS_NAMES:\n            self.assertIsNotNone(getattr(go, class_name, None))\n", "docstring": "these were all defined at one point, we want to maintain backwards"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_graph_objs.py", "original_string": "    def test_legacy_title_props_remapped(self):\n        # plain Layout\n        obj = go.Layout()\n        self.assertIs(obj.titlefont, obj.title.font)\n        self.assertIsNone(obj.title.font.family)\n        # Set titlefont in constructor\n        obj = go.Layout(titlefont={\"family\": \"Courier\"})\n        self.assertIs(obj.titlefont, obj.title.font)\n        self.assertEqual(obj.titlefont.family, \"Courier\")\n        self.assertEqual(obj.title.font.family, \"Courier\")\n        # Property assignment\n        obj = go.Layout()\n        obj.titlefont.family = \"Courier\"\n        self.assertIs(obj.titlefont, obj.title.font)\n        self.assertEqual(obj[\"titlefont.family\"], \"Courier\")\n        self.assertEqual(obj.title.font.family, \"Courier\")\n        # In/Iter\n        self.assertIn(\"titlefont\", obj)\n        self.assertIn(\"titlefont.family\", obj)\n        self.assertIn(\"titlefont\", iter(obj))\n", "docstring": "plain Layout"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_figure.py", "original_string": "    def test_access_top_level(self):\n        # Figure is special, we define top-level objects that always exist.\n        self.assertEqual(go.Figure().data, ())\n        self.assertEqual(go.Figure().layout.to_plotly_json(), {})\n        self.assertEqual(go.Figure().frames, ())\n", "docstring": "Figure is special, we define top-level objects that always exist."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_properties_validated.py", "original_string": "    def setUp(self):\n        # Construct initial scatter object\n        self.scatter = go.Scatter()\n        self.scatter.name = \"Scatter 1\"\n", "docstring": "Construct initial scatter object"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_properties_validated.py", "original_string": "    def test_invalid_item_assignment(self):\n        with pytest.raises(ValueError):\n            self.scatter[\"bogus\"] = 87\n", "docstring": "with pytest.raises(ValueError):"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_properties_validated.py", "original_string": "    def setUp(self):\n        # Construct initial scatter object\n        self.scatter = go.Scatter()\n        self.scatter.name = \"Scatter 1\"\n        self.layout = go.Layout()\n", "docstring": "Construct initial scatter object"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_properties_validated.py", "original_string": "    def setUp(self):\n        # Construct initial scatter object\n        self.parcoords = go.Parcoords()\n        self.parcoords.name = \"Scatter 1\"\n", "docstring": "Construct initial scatter object"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_update.py", "original_string": "    def test_update_initialize_nonempty_list_with_list_extends(self):\n        layout = go.Layout(\n            annotations=[\n                go.layout.Annotation(text=\"one\"),\n                go.layout.Annotation(text=\"two\"),\n            ]\n        )\n        layout.update(\n            annotations=[\n                go.layout.Annotation(width=10),\n                go.layout.Annotation(width=20),\n                go.layout.Annotation(width=30),\n                go.layout.Annotation(width=40),\n                go.layout.Annotation(width=50),\n            ]\n        )\n        expected = {\n            \"annotations\": [\n                {\"text\": \"one\", \"width\": 10},\n                {\"text\": \"two\", \"width\": 20},\n                {\"width\": 30},\n                {\"width\": 40},\n                {\"width\": 50},\n            ]\n        }\n        self.assertEqual(layout.to_plotly_json(), expected)\n", "docstring": "layout = go.Layout("}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_figure_properties.py", "original_string": "    def setUp(self):\n        # Disable default template\n        pio.templates.default = None\n        # Construct initial scatter object\n        self.figure = go.Figure(\n            data=[go.Scatter(y=[3, 2, 1], marker={\"color\": \"green\"})],\n            layout={\"xaxis\": {\"range\": [-1, 4]}},\n            frames=[go.Frame(layout={\"yaxis\": {\"title\": \"f1\"}})],\n        )\n", "docstring": "Disable default template"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_figure_properties.py", "original_string": "    def test_update_layout(self):\n        # Check initial x-range\n        self.assertEqual(self.figure.layout.xaxis.range, (-1, 4))\n        # Update with kwarg\n        self.figure.update(layout={\"xaxis\": {\"range\": [10, 20]}})\n        self.assertEqual(self.figure.layout.xaxis.range, (10, 20))\n        # Update with dict\n        self.figure.update({\"layout\": {\"xaxis\": {\"range\": [100, 200]}}})\n        self.assertEqual(self.figure.layout.xaxis.range, (100, 200))\n", "docstring": "Check initial x-range"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_figure_properties.py", "original_string": "    def test_update_data_dots(self):\n        # Check initial marker color\n        self.assertEqual(self.figure.data[0].marker.color, \"green\")\n        # Update with dict kwarg\n        self.figure.update(data={0: {\"marker.color\": \"blue\"}})\n        self.assertEqual(self.figure.data[0].marker.color, \"blue\")\n        # Update with list kwarg\n        self.figure.update(data=[{\"marker.color\": \"red\"}])\n        self.assertEqual(self.figure.data[0].marker.color, \"red\")\n        # Update with dict\n        self.figure.update({\"data[0].marker.color\": \"yellow\"})\n        self.assertEqual(self.figure.data[0].marker.color, \"yellow\")\n", "docstring": "Check initial marker color"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_figure_properties.py", "original_string": "    def test_update_data_empty(self):\n        # Create figure with empty data (no traces)\n        figure = go.Figure(layout={\"width\": 1000})\n        # Update data with new traces\n        figure.update(data=[go.Scatter(y=[2, 1, 3]), go.Bar(y=[1, 2, 3])])\n        # Build expected dict\n        expected = {\n            \"data\": [\n                {\"y\": [2, 1, 3], \"type\": \"scatter\"},\n                {\"y\": [1, 2, 3], \"type\": \"bar\"},\n            ],\n            \"layout\": {\"width\": 1000},\n        }\n        # Compute expected figure dict (pop uids for comparison)\n        result = figure.to_dict()\n        # Perform comparison\n        self.assertEqual(result, expected)\n", "docstring": "Create figure with empty data (no traces)"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_figure_properties.py", "original_string": "    def test_plotly_restyle(self):\n        # Check initial marker color\n        self.assertEqual(self.figure.data[0].marker.color, \"green\")\n        # Update with dict kwarg\n        self.figure.plotly_restyle(\n            restyle_data={\"marker.color\": \"blue\"}, trace_indexes=0\n        )\n        self.assertEqual(self.figure.data[0].marker.color, \"blue\")\n", "docstring": "Check initial marker color"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_figure_properties.py", "original_string": "    def test_plotly_relayout(self):\n        # Check initial x-range\n        self.assertEqual(self.figure.layout.xaxis.range, (-1, 4))\n        # Update with kwarg\n        self.figure.plotly_relayout(relayout_data={\"xaxis.range\": [10, 20]})\n        self.assertEqual(self.figure.layout.xaxis.range, (10, 20))\n", "docstring": "Check initial x-range"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_figure_properties.py", "original_string": "    def test_plotly_update_layout(self):\n        # Check initial x-range\n        self.assertEqual(self.figure.layout.xaxis.range, (-1, 4))\n        # Update with kwarg\n        self.figure.plotly_update(relayout_data={\"xaxis.range\": [10, 20]})\n        self.assertEqual(self.figure.layout.xaxis.range, (10, 20))\n", "docstring": "Check initial x-range"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_update_objects/test_update_subplots.py", "original_string": "        def check_select(fig):\n            # Check select_*\n            subplots = list(\n                select_fn(fig, selector=selector, row=row, col=col, **sec_y_args)\n            )\n            expected_keys = [\n                subplot_type + (str(cnt) if cnt > 1 else \"\") for cnt in expected_nums\n            ]\n            self.assertEqual(len(subplots), len(expected_keys))\n            self.assertTrue(\n                all(v1 is fig.layout[k] for v1, k in zip(subplots, expected_keys))\n            )\n            # Check for_each_*\n            subplots = []\n            res = for_each_fn(\n                fig,\n                lambda obj: subplots.append(obj),\n                selector=selector,\n                row=row,\n                col=col,\n                **sec_y_args\n            )\n            self.assertIs(res, fig)\n            self.assertEqual(len(subplots), len(expected_keys))\n            self.assertTrue(\n                all(v1 is fig.layout[k] for v1, k in zip(subplots, expected_keys))\n            )\n", "docstring": "Check select_*"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_update_objects/test_update_subplots.py", "original_string": "        def check_update(fig):\n            # Copy input figure so that we don't modify it\n            fig_orig = fig\n            fig = copy.deepcopy(fig)\n            # perform update_*\n            update_res = update_fn(\n                fig,\n                patch,\n                selector=selector,\n                row=row,\n                col=col,\n                **dict(kwargs, **secy_kwargs)\n            )\n            self.assertIs(update_res, fig)\n            # Build expected layout keys\n            expected_keys = [\n                subplot_type + (str(cnt) if cnt > 1 else \"\") for cnt in expected_nums\n            ]\n            # Iterate over all layout keys\n            for k in fig.layout:\n                orig_obj = copy.deepcopy(fig_orig.layout[k])\n                new_obj = fig.layout[k]\n                if k in expected_keys:\n                    # Make sure sure there is an initial difference\n                    self.assertNotEqual(orig_obj, new_obj)\n                    orig_obj.update(patch, **kwargs)\n                self.assertEqual(new_obj, orig_obj)\n", "docstring": "Copy input figure so that we don't modify it"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_update_objects/test_update_annotations.py", "original_string": "    def test_add_annotation_no_grid(self):\n        # Paper annotation\n        fig = go.Figure()\n        fig.add_annotation(text=\"A\", yref=\"paper\")\n        annot = fig.layout.annotations[-1]\n        self.assertEqual(annot.text, \"A\")\n        self.assertEqual(annot.xref, None)\n        self.assertEqual(annot.yref, \"paper\")\n        # Not valid to add annotation by row/col\n        with self.assertRaisesRegexp(Exception, \"make_subplots\"):\n            fig.add_annotation(text=\"B\", row=1, col=1)\n", "docstring": "Paper annotation"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_update_objects/test_update_traces.py", "original_string": "    def test_select_property_and_grid(self):\n        # (1, 1)\n        self.assert_select_traces([0], selector={\"mode\": \"markers\"}, row=1, col=1)\n        self.assert_select_traces([1], selector={\"type\": \"bar\"}, row=1, col=1)\n        # (2, 1)\n        self.assert_select_traces([2, 9], selector={\"mode\": \"lines\"}, row=2, col=1)\n        # (1, 2)\n        self.assert_select_traces([4], selector={\"marker.color\": \"green\"}, row=1, col=2)\n        # Valid row/col and valid selector but the intersection is empty\n        self.assert_select_traces([], selector={\"type\": \"markers\"}, row=3, col=1)\n", "docstring": "(1, 1)"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_update_objects/test_selector_matches.py", "original_string": "def test_selector_none():\n    # should return True\n    assert BaseFigure._selector_matches({}, None) == True  # arbitrary,\n", "docstring": "should return True"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_update_objects/test_selector_matches.py", "original_string": "def test_selector_matches_subset_of_obj():\n    # should return True\n    assert (\n        BaseFigure._selector_matches(\n            dict(hello=\"everybody\", today=\"cloudy\", myiq=55),\n            dict(myiq=55, today=\"cloudy\"),\n        )\n        == True\n    )\n", "docstring": "should return True"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_update_objects/test_selector_matches.py", "original_string": "def test_selector_has_nonmatching_value():\n    # should return False\n    assert (\n        BaseFigure._selector_matches(\n            dict(hello=\"everybody\", today=\"cloudy\", myiq=55),\n            dict(myiq=55, today=\"sunny\"),\n        )\n        == False\n    )\n", "docstring": "should return False"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_update_objects/test_selector_matches.py", "original_string": "def test_baseplotlytypes_could_not_match():\n    # should return False\n    obj = go.layout.Annotation(x=1, y=3, text=\"pat metheny\")\n    sel = go.layout.Annotation(x=1, y=2, text=\"pat metheny\")\n    assert BaseFigure._selector_matches(obj, sel) == False\n", "docstring": "should return False"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_update_objects/test_selector_matches.py", "original_string": "def test_function_selector_could_match():\n    # should return True\n    obj = go.layout.Annotation(x=1, y=2, text=\"pat metheny\")\n    def _sel(d):\n        return d[\"x\"] == 1 and d[\"y\"] == 2 and d[\"text\"] == \"pat metheny\"\n    assert BaseFigure._selector_matches(obj, _sel) == True\n", "docstring": "should return True"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_core/test_update_objects/test_update_layout.py", "original_string": "    def test_update_layout_dict(self):\n        # Create initial figure\n        fig = go.Figure()\n        fig.layout.title.font.size = 10\n        # Grab copy of original figure\n        orig_fig = go.Figure(fig)\n        fig.update_layout(dict(title=dict(font=dict(family=\"Courier New\"))))\n        orig_fig.layout.update(title_font_family=\"Courier New\")\n        self.assertEqual(fig, orig_fig)\n", "docstring": "Create initial figure"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_io/test_renderers.py", "original_string": "def test_notebook_connected_show(fig1, name, connected):\n    # Set renderer\n    pio.renderers.default = name\n    # Show\n    with mock.patch(\"IPython.display.display_html\") as mock_display_html:\n        with mock.patch(\"IPython.display.display\") as mock_display:\n            pio.show(fig1)\n    # ### Check initialization ###\n    # Get display call arguments\n    mock_call_args_html = mock_display_html.call_args\n    mock_arg1_html = mock_call_args_html[0][0]\n    # Check init display contents\n    bundle_display_html = mock_arg1_html\n    if connected:\n        assert_html_renderer_connected(bundle_display_html)\n    else:\n        assert_offline(bundle_display_html)\n    # ### Check display call ###\n    # Get display call arguments\n    mock_call_args = mock_display.call_args\n    mock_arg1 = mock_call_args[0][0]\n    # Check for html bundle\n    assert list(mock_arg1) == [\"text/html\"]\n    # Check html display contents\n    bundle_html = mock_arg1[\"text/html\"]\n    assert_not_full_html(bundle_html)\n    assert_requirejs(bundle_html)\n    # check kwargs\n    mock_kwargs = mock_call_args[1]\n    assert mock_kwargs == {\"raw\": True}\n", "docstring": "Set renderer"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_io/test_to_from_json.py", "original_string": "def test_read_json_from_filelike(fig1, fig_type_spec, fig_type):\n    # Configure file-like mock\n    filemock = MagicMock()\n    del filemock.read_text\n    filemock.read.return_value = pio.to_json(fig1)\n    # read_json on mock file\n    fig1_loaded = pio.read_json(filemock, output_type=fig_type_spec)\n    # Check return type\n    assert isinstance(fig1_loaded, fig_type)\n    # Check loaded figure\n    assert pio.to_json(fig1_loaded) == pio.to_json(fig1.to_dict())\n", "docstring": "Configure file-like mock"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_io/test_to_from_json.py", "original_string": "def test_read_json_from_pathlib(fig1, fig_type_spec, fig_type):\n    # Configure pathlib.Path-like mock\n    filemock = MagicMock(spec=Path)\n    filemock.read_text.return_value = pio.to_json(fig1)\n    # read_json on mock file\n    fig1_loaded = pio.read_json(filemock, output_type=fig_type_spec)\n    # Check return type\n    assert isinstance(fig1_loaded, fig_type)\n    # Check loaded figure\n    assert pio.to_json(fig1_loaded) == pio.to_json(fig1.to_dict())\n", "docstring": "Configure pathlib.Path-like mock"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_io/test_to_from_json.py", "original_string": "def test_write_json_filelike(fig1, pretty, remove_uids):\n    # Configure file-like mock\n    filemock = MagicMock()\n    del filemock.write_text\n    # write_json to mock file\n    pio.write_json(fig1, filemock, pretty=pretty, remove_uids=remove_uids)\n    # check write contents\n    expected = pio.to_json(fig1, pretty=pretty, remove_uids=remove_uids)\n    filemock.write.assert_called_once_with(expected)\n", "docstring": "Configure file-like mock"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_io/test_to_from_json.py", "original_string": "def test_write_json_pathlib(fig1, pretty, remove_uids):\n    # Configure file-like mock\n    filemock = MagicMock(spec=Path)\n    # write_json to mock file\n    pio.write_json(fig1, filemock, pretty=pretty, remove_uids=remove_uids)\n    # check write contents\n    expected = pio.to_json(fig1, pretty=pretty, remove_uids=remove_uids)\n    filemock.write_text.assert_called_once_with(expected)\n", "docstring": "Configure file-like mock"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/tests/test_io/test_pathlib.py", "original_string": "def test_write_html():\n    \"\"\"Verify that various methods for producing HTML have equivalent results.\n    The results will not be identical because the div id is pseudorandom. Thus\n    we compare the results after replacing the div id.\n    We test the results of\n    - pio.to_html\n    - pio.write_html with a StringIO buffer\n    - pio.write_html with a mock pathlib Path\n    - pio.write_html with a mock file descriptor\n    \"\"\"\n    # Test pio.to_html\n    html = pio.to_html(fig)\n    # Test pio.write_html with a StringIO buffer\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)  # Rewind to the beginning of the buffer, otherwise read() returns ''.\n    sio_html = sio.read()\n    assert replace_div_id(html) == replace_div_id(sio_html)\n    # Test pio.write_html with a mock pathlib Path\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    (pl_html,) = mock_pathlib_path.write_text.call_args[0]\n    assert replace_div_id(html) == replace_div_id(pl_html)\n    # Test pio.write_html with a mock file descriptor\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    (fd_html,) = mock_file_descriptor.write.call_args[0]\n    assert replace_div_id(html) == replace_div_id(fd_html)\n", "docstring": "Verify that various methods for producing HTML have equivalent results."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mpltools.py", "original_string": "def check_bar_match(old_bar, new_bar):\n    \"\"\"Check if two bars belong in the same collection (bar chart).\n    Positional arguments:\n    old_bar -- a previously sorted bar dictionary.\n    new_bar -- a new bar dictionary that needs to be sorted.\n    \"\"\"\n    tests = []\n    tests += (new_bar[\"orientation\"] == old_bar[\"orientation\"],)\n    tests += (new_bar[\"facecolor\"] == old_bar[\"facecolor\"],)\n    if new_bar[\"orientation\"] == \"v\":\n        new_width = new_bar[\"x1\"] - new_bar[\"x0\"]\n        old_width = old_bar[\"x1\"] - old_bar[\"x0\"]\n        tests += (new_width - old_width < 0.000001,)\n        tests += (new_bar[\"y0\"] == old_bar[\"y0\"],)\n    elif new_bar[\"orientation\"] == \"h\":\n        new_height = new_bar[\"y1\"] - new_bar[\"y0\"]\n        old_height = old_bar[\"y1\"] - old_bar[\"y0\"]\n        tests += (new_height - old_height < 0.000001,)\n        tests += (new_bar[\"x0\"] == old_bar[\"x0\"],)\n    if all(tests):\n        return True\n    else:\n        return False\n", "docstring": "Check if two bars belong in the same collection (bar chart)."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mpltools.py", "original_string": "def convert_dash(mpl_dash):\n    \"\"\"Convert mpl line symbol to plotly line symbol and return symbol.\"\"\"\n    if mpl_dash in DASH_MAP:\n        return DASH_MAP[mpl_dash]\n    else:\n        dash_array = mpl_dash.split(\",\")\n        if len(dash_array) < 2:\n            return \"solid\"\n        # Catch the exception where the off length is zero, in case\n        # matplotlib 'solid' changes from '10,0' to 'N,0'\n        if math.isclose(float(dash_array[1]), 0.0):\n            return \"solid\"\n        # If we can't find the dash pattern in the map, convert it\n        # into custom values in px, e.g. '7,5' -> '7px,5px'\n        dashpx = \",\".join([x + \"px\" for x in dash_array])\n        # TODO: rewrite the convert_dash code\n        # only strings 'solid', 'dashed', etc allowed\n        if dashpx == \"7.4px,3.2px\":\n            dashpx = \"dashed\"\n        elif dashpx == \"12.8px,3.2px,2.0px,3.2px\":\n            dashpx = \"dashdot\"\n        elif dashpx == \"2.0px,3.3px\":\n            dashpx = \"dotted\"\n        return dashpx\n", "docstring": "Convert mpl line symbol to plotly line symbol and return symbol.\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mpltools.py", "original_string": "def convert_symbol(mpl_symbol):\n    \"\"\"Convert mpl marker symbol to plotly symbol and return symbol.\"\"\"\n    if isinstance(mpl_symbol, list):\n        symbol = list()\n        for s in mpl_symbol:\n            symbol += [convert_symbol(s)]\n        return symbol\n    elif mpl_symbol in SYMBOL_MAP:\n        return SYMBOL_MAP[mpl_symbol]\n    else:\n        return \"circle\"  # default\n", "docstring": "Convert mpl marker symbol to plotly symbol and return symbol.\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mpltools.py", "original_string": "def convert_x_domain(mpl_plot_bounds, mpl_max_x_bounds):\n    \"\"\"Map x dimension of current plot to plotly's domain space.\n    The bbox used to locate an axes object in mpl differs from the\n    method used to locate axes in plotly. The mpl version locates each\n    axes in the figure so that axes in a single-plot figure might have\n    the bounds, [0.125, 0.125, 0.775, 0.775] (x0, y0, width, height),\n    in mpl's figure coordinates. However, the axes all share one space in\n    plotly such that the domain will always be [0, 0, 1, 1]\n    (x0, y0, x1, y1). To convert between the two, the mpl figure bounds\n    need to be mapped to a [0, 1] domain for x and y. The margins set\n    upon opening a new figure will appropriately match the mpl margins.\n    Optionally, setting margins=0 and simply copying the domains from\n    mpl to plotly would place axes appropriately. However,\n    this would throw off axis and title labeling.\n    Positional arguments:\n    mpl_plot_bounds -- the (x0, y0, width, height) params for current ax **\n    mpl_max_x_bounds -- overall (x0, x1) bounds for all axes **\n    ** these are all specified in mpl figure coordinates\n    \"\"\"\n    mpl_x_dom = [mpl_plot_bounds[0], mpl_plot_bounds[0] + mpl_plot_bounds[2]]\n    plotting_width = mpl_max_x_bounds[1] - mpl_max_x_bounds[0]\n    x0 = (mpl_x_dom[0] - mpl_max_x_bounds[0]) / plotting_width\n    x1 = (mpl_x_dom[1] - mpl_max_x_bounds[0]) / plotting_width\n    return [x0, x1]\n", "docstring": "Map x dimension of current plot to plotly's domain space."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mpltools.py", "original_string": "def display_to_paper(x, y, layout):\n    \"\"\"Convert mpl display coordinates to plotly paper coordinates.\n    Plotly references object positions with an (x, y) coordinate pair in either\n    'data' or 'paper' coordinates which reference actual data in a plot or\n    the entire plotly axes space where the bottom-left of the bottom-left\n    plot has the location (x, y) = (0, 0) and the top-right of the top-right\n    plot has the location (x, y) = (1, 1). Display coordinates in mpl reference\n    objects with an (x, y) pair in pixel coordinates, where the bottom-left\n    corner is at the location (x, y) = (0, 0) and the top-right corner is at\n    the location (x, y) = (figwidth*dpi, figheight*dpi). Here, figwidth and\n    figheight are in inches and dpi are the dots per inch resolution.\n    \"\"\"\n    num_x = x - layout[\"margin\"][\"l\"]\n    den_x = layout[\"width\"] - (layout[\"margin\"][\"l\"] + layout[\"margin\"][\"r\"])\n    num_y = y - layout[\"margin\"][\"b\"]\n    den_y = layout[\"height\"] - (layout[\"margin\"][\"b\"] + layout[\"margin\"][\"t\"])\n    return num_x / den_x, num_y / den_y\n", "docstring": "Convert mpl display coordinates to plotly paper coordinates."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mpltools.py", "original_string": "def get_axis_mirror(main_spine, mirror_spine):\n    if main_spine and mirror_spine:\n        return \"ticks\"\n    elif main_spine and not mirror_spine:\n        return False\n    elif not main_spine and mirror_spine:\n        return False  # can't handle this case yet!\n    else:\n        return False  # nuttin'!\n", "docstring": "if main_spine and mirror_spine:"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mpltools.py", "original_string": "def get_rect_xmax(data):\n    \"\"\"Find maximum x value from four (x,y) vertices.\"\"\"\n    return max(data[0][0], data[1][0], data[2][0], data[3][0])\n", "docstring": "Find maximum x value from four (x,y) vertices.\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mpltools.py", "original_string": "def get_rect_ymax(data):\n    \"\"\"Find maximum y value from four (x,y) vertices.\"\"\"\n    return max(data[0][1], data[1][1], data[2][1], data[3][1])\n", "docstring": "Find maximum y value from four (x,y) vertices.\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mpltools.py", "original_string": "def is_bar(bar_containers, **props):\n    \"\"\"A test to decide whether a path is a bar from a vertical bar chart.\"\"\"\n    # is this patch in a bar container?\n    for container in bar_containers:\n        if props[\"mplobj\"] in container:\n            return True\n    return False\n", "docstring": "A test to decide whether a path is a bar from a vertical bar chart.\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mpltools.py", "original_string": "def mpl_dates_to_datestrings(dates, mpl_formatter):\n    \"\"\"Convert matplotlib dates to iso-formatted-like time strings.\n    Plotly's accepted format: \"YYYY-MM-DD HH:MM:SS\" (e.g., 2001-01-01 00:00:00)\n    Info on mpl dates: http://matplotlib.org/api/dates_api.html\n    \"\"\"\n    _dates = dates\n    # this is a pandas datetime formatter, times show up in floating point days\n    # since the epoch (1970-01-01T00:00:00+00:00)\n    if mpl_formatter == \"TimeSeries_DateFormatter\":\n        try:\n            dates = matplotlib.dates.epoch2num([date * 24 * 60 * 60 for date in dates])\n            dates = matplotlib.dates.num2date(dates)\n        except:\n            return _dates\n    # the rest of mpl dates are in floating point days since\n    # (0001-01-01T00:00:00+00:00) + 1. I.e., (0001-01-01T00:00:00+00:00) == 1.0\n    # according to mpl --> try num2date(1)\n    else:\n        try:\n            dates = matplotlib.dates.num2date(dates)\n        except:\n            return _dates\n    time_stings = [\n        \" \".join(date.isoformat().split(\"+\")[0].split(\"T\")) for date in dates\n    ]\n    return time_stings\n", "docstring": "Convert matplotlib dates to iso-formatted-like time strings."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/renderer.py", "original_string": "    def __init__(self):\n        \"\"\"Initialize PlotlyRenderer obj.\n        PlotlyRenderer obj is called on by an Exporter object to draw\n        matplotlib objects like figures, axes, text, etc.\n        All class attributes are listed here in the __init__ method.\n        \"\"\"\n        self.plotly_fig = go.Figure()\n        self.mpl_fig = None\n        self.current_mpl_ax = None\n        self.bar_containers = None\n        self.current_bars = []\n        self.axis_ct = 0\n        self.x_is_mpl_date = False\n        self.mpl_x_bounds = (0, 1)\n        self.mpl_y_bounds = (0, 1)\n        self.msg = \"Initialized PlotlyRenderer\\n\"\n", "docstring": "Initialize PlotlyRenderer obj."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/renderer.py", "original_string": "    def close_figure(self, fig):\n        \"\"\"Closes figure by cleaning up data and layout dictionaries.\n        The PlotlyRenderer's job is to create an appropriate set of data and\n        layout dictionaries. When the figure is closed, some cleanup and\n        repair is necessary. This method removes inappropriate dictionary\n        entries, freeing up Plotly to use defaults and best judgements to\n        complete the entries. This method is called by an Exporter object.\n        Positional arguments:\n        fig -- a matplotlib.figure.Figure object.\n        \"\"\"\n        self.plotly_fig[\"layout\"][\"showlegend\"] = False\n        self.msg += \"Closing figure\\n\"\n", "docstring": "Closes figure by cleaning up data and layout dictionaries."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/renderer.py", "original_string": "    def close_axes(self, ax):\n        \"\"\"Close the axes object and clean up.\n        Bars from bar charts are given to PlotlyRenderer one-by-one,\n        thus they need to be taken care of at the close of each axes object.\n        The self.current_bars variable should be empty unless a bar\n        chart has been created.\n        Positional arguments:\n        ax -- an mpl axes object, not required at this time.\n        \"\"\"\n        self.draw_bars(self.current_bars)\n        self.msg += \"  Closing axes\\n\"\n        self.x_is_mpl_date = False\n", "docstring": "Close the axes object and clean up."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/renderer.py", "original_string": "    def draw_path_collection(self, **props):\n        \"\"\"Add a path collection to data list as a scatter plot.\n        Current implementation defaults such collections as scatter plots.\n        Matplotlib supports collections that have many of the same parameters\n        in common like color, size, path, etc. However, they needn't all be\n        the same. Plotly does not currently support such functionality and\n        therefore, the style for the first object is taken and used to define\n        the remaining paths in the collection.\n        props.keys() -- [\n        'paths',                (structure: [vertices, path_code])\n        'path_coordinates',     ('data', 'axes', 'figure', or 'display')\n        'path_transforms',      (mpl transform, including Affine2D matrix)\n        'offsets',              (offset from axes, helpful if in 'data')\n        'offset_coordinates',   ('data', 'axes', 'figure', or 'display')\n        'offset_order',\n        'styles',               (style dict, see below)\n        'mplobj'                (the collection obj being drawn)\n        ]\n        props['styles'].keys() -- [\n        'linewidth',            (one or more linewidths)\n        'facecolor',            (one or more facecolors for path)\n        'edgecolor',            (one or more edgecolors for path)\n        'alpha',                (one or more opacites for path)\n        'zorder',               (precedence when stacked)\n        ]\n        \"\"\"\n        self.msg += \"    Attempting to draw a path collection\\n\"\n        if props[\"offset_coordinates\"] == \"data\":\n            markerstyle = mpltools.get_markerstyle_from_collection(props)\n            scatter_props = {\n                \"coordinates\": \"data\",\n                \"data\": props[\"offsets\"],\n                \"label\": None,\n                \"markerstyle\": markerstyle,\n                \"linestyle\": None,\n            }\n            self.msg += \"    Drawing path collection as markers\\n\"\n            self.draw_marked_line(**scatter_props)\n        else:\n            self.msg += \"    Path collection not linked to 'data', \" \"not drawing\\n\"\n            warnings.warn(\n                \"Dang! That path collection is out of this \"\n                \"world. I totally don't know what to do with \"\n                \"it yet! Plotly can only import path \"\n                \"collections linked to 'data' coordinates\"\n            )\n", "docstring": "Add a path collection to data list as a scatter plot."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/renderer.py", "original_string": "    def draw_xlabel(self, **props):\n        \"\"\"Add an xaxis label to the current subplot in layout dictionary.\n        props.keys() -- [\n        'text',         (actual content string, not the text obj)\n        'position',     (an x, y pair, not an mpl Bbox)\n        'coordinates',  ('data', 'axes', 'figure', 'display')\n        'text_type',    ('title', 'xlabel', or 'ylabel')\n        'style',        (style dict, see below)\n        'mplobj'        (actual mpl text object)\n        ]\n        props['style'].keys() -- [\n        'alpha',        (opacity of text)\n        'fontsize',     (size in points of text)\n        'color',        (hex color)\n        'halign',       (horizontal alignment, 'left', 'center', or 'right')\n        'valign',       (vertical alignment, 'baseline', 'center', or 'top')\n        'rotation',\n        'zorder',       (precedence of text when stacked with other objs)\n        ]\n        \"\"\"\n        self.msg += \"        Adding xlabel\\n\"\n        axis_key = \"xaxis{0}\".format(self.axis_ct)\n        self.plotly_fig[\"layout\"][axis_key][\"title\"] = str(props[\"text\"])\n        titlefont = dict(size=props[\"style\"][\"fontsize\"], color=props[\"style\"][\"color\"])\n        self.plotly_fig[\"layout\"][axis_key][\"titlefont\"] = titlefont\n", "docstring": "Add an xaxis label to the current subplot in layout dictionary."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/renderer.py", "original_string": "    def resize(self):\n        \"\"\"Revert figure layout to allow plotly to resize.\n        By default, PlotlyRenderer tries its hardest to precisely mimic an\n        mpl figure. However, plotly is pretty good with aesthetics. By\n        running PlotlyRenderer.resize(), layout parameters are deleted. This\n        lets plotly choose them instead of mpl.\n        \"\"\"\n        self.msg += \"Resizing figure, deleting keys from layout\\n\"\n        for key in [\"width\", \"height\", \"autosize\", \"margin\"]:\n            try:\n                del self.plotly_fig[\"layout\"][key]\n            except (KeyError, AttributeError):\n                pass\n", "docstring": "Revert figure layout to allow plotly to resize."}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mplexporter/utils.py", "original_string": "def export_color(color):\n    \"\"\"Convert matplotlib color code to hex color or RGBA color\"\"\"\n    if color is None or colorConverter.to_rgba(color)[3] == 0:\n        return \"none\"\n    elif colorConverter.to_rgba(color)[3] == 1:\n        rgb = colorConverter.to_rgb(color)\n        return \"#{0:02X}{1:02X}{2:02X}\".format(*(int(255 * c) for c in rgb))\n    else:\n        c = colorConverter.to_rgba(color)\n        return (\n            \"rgba(\"\n            + \", \".join(str(int(np.round(val * 255))) for val in c[:3])\n            + \", \"\n            + str(c[3])\n            + \")\"\n        )\n", "docstring": "Convert matplotlib color code to hex color or RGBA color\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mplexporter/utils.py", "original_string": "def get_dasharray(obj):\n    \"\"\"Get an SVG dash array for the given matplotlib linestyle\n    Parameters\n    ----------\n    obj : matplotlib object\n        The matplotlib line or path object, which must have a get_linestyle()\n        method which returns a valid matplotlib line code\n    Returns\n    -------\n    dasharray : string\n        The HTML/SVG dasharray code associated with the object.\n    \"\"\"\n    if obj.__dict__.get(\"_dashSeq\", None) is not None:\n        return \",\".join(map(str, obj._dashSeq))\n    else:\n        ls = obj.get_linestyle()\n        dasharray = LINESTYLES.get(ls, \"not found\")\n        if dasharray == \"not found\":\n            warnings.warn(\n                \"line style '{0}' not understood: \"\n                \"defaulting to solid line.\".format(ls)\n            )\n            dasharray = LINESTYLES[\"solid\"]\n        return dasharray\n", "docstring": "Get an SVG dash array for the given matplotlib linestyle"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mplexporter/utils.py", "original_string": "def SVG_path(path, transform=None, simplify=False):\n    \"\"\"Construct the vertices and SVG codes for the path\n    Parameters\n    ----------\n    path : matplotlib.Path object\n    transform : matplotlib transform (optional)\n        if specified, the path will be transformed before computing the output.\n    Returns\n    -------\n    vertices : array\n        The shape (M, 2) array of vertices of the Path. Note that some Path\n        codes require multiple vertices, so the length of these vertices may\n        be longer than the list of path codes.\n    path_codes : list\n        A length N list of single-character path codes, N <= M. Each code is\n        a single character, in ['L','M','S','C','Z']. See the standard SVG\n        path specification for a description of these.\n    \"\"\"\n    if transform is not None:\n        path = path.transformed(transform)\n    vc_tuples = [\n        (vertices if path_code != Path.CLOSEPOLY else [], PATH_DICT[path_code])\n        for (vertices, path_code) in path.iter_segments(simplify=simplify)\n    ]\n    if not vc_tuples:\n        # empty path is a special case\n        return np.zeros((0, 2)), []\n    else:\n        vertices, codes = zip(*vc_tuples)\n        vertices = np.array(list(itertools.chain(*vertices))).reshape(-1, 2)\n        return vertices, list(codes)\n", "docstring": "Construct the vertices and SVG codes for the path"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mplexporter/utils.py", "original_string": "def get_line_style(line):\n    \"\"\"Get the style dictionary for matplotlib line objects\"\"\"\n    style = {}\n    style[\"alpha\"] = line.get_alpha()\n    if style[\"alpha\"] is None:\n        style[\"alpha\"] = 1\n    style[\"color\"] = export_color(line.get_color())\n    style[\"linewidth\"] = line.get_linewidth()\n    style[\"dasharray\"] = get_dasharray(line)\n    style[\"zorder\"] = line.get_zorder()\n    style[\"drawstyle\"] = line.get_drawstyle()\n    return style\n", "docstring": "Get the style dictionary for matplotlib line objects\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mplexporter/utils.py", "original_string": "def get_text_style(text):\n    \"\"\"Return the text style dict for a text instance\"\"\"\n    style = {}\n    style[\"alpha\"] = text.get_alpha()\n    if style[\"alpha\"] is None:\n        style[\"alpha\"] = 1\n    style[\"fontsize\"] = text.get_size()\n    style[\"color\"] = export_color(text.get_color())\n    style[\"halign\"] = text.get_horizontalalignment()  # left, center, right\n    style[\"valign\"] = text.get_verticalalignment()  # baseline, center, top\n    style[\"malign\"] = text._multialignment  # text alignment when '\\n' in text\n    style[\"rotation\"] = text.get_rotation()\n    style[\"zorder\"] = text.get_zorder()\n    return style\n", "docstring": "Return the text style dict for a text instance\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mplexporter/exporter.py", "original_string": "    def crawl_fig(self, fig):\n        \"\"\"Crawl the figure and process all axes\"\"\"\n        with self.renderer.draw_figure(fig=fig, props=utils.get_figure_properties(fig)):\n            for ax in fig.axes:\n                self.crawl_ax(ax)\n", "docstring": "Crawl the figure and process all axes\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mplexporter/exporter.py", "original_string": "    def draw_text(self, ax, text, force_trans=None, text_type=None):\n        \"\"\"Process a matplotlib text object and call renderer.draw_text\"\"\"\n        content = text.get_text()\n        if content:\n            transform = text.get_transform()\n            position = text.get_position()\n            coords, position = self.process_transform(\n                transform, ax, position, force_trans=force_trans\n            )\n            style = utils.get_text_style(text)\n            self.renderer.draw_text(\n                text=content,\n                position=position,\n                coordinates=coords,\n                text_type=text_type,\n                style=style,\n                mplobj=text,\n            )\n", "docstring": "Process a matplotlib text object and call renderer.draw_text\n"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mplexporter/exporter.py", "original_string": "    def draw_collection(\n        self, ax, collection, force_pathtrans=None, force_offsettrans=None\n", "docstring": "self, ax, collection, force_pathtrans=None, force_offsettrans=None"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mplexporter/renderers/base.py", "original_string": "    def draw_marked_line(\n        self, data, coordinates, linestyle, markerstyle, label, mplobj=None\n", "docstring": "self, data, coordinates, linestyle, markerstyle, label, mplobj=None"}
{"repo": "plotly.py-master/packages/python/plotly/plotly/matplotlylib/mplexporter/renderers/base.py", "original_string": "    def _iter_path_collection(paths, path_transforms, offsets, styles):\n        \"\"\"Build an iterator over the elements of the path collection\"\"\"\n        N = max(len(paths), len(offsets))\n        # Before mpl 1.4.0, path_transform can be a false-y value, not a valid\n        # transformation matrix.\n        if LooseVersion(mpl.__version__) < LooseVersion(\"1.4.0\"):\n            if path_transforms is None:\n                path_transforms = [np.eye(3)]\n        edgecolor = styles[\"edgecolor\"]\n        if np.size(edgecolor) == 0:\n            edgecolor = [\"none\"]\n        facecolor = styles[\"facecolor\"]\n        if np.size(facecolor) == 0:\n            facecolor = [\"none\"]\n        elements = [\n            paths,\n            path_transforms,\n            offsets,\n            edgecolor,\n            styles[\"linewidth\"],\n            facecolor,\n        ]\n        it = itertools\n        return it.islice(py3k.zip(*py3k.map(it.cycle, elements)), N)\n", "docstring": "Build an iterator over the elements of the path collection\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/basevalidators.py", "original_string": "def fullmatch(regex, string, flags=0):\n    \"\"\"Emulate python-3.4 re.fullmatch().\"\"\"\n    if \"pattern\" in dir(regex):\n        regex_string = regex.pattern\n    else:\n        regex_string = regex\n    return re.match(\"(?:\" + regex_string + r\")\\Z\", string, flags=flags)\n", "docstring": "Emulate python-3.4 re.fullmatch().\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/basevalidators.py", "original_string": "def to_scalar_or_list(v):\n    # Handle the case where 'v' is a non-native scalar-like type,\n    # such as numpy.float32. Without this case, the object might be\n    # considered numpy-convertable and therefore promoted to a\n    # 0-dimensional array, but we instead want it converted to a\n    # Python native scalar type ('float' in the example above).\n    # We explicitly check if is has the 'item' method, which conventionally\n    # converts these types to native scalars.\n    np = get_module(\"numpy\", should_load=False)\n    pd = get_module(\"pandas\", should_load=False)\n    if np and np.isscalar(v) and hasattr(v, \"item\"):\n        return v.item()\n    if isinstance(v, (list, tuple)):\n        return [to_scalar_or_list(e) for e in v]\n    elif np and isinstance(v, np.ndarray):\n        if v.ndim == 0:\n            return v.item()\n        return [to_scalar_or_list(e) for e in v]\n    elif pd and isinstance(v, (pd.Series, pd.Index)):\n        return [to_scalar_or_list(e) for e in v]\n    elif is_numpy_convertable(v):\n        return to_scalar_or_list(np.array(v))\n    else:\n        return v\n", "docstring": "Handle the case where 'v' is a non-native scalar-like type,"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/basevalidators.py", "original_string": "    def raise_invalid_elements(self, invalid_els):\n        if invalid_els:\n            raise ValueError(\n                \"\"\"\n", "docstring": "if invalid_els:"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/basevalidators.py", "original_string": "    def __init__(self, plotly_name, parent_name, **kwargs):\n        super(DataArrayValidator, self).__init__(\n            plotly_name=plotly_name, parent_name=parent_name, **kwargs\n        )\n        self.array_ok = True\n", "docstring": "super(DataArrayValidator, self).__init__("}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/basevalidators.py", "original_string": "    def build_regex_replacement(regex_str):\n        # Example: regex_str == r\"^y([2-9]|[1-9][0-9]+)?$\"\n        #\n        # When we see a regular expression like the one above, we want to\n        # build regular expression replacement params that will remove a\n        # suffix of 1 from the input string ('y1' -> 'y' in this example)\n        #\n        # Why?: Regular expressions like this one are used in enumeration\n        # properties that refer to subplotids (e.g. layout.annotation.xref)\n        # The regular expressions forbid suffixes of 1, like 'x1'. But we\n        # want to accept 'x1' and coerce it into 'x'\n        #\n        # To be cautious, we only perform this conversion for enumerated\n        # values that match the anchor-style regex\n        match = re.match(\n            r\"\\^(\\w)\\(\\[2\\-9\\]\\|\\[1\\-9\\]\\[0\\-9\\]\\+\\)\\?\\( domain\\)\\?\\$\", regex_str\n        )\n        if match:\n            anchor_char = match.group(1)\n            return \"^\" + anchor_char + \"1$\", anchor_char\n        else:\n            return None\n", "docstring": "Example: regex_str == r\"^y([2-9]|[1-9][0-9]+)?$\""}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/basevalidators.py", "original_string": "    def description(self):\n        # Separate regular values from regular expressions\n        enum_vals = []\n        enum_regexs = []\n        for v, regex in zip(self.values, self.val_regexs):\n            if regex is not None:\n                enum_regexs.append(regex.pattern)\n            else:\n                enum_vals.append(v)\n        desc = \"\"\"\\\n", "docstring": "Separate regular values from regular expressions"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/basevalidators.py", "original_string": "    def __init__(self, plotly_name, parent_name, **kwargs):\n        super(BooleanValidator, self).__init__(\n            plotly_name=plotly_name, parent_name=parent_name, **kwargs\n        )\n", "docstring": "super(BooleanValidator, self).__init__("}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/basevalidators.py", "original_string": "    def validate_coerce(self, v):\n        if v is None:\n            # Pass None through\n            pass\n        elif self.array_ok and is_array(v):\n            # If strict, make sure all elements are strings.\n            if self.strict:\n                invalid_els = [e for e in v if not isinstance(e, string_types)]\n                if invalid_els:\n                    self.raise_invalid_elements(invalid_els)\n            if is_homogeneous_array(v):\n                np = get_module(\"numpy\")\n                # If not strict, let numpy cast elements to strings\n                v = copy_to_readonly_numpy_array(v, kind=\"U\")\n                # Check no_blank\n                if self.no_blank:\n                    invalid_els = v[v == \"\"][:10].tolist()\n                    if invalid_els:\n                        self.raise_invalid_elements(invalid_els)\n                # Check values\n                if self.values:\n                    invalid_inds = np.logical_not(np.isin(v, self.values))\n                    invalid_els = v[invalid_inds][:10].tolist()\n                    if invalid_els:\n                        self.raise_invalid_elements(invalid_els)\n            elif is_simple_array(v):\n                if not self.strict:\n                    v = [StringValidator.to_str_or_unicode_or_none(e) for e in v]\n                # Check no_blank\n                if self.no_blank:\n                    invalid_els = [e for e in v if e == \"\"]\n                    if invalid_els:\n                        self.raise_invalid_elements(invalid_els)\n                # Check values\n                if self.values:\n                    invalid_els = [e for e in v if v not in self.values]\n                    if invalid_els:\n                        self.raise_invalid_elements(invalid_els)\n                v = to_scalar_or_list(v)\n        else:\n            if self.strict:\n                if not isinstance(v, string_types):\n                    self.raise_invalid_val(v)\n            else:\n                if isinstance(v, string_types):\n                    pass\n                elif isinstance(v, (int, float)):\n                    # Convert value to a string\n                    v = str(v)\n                else:\n                    self.raise_invalid_val(v)\n            if self.no_blank and len(v) == 0:\n                self.raise_invalid_val(v)\n            if self.values and v not in self.values:\n                self.raise_invalid_val(v)\n        return v\n", "docstring": "Pass None through"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/basevalidators.py", "original_string": "    def vc_scalar(self, v):\n        \"\"\" Helper to validate/coerce a scalar color \"\"\"\n        return ColorValidator.perform_validate_coerce(\n            v, allow_number=self.numbers_allowed()\n        )\n", "docstring": "Helper to validate/coerce a scalar color \n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/basevalidators.py", "original_string": "    def __init__(self, plotly_name, parent_name, **kwargs):\n        super(ColorlistValidator, self).__init__(\n            plotly_name=plotly_name, parent_name=parent_name, **kwargs\n        )\n", "docstring": "super(ColorlistValidator, self).__init__("}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/basevalidators.py", "original_string": "    def __init__(self, plotly_name, parent_name, values, **kwargs):\n        # Add regex to handle dash length lists\n        dash_list_regex = r\"/^\\d+(\\.\\d+)?(px|%)?((,|\\s)\\s*\\d+(\\.\\d+)?(px|%)?)*$/\"\n        values = values + [dash_list_regex]\n        # Call EnumeratedValidator superclass\n        super(DashValidator, self).__init__(\n            plotly_name=plotly_name, parent_name=parent_name, values=values, **kwargs\n        )\n", "docstring": "Add regex to handle dash length lists"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/basevalidators.py", "original_string": "    def present(self, v):\n        # Return compound object as tuple\n        return tuple(v)\n", "docstring": "Return compound object as tuple"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/basevalidators.py", "original_string": "    def get_trace_class(self, trace_name):\n        # Import trace classes\n        if trace_name not in self._class_map:\n            trace_module = import_module(\"plotly.graph_objs\")\n            trace_class_name = self.class_strs_map[trace_name]\n            self._class_map[trace_name] = getattr(trace_module, trace_class_name)\n        return self._class_map[trace_name]\n", "docstring": "Import trace classes"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/utils.py", "original_string": "    def encode_as_plotly(obj):\n        \"\"\"Attempt to use a builtin `to_plotly_json` method.\"\"\"\n        try:\n            return obj.to_plotly_json()\n        except AttributeError:\n            raise NotEncodable\n", "docstring": "Attempt to use a builtin `to_plotly_json` method.\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/utils.py", "original_string": "    def encode_as_list(obj):\n        \"\"\"Attempt to use `tolist` method to convert to normal Python list.\"\"\"\n        if hasattr(obj, \"tolist\"):\n            return obj.tolist()\n        else:\n            raise NotEncodable\n", "docstring": "Attempt to use `tolist` method to convert to normal Python list.\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/utils.py", "original_string": "    def encode_as_sage(obj):\n        \"\"\"Attempt to convert sage.all.RR to floats and sage.all.ZZ to ints\"\"\"\n        sage_all = get_module(\"sage.all\")\n        if not sage_all:\n            raise NotEncodable\n        if obj in sage_all.RR:\n            return float(obj)\n        elif obj in sage_all.ZZ:\n            return int(obj)\n        else:\n            raise NotEncodable\n", "docstring": "Attempt to convert sage.all.RR to floats and sage.all.ZZ to ints\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/utils.py", "original_string": "    def encode_as_pandas(obj):\n        \"\"\"Attempt to convert pandas.NaT\"\"\"\n        pandas = get_module(\"pandas\", should_load=False)\n        if not pandas:\n            raise NotEncodable\n        if obj is pandas.NaT:\n            return None\n        else:\n            raise NotEncodable\n", "docstring": "Attempt to convert pandas.NaT\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/utils.py", "original_string": "    def encode_as_numpy(obj):\n        \"\"\"Attempt to convert numpy.ma.core.masked\"\"\"\n        numpy = get_module(\"numpy\", should_load=False)\n        if not numpy:\n            raise NotEncodable\n        if obj is numpy.ma.core.masked:\n            return float(\"nan\")\n        elif isinstance(obj, numpy.ndarray) and obj.dtype.kind == \"M\":\n            try:\n                return numpy.datetime_as_string(obj).tolist()\n            except TypeError:\n                pass\n        raise NotEncodable\n", "docstring": "Attempt to convert numpy.ma.core.masked\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/utils.py", "original_string": "    def encode_as_datetime(obj):\n        \"\"\"Convert datetime objects to iso-format strings\"\"\"\n        try:\n            return obj.isoformat()\n        except AttributeError:\n            raise NotEncodable\n", "docstring": "Convert datetime objects to iso-format strings\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/utils.py", "original_string": "    def encode_as_date(obj):\n        \"\"\"Attempt to convert to utc-iso time string using date methods.\"\"\"\n        try:\n            time_string = obj.isoformat()\n        except AttributeError:\n            raise NotEncodable\n        else:\n            return iso_to_plotly_time_string(time_string)\n", "docstring": "Attempt to convert to utc-iso time string using date methods.\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/utils.py", "original_string": "    def encode_as_decimal(obj):\n        \"\"\"Attempt to encode decimal by converting it to float\"\"\"\n        if isinstance(obj, decimal.Decimal):\n            return float(obj)\n        else:\n            raise NotEncodable\n", "docstring": "Attempt to encode decimal by converting it to float\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/utils.py", "original_string": "    def encode_as_pil(obj):\n        \"\"\"Attempt to convert PIL.Image.Image to base64 data uri\"\"\"\n        image = get_module(\"PIL.Image\")\n        if image is not None and isinstance(obj, image.Image):\n            return ImageUriValidator.pil_image_to_uri(obj)\n        else:\n            raise NotEncodable\n", "docstring": "Attempt to convert PIL.Image.Image to base64 data uri\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/utils.py", "original_string": "def iso_to_plotly_time_string(iso_string):\n    \"\"\"Remove timezone info and replace 'T' delimeter with ' ' (ws).\"\"\"\n    # make sure we don't send timezone info to plotly\n    if (iso_string.split(\"-\")[:3] == \"00:00\") or (iso_string.split(\"+\")[0] == \"00:00\"):\n        raise Exception(\n            \"Plotly won't accept timestrings with timezone info.\\n\"\n            \"All timestrings are assumed to be in UTC.\"\n        )\n    iso_string = iso_string.replace(\"-00:00\", \"\").replace(\"+00:00\", \"\")\n    if iso_string.endswith(\"T00:00:00\"):\n        return iso_string.replace(\"T00:00:00\", \"\")\n    else:\n        return iso_string.replace(\"T\", \" \")\n", "docstring": "Remove timezone info and replace 'T' delimeter with ' ' (ws).\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/utils.py", "original_string": "    def _decorator(func):\n        if not sys.version_info[:2] == (3, 2):\n            if func.__doc__ is not None:\n                func.__doc__ = func.__doc__.format(**names)\n        return func\n", "docstring": "if not sys.version_info[:2] == (3, 2):"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/utils.py", "original_string": "    def _rev(l):\n        return [s[::-1] for s in l][::-1]\n", "docstring": "return [s[::-1] for s in l][::-1]"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/utils.py", "original_string": "    def _key(s):\n        # sort by levenshtein distance and lexographically to maintain a stable\n        # sort for different keys with the same levenshtein distance\n        return (levenshtein(s, string), s)\n", "docstring": "sort by levenshtein distance and lexographically to maintain a stable"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "def group(s, n):\n    return list(zip(*[iter(s)] * n))\n", "docstring": "return list(zip(*[iter(s)] * n))"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "    def __str__(self):\n        return self.__class__.__name__ + \": \" + \" \".join(self.args)\n", "docstring": "return self.__class__.__name__ + \": \" + \" \".join(self.args)"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "def write_chunks(out, chunks):\n    \"\"\"Create a PNG file by writing out the chunks.\"\"\"\n    out.write(signature)\n    for chunk in chunks:\n        write_chunk(out, *chunk)\n", "docstring": "Create a PNG file by writing out the chunks.\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "def pack_rows(rows, bitdepth):\n    \"\"\"Yield packed rows that are a byte array.\n    Each byte is packed with the values from several pixels.\n    \"\"\"\n    assert bitdepth < 8\n    assert 8 % bitdepth == 0\n    # samples per byte\n    spb = int(8 / bitdepth)\n    def make_byte(block):\n        \"\"\"Take a block of (2, 4, or 8) values,\n        and pack them into a single byte.\n        \"\"\"\n        res = 0\n        for v in block:\n            res = (res << bitdepth) + v\n        return res\n    for row in rows:\n        a = bytearray(row)\n        # Adding padding bytes so we can group into a whole\n        # number of spb-tuples.\n        n = float(len(a))\n        extra = math.ceil(n / spb) * spb - n\n        a.extend([0] * int(extra))\n        # Pack into bytes.\n        # Each block is the samples for one byte.\n        blocks = group(a, spb)\n        yield bytearray(make_byte(block) for block in blocks)\n", "docstring": "Yield packed rows that are a byte array."}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "    def write(self, file):\n        \"\"\"Write the image to the open file object.\n        See `.save()` if you have a filename.\n        In general, you can only call this method once;\n        after it has been called the first time the PNG image is written,\n        the source data will have been streamed, and\n        cannot be streamed again.\n        \"\"\"\n        w = Writer(**self.info)\n        w.write(file, self.rows)\n", "docstring": "Write the image to the open file object."}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "    def chunks(self):\n        \"\"\"Return an iterator that will yield each chunk as a\n        (*chunktype*, *content*) pair.\n        \"\"\"\n        while True:\n            t, v = self.chunk()\n            yield t, v\n            if t == b\"IEND\":\n                break\n", "docstring": "Return an iterator that will yield each chunk as a"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "    def _bytes_to_values(self, bs, width=None):\n        \"\"\"Convert a packed row of bytes into a row of values.\n        Result will be a freshly allocated object,\n        not shared with the argument.\n        \"\"\"\n        if self.bitdepth == 8:\n            return bytearray(bs)\n        if self.bitdepth == 16:\n            return array(\"H\", struct.unpack(\"!%dH\" % (len(bs) // 2), bs))\n        assert self.bitdepth < 8\n        if width is None:\n            width = self.width\n        # Samples per byte\n        spb = 8 // self.bitdepth\n        out = bytearray()\n        mask = 2 ** self.bitdepth - 1\n        shifts = [self.bitdepth * i for i in reversed(list(range(spb)))]\n        for o in bs:\n            out.extend([mask & (o >> i) for i in shifts])\n        return out[:width]\n", "docstring": "Convert a packed row of bytes into a row of values."}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "    def _process_IHDR(self, data):\n        # http://www.w3.org/TR/PNG/#11IHDR\n        if len(data) != 13:\n            raise FormatError(\"IHDR chunk has incorrect length.\")\n        (\n            self.width,\n            self.height,\n            self.bitdepth,\n            self.color_type,\n            self.compression,\n            self.filter,\n            self.interlace,\n        ) = struct.unpack(\"!2I5B\", data)\n        check_bitdepth_colortype(self.bitdepth, self.color_type)\n        if self.compression != 0:\n            raise FormatError(\"Unknown compression method %d\" % self.compression)\n        if self.filter != 0:\n            raise FormatError(\n                \"Unknown filter method %d,\"\n                \" see http://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters .\"\n                % self.filter\n            )\n        if self.interlace not in (0, 1):\n            raise FormatError(\n                \"Unknown interlace method %d, see \"\n                \"http://www.w3.org/TR/2003/REC-PNG-20031110/#8InterlaceMethods\"\n                \" .\" % self.interlace\n            )\n        # Derived values\n        # http://www.w3.org/TR/PNG/#6Colour-values\n        colormap = bool(self.color_type & 1)\n        greyscale = not (self.color_type & 2)\n        alpha = bool(self.color_type & 4)\n        color_planes = (3, 1)[greyscale or colormap]\n        planes = color_planes + alpha\n        self.colormap = colormap\n        self.greyscale = greyscale\n        self.alpha = alpha\n        self.color_planes = color_planes\n        self.planes = planes\n        self.psize = float(self.bitdepth) / float(8) * planes\n        if int(self.psize) == self.psize:\n            self.psize = int(self.psize)\n        self.row_bytes = int(math.ceil(self.width * self.psize))\n        # Stores PLTE chunk if present, and is used to check\n        # chunk ordering constraints.\n        self.plte = None\n        # Stores tRNS chunk if present, and is used to check chunk\n        # ordering constraints.\n        self.trns = None\n        # Stores sBIT chunk if present.\n        self.sbit = None\n", "docstring": "http://www.w3.org/TR/PNG/#11IHDR"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "    def _process_pHYs(self, data):\n        # http://www.w3.org/TR/PNG/#11pHYs\n        self.phys = data\n        fmt = \"!LLB\"\n        if len(data) != struct.calcsize(fmt):\n            raise FormatError(\"pHYs chunk has incorrect length.\")\n        self.x_pixels_per_unit, self.y_pixels_per_unit, unit = struct.unpack(fmt, data)\n        self.unit_is_meter = bool(unit)\n", "docstring": "http://www.w3.org/TR/PNG/#11pHYs"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "        def iteridat():\n            \"\"\"Iterator that yields all the ``IDAT`` chunks as strings.\"\"\"\n            while True:\n                type, data = self.chunk(lenient=lenient)\n                if type == b\"IEND\":\n                    # http://www.w3.org/TR/PNG/#11IEND\n                    break\n                if type != b\"IDAT\":\n                    continue\n                # type == b'IDAT'\n                # http://www.w3.org/TR/PNG/#11IDAT\n                if self.colormap and not self.plte:\n                    warnings.warn(\"PLTE chunk is required before IDAT chunk\")\n                yield data\n", "docstring": "Iterator that yields all the ``IDAT`` chunks as strings.\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "            def rows_from_interlace():\n                \"\"\"Yield each row from an interlaced PNG.\"\"\"\n                # It's important that this iterator doesn't read\n                # IDAT chunks until it yields the first row.\n                bs = bytearray(itertools.chain(*raw))\n                arraycode = \"BH\"[self.bitdepth > 8]\n                # Like :meth:`group` but\n                # producing an array.array object for each row.\n                values = self._deinterlace(bs)\n                vpr = self.width * self.planes\n                for i in range(0, len(values), vpr):\n                    row = array(arraycode, values[i : i + vpr])\n                    yield row\n", "docstring": "Yield each row from an interlaced PNG.\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "        def iterscale():\n            for row in pixels:\n                yield [int(round(x * factor)) for x in row]\n", "docstring": "for row in pixels:"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "            def newarray():\n                return array(\"H\", maxbuffer)\n", "docstring": "return array(\"H\", maxbuffer)"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0\n", "docstring": "A non-negative integer.\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "def undo_filter_up(filter_unit, scanline, previous, result):\n    \"\"\"Undo up filter.\"\"\"\n    for i in range(len(result)):\n        x = scanline[i]\n        b = previous[i]\n        result[i] = (x + b) & 0xFF\n", "docstring": "Undo up filter.\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/png.py", "original_string": "def undo_filter_paeth(filter_unit, scanline, previous, result):\n    \"\"\"Undo Paeth filter.\"\"\"\n    # Also used for ci.\n    ai = -filter_unit\n    for i in range(len(result)):\n        x = scanline[i]\n        if ai < 0:\n            a = c = 0\n        else:\n            a = result[ai]\n            c = previous[ai]\n        b = previous[i]\n        p = a + b - c\n        pa = abs(p - a)\n        pb = abs(p - b)\n        pc = abs(p - c)\n        if pa <= pb and pa <= pc:\n            pr = a\n        elif pb <= pc:\n            pr = b\n        else:\n            pr = c\n        result[i] = (x + pr) & 0xFF\n        ai += 1\n", "docstring": "Undo Paeth filter.\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/exceptions.py", "original_string": "    def __init__(self, obj, path, notes=()):\n        \"\"\"See PlotlyGraphObjectError.__init__ for param docs.\"\"\"\n        format_dict = {\"attribute\": path[-1], \"object_name\": obj._name}\n        message = \"'{attribute}' is not allowed in '{object_name}'\".format(\n            **format_dict\n        )\n        notes = [obj.help(return_help=True)] + list(notes)\n        super(PlotlyDictKeyError, self).__init__(\n            message=message, path=path, notes=notes\n        )\n", "docstring": "See PlotlyGraphObjectError.__init__ for param docs.\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/exceptions.py", "original_string": "    def __init__(self, obj, path, notes=()):\n        \"\"\"See PlotlyGraphObjectError.__init__ for param docs.\"\"\"\n        format_dict = {\"attribute\": path[-1], \"object_name\": obj._name}\n        message = \"'{attribute}' has invalid value inside '{object_name}'\".format(\n            **format_dict\n        )\n        notes = [obj.help(path[-1], return_help=True)] + list(notes)\n        super(PlotlyDictValueError, self).__init__(\n            message=message, notes=notes, path=path\n        )\n", "docstring": "See PlotlyGraphObjectError.__init__ for param docs.\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/exceptions.py", "original_string": "    def __init__(self, obj, path, notes=()):\n        \"\"\"See PlotlyGraphObjectError.__init__ for param docs.\"\"\"\n        format_dict = {\"index\": path[-1], \"object_name\": obj._name}\n        message = \"Invalid entry found in '{object_name}' at index, '{index}'\".format(\n            **format_dict\n        )\n        notes = [obj.help(return_help=True)] + list(notes)\n        super(PlotlyListEntryError, self).__init__(\n            message=message, path=path, notes=notes\n        )\n", "docstring": "See PlotlyGraphObjectError.__init__ for param docs.\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/exceptions.py", "original_string": "    def __init__(self, obj, path, notes=()):\n        \"\"\"See PlotlyGraphObjectError.__init__ for param docs.\"\"\"\n        format_dict = {\"index\": path[-1], \"object_name\": obj._name}\n        message = \"Invalid entry found in '{object_name}' at index, '{index}'\".format(\n            **format_dict\n        )\n        note = \"It's invalid because it doesn't contain a valid 'type' value.\"\n        notes = [note] + list(notes)\n        super(PlotlyDataTypeError, self).__init__(\n            message=message, path=path, notes=notes\n        )\n", "docstring": "See PlotlyGraphObjectError.__init__ for param docs.\n"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/tests/validators/test_flaglist_validator.py", "original_string": "def validator(request):\n    # Validator with or without extras\n    return FlaglistValidator(\n        \"prop\", \"parent\", flags=[\"lines\", \"markers\", \"text\"], extras=request.param\n    )\n", "docstring": "Validator with or without extras"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/tests/validators/test_enumerated_validator.py", "original_string": "def test_acceptance(val, validator):\n    # Values should be accepted and returned unchanged\n    assert validator.validate_coerce(val) == val\n", "docstring": "Values should be accepted and returned unchanged"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/tests/validators/test_enumerated_validator.py", "original_string": "def test_acceptance(val, validator_re):\n    # Values should be accepted and returned unchanged\n    assert validator_re.validate_coerce(val) == val\n", "docstring": "Values should be accepted and returned unchanged"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/tests/validators/test_enumerated_validator.py", "original_string": "def test_acceptance_aok(val, validator_aok):\n    # Values should be accepted and returned unchanged\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, (list, np.ndarray)):\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    else:\n        assert coerce_val == val\n", "docstring": "Values should be accepted and returned unchanged"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/tests/validators/test_enumerated_validator.py", "original_string": "def test_acceptance_aok(val, validator_aok_re):\n    # Values should be accepted and returned unchanged\n    coerce_val = validator_aok_re.validate_coerce(val)\n    if isinstance(val, (np.ndarray, pd.Series)):\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif isinstance(val, (list, tuple)):\n        assert validator_aok_re.present(coerce_val) == tuple(val)\n    else:\n        assert validator_aok_re.present(coerce_val) == val\n", "docstring": "Values should be accepted and returned unchanged"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/tests/validators/test_imageuri_validator.py", "original_string": "def test_validator_coercion_PIL(validator):\n    # Single pixel black png (http://png-pixel.com/)\n    tests_dir = os.path.dirname(os.path.dirname(__file__))\n    img_path = os.path.join(tests_dir, \"resources\", \"1x1-black.png\")\n    with open(img_path, \"rb\") as f:\n        hex_bytes = base64.b64encode(f.read()).decode(\"ascii\")\n        expected_uri = \"data:image/png;base64,\" + hex_bytes\n    img = Image.open(img_path)\n    coerce_val = validator.validate_coerce(img)\n    assert coerce_val == expected_uri\n", "docstring": "Single pixel black png (http://png-pixel.com/)"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/tests/validators/test_dash_validator.py", "original_string": "def test_acceptance_dash_types(val, validator):\n    # Values should be accepted and returned unchanged\n    assert validator.validate_coerce(val) == val\n", "docstring": "Values should be accepted and returned unchanged"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/tests/validators/test_dash_validator.py", "original_string": "def test_acceptance_dash_lists(val, validator):\n    # Values should be accepted and returned unchanged\n    assert validator.validate_coerce(val) == val\n", "docstring": "Values should be accepted and returned unchanged"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/tests/validators/test_colorscale_validator.py", "original_string": "def test_acceptance_named(named_colorscale, validator):\n    # Get expected value of named colorscale\n    d = len(named_colorscales[named_colorscale]) - 1\n    expected = [\n        [(1.0 * i) / (1.0 * d), x]\n        for i, x in enumerate(named_colorscales[named_colorscale])\n    ]\n    assert validator.validate_coerce(named_colorscale) == expected\n    # Uppercase\n    assert validator.validate_coerce(named_colorscale.upper()) == expected\n    # Present as tuples\n    expected_tuples = tuple((c[0], c[1]) for c in expected)\n    assert validator.present(expected) == expected_tuples\n", "docstring": "Get expected value of named colorscale"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/tests/validators/test_colorscale_validator.py", "original_string": "def test_acceptance_sequence(seqence_colorscale, validator):\n    # Get expected value of named colorscale\n    d = len(seqence_colorscale) - 1\n    expected = [[(1.0 * i) / (1.0 * d), x] for i, x in enumerate(seqence_colorscale)]\n    # Accepted as is\n    assert validator.validate_coerce(seqence_colorscale) == expected\n    # Present as tuples\n    expected_tuples = tuple((c[0], c[1]) for c in expected)\n    assert validator.present(expected) == expected_tuples\n", "docstring": "Get expected value of named colorscale"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/tests/validators/test_colorscale_validator.py", "original_string": "def test_acceptance_array(val, validator):\n    # Compute expected (tuple of tuples where color is\n    # lowercase with no spaces)\n    expected = [[e[0], e[1]] for e in val]\n    coerce_val = validator.validate_coerce(val)\n    assert coerce_val == expected\n    expected_present = tuple([tuple(e) for e in expected])\n    assert validator.present(coerce_val) == expected_present\n", "docstring": "Compute expected (tuple of tuples where color is"}
{"repo": "plotly.py-master/packages/python/plotly/_plotly_utils/colors/__init__.py", "original_string": "def validate_colorscale(colorscale):\n    \"\"\"Validate the structure, scale values and colors of colorscale.\"\"\"\n    if not isinstance(colorscale, list):\n        # TODO Write tests for these exceptions\n        raise exceptions.PlotlyError(\"A valid colorscale must be a list.\")\n    if not all(isinstance(innerlist, list) for innerlist in colorscale):\n        raise exceptions.PlotlyError(\"A valid colorscale must be a list of lists.\")\n    colorscale_colors = colorscale_to_colors(colorscale)\n    scale_values = colorscale_to_scale(colorscale)\n    validate_scale_values(scale_values)\n    validate_colors(colorscale_colors)\n", "docstring": "Validate the structure, scale values and colors of colorscale.\n"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/session.py", "original_string": "def get_session_plot_options():\n    \"\"\" Returns a copy of the user supplied plot options.\n    Use `update_plot_options()` to change.\n    \"\"\"\n    return copy.deepcopy(_session[\"plot_options\"])\n", "docstring": "Returns a copy of the user supplied plot options."}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/utils.py", "original_string": "def load_json_dict(filename, *args):\n    \"\"\"Checks if file exists. Returns {} if something fails.\"\"\"\n    data = {}\n    if os.path.exists(filename):\n        lock.acquire()\n        with open(filename, \"r\") as f:\n            try:\n                data = _json.load(f)\n                if not isinstance(data, dict):\n                    data = {}\n            except:\n                data = {}  # TODO: issue a warning and bubble it up\n        lock.release()\n        if args:\n            return {key: data[key] for key in args if key in data}\n    return data\n", "docstring": "Checks if file exists. Returns {} if something fails.\n"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/utils.py", "original_string": "def ensure_file_exists(filename):\n    \"\"\"Given a valid filename, make sure it exists (will create if DNE).\"\"\"\n    if not os.path.exists(filename):\n        head, tail = os.path.split(filename)\n        ensure_dir_exists(head)\n        with open(filename, \"w\") as f:\n            pass  # just create the file\n", "docstring": "Given a valid filename, make sure it exists (will create if DNE).\n"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/config.py", "original_string": "def get_credentials():\n    \"\"\"Returns the credentials that will be sent to plotly.\"\"\"\n    credentials = tools.get_credentials_file()\n    session_credentials = session.get_session_credentials()\n    for credentials_key in credentials:\n        # checking for not false, but truthy value here is the desired behavior\n        session_value = session_credentials.get(credentials_key)\n        if session_value is False or session_value:\n            credentials[credentials_key] = session_value\n    return credentials\n", "docstring": "Returns the credentials that will be sent to plotly.\n"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tools.py", "original_string": "def set_credentials_file(\n    username=None,\n    api_key=None,\n    stream_ids=None,\n    proxy_username=None,\n    proxy_password=None,\n", "docstring": "username=None,"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tools.py", "original_string": "def get_credentials_file(*args):\n    \"\"\"Return specified args from `~/.plotly_credentials`. as dict.\n    Returns all if no arguments are specified.\n    Example:\n        get_credentials_file('username')\n    \"\"\"\n    # Read credentials from file if possible\n    credentials = utils.load_json_dict(CREDENTIALS_FILE, *args)\n    if not credentials:\n        # Credentials could not be read, use defaults\n        credentials = copy.copy(FILE_CONTENT[CREDENTIALS_FILE])\n    return credentials\n", "docstring": "Return specified args from `~/.plotly_credentials`. as dict."}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tools.py", "original_string": "def get_config_file(*args):\n    \"\"\"Return specified args from `~/.plotly/.config`. as tuple.\n    Returns all if no arguments are specified.\n    Example:\n        get_config_file('plotly_domain')\n    \"\"\"\n    # Read config from file if possible\n    config = utils.load_json_dict(CONFIG_FILE, *args)\n    if not config:\n        # Config could not be read, use defaults\n        config = copy.copy(FILE_CONTENT[CONFIG_FILE])\n    return config\n", "docstring": "Return specified args from `~/.plotly/.config`. as tuple."}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/dashboard_objs/dashboard_objs.py", "original_string": "    def get_box(self, box_id):\n        \"\"\"Returns box from box_id number.\"\"\"\n        box_ids_to_path = self._compute_box_ids()\n        loc_in_dashboard = self[\"layout\"]\n        if box_id not in box_ids_to_path.keys():\n            raise _plotly_utils.exceptions.PlotlyError(ID_NOT_VALID_MESSAGE)\n        for first_second in box_ids_to_path[box_id]:\n            loc_in_dashboard = loc_in_dashboard[first_second]\n        return loc_in_dashboard\n", "docstring": "Returns box from box_id number.\n"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/api/v2/dashboards.py", "original_string": "def create(body):\n    \"\"\"Create a dashboard.\"\"\"\n    url = build_url(RESOURCE)\n    return request(\"post\", url, json=body)\n", "docstring": "Create a dashboard.\n"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/api/v2/dashboards.py", "original_string": "def retrieve(fid):\n    \"\"\"Retrieve a dashboard from Plotly.\"\"\"\n    url = build_url(RESOURCE, id=fid)\n    return request(\"get\", url)\n", "docstring": "Retrieve a dashboard from Plotly.\n"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/api/v2/utils.py", "original_string": "def should_retry(exception):\n    if isinstance(exception, exceptions.PlotlyRequestError):\n        if isinstance(exception.status_code, int) and (\n            500 <= exception.status_code < 600 or exception.status_code == 429\n        ):\n            # Retry on 5XX and 429 (image export throttling) errors.\n            return True\n        elif \"Uh oh, an error occurred\" in exception.message:\n            return True\n    return False\n", "docstring": "if isinstance(exception, exceptions.PlotlyRequestError):"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/api/v2/spectacle_presentations.py", "original_string": "def create(body):\n    \"\"\"Create a presentation.\"\"\"\n    url = build_url(RESOURCE)\n    return request(\"post\", url, json=body)\n", "docstring": "Create a presentation.\n"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/api/v2/spectacle_presentations.py", "original_string": "def retrieve(fid):\n    \"\"\"Retrieve a presentation from Plotly.\"\"\"\n    url = build_url(RESOURCE, id=fid)\n    return request(\"get\", url)\n", "docstring": "Retrieve a presentation from Plotly.\n"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/api/v2/dash_apps.py", "original_string": "def create(body):\n    \"\"\"Create a dash app item.\"\"\"\n    url = build_url(RESOURCE)\n    return request(\"post\", url, json=body)\n", "docstring": "Create a dash app item.\n"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/presentation_objs/presentation_objs.py", "original_string": "def _generate_id(size):\n    letters_and_numbers = string.ascii_letters\n    for num in range(10):\n        letters_and_numbers += str(num)\n    letters_and_numbers += str(num)\n    id_str = \"\"\n    for _ in range(size):\n        id_str += random.choice(list(letters_and_numbers))\n    return id_str\n", "docstring": "letters_and_numbers = string.ascii_letters"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/presentation_objs/presentation_objs.py", "original_string": "def _top_spec_for_text_at_bottom(text_block, width_per, per_from_bottom=0, min_top=30):\n    # This function ensures that if there is a large block of\n    # text in your slide it will not overflow off the bottom\n    # of the slide.\n    # The input for this function are a block of text and the\n    # params that define where it will be placed in the slide.\n    # The function makes some calculations and will output a\n    # 'top' value (i.e. the left, top, height, width css params)\n    # so that the text block will come down to some specified\n    # distance from the bottom of the page.\n    # TODO: customize this function for different fonts/sizes\n    max_lines = 37\n    one_char_percent_width = 0.764\n    chars_in_full_line = width_per / one_char_percent_width\n    num_of_lines = 0\n    char_group = 0\n    for char in text_block:\n        if char == \"\\n\":\n            num_of_lines += 1\n            char_group = 0\n        else:\n            if char_group >= chars_in_full_line:\n                char_group = 0\n                num_of_lines += 1\n            else:\n                char_group += 1\n    num_of_lines += 1\n    top_frac = (max_lines - num_of_lines) / float(max_lines)\n    top = top_frac * 100 - per_from_bottom\n    # to be safe\n    return max(top, min_top)\n", "docstring": "This function ensures that if there is a large block of"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/plotly/plotly.py", "original_string": "def plot_mpl(fig, resize=True, strip_style=False, update=None, **plot_options):\n    \"\"\"Replot a matplotlib figure with plotly.\n    This function:\n    1. converts the mpl figure into JSON (run help(plotly.tools.mpl_to_plotly))\n    2. makes a request to Plotly to save this figure in your account\n    3. opens your figure in a browser tab OR returns the unique figure url\n    Positional arguments:\n    fig -- a figure object from matplotlib\n    Keyword arguments:\n    resize (default=True) -- allow plotly to choose the figure size\n    strip_style (default=False) -- allow plotly to choose style options\n    update (default=None) -- update the resulting figure with an 'update'\n        dictionary-like object resembling a plotly 'Figure' object\n    Additional keyword arguments:\n    plot_options -- run help(plotly.plotly.plot)\n    \"\"\"\n    import plotly.tools\n    fig = plotly.tools.mpl_to_plotly(fig, resize=resize, strip_style=strip_style)\n    if update and isinstance(update, dict):\n        fig.update(update)\n    elif update is not None:\n        raise _plotly_utils.exceptions.PlotlyGraphObjectError(\n            \"'update' must be dictionary-like and a valid plotly Figure \"\n            \"object. Run 'help(plotly.graph_objs.Figure)' for more info.\"\n        )\n    return plot(fig, **plot_options)\n", "docstring": "Replot a matplotlib figure with plotly."}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/plotly/plotly.py", "original_string": "def _swap_xy_data(data_obj):\n    \"\"\"Swap x and y data and references\"\"\"\n    swaps = [\n        (\"x\", \"y\"),\n        (\"x0\", \"y0\"),\n        (\"dx\", \"dy\"),\n        (\"xbins\", \"ybins\"),\n        (\"nbinsx\", \"nbinsy\"),\n        (\"autobinx\", \"autobiny\"),\n        (\"error_x\", \"error_y\"),\n    ]\n    for swap in swaps:\n        _swap_keys(data_obj, swap[0], swap[1])\n    try:\n        rows = len(data_obj[\"z\"])\n        cols = len(data_obj[\"z\"][0])\n        for row in data_obj[\"z\"]:\n            if len(row) != cols:\n                raise TypeError\n        # if we can't do transpose, we hit an exception before here\n        z = data_obj.pop(\"z\")\n        data_obj[\"z\"] = [[0 for rrr in range(rows)] for ccc in range(cols)]\n        for iii in range(rows):\n            for jjj in range(cols):\n                data_obj[\"z\"][jjj][iii] = z[iii][jjj]\n    except (KeyError, TypeError, IndexError) as err:\n        warn = False\n        try:\n            if data_obj[\"z\"] is not None:\n                warn = True\n            if len(data_obj[\"z\"]) == 0:\n                warn = False\n        except (KeyError, TypeError):\n            pass\n        if warn:\n            warnings.warn(\n                \"Data in this file required an 'xy' swap but the 'z' matrix \"\n                \"in one of the data objects could not be transposed. Here's \"\n                \"why:\\n\\n{}\".format(repr(err))\n            )\n", "docstring": "Swap x and y data and references\n"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/plotly/plotly.py", "original_string": "    def connected(self):\n        if self._stream is None:\n            return False\n        return self._stream._isconnected()\n", "docstring": "if self._stream is None:"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/plotly/plotly.py", "original_string": "    def get(figure_or_data, format=\"png\", width=None, height=None, scale=None):\n        \"\"\"Return a static image of the plot described by `figure_or_data`.\n        positional arguments:\n        - figure_or_data: The figure dict-like or data list-like object that\n                          describes a plotly figure.\n                          Same argument used in `py.plot`, `py.iplot`,\n                          see https://plotly.com/python for examples\n        - format: 'png', 'svg', 'jpeg', 'pdf', 'emf'\n        - width: output width\n        - height: output height\n        - scale: Increase the resolution of the image by `scale`\n                 amount (e.g. `3`)\n                 Only valid for PNG and JPEG images.\n        example:\n        ```\n        import plotly.plotly as py\n        fig = {'data': [{'x': [1, 2, 3], 'y': [3, 1, 5], 'type': 'bar'}]}\n        py.image.get(fig, 'png', scale=3)\n        ```\n        \"\"\"\n        # TODO: format is a built-in name... we shouldn't really use it\n        import plotly.tools\n        figure = plotly.tools.return_figure_from_figure_or_data(figure_or_data, True)\n        if format not in [\"png\", \"svg\", \"jpeg\", \"pdf\", \"emf\"]:\n            raise _plotly_utils.exceptions.PlotlyError(\n                \"Invalid format. This version of your Plotly-Python \"\n                \"package currently only supports png, svg, jpeg, and pdf. \"\n                \"Learn more about image exporting, and the currently \"\n                \"supported file types here: \"\n                \"https://plotly.com/python/static-image-export/\"\n            )\n        if scale is not None:\n            try:\n                scale = float(scale)\n            except:\n                raise _plotly_utils.exceptions.PlotlyError(\n                    \"Invalid scale parameter. Scale must be a number.\"\n                )\n        payload = {\"figure\": figure, \"format\": format}\n        if width is not None:\n            payload[\"width\"] = width\n        if height is not None:\n            payload[\"height\"] = height\n        if scale is not None:\n            payload[\"scale\"] = scale\n        response = v2.images.create(payload)\n        headers = response.headers\n        if \"content-type\" in headers and headers[\"content-type\"] in [\n            \"image/png\",\n            \"image/jpeg\",\n            \"application/pdf\",\n            \"image/svg+xml\",\n            \"image/emf\",\n        ]:\n            return response.content\n        elif \"content-type\" in headers and \"json\" in headers[\"content-type\"]:\n            return response.json()[\"image\"]\n", "docstring": "Return a static image of the plot described by `figure_or_data`."}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/plotly/plotly.py", "original_string": "    def ishow(cls, figure_or_data, format=\"png\", width=None, height=None, scale=None):\n        \"\"\"Display a static image of the plot described by `figure_or_data`\n        in an IPython Notebook.\n        positional arguments:\n        - figure_or_data: The figure dict-like or data list-like object that\n                          describes a plotly figure.\n                          Same argument used in `py.plot`, `py.iplot`,\n                          see https://plotly.com/python for examples\n        - format: 'png', 'svg', 'jpeg', 'pdf'\n        - width: output width\n        - height: output height\n        - scale: Increase the resolution of the image by `scale` amount\n               Only valid for PNG and JPEG images.\n        example:\n        ```\n        import plotly.plotly as py\n        fig = {'data': [{'x': [1, 2, 3], 'y': [3, 1, 5], 'type': 'bar'}]}\n        py.image.ishow(fig, 'png', scale=3)\n        \"\"\"\n        if format == \"pdf\":\n            raise _plotly_utils.exceptions.PlotlyError(\n                \"Aw, snap! \"\n                \"It's not currently possible to embed a pdf into \"\n                \"an IPython notebook. You can save the pdf \"\n                \"with the `image.save_as` or you can \"\n                \"embed an png, jpeg, or svg.\"\n            )\n        img = cls.get(figure_or_data, format, width, height, scale)\n        from IPython.display import display, Image, SVG\n        if format == \"svg\":\n            display(SVG(img))\n        else:\n            display(Image(img))\n", "docstring": "Display a static image of the plot described by `figure_or_data`"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/plotly/plotly.py", "original_string": "    def save_as(\n        cls, figure_or_data, filename, format=None, width=None, height=None, scale=None\n", "docstring": "cls, figure_or_data, filename, format=None, width=None, height=None, scale=None"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/plotly/plotly.py", "original_string": "    def _fill_in_response_column_ids(cls, request_columns, response_columns, grid_id):\n        for req_col in request_columns:\n            for resp_col in response_columns:\n                if resp_col[\"name\"] == req_col.name:\n                    req_col.id = \"{0}:{1}\".format(grid_id, resp_col[\"uid\"])\n                    response_columns.remove(resp_col)\n", "docstring": "for req_col in request_columns:"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/plotly/plotly.py", "original_string": "    def _get_all_dashboards(cls):\n        dashboards = []\n        res = v2.dashboards.list().json()\n        for dashboard in res[\"results\"]:\n            if not dashboard[\"deleted\"]:\n                dashboards.append(dashboard)\n        while res[\"next\"]:\n            res = v2.utils.request(\"get\", res[\"next\"]).json()\n            for dashboard in res[\"results\"]:\n                if not dashboard[\"deleted\"]:\n                    dashboards.append(dashboard)\n        return dashboards\n", "docstring": "dashboards = []"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/plotly/plotly.py", "original_string": "    def get_dashboard(cls, dashboard_name):\n        \"\"\"Returns a Dashboard object from a dashboard name.\"\"\"\n        dashboard_json = cls._get_dashboard_json(dashboard_name)\n        return dashboard.Dashboard(dashboard_json)\n", "docstring": "Returns a Dashboard object from a dashboard name.\n"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/plotly/plotly.py", "original_string": "    def get_dashboard_names(cls):\n        \"\"\"Return list of all active dashboard names from users' account.\"\"\"\n        dashboards = cls._get_all_dashboards()\n        return [str(dboard[\"filename\"]) for dboard in dashboards]\n", "docstring": "Return list of all active dashboard names from users' account.\n"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/plotly/chunked_requests/chunked_request.py", "original_string": "    def write(self, data, reconnect_on=(\"\", 200, 502)):\n        \"\"\" Send `data` to the server in chunk-encoded form.\n        Check the connection before writing and reconnect\n        if disconnected and if the response status code is in `reconnect_on`.\n        The response may either be an HTTPResponse object or an empty string.\n        \"\"\"\n        if not self._isconnected():\n            # Attempt to get the response.\n            response = self._getresponse()\n            # Reconnect depending on the status code.\n            if (response == \"\" and \"\" in reconnect_on) or (\n                response\n                and isinstance(response, http_client.HTTPResponse)\n                and response.status in reconnect_on\n            ):\n                self._reconnect()\n            elif response and isinstance(response, http_client.HTTPResponse):\n                # If an HTTPResponse was recieved then\n                # make the users aware instead of\n                # auto-reconnecting in case the\n                # server is responding with an important\n                # message that might prevent\n                # future requests from going through,\n                # like Invalid Credentials.\n                # This allows the user to determine when\n                # to reconnect.\n                raise Exception(\n                    \"Server responded with \"\n                    \"status code: {status_code}\\n\"\n                    \"and message: {msg}.\".format(\n                        status_code=response.status, msg=response.read()\n                    )\n                )\n            elif response == \"\":\n                raise Exception(\"Attempted to write but socket \" \"was not connected.\")\n        try:\n            msg = data\n            msglen = format(len(msg), \"x\")  # msg length in hex\n            # Send the message in chunk-encoded form\n            self._conn.sock.setblocking(1)\n            self._conn.send(\n                \"{msglen}\\r\\n{msg}\\r\\n\".format(msglen=msglen, msg=msg).encode(\"utf-8\")\n            )\n            self._conn.sock.setblocking(0)\n        except http_client.socket.error:\n            self._reconnect()\n            self.write(data)\n", "docstring": "Send `data` to the server in chunk-encoded form."}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/plotly/chunked_requests/chunked_request.py", "original_string": "    def close(self):\n        \"\"\" Close the connection to server.\n        If available, return a http_client.HTTPResponse object.\n        Closing the connection involves sending the\n        Transfer-Encoding terminating bytes.\n        \"\"\"\n        self._reset_retries()\n        self._closed = True\n        # Chunked-encoded posts are terminated with '0\\r\\n\\r\\n'\n        # For some reason, either Python or node.js seems to\n        # require an extra \\r\\n.\n        try:\n            self._conn.send(\"\\r\\n0\\r\\n\\r\\n\".encode(\"utf-8\"))\n        except http_client.socket.error:\n            # In case the socket has already been closed\n            return \"\"\n        return self._getresponse()\n", "docstring": "Close the connection to server."}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/plotly/chunked_requests/chunked_request.py", "original_string": "    def _reset_retries(self):\n        \"\"\" Reset the connect counters and delays\n        \"\"\"\n        self._tries = 0\n        self._delay = 1\n", "docstring": "Reset the connect counters and delays"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/grid_objs/grid_objs.py", "original_string": "    def __repr__(self):\n        return 'Column(\"{0}\", {1})'.format(self.data, self.name)\n", "docstring": "return 'Column(\"{0}\", {1})'.format(self.data, self.name)"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/grid_objs/grid_objs.py", "original_string": "    def __getitem__(self, index):\n        return self._columns[index]\n", "docstring": "return self._columns[index]"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_core/test_tools/test_file_tools.py", "original_string": "    def test_set_config_file_all_entries(self):\n        # Check set_config and get_config return the same values\n        domain, streaming_domain, api, sharing = (\"this\", \"thing\", \"that\", \"private\")\n        ssl_verify, proxy_auth, world_readable, auto_open = (True, True, False, False)\n        tools.set_config_file(\n            plotly_domain=domain,\n            plotly_streaming_domain=streaming_domain,\n            plotly_api_domain=api,\n            plotly_ssl_verification=ssl_verify,\n            plotly_proxy_authorization=proxy_auth,\n            world_readable=world_readable,\n            auto_open=auto_open,\n        )\n        config = tools.get_config_file()\n        self.assertEqual(config[\"plotly_domain\"], domain)\n        self.assertEqual(config[\"plotly_streaming_domain\"], streaming_domain)\n        self.assertEqual(config[\"plotly_api_domain\"], api)\n        self.assertEqual(config[\"plotly_ssl_verification\"], ssl_verify)\n        self.assertEqual(config[\"plotly_proxy_authorization\"], proxy_auth)\n        self.assertEqual(config[\"world_readable\"], world_readable)\n        self.assertEqual(config[\"sharing\"], sharing)\n        self.assertEqual(config[\"auto_open\"], auto_open)\n        tools.reset_config_file()\n", "docstring": "Check set_config and get_config return the same values"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_core/test_tools/test_file_tools.py", "original_string": "    def test_set_config_file_world_readable(self):\n        # Return TypeError when world_readable type is not a bool\n        kwargs = {\"world_readable\": \"True\"}\n        self.assertRaises(TypeError, tools.set_config_file, **kwargs)\n", "docstring": "Return TypeError when world_readable type is not a bool"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_core/test_tools/test_file_tools.py", "original_string": "    def test_set_config_no_warning_msg_if_plotly_domain_is_https(self):\n        # Check that no UserWarning is being called with https plotly_domain\n        with warnings.catch_warnings(record=True) as w:\n            warnings.simplefilter(\"always\")\n            kwargs = {\"plotly_domain\": \"https://www.foo-bar.com\"}\n            tools.set_config_file(**kwargs)\n            assert len(w) == 0\n", "docstring": "Check that no UserWarning is being called with https plotly_domain"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_core/test_tools/test_file_tools.py", "original_string": "    def test_get_credentials_file(self):\n        # Check get_credentials returns all the keys\n        original_creds = tools.get_credentials_file()\n        expected = [\n            \"username\",\n            \"stream_ids\",\n            \"api_key\",\n            \"proxy_username\",\n            \"proxy_password\",\n        ]\n        self.assertTrue(all(x in original_creds for x in expected))\n", "docstring": "Check get_credentials returns all the keys"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_plot_ly/test_api/test_v2/test_grids.py", "original_string": "    def test_lookup(self):\n        # requests does urlencode, so don't worry about the `' '` character!\n        path = \"/mah grid\"\n        parent = 43\n        user = \"someone\"\n        exists = True\n        grids.lookup(path=path, parent=parent, user=user, exists=exists)\n        assert self.request_mock.call_count == 1\n        args, kwargs = self.request_mock.call_args\n        method, url = args\n        expected_params = {\n            \"path\": path,\n            \"parent\": parent,\n            \"exists\": \"true\",\n            \"user\": user,\n        }\n        self.assertEqual(method, \"get\")\n        self.assertEqual(url, \"{}/v2/grids/lookup\".format(self.plotly_api_domain))\n        self.assertEqual(kwargs[\"params\"], expected_params)\n", "docstring": "requests does urlencode, so don't worry about the `' '` character!"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_plot_ly/test_api/test_v2/test_utils.py", "original_string": "    def test_validate_no_content(self):\n        # We shouldn't flake if the response has no content.\n        response = self.get_response(content=b\"\", status_code=400)\n        try:\n            utils.validate_response(response)\n        except PlotlyRequestError as e:\n            self.assertEqual(e.message, \"No Content\")\n            self.assertEqual(e.status_code, 400)\n            self.assertEqual(e.content.decode(\"utf-8\"), \"\")\n        else:\n            self.fail(\"Expected this to raise!\")\n", "docstring": "We shouldn't flake if the response has no content."}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_plot_ly/test_api/test_v2/test_utils.py", "original_string": "    def test_request_with_non_native_objects(self):\n        # We always send along json, but it may contain non-native objects like\n        # a pandas array or a Column reference. Make sure that's handled in one\n        # central place.\n        class Duck(object):\n            def to_plotly_json(self):\n                return \"what else floats?\"\n        utils.request(self.method, self.url, json={\"foo\": [Duck(), Duck()]})\n        args, kwargs = self.request_mock.call_args\n        method, url = args\n        expected_data = '{\"foo\": [\"what else floats?\", \"what else floats?\"]}'\n        self.assertEqual(method, self.method)\n        self.assertEqual(url, self.url)\n        self.assertEqual(kwargs[\"data\"], expected_data)\n        self.assertNotIn(\"json\", kwargs)\n", "docstring": "We always send along json, but it may contain non-native objects like"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_plot_ly/test_plotly/test_plot.py", "original_string": "    def test_plot_sharing_invalid_argument(self):\n        # Raise an error if sharing argument is incorrect\n        # correct arguments {'public, 'private', 'secret'}\n        kwargs = {\"filename\": \"invalid-sharing-argument\", \"sharing\": \"privste\"}\n        with self.assertRaisesRegexp(\n            PlotlyError, \"The 'sharing' argument only accepts\"\n        ):\n            py.plot(self.simple_figure, **kwargs)\n", "docstring": "Raise an error if sharing argument is incorrect"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_plot_ly/test_plotly/test_plot.py", "original_string": "    def test_plot_world_readable_sharing_conflict_2(self):\n        # Raise an error if world_readable=True but sharing='secret'\n        kwargs = {\n            \"filename\": \"invalid-privacy-setting\",\n            \"world_readable\": True,\n            \"sharing\": \"secret\",\n        }\n        with self.assertRaisesRegexp(\n            PlotlyError, \"setting your plot privacy to both public and private.\"\n        ):\n            py.plot(self.simple_figure, **kwargs)\n", "docstring": "Raise an error if world_readable=True but sharing='secret'"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_plot_ly/test_plotly/test_plot.py", "original_string": "    def test_plot_option_logic_only_sharing_given(self):\n        # If world_readable is not given and sharing ='private',\n        # world_readable should be set to False\n        kwargs = {\n            \"filename\": \"test\",\n            \"auto_open\": True,\n            \"validate\": True,\n            \"sharing\": \"private\",\n        }\n        plot_option_logic = py._plot_option_logic(kwargs)\n        expected_plot_option_logic = {\n            \"filename\": \"test\",\n            \"auto_open\": True,\n            \"validate\": True,\n            \"world_readable\": False,\n            \"sharing\": \"private\",\n        }\n        self.assertEqual(plot_option_logic, expected_plot_option_logic)\n", "docstring": "If world_readable is not given and sharing ='private',"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_plot_ly/test_plotly/test_plot.py", "original_string": "    def test_plot_url_response_given_sharing_key(self):\n        # Given share_key is requested, get request of the url should\n        # be 200\n        kwargs = {\n            \"filename\": \"is_share_key_included2\",\n            \"auto_open\": False,\n            \"world_readable\": False,\n            \"sharing\": \"secret\",\n        }\n        plot_url = py.plot(self.simple_figure, **kwargs)\n        # shareplot basically always gives a 200 if even if permission denied\n        # embedplot returns an actual 404\n        embed_url = plot_url.split(\"?\")[0] + \".embed?\" + plot_url.split(\"?\")[1]\n        response = requests.get(embed_url)\n        self.assertEqual(response.status_code, 200)\n", "docstring": "Given share_key is requested, get request of the url should"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_plot_ly/test_plotly/test_plot.py", "original_string": "def generate_conflicting_plot_options_in_signin():\n    \"\"\"sign_in overrides the default plot options.\n    conflicting options aren't raised until plot or iplot is called,\n    through _plot_option_logic\n    \"\"\"\n    def gen_test(plot_options):\n        def test(self):\n            py.sign_in(\"username\", \"key\", **plot_options)\n            self.assertRaises(PlotlyError, py._plot_option_logic, {})\n        return test\n    for i, plot_options in enumerate(TestPlotOptionLogic.conflicting_option_set):\n        setattr(\n            TestPlotOptionLogic,\n            \"test_conflicting_plot_options_in_signin_{}\".format(i),\n            gen_test(plot_options),\n        )\n", "docstring": "sign_in overrides the default plot options."}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_plot_ly/test_plotly/test_plot.py", "original_string": "def generate_conflicting_plot_options_in_tools_dot_set_config():\n    \"\"\"tls.set_config overrides the default plot options.\n    conflicting options are actually raised when the options are saved,\n    because we push out default arguments for folks, and we don't want to\n    require users to specify both world_readable and secret *and* we don't\n    want to raise an error if they specified only one of these options\n    and didn't know that a default option was being saved for them.\n    \"\"\"\n    def gen_test(plot_options):\n        def test(self):\n            self.assertRaises(PlotlyError, tls.set_config_file, **plot_options)\n        return test\n    for i, plot_options in enumerate(TestPlotOptionLogic.conflicting_option_set):\n        setattr(\n            TestPlotOptionLogic,\n            \"test_conflicting_plot_options_in_\" \"tools_dot_set_config{}\".format(i),\n            gen_test(plot_options),\n        )\n", "docstring": "tls.set_config overrides the default plot options."}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_plot_ly/test_plotly/test_plot.py", "original_string": "def generate_conflicting_plot_options_with_json_writes_of_config():\n    \"\"\" if the user wrote their own options in the config file,\n    then we'll raise the error when the call plot or iplot through\n    _plot_option_logic\n    \"\"\"\n    def gen_test(plot_options):\n        def test(self):\n            config = _json.load(open(CONFIG_FILE))\n            with open(CONFIG_FILE, \"w\") as f:\n                config.update(plot_options)\n                f.write(_json.dumps(config))\n            self.assertRaises(PlotlyError, py._plot_option_logic, {})\n        return test\n    for i, plot_options in enumerate(TestPlotOptionLogic.conflicting_option_set):\n        setattr(\n            TestPlotOptionLogic,\n            \"test_conflicting_plot_options_with_\" \"json_writes_of_config{}\".format(i),\n            gen_test(plot_options),\n        )\n", "docstring": "if the user wrote their own options in the config file,"}
{"repo": "plotly.py-master/packages/python/chart-studio/chart_studio/tests/test_plot_ly/test_plotly/test_plot.py", "original_string": "def generate_private_sharing_and_public_world_readable_precedence():\n    \"\"\" Test that call signature arguments applied through _plot_option_logic\n    overwrite options supplied through py.sign_in which overwrite options\n    set through tls.set_config\n    \"\"\"\n    plot_option_sets = (\n        {\n            \"parent\": {\"world_readable\": True, \"auto_open\": False},\n            \"child\": {\"sharing\": \"secret\", \"auto_open\": True},\n            \"expected_output\": {\n                \"world_readable\": False,\n                \"sharing\": \"secret\",\n                \"auto_open\": True,\n            },\n        },\n        {\n            \"parent\": {\"world_readable\": True, \"auto_open\": True},\n            \"child\": {\"sharing\": \"private\", \"auto_open\": False},\n            \"expected_output\": {\n                \"world_readable\": False,\n                \"sharing\": \"private\",\n                \"auto_open\": False,\n            },\n        },\n        {\n            \"parent\": {\"world_readable\": False, \"auto_open\": False},\n            \"child\": {\"sharing\": \"public\", \"auto_open\": True},\n            \"expected_output\": {\n                \"world_readable\": True,\n                \"sharing\": \"public\",\n                \"auto_open\": True,\n            },\n        },\n    )\n    def gen_test_signin(plot_options):\n        def test(self):\n            py.sign_in(\"username\", \"key\", **plot_options[\"parent\"])\n            options = py._plot_option_logic(plot_options[\"child\"])\n            for option, value in plot_options[\"expected_output\"].items():\n                self.assertEqual(options[option], value)\n        return test\n    def gen_test_config(plot_options):\n        def test(self):\n            tls.set_config(**plot_options[\"parent\"])\n            options = py._plot_option_logic(plot_options[\"child\"])\n            for option, value in plot_options[\"expected_output\"].items():\n                self.assertEqual(options[option], value)\n    for i, plot_options in enumerate(plot_option_sets):\n        setattr(\n            TestPlotOptionLogic,\n            \"test_private_sharing_and_public_\"\n            \"world_readable_precedence_signin{}\".format(i),\n            gen_test_signin(plot_options),\n        )\n        setattr(\n            TestPlotOptionLogic,\n            \"test_private_sharing_and_public_\"\n            \"world_readable_precedence_config{}\".format(i),\n            gen_test_config(plot_options),\n        )\n", "docstring": "Test that call signature arguments applied through _plot_option_logic"}
{"repo": "eliot-master/versioneer.py", "original_string": "def get_root():\n    \"\"\"Get the project root directory.\n    We require that all commands are run from the project root, i.e. the\n    directory that contains setup.py, setup.cfg, and versioneer.py .\n    \"\"\"\n    root = os.path.realpath(os.path.abspath(os.getcwd()))\n    setup_py = os.path.join(root, \"setup.py\")\n    versioneer_py = os.path.join(root, \"versioneer.py\")\n    if not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n        # allow 'python path/to/setup.py COMMAND'\n        root = os.path.dirname(os.path.realpath(os.path.abspath(sys.argv[0])))\n        setup_py = os.path.join(root, \"setup.py\")\n        versioneer_py = os.path.join(root, \"versioneer.py\")\n    if not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n        err = (\"Versioneer was unable to run the project root directory. \"\n               \"Versioneer requires setup.py to be executed from \"\n               \"its immediate directory (like 'python setup.py COMMAND'), \"\n               \"or in a way that lets it use sys.argv[0] to find the root \"\n               \"(like 'python path/to/setup.py COMMAND').\")\n        raise VersioneerBadRootError(err)\n    try:\n        # Certain runtime workflows (setup.py install/develop in a setuptools\n        # tree) execute all dependencies in a single python process, so\n        # \"versioneer\" may be imported multiple times, and python's shared\n        # module-import table will cache the first one. So we can't use\n        # os.path.dirname(__file__), as that will find whichever\n        # versioneer.py was first imported, even in later projects.\n        me = os.path.realpath(os.path.abspath(__file__))\n        me_dir = os.path.normcase(os.path.splitext(me)[0])\n        vsr_dir = os.path.normcase(os.path.splitext(versioneer_py)[0])\n        if me_dir != vsr_dir:\n            print(\"Warning: build in %s is using versioneer.py from %s\"\n                  % (os.path.dirname(me), versioneer_py))\n    except NameError:\n        pass\n    return root\n", "docstring": "Get the project root directory."}
{"repo": "eliot-master/versioneer.py", "original_string": "def register_vcs_handler(vcs, method):  # decorator\n    \"\"\"Decorator to mark a method as the handler for a particular VCS.\"\"\"\n    def decorate(f):\n        \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n    return decorate\n", "docstring": "Decorator to mark a method as the handler for a particular VCS.\n"}
{"repo": "eliot-master/versioneer.py", "original_string": "def get_keywords():\n    \"\"\"Get the keywords needed to look up the version information.\"\"\"\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = \"%(DOLLAR)sFormat:%%d%(DOLLAR)s\"\n    git_full = \"%(DOLLAR)sFormat:%%H%(DOLLAR)s\"\n    git_date = \"%(DOLLAR)sFormat:%%ci%(DOLLAR)s\"\n    keywords = {\"refnames\": git_refnames, \"full\": git_full, \"date\": git_date}\n    return keywords\n", "docstring": "Get the keywords needed to look up the version information.\n"}
{"repo": "eliot-master/versioneer.py", "original_string": "def get_config():\n    \"\"\"Create, populate and return the VersioneerConfig() object.\"\"\"\n    # these strings are filled in when 'setup.py versioneer' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = \"git\"\n    cfg.style = \"%(STYLE)s\"\n    cfg.tag_prefix = \"%(TAG_PREFIX)s\"\n    cfg.parentdir_prefix = \"%(PARENTDIR_PREFIX)s\"\n    cfg.versionfile_source = \"%(VERSIONFILE_SOURCE)s\"\n    cfg.verbose = False\n    return cfg\n", "docstring": "Create, populate and return the VersioneerConfig() object.\n"}
{"repo": "eliot-master/versioneer.py", "original_string": "def register_vcs_handler(vcs, method):  # decorator\n    \"\"\"Decorator to mark a method as the handler for a particular VCS.\"\"\"\n    def decorate(f):\n        \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n    return decorate\n", "docstring": "Decorator to mark a method as the handler for a particular VCS.\n"}
{"repo": "eliot-master/versioneer.py", "original_string": "def versions_from_parentdir(parentdir_prefix, root, verbose):\n    \"\"\"Try to determine the version from the parent directory name.\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    \"\"\"\n    rootdirs = []\n    for i in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {\"version\": dirname[len(parentdir_prefix):],\n                    \"full-revisionid\": None,\n                    \"dirty\": False, \"error\": None, \"date\": None}\n        else:\n            rootdirs.append(root)\n            root = os.path.dirname(root)  # up a level\n    if verbose:\n        print(\"Tried directories %%s but none started with prefix %%s\" %%\n              (str(rootdirs), parentdir_prefix))\n    raise NotThisMethod(\"rootdir doesn't start with parentdir_prefix\")\n", "docstring": "Try to determine the version from the parent directory name."}
{"repo": "eliot-master/versioneer.py", "original_string": "def git_get_keywords(versionfile_abs):\n    \"\"\"Extract version information from the given file.\"\"\"\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don't want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        f = open(versionfile_abs, \"r\")\n        for line in f.readlines():\n            if line.strip().startswith(\"git_refnames =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"refnames\"] = mo.group(1)\n            if line.strip().startswith(\"git_full =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"full\"] = mo.group(1)\n            if line.strip().startswith(\"git_date =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"date\"] = mo.group(1)\n        f.close()\n    except EnvironmentError:\n        pass\n    return keywords\n", "docstring": "Extract version information from the given file.\n"}
{"repo": "eliot-master/versioneer.py", "original_string": "def git_versions_from_keywords(keywords, tag_prefix, verbose):\n    \"\"\"Get version information from git keywords.\"\"\"\n    if not keywords:\n        raise NotThisMethod(\"no keywords at all, weird\")\n    date = keywords.get(\"date\")\n    if date is not None:\n        # git-2.2.0 added \"%%cI\", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer \"%%ci\" (which expands to an \"ISO-8601\n        # -like\" string, which we must then edit to make compliant), because\n        # it's been around since git-1.5.3, and it's too difficult to\n        # discover which version we're using, or to work around using an\n        # older one.\n        date = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n    refnames = keywords[\"refnames\"].strip()\n    if refnames.startswith(\"$Format\"):\n        if verbose:\n            print(\"keywords are unexpanded, not using\")\n        raise NotThisMethod(\"unexpanded keywords, not a git-archive tarball\")\n    refs = set([r.strip() for r in refnames.strip(\"()\").split(\",\")])\n    # starting in git-1.8.3, tags are listed as \"tag: foo-1.0\" instead of\n    # just \"foo-1.0\". If we see a \"tag: \" prefix, prefer those.\n    TAG = \"tag: \"\n    tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)])\n    if not tags:\n        # Either we're using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %%d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like \"release\" and\n        # \"stabilization\", as well as \"HEAD\" and \"master\".\n        tags = set([r for r in refs if re.search(r'\\d', r)])\n        if verbose:\n            print(\"discarding '%%s', no digits\" %% \",\".join(refs - tags))\n    if verbose:\n        print(\"likely tags: %%s\" %% \",\".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. \"2.0\" over \"2.0rc1\"\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix):]\n            if verbose:\n                print(\"picking %%s\" %% r)\n            return {\"version\": r,\n                    \"full-revisionid\": keywords[\"full\"].strip(),\n                    \"dirty\": False, \"error\": None,\n                    \"date\": date}\n    # no suitable tags, so version is \"0+unknown\", but full hex is still there\n    if verbose:\n        print(\"no suitable tags, using unknown + full revision id\")\n    return {\"version\": \"0+unknown\",\n            \"full-revisionid\": keywords[\"full\"].strip(),\n            \"dirty\": False, \"error\": \"no suitable tags\", \"date\": None}\n", "docstring": "Get version information from git keywords.\n"}
{"repo": "eliot-master/versioneer.py", "original_string": "def render_pep440(pieces):\n    \"\"\"Build up version string, with post-release \"local version identifier\".\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += plus_or_dot(pieces)\n            rendered += \"%%d.g%%s\" %% (pieces[\"distance\"], pieces[\"short\"])\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0+untagged.%%d.g%%s\" %% (pieces[\"distance\"],\n                                          pieces[\"short\"])\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n", "docstring": "Build up version string, with post-release \"local version identifier\"."}
{"repo": "eliot-master/versioneer.py", "original_string": "def render_pep440_post(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]+gHEX] .\n    The \".dev0\" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear \"older\" than the corresponding clean one),\n    but you shouldn't be releasing software with -dirty anyways.\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%%d\" %% pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"g%%s\" %% pieces[\"short\"]\n    else:\n        # exception #1\n        rendered = \"0.post%%d\" %% pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n        rendered += \"+g%%s\" %% pieces[\"short\"]\n    return rendered\n", "docstring": "TAG[.postDISTANCE[.dev0]+gHEX] ."}
{"repo": "eliot-master/versioneer.py", "original_string": "def render_git_describe(pieces):\n    \"\"\"TAG[-DISTANCE-gHEX][-dirty].\n    Like 'git describe --tags --dirty --always'.\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"]:\n            rendered += \"-%%d-g%%s\" %% (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n", "docstring": "TAG[-DISTANCE-gHEX][-dirty]."}
{"repo": "eliot-master/versioneer.py", "original_string": "def render(pieces, style):\n    \"\"\"Render the given version pieces into the requested style.\"\"\"\n    if pieces[\"error\"]:\n        return {\"version\": \"unknown\",\n                \"full-revisionid\": pieces.get(\"long\"),\n                \"dirty\": None,\n                \"error\": pieces[\"error\"],\n                \"date\": None}\n    if not style or style == \"default\":\n        style = \"pep440\"  # the default\n    if style == \"pep440\":\n        rendered = render_pep440(pieces)\n    elif style == \"pep440-pre\":\n        rendered = render_pep440_pre(pieces)\n    elif style == \"pep440-post\":\n        rendered = render_pep440_post(pieces)\n    elif style == \"pep440-old\":\n        rendered = render_pep440_old(pieces)\n    elif style == \"git-describe\":\n        rendered = render_git_describe(pieces)\n    elif style == \"git-describe-long\":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(\"unknown style '%%s'\" %% style)\n    return {\"version\": rendered, \"full-revisionid\": pieces[\"long\"],\n            \"dirty\": pieces[\"dirty\"], \"error\": None,\n            \"date\": pieces.get(\"date\")}\n", "docstring": "Render the given version pieces into the requested style.\n"}
{"repo": "eliot-master/versioneer.py", "original_string": "def git_get_keywords(versionfile_abs):\n    \"\"\"Extract version information from the given file.\"\"\"\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don't want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        f = open(versionfile_abs, \"r\")\n        for line in f.readlines():\n            if line.strip().startswith(\"git_refnames =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"refnames\"] = mo.group(1)\n            if line.strip().startswith(\"git_full =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"full\"] = mo.group(1)\n            if line.strip().startswith(\"git_date =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"date\"] = mo.group(1)\n        f.close()\n    except EnvironmentError:\n        pass\n    return keywords\n", "docstring": "Extract version information from the given file.\n"}
{"repo": "eliot-master/versioneer.py", "original_string": "def git_versions_from_keywords(keywords, tag_prefix, verbose):\n    \"\"\"Get version information from git keywords.\"\"\"\n    if not keywords:\n        raise NotThisMethod(\"no keywords at all, weird\")\n    date = keywords.get(\"date\")\n    if date is not None:\n        # git-2.2.0 added \"%cI\", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer \"%ci\" (which expands to an \"ISO-8601\n        # -like\" string, which we must then edit to make compliant), because\n        # it's been around since git-1.5.3, and it's too difficult to\n        # discover which version we're using, or to work around using an\n        # older one.\n        date = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n    refnames = keywords[\"refnames\"].strip()\n    if refnames.startswith(\"$Format\"):\n        if verbose:\n            print(\"keywords are unexpanded, not using\")\n        raise NotThisMethod(\"unexpanded keywords, not a git-archive tarball\")\n    refs = set([r.strip() for r in refnames.strip(\"()\").split(\",\")])\n    # starting in git-1.8.3, tags are listed as \"tag: foo-1.0\" instead of\n    # just \"foo-1.0\". If we see a \"tag: \" prefix, prefer those.\n    TAG = \"tag: \"\n    tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)])\n    if not tags:\n        # Either we're using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like \"release\" and\n        # \"stabilization\", as well as \"HEAD\" and \"master\".\n        tags = set([r for r in refs if re.search(r'\\d', r)])\n        if verbose:\n            print(\"discarding '%s', no digits\" % \",\".join(refs - tags))\n    if verbose:\n        print(\"likely tags: %s\" % \",\".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. \"2.0\" over \"2.0rc1\"\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix):]\n            if verbose:\n                print(\"picking %s\" % r)\n            return {\"version\": r,\n                    \"full-revisionid\": keywords[\"full\"].strip(),\n                    \"dirty\": False, \"error\": None,\n                    \"date\": date}\n    # no suitable tags, so version is \"0+unknown\", but full hex is still there\n    if verbose:\n        print(\"no suitable tags, using unknown + full revision id\")\n    return {\"version\": \"0+unknown\",\n            \"full-revisionid\": keywords[\"full\"].strip(),\n            \"dirty\": False, \"error\": \"no suitable tags\", \"date\": None}\n", "docstring": "Get version information from git keywords.\n"}
{"repo": "eliot-master/versioneer.py", "original_string": "def versions_from_parentdir(parentdir_prefix, root, verbose):\n    \"\"\"Try to determine the version from the parent directory name.\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    \"\"\"\n    rootdirs = []\n    for i in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {\"version\": dirname[len(parentdir_prefix):],\n                    \"full-revisionid\": None,\n                    \"dirty\": False, \"error\": None, \"date\": None}\n        else:\n            rootdirs.append(root)\n            root = os.path.dirname(root)  # up a level\n    if verbose:\n        print(\"Tried directories %s but none started with prefix %s\" %\n              (str(rootdirs), parentdir_prefix))\n    raise NotThisMethod(\"rootdir doesn't start with parentdir_prefix\")\n", "docstring": "Try to determine the version from the parent directory name."}
{"repo": "eliot-master/versioneer.py", "original_string": "def versions_from_file(filename):\n    \"\"\"Try to determine the version from _version.py if present.\"\"\"\n    try:\n        with open(filename) as f:\n            contents = f.read()\n    except EnvironmentError:\n        raise NotThisMethod(\"unable to read _version.py\")\n    mo = re.search(r\"version_json = '''\\n(.*)'''  # END VERSION_JSON\",\n                   contents, re.M | re.S)\n    if not mo:\n        mo = re.search(r\"version_json = '''\\r\\n(.*)'''  # END VERSION_JSON\",\n                       contents, re.M | re.S)\n    if not mo:\n        raise NotThisMethod(\"no version_json in _version.py\")\n    return json.loads(mo.group(1))\n", "docstring": "Try to determine the version from _version.py if present.\n"}
{"repo": "eliot-master/versioneer.py", "original_string": "def plus_or_dot(pieces):\n    \"\"\"Return a + if we don't already have one, else return a .\"\"\"\n    if \"+\" in pieces.get(\"closest-tag\", \"\"):\n        return \".\"\n    return \"+\"\n", "docstring": "Return a + if we don't already have one, else return a .\n"}
{"repo": "eliot-master/versioneer.py", "original_string": "def render_pep440_pre(pieces):\n    \"\"\"TAG[.post.devDISTANCE] -- No -dirty.\n    Exceptions:\n    1: no tags. 0.post.devDISTANCE\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"]:\n            rendered += \".post.dev%d\" % pieces[\"distance\"]\n    else:\n        # exception #1\n        rendered = \"0.post.dev%d\" % pieces[\"distance\"]\n    return rendered\n", "docstring": "TAG[.post.devDISTANCE] -- No -dirty."}
{"repo": "eliot-master/versioneer.py", "original_string": "def render_pep440_old(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]] .\n    The \".dev0\" means dirty.\n    Eexceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%d\" % pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n    else:\n        # exception #1\n        rendered = \"0.post%d\" % pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n    return rendered\n", "docstring": "TAG[.postDISTANCE[.dev0]] ."}
{"repo": "eliot-master/versioneer.py", "original_string": "def render_git_describe_long(pieces):\n    \"\"\"TAG-DISTANCE-gHEX[-dirty].\n    Like 'git describe --tags --dirty --always -long'.\n    The distance/hash is unconditional.\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n", "docstring": "TAG-DISTANCE-gHEX[-dirty]."}
{"repo": "eliot-master/versioneer.py", "original_string": "def get_versions(verbose=False):\n    \"\"\"Get the project version from whatever source is available.\n    Returns dict with two keys: 'version' and 'full'.\n    \"\"\"\n    if \"versioneer\" in sys.modules:\n        # see the discussion in cmdclass.py:get_cmdclass()\n        del sys.modules[\"versioneer\"]\n    root = get_root()\n    cfg = get_config_from_root(root)\n    assert cfg.VCS is not None, \"please set [versioneer]VCS= in setup.cfg\"\n    handlers = HANDLERS.get(cfg.VCS)\n    assert handlers, \"unrecognized VCS '%s'\" % cfg.VCS\n    verbose = verbose or cfg.verbose\n    assert cfg.versionfile_source is not None, \\\n        \"please set versioneer.versionfile_source\"\n    assert cfg.tag_prefix is not None, \"please set versioneer.tag_prefix\"\n    versionfile_abs = os.path.join(root, cfg.versionfile_source)\n    # extract version from first of: _version.py, VCS command (e.g. 'git\n    # describe'), parentdir. This is meant to work for developers using a\n    # source checkout, for users of a tarball created by 'setup.py sdist',\n    # and for users of a tarball/zipball created by 'git archive' or github's\n    # download-from-tag feature or the equivalent in other VCSes.\n    get_keywords_f = handlers.get(\"get_keywords\")\n    from_keywords_f = handlers.get(\"keywords\")\n    if get_keywords_f and from_keywords_f:\n        try:\n            keywords = get_keywords_f(versionfile_abs)\n            ver = from_keywords_f(keywords, cfg.tag_prefix, verbose)\n            if verbose:\n                print(\"got version from expanded keyword %s\" % ver)\n            return ver\n        except NotThisMethod:\n            pass\n    try:\n        ver = versions_from_file(versionfile_abs)\n        if verbose:\n            print(\"got version from file %s %s\" % (versionfile_abs, ver))\n        return ver\n    except NotThisMethod:\n        pass\n    from_vcs_f = handlers.get(\"pieces_from_vcs\")\n    if from_vcs_f:\n        try:\n            pieces = from_vcs_f(cfg.tag_prefix, root, verbose)\n            ver = render(pieces, cfg.style)\n            if verbose:\n                print(\"got version from VCS %s\" % ver)\n            return ver\n        except NotThisMethod:\n            pass\n    try:\n        if cfg.parentdir_prefix:\n            ver = versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n            if verbose:\n                print(\"got version from parentdir %s\" % ver)\n            return ver\n    except NotThisMethod:\n        pass\n    if verbose:\n        print(\"unable to compute version\")\n    return {\"version\": \"0+unknown\", \"full-revisionid\": None,\n            \"dirty\": None, \"error\": \"unable to compute version\",\n            \"date\": None}\n", "docstring": "Get the project version from whatever source is available."}
{"repo": "eliot-master/examples/dask_eliot.py", "original_string": "def main():\n    # Setup logging on the main process:\n    _start_logging()\n    # Start three worker processes on the local machine:\n    client = Client(n_workers=3, threads_per_worker=1)\n    # Setup Eliot logging on each worker process:\n    client.run(_start_logging)\n    # Run the Dask computation in the worker processes:\n    result = main_computation()\n    print(\"Result:\", result)\n", "docstring": "Setup logging on the main process:"}
{"repo": "eliot-master/eliot/twisted.py", "original_string": "        def callbackWithContext(*args, **kwargs):\n            return self._action.run(callback, *args, **kwargs)\n", "docstring": "return self._action.run(callback, *args, **kwargs)"}
{"repo": "eliot-master/eliot/twisted.py", "original_string": "        def done(result):\n            if isinstance(result, Failure):\n                exception = result.value\n            else:\n                exception = None\n            self._action.finish(exception)\n            return result\n", "docstring": "if isinstance(result, Failure):"}
{"repo": "eliot-master/eliot/_version.py", "original_string": "def get_keywords():\n    \"\"\"Get the keywords needed to look up the version information.\"\"\"\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = \" (HEAD -> master)\"\n    git_full = \"8609d380866491abe9e97eb814e4a04478b5893e\"\n    git_date = \"2021-05-19 17:07:25 -0400\"\n    keywords = {\"refnames\": git_refnames, \"full\": git_full, \"date\": git_date}\n    return keywords\n", "docstring": "Get the keywords needed to look up the version information.\n"}
{"repo": "eliot-master/eliot/_version.py", "original_string": "def get_config():\n    \"\"\"Create, populate and return the VersioneerConfig() object.\"\"\"\n    # these strings are filled in when 'setup.py versioneer' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = \"git\"\n    cfg.style = \"pep440\"\n    cfg.tag_prefix = \"\"\n    cfg.parentdir_prefix = \"eliot-\"\n    cfg.versionfile_source = \"eliot/_version.py\"\n    cfg.verbose = False\n    return cfg\n", "docstring": "Create, populate and return the VersioneerConfig() object.\n"}
{"repo": "eliot-master/eliot/_version.py", "original_string": "def register_vcs_handler(vcs, method):  # decorator\n    \"\"\"Decorator to mark a method as the handler for a particular VCS.\"\"\"\n    def decorate(f):\n        \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n    return decorate\n", "docstring": "Decorator to mark a method as the handler for a particular VCS.\n"}
{"repo": "eliot-master/eliot/_version.py", "original_string": "def versions_from_parentdir(parentdir_prefix, root, verbose):\n    \"\"\"Try to determine the version from the parent directory name.\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    \"\"\"\n    rootdirs = []\n    for i in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {\n                \"version\": dirname[len(parentdir_prefix) :],\n                \"full-revisionid\": None,\n                \"dirty\": False,\n                \"error\": None,\n                \"date\": None,\n            }\n        else:\n            rootdirs.append(root)\n            root = os.path.dirname(root)  # up a level\n    if verbose:\n        print(\n            \"Tried directories %s but none started with prefix %s\"\n            % (str(rootdirs), parentdir_prefix)\n        )\n    raise NotThisMethod(\"rootdir doesn't start with parentdir_prefix\")\n", "docstring": "Try to determine the version from the parent directory name."}
{"repo": "eliot-master/eliot/_version.py", "original_string": "def git_get_keywords(versionfile_abs):\n    \"\"\"Extract version information from the given file.\"\"\"\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don't want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        f = open(versionfile_abs, \"r\")\n        for line in f.readlines():\n            if line.strip().startswith(\"git_refnames =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"refnames\"] = mo.group(1)\n            if line.strip().startswith(\"git_full =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"full\"] = mo.group(1)\n            if line.strip().startswith(\"git_date =\"):\n                mo = re.search(r'=\\s*\"(.*)\"', line)\n                if mo:\n                    keywords[\"date\"] = mo.group(1)\n        f.close()\n    except EnvironmentError:\n        pass\n    return keywords\n", "docstring": "Extract version information from the given file.\n"}
{"repo": "eliot-master/eliot/_version.py", "original_string": "def git_versions_from_keywords(keywords, tag_prefix, verbose):\n    \"\"\"Get version information from git keywords.\"\"\"\n    if not keywords:\n        raise NotThisMethod(\"no keywords at all, weird\")\n    date = keywords.get(\"date\")\n    if date is not None:\n        # git-2.2.0 added \"%cI\", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer \"%ci\" (which expands to an \"ISO-8601\n        # -like\" string, which we must then edit to make compliant), because\n        # it's been around since git-1.5.3, and it's too difficult to\n        # discover which version we're using, or to work around using an\n        # older one.\n        date = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n    refnames = keywords[\"refnames\"].strip()\n    if refnames.startswith(\"$Format\"):\n        if verbose:\n            print(\"keywords are unexpanded, not using\")\n        raise NotThisMethod(\"unexpanded keywords, not a git-archive tarball\")\n    refs = set([r.strip() for r in refnames.strip(\"()\").split(\",\")])\n    # starting in git-1.8.3, tags are listed as \"tag: foo-1.0\" instead of\n    # just \"foo-1.0\". If we see a \"tag: \" prefix, prefer those.\n    TAG = \"tag: \"\n    tags = set([r[len(TAG) :] for r in refs if r.startswith(TAG)])\n    if not tags:\n        # Either we're using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like \"release\" and\n        # \"stabilization\", as well as \"HEAD\" and \"master\".\n        tags = set([r for r in refs if re.search(r\"\\d\", r)])\n        if verbose:\n            print(\"discarding '%s', no digits\" % \",\".join(refs - tags))\n    if verbose:\n        print(\"likely tags: %s\" % \",\".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. \"2.0\" over \"2.0rc1\"\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix) :]\n            if verbose:\n                print(\"picking %s\" % r)\n            return {\n                \"version\": r,\n                \"full-revisionid\": keywords[\"full\"].strip(),\n                \"dirty\": False,\n                \"error\": None,\n                \"date\": date,\n            }\n    # no suitable tags, so version is \"0+unknown\", but full hex is still there\n    if verbose:\n        print(\"no suitable tags, using unknown + full revision id\")\n    return {\n        \"version\": \"0+unknown\",\n        \"full-revisionid\": keywords[\"full\"].strip(),\n        \"dirty\": False,\n        \"error\": \"no suitable tags\",\n        \"date\": None,\n    }\n", "docstring": "Get version information from git keywords.\n"}
{"repo": "eliot-master/eliot/_version.py", "original_string": "def render_pep440(pieces):\n    \"\"\"Build up version string, with post-release \"local version identifier\".\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += plus_or_dot(pieces)\n            rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0+untagged.%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n", "docstring": "Build up version string, with post-release \"local version identifier\"."}
{"repo": "eliot-master/eliot/_version.py", "original_string": "def render_pep440_post(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]+gHEX] .\n    The \".dev0\" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear \"older\" than the corresponding clean one),\n    but you shouldn't be releasing software with -dirty anyways.\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%d\" % pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"g%s\" % pieces[\"short\"]\n    else:\n        # exception #1\n        rendered = \"0.post%d\" % pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n        rendered += \"+g%s\" % pieces[\"short\"]\n    return rendered\n", "docstring": "TAG[.postDISTANCE[.dev0]+gHEX] ."}
{"repo": "eliot-master/eliot/_version.py", "original_string": "def render_git_describe(pieces):\n    \"\"\"TAG[-DISTANCE-gHEX][-dirty].\n    Like 'git describe --tags --dirty --always'.\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"]:\n            rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n", "docstring": "TAG[-DISTANCE-gHEX][-dirty]."}
{"repo": "eliot-master/eliot/_version.py", "original_string": "def render(pieces, style):\n    \"\"\"Render the given version pieces into the requested style.\"\"\"\n    if pieces[\"error\"]:\n        return {\n            \"version\": \"unknown\",\n            \"full-revisionid\": pieces.get(\"long\"),\n            \"dirty\": None,\n            \"error\": pieces[\"error\"],\n            \"date\": None,\n        }\n    if not style or style == \"default\":\n        style = \"pep440\"  # the default\n    if style == \"pep440\":\n        rendered = render_pep440(pieces)\n    elif style == \"pep440-pre\":\n        rendered = render_pep440_pre(pieces)\n    elif style == \"pep440-post\":\n        rendered = render_pep440_post(pieces)\n    elif style == \"pep440-old\":\n        rendered = render_pep440_old(pieces)\n    elif style == \"git-describe\":\n        rendered = render_git_describe(pieces)\n    elif style == \"git-describe-long\":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(\"unknown style '%s'\" % style)\n    return {\n        \"version\": rendered,\n        \"full-revisionid\": pieces[\"long\"],\n        \"dirty\": pieces[\"dirty\"],\n        \"error\": None,\n        \"date\": pieces.get(\"date\"),\n    }\n", "docstring": "Render the given version pieces into the requested style.\n"}
{"repo": "eliot-master/eliot/_action.py", "original_string": "    def __init__(self, level):\n        self._level = level\n", "docstring": "self._level = level"}
{"repo": "eliot-master/eliot/_action.py", "original_string": "    def log(self, message_type, **fields):\n        \"\"\"Log individual message.\"\"\"\n        fields[TIMESTAMP_FIELD] = time.time()\n        fields[TASK_UUID_FIELD] = self._identification[TASK_UUID_FIELD]\n        fields[TASK_LEVEL_FIELD] = self._nextTaskLevel().as_list()\n        fields[MESSAGE_TYPE_FIELD] = message_type\n        self._logger.write(fields, fields.pop(\"__eliot_serializer__\", None))\n", "docstring": "Log individual message.\n"}
{"repo": "eliot-master/eliot/_action.py", "original_string": "    def __init__(self, action, message):\n        Exception.__init__(\n            self,\n            \"Tried to add {} to {}. Expected task_uuid = {}, got {}\".format(\n                message, action, action.task_uuid, message.task_uuid\n            ),\n        )\n", "docstring": "Exception.__init__("}
{"repo": "eliot-master/eliot/_action.py", "original_string": "    def logging_wrapper(*args, **kwargs):\n        callargs = getcallargs(wrapped_function, *args, **kwargs)\n        # Remove self is it's included:\n        if \"self\" in callargs:\n            callargs.pop(\"self\")\n        # Filter arguments to log, if necessary:\n        if include_args is not None:\n            callargs = {k: callargs[k] for k in include_args}\n        with start_action(action_type=action_type, **callargs) as ctx:\n            result = wrapped_function(*args, **kwargs)\n            if include_result:\n                ctx.add_success_fields(result=result)\n            return result\n", "docstring": "Remove self is it's included:"}
{"repo": "eliot-master/eliot/_action.py", "original_string": "def log_message(message_type, **fields):\n    \"\"\"Log a message in the context of the current action.\n    If there is no current action, a new UUID will be generated.\n    \"\"\"\n    # Loggers will hopefully go away...\n    logger = fields.pop(\"__eliot_logger__\", None)\n    action = current_action()\n    if action is None:\n        action = Action(logger, str(uuid4()), TaskLevel(level=[]), \"\")\n    action.log(message_type, **fields)\n", "docstring": "Log a message in the context of the current action."}
{"repo": "eliot-master/eliot/journald.py", "original_string": "    def __init__(self):\n        self._identifier = basename(argv[0]).encode(\"utf-8\")\n", "docstring": "self._identifier = basename(argv[0]).encode(\"utf-8\")"}
{"repo": "eliot-master/eliot/prettyprint.py", "original_string": "def _render_timestamp(message: dict, local_timezone: bool) -> str:\n    \"\"\"Convert a message's timestamp to a string.\"\"\"\n    # If we were returning or storing the datetime we'd want to use an\n    # explicit timezone instead of a naive datetime, but since we're\n    # just using it for formatting we needn't bother.\n    if local_timezone:\n        dt = datetime.fromtimestamp(message[TIMESTAMP_FIELD])\n    else:\n        dt = datetime.utcfromtimestamp(message[TIMESTAMP_FIELD])\n    result = dt.isoformat(sep=\"T\")\n    if not local_timezone:\n        result += \"Z\"\n    return result\n", "docstring": "Convert a message's timestamp to a string.\n"}
{"repo": "eliot-master/eliot/prettyprint.py", "original_string": "def compact_format(message: dict, local_timezone: bool = False) -> str:\n    \"\"\"Format an Eliot message into a single line.\n    The message is presumed to be JSON-serializable.\n    \"\"\"\n    ordered_message = OrderedDict()\n    for field in _first_fields:\n        if field in message:\n            ordered_message[field] = message[field]\n    for (key, value) in sorted(message.items()):\n        if key not in _skip_fields:\n            ordered_message[key] = value\n    # drop { and } from JSON:\n    rendered = \" \".join(\n        \"{}={}\".format(key, dumps(value, separators=(\",\", \":\")))\n        for (key, value) in ordered_message.items()\n    )\n    return \"%s%s %s %s\" % (\n        message[TASK_UUID_FIELD],\n        \"/\" + \"/\".join(map(str, message[TASK_LEVEL_FIELD])),\n        _render_timestamp(message, local_timezone),\n        rendered,\n    )\n", "docstring": "Format an Eliot message into a single line."}
{"repo": "eliot-master/eliot/_generators.py", "original_string": "    def in_generator(self, generator):\n        \"\"\"Context manager: set the given generator as the current generator.\"\"\"\n        previous_generator = self._current_generator\n        try:\n            self._current_generator = generator\n            yield\n        finally:\n            self._current_generator = previous_generator\n", "docstring": "Context manager: set the given generator as the current generator.\n"}
{"repo": "eliot-master/eliot/dask.py", "original_string": "def compute_with_trace(*args):\n    \"\"\"Do Dask compute(), but with added Eliot tracing.\n    Dask is a graph of tasks, but Eliot logs trees.  So we need to emulate a\n    graph using a tree.  We do this by making Eliot action for each task, but\n    having it list the tasks it depends on.\n    We use the following algorithm:\n        1. Create a top-level action.\n        2. For each entry in the dask graph, create a child with\n           serialize_task_id.  Do this in likely order of execution, so that\n           if B depends on A the task level of B is higher than the task Ievel\n           of A.\n        3. Replace each function with a wrapper that uses the corresponding\n           task ID (with Action.continue_task), and while it's at it also\n           records which other things this function depends on.\n    Known issues:\n        1. Retries will confuse Eliot.  Probably need different\n           distributed-tree mechanism within Eliot to solve that.\n    \"\"\"\n    # 1. Create top-level Eliot Action:\n    with start_action(action_type=\"dask:compute\"):\n        # In order to reduce logging verbosity, add logging to the already\n        # optimized graph:\n        optimized = optimize(*args, optimizations=[_add_logging])\n        return compute(*optimized, optimize_graph=False)\n", "docstring": "Do Dask compute(), but with added Eliot tracing."}
{"repo": "eliot-master/eliot/testing.py", "original_string": "    def __new__(cls, startMessage, endMessage, children):\n        return PClass.__new__(\n            cls, startMessage=startMessage, endMessage=endMessage, children=children\n        )\n", "docstring": "return PClass.__new__("}
{"repo": "eliot-master/eliot/testing.py", "original_string": "    def __new__(cls, message):\n        return PClass.__new__(cls, message=message)\n", "docstring": "return PClass.__new__(cls, message=message)"}
{"repo": "eliot-master/eliot/testing.py", "original_string": "def validateLogging(\n    assertion, *assertionArgs, encoder_=EliotJSONEncoder, **assertionKwargs\n", "docstring": "assertion, *assertionArgs, encoder_=EliotJSONEncoder, **assertionKwargs"}
{"repo": "eliot-master/eliot/_validation.py", "original_string": "    def __init__(self, fields, allow_additional_fields=False):\n        keys = []\n        for field in fields:\n            if not isinstance(field, Field):\n                raise TypeError(\"Expected a Field instance but got\", field)\n            keys.append(field.key)\n        if len(set(keys)) != len(keys):\n            raise ValueError(keys, \"Duplicate field name\")\n        if ACTION_TYPE_FIELD in keys:\n            if MESSAGE_TYPE_FIELD in keys:\n                raise ValueError(\n                    keys,\n                    \"Messages must have either \"\n                    \"'action_type' or 'message_type', not both\",\n                )\n        elif MESSAGE_TYPE_FIELD not in keys:\n            raise ValueError(\n                keys, \"Messages must have either 'action_type' \", \"or 'message_type'\"\n            )\n        if any(key.startswith(\"_\") for key in keys):\n            raise ValueError(keys, \"Field names must not start with '_'\")\n        for reserved in RESERVED_FIELDS:\n            if reserved in keys:\n                raise ValueError(\n                    keys,\n                    \"The field name %r is reserved for use \"\n                    \"by the logging framework\" % (reserved,),\n                )\n        self.fields = dict((field.key, field) for field in fields)\n        self.allow_additional_fields = allow_additional_fields\n", "docstring": "keys = []"}
{"repo": "eliot-master/eliot/_validation.py", "original_string": "        def setstatus(key, status):\n            doactualset(key, status)\n            LOG_STATUS(key=key, status=status).write()\n", "docstring": "doactualset(key, status)"}
{"repo": "eliot-master/eliot/_validation.py", "original_string": "        def dosomething(key):\n            with LOG_DOSOMETHING(logger, key=key) as action:\n                _dostuff(key)\n                _morestuff(key)\n                result = _theresult()\n                action.addSuccessFields(result=result)\n            return result\n", "docstring": "with LOG_DOSOMETHING(logger, key=key) as action:"}
{"repo": "eliot-master/eliot/__init__.py", "original_string": "def _parse_compat():\n    # Force eliot.parse to be imported in way that works with old Python:\n    from .parse import Parser\n    del Parser\n    import sys\n    sys.modules[\"eliot._parse\"] = sys.modules[\"eliot.parse\"]\n    return sys.modules[\"eliot.parse\"]\n", "docstring": "Force eliot.parse to be imported in way that works with old Python:"}
{"repo": "eliot-master/eliot/_output.py", "original_string": "    def __new__(cls, file, encoder=EliotJSONEncoder):\n        if isinstance(file, IOBase) and not file.writable():\n            raise RuntimeError(\"Given file {} is not writeable.\")\n        unicodeFile = False\n        try:\n            file.write(b\"\")\n        except TypeError:\n            unicodeFile = True\n        if unicodeFile:\n            # On Python 3 native json module outputs unicode:\n            _dumps = pyjson.dumps\n            _linebreak = \"\\n\"\n        else:\n            _dumps = bytesjson.dumps\n            _linebreak = b\"\\n\"\n        return PClass.__new__(\n            cls, file=file, _dumps=_dumps, _linebreak=_linebreak, encoder=encoder\n        )\n", "docstring": "if isinstance(file, IOBase) and not file.writable():"}
{"repo": "eliot-master/eliot/_bytesjson.py", "original_string": "        def default(self, o):\n            if isinstance(o, bytes):\n                warnings.warn(\n                    \"Eliot will soon stop supporting encoding bytes in JSON\"\n                    \" on Python 3\",\n                    DeprecationWarning,\n                )\n                return o.decode(\"utf-8\")\n            return cls.default(self, o)\n", "docstring": "if isinstance(o, bytes):"}
{"repo": "eliot-master/eliot/tests/test_twisted.py", "original_string": "    def test(self):\n        with action.context():\n            return f(self)\n", "docstring": "with action.context():"}
{"repo": "eliot-master/eliot/tests/test_twisted.py", "original_string": "        def raiser():\n            raise RuntimeError(\"because\")\n", "docstring": "raise RuntimeError(\"because\")"}
{"repo": "eliot-master/eliot/tests/test_twisted.py", "original_string": "    def _a_b_test(self, logger, g):\n        \"\"\"A yield was done in between messages a and b inside C{inline_callbacks}.\"\"\"\n        with start_action(action_type=\"the-action\"):\n            self.assertIs(None, self.successResultOf(g()))\n        assert_expected_action_tree(self, logger, \"the-action\", [\"a\", \"yielded\", \"b\"])\n", "docstring": "A yield was done in between messages a and b inside C{inline_callbacks}.\n"}
{"repo": "eliot-master/eliot/tests/test_parse.py", "original_string": "    def test_parse_into_tasks(\n        self, structure_and_messages1, structure_and_messages2, structure_and_messages3\n", "docstring": "self, structure_and_messages1, structure_and_messages2, structure_and_messages3"}
{"repo": "eliot-master/eliot/tests/test_parse.py", "original_string": "    def test_parse_stream(\n        self, structure_and_messages1, structure_and_messages2, structure_and_messages3\n", "docstring": "self, structure_and_messages1, structure_and_messages2, structure_and_messages3"}
{"repo": "eliot-master/eliot/tests/test_logwriter.py", "original_string": "    def write(self, data):\n        with self.lock:\n            self.file.write(data)\n", "docstring": "with self.lock:"}
{"repo": "eliot-master/eliot/tests/test_logwriter.py", "original_string": "        def done(_):\n            self.assertEqual(f.getvalue(), b'{\"hello\": 123}\\n')\n            self.assertNotEqual(threading.enumerate(), threads)\n", "docstring": "self.assertEqual(f.getvalue(), b'{\"hello\": 123}\\n')"}
{"repo": "eliot-master/eliot/tests/test_logwriter.py", "original_string": "        def destination(message):\n            result.append((message, threading.currentThread().ident))\n", "docstring": "result.append((message, threading.currentThread().ident))"}
{"repo": "eliot-master/eliot/tests/test_logwriter.py", "original_string": "        def done(_):\n            self.assertTrue(f.closed)\n", "docstring": "self.assertTrue(f.closed)"}
{"repo": "eliot-master/eliot/tests/test_output.py", "original_string": "        def write(msg, serializer):\n            for i in range(write_count):\n                logger.write(msg, serializer)\n", "docstring": "for i in range(write_count):"}
{"repo": "eliot-master/eliot/tests/test_output.py", "original_string": "            def __repr__(self):\n                raise TypeError()\n", "docstring": "raise TypeError()"}
{"repo": "eliot-master/eliot/tests/test_output.py", "original_string": "            def __repr__(self):\n                raise TypeError()\n", "docstring": "raise TypeError()"}
{"repo": "eliot-master/eliot/tests/test_output.py", "original_string": "        def always_raise(message):\n            raise ZeroDivisionError()\n", "docstring": "raise ZeroDivisionError()"}
{"repo": "eliot-master/eliot/tests/test_output.py", "original_string": "    def test_default_encoder_is_EliotJSONEncoder(self):\n        \"\"\"The default encoder if none are specified is EliotJSONEncoder.\"\"\"\n        message = {\"x\": np.int64(3)}\n        f = StringIO()\n        destination = FileDestination(file=f)\n        destination(message)\n        self.assertEqual(\n            [json.loads(line) for line in f.getvalue().splitlines()], [{\"x\": 3}]\n        )\n", "docstring": "The default encoder if none are specified is EliotJSONEncoder.\n"}
{"repo": "eliot-master/eliot/tests/test_journald.py", "original_string": "    def setUp(self):\n        self.destination = JournaldDestination()\n        self.logger = MemoryLogger()\n", "docstring": "self.destination = JournaldDestination()"}
{"repo": "eliot-master/eliot/tests/test_dask.py", "original_string": "    def test_future(self):\n        \"\"\"compute_with_trace() can handle Futures.\"\"\"\n        client = Client(processes=False)\n        self.addCleanup(client.shutdown)\n        [bag] = dask.persist(from_sequence([1, 2, 3]))\n        bag = bag.map(lambda x: x * 5)\n        result = dask.compute(bag)\n        self.assertEqual(result, ([5, 10, 15],))\n        self.assertEqual(result, compute_with_trace(bag))\n", "docstring": "compute_with_trace() can handle Futures.\n"}
{"repo": "eliot-master/eliot/tests/test_dask.py", "original_string": "    def test_persist_pandas(self):\n        \"\"\"persist_with_trace() with a Pandas dataframe.\n        This ensures we don't blow up, which used to be the case.\n        \"\"\"\n        df = pd.DataFrame()\n        df = dd.from_pandas(df, npartitions=1)\n        persist_with_trace(df)\n", "docstring": "persist_with_trace() with a Pandas dataframe."}
{"repo": "eliot-master/eliot/tests/test_dask.py", "original_string": "    def test_persist_logging(self, logger):\n        \"\"\"persist_with_trace() preserves Eliot context.\"\"\"\n        def persister(bag):\n            [bag] = persist_with_trace(bag)\n            return dask.compute(bag)\n        self.assert_logging(logger, persister, \"dask:persist\")\n", "docstring": "persist_with_trace() preserves Eliot context.\n"}
{"repo": "eliot-master/eliot/tests/test_dask.py", "original_string": "    def test_compute_logging(self, logger):\n        \"\"\"compute_with_trace() preserves Eliot context.\"\"\"\n        self.assert_logging(logger, compute_with_trace, \"dask:compute\")\n", "docstring": "compute_with_trace() preserves Eliot context.\n"}
{"repo": "eliot-master/eliot/tests/test_dask.py", "original_string": "    def test_add_logging_to_full_graph(self):\n        \"\"\"_add_logging() recreates Dask graph with wrappers.\"\"\"\n        bag = from_sequence([1, 2, 3])\n        bag = bag.map(lambda x: x * 7).map(lambda x: x * 4)\n        bag = bag.fold(lambda x, y: x + y)\n        graph = bag.__dask_graph__()\n        # Add logging:\n        with start_action(action_type=\"bleh\"):\n            logging_added = _add_logging(graph)\n        # Ensure resulting graph hasn't changed substantively:\n        logging_removed = {}\n        for key, value in logging_added.items():\n            if callable(value[0]):\n                func, args = value[0], value[1:]\n                self.assertIsInstance(func, _RunWithEliotContext)\n                value = (func.func,) + args\n            logging_removed[key] = value\n        self.assertEqual(logging_removed, graph)\n", "docstring": "_add_logging() recreates Dask graph with wrappers.\n"}
{"repo": "eliot-master/eliot/tests/test_json.py", "original_string": "    def test_nan_inf(self):\n        \"\"\"NaN, inf and -inf are round-tripped.\"\"\"\n        l = [float(\"nan\"), float(\"inf\"), float(\"-inf\")]\n        roundtripped = loads(dumps(l, cls=EliotJSONEncoder))\n        self.assertEqual(l[1:], roundtripped[1:])\n        self.assertTrue(isnan(roundtripped[0]))\n", "docstring": "NaN, inf and -inf are round-tripped.\n"}
{"repo": "eliot-master/eliot/tests/test_json.py", "original_string": "    def test_numpy(self):\n        \"\"\"NumPy objects get serialized to readable JSON.\"\"\"\n        l = [\n            np.float32(12.5),\n            np.float64(2.0),\n            np.float16(0.5),\n            np.bool(True),\n            np.bool(False),\n            np.bool_(True),\n            np.unicode_(\"hello\"),\n            np.byte(12),\n            np.short(12),\n            np.intc(-13),\n            np.int_(0),\n            np.longlong(100),\n            np.intp(7),\n            np.ubyte(12),\n            np.ushort(12),\n            np.uintc(13),\n            np.ulonglong(100),\n            np.uintp(7),\n            np.int8(1),\n            np.int16(3),\n            np.int32(4),\n            np.int64(5),\n            np.uint8(1),\n            np.uint16(3),\n            np.uint32(4),\n            np.uint64(5),\n        ]\n        l2 = [l, np.array([1, 2, 3])]\n        roundtripped = loads(dumps(l2, cls=EliotJSONEncoder))\n        self.assertEqual([l, [1, 2, 3]], roundtripped)\n", "docstring": "NumPy objects get serialized to readable JSON.\n"}
{"repo": "eliot-master/eliot/tests/test_json.py", "original_string": "    def test_numpy_not_imported(self):\n        \"\"\"If NumPy is not available, EliotJSONEncoder continues to work.\n        This ensures NumPy isn't a hard dependency.\n        \"\"\"\n        with self.assertRaises(TypeError):\n            dumps([object()], cls=EliotJSONEncoder)\n        self.assertEqual(dumps(12, cls=EliotJSONEncoder), \"12\")\n", "docstring": "If NumPy is not available, EliotJSONEncoder continues to work."}
{"repo": "eliot-master/eliot/tests/test_validation.py", "original_string": "        def validate(i):\n            if i > 10:\n                return\n            else:\n                raise ValidationError(\"too small\")\n", "docstring": "if i > 10:"}
{"repo": "eliot-master/eliot/tests/test_validation.py", "original_string": "        def serialize(obj):\n            raise MyException()\n", "docstring": "raise MyException()"}
{"repo": "eliot-master/eliot/tests/test_validation.py", "original_string": "        def validate(i):\n            if i > 10:\n                return\n            else:\n                raise ValidationError(\"too small\")\n", "docstring": "if i > 10:"}
{"repo": "eliot-master/eliot/tests/test_validation.py", "original_string": "        def run():\n            with self.ACTION(logger, key=123):\n                raise RuntimeError(\"hello\")\n", "docstring": "with self.ACTION(logger, key=123):"}
{"repo": "eliot-master/eliot/tests/test_traceback.py", "original_string": "def assert_expected_traceback(test, logger, message, exception, expected_traceback):\n    \"\"\"Assert we logged the given exception and the expected traceback.\"\"\"\n    lines = expected_traceback.split(\"\\n\")\n    # Remove source code lines:\n    expected_traceback = \"\\n\".join([l for l in lines if not l.startswith(\"    \")])\n    assertContainsFields(\n        test,\n        message,\n        {\n            \"message_type\": \"eliot:traceback\",\n            \"exception\": RuntimeError,\n            \"reason\": exception,\n            \"traceback\": expected_traceback,\n        },\n    )\n    logger.flushTracebacks(RuntimeError)\n", "docstring": "Assert we logged the given exception and the expected traceback.\n"}
{"repo": "eliot-master/eliot/tests/test_stdlib.py", "original_string": "    def test_handler(self, logger):\n        \"\"\"The EliotHandler routes messages to Eliot.\"\"\"\n        stdlib_logger = logging.getLogger(\"eliot-test\")\n        stdlib_logger.setLevel(logging.DEBUG)\n        handler = EliotHandler()\n        stdlib_logger.addHandler(handler)\n        stdlib_logger.info(\"hello\")\n        stdlib_logger.warning(\"ono\")\n        message = logger.messages[0]\n        assertContainsFields(\n            self,\n            message,\n            {\n                \"message_type\": \"eliot:stdlib\",\n                \"log_level\": \"INFO\",\n                \"message\": \"hello\",\n                \"logger\": \"eliot-test\",\n            },\n        )\n        message = logger.messages[1]\n        assertContainsFields(\n            self,\n            message,\n            {\n                \"message_type\": \"eliot:stdlib\",\n                \"log_level\": \"WARNING\",\n                \"message\": \"ono\",\n                \"logger\": \"eliot-test\",\n            },\n        )\n", "docstring": "The EliotHandler routes messages to Eliot.\n"}
{"repo": "eliot-master/eliot/tests/test_testing.py", "original_string": "        def __init__(self, message, expectedFields):\n            TestCase.__init__(self)\n            self.message = message\n            self.expectedFields = expectedFields\n", "docstring": "TestCase.__init__(self)"}
{"repo": "eliot-master/eliot/tests/test_testing.py", "original_string": "        def another_wrapper(f):\n            def g(this):\n                f(this, 1, 2, c=3)\n            return g\n", "docstring": "def g(this):"}
{"repo": "eliot-master/eliot/tests/test_testing.py", "original_string": "            def test_foo(self, logger):\n                return 123\n", "docstring": "return 123"}
{"repo": "eliot-master/eliot/tests/test_testing.py", "original_string": "            def assertLogging(self, logger, x, y):\n                result.append((self, logger, x, y))\n", "docstring": "result.append((self, logger, x, y))"}
{"repo": "eliot-master/eliot/tests/test_testing.py", "original_string": "            def assertLogging(self, logger):\n                logger.flushTracebacks(ZeroDivisionError)\n                self.flushed = True\n", "docstring": "logger.flushTracebacks(ZeroDivisionError)"}
{"repo": "eliot-master/eliot/tests/test_testing.py", "original_string": "    def setUp(self):\n        # Since we're not always calling the test method via the TestCase\n        # infrastructure, sometimes cleanup methods are not called. This\n        # means the original default logger is not restored. So we do so\n        # manually. If the issue is a bug in capture_logging itself the\n        # tests below will catch that.\n        original_logger = _output._DEFAULT_LOGGER\n        def cleanup():\n            _output._DEFAULT_LOGGER = original_logger\n        self.addCleanup(cleanup)\n", "docstring": "Since we're not always calling the test method via the TestCase"}
{"repo": "eliot-master/eliot/tests/test_testing.py", "original_string": "            def runTest(self, logger):\n                raise RuntimeError()\n", "docstring": "raise RuntimeError()"}
{"repo": "eliot-master/eliot/tests/test_testing.py", "original_string": "    def test_swap_logger(self, logger):\n        \"\"\"C{swap_logger} swaps out the current logger.\"\"\"\n        new_logger = MemoryLogger()\n        old_logger = swap_logger(new_logger)\n        Message.log(message_type=\"hello\")\n        # We swapped out old logger for new:\n        self.assertIs(old_logger, logger)\n        self.assertEqual(new_logger.messages[0][\"message_type\"], \"hello\")\n        # Now restore old logger:\n        intermediate_logger = swap_logger(old_logger)\n        Message.log(message_type=\"goodbye\")\n        self.assertIs(intermediate_logger, new_logger)\n        self.assertEqual(logger.messages[0][\"message_type\"], \"goodbye\")\n", "docstring": "C{swap_logger} swaps out the current logger.\n"}
{"repo": "eliot-master/eliot/tests/test_message.py", "original_string": "            def write(self, dictionary, serializer):\n                self.append(serializer)\n", "docstring": "self.append(serializer)"}
{"repo": "eliot-master/eliot/tests/test_action.py", "original_string": "    def test_per_thread_context(self):\n        \"\"\"Different threads have different contexts.\"\"\"\n        in_thread = []\n        def run_in_thread():\n            action = Action(None, \"\", TaskLevel(level=[]), \"\")\n            with action.context():\n                time.sleep(0.5)\n                in_thread.append(current_action())\n        thread = Thread(target=run_in_thread)\n        thread.start()\n        time.sleep(0.2)\n        self.assertEqual(current_action(), None)\n        thread.join()\n        self.assertIsInstance(in_thread[0], Action)\n", "docstring": "Different threads have different contexts.\n"}
{"repo": "eliot-master/eliot/tests/test_action.py", "original_string": "            def write(self, msg, serializer):\n                self.append(serializer)\n", "docstring": "self.append(serializer)"}
{"repo": "eliot-master/eliot/tests/test_action.py", "original_string": "            def __str__(self):\n                raise TypeError()\n", "docstring": "raise TypeError()"}
{"repo": "eliot-master/eliot/tests/test_action.py", "original_string": "            def extract(e):\n                return e.nosuchattribute\n", "docstring": "return e.nosuchattribute"}
{"repo": "eliot-master/eliot/tests/test_action.py", "original_string": "    def assert_logged(self, logger, action_type, expected_params, expected_result):\n        \"\"\"Assert that an action of given structure was logged.\"\"\"\n        if six.PY2:\n            # On Python 2 we don't include the module or class:\n            action_type = action_type.split(\".\")[-1]\n        [tree] = Parser.parse_stream(logger.messages)\n        root = tree.root()\n        self.assertEqual(root.action_type, action_type)\n        message = dict(root.start_message.contents)\n        for field in [ACTION_STATUS_FIELD, ACTION_TYPE_FIELD]:\n            message.pop(field)\n        self.assertEqual(message, expected_params)\n        self.assertEqual(root.end_message.contents[\"result\"], expected_result)\n        self.assertEqual(root.status, SUCCEEDED_STATUS)\n", "docstring": "Assert that an action of given structure was logged.\n"}
{"repo": "eliot-master/eliot/tests/test_action.py", "original_string": "    def test_exception(self, logger):\n        \"\"\"C{@log_call} with an exception logs a failed action.\"\"\"\n        @log_call\n        def myfunc(x, y):\n            1 / 0\n        with self.assertRaises(ZeroDivisionError):\n            myfunc(2, 4)\n        [tree] = Parser.parse_stream(logger.messages)\n        root = tree.root()\n        self.assertIn(\"ZeroDivisionError\", root.end_message.contents[\"exception\"])\n        self.assertEqual(root.status, FAILED_STATUS)\n", "docstring": "C{@log_call} with an exception logs a failed action.\n"}
{"repo": "eliot-master/eliot/tests/test_action.py", "original_string": "    def test_action_type(self, logger):\n        \"\"\"C{@log_call} can take an action type.\"\"\"\n        @log_call(action_type=\"myaction\")\n        def myfunc(x, y):\n            return 4\n        myfunc(2, 3)\n        self.assert_logged(logger, \"myaction\", {\"x\": 2, \"y\": 3}, 4)\n", "docstring": "C{@log_call} can take an action type.\n"}
{"repo": "eliot-master/eliot/tests/test_action.py", "original_string": "    def test_default_argument_given(self, logger):\n        \"\"\"C{@log_call} logs default arguments that were passed in.\"\"\"\n        @log_call\n        def myfunc(x, y=1):\n            return 4\n        myfunc(2, y=5)\n        self.assert_logged(logger, self.id() + \".<locals>.myfunc\", {\"x\": 2, \"y\": 5}, 4)\n", "docstring": "C{@log_call} logs default arguments that were passed in.\n"}
{"repo": "eliot-master/eliot/tests/test_action.py", "original_string": "    def test_default_argument_missing(self, logger):\n        \"\"\"C{@log_call} logs default arguments that weren't passed in.\"\"\"\n        @log_call\n        def myfunc(x, y=1):\n            return 6\n        myfunc(2)\n        self.assert_logged(logger, self.id() + \".<locals>.myfunc\", {\"x\": 2, \"y\": 1}, 6)\n", "docstring": "C{@log_call} logs default arguments that weren't passed in.\n"}
{"repo": "eliot-master/eliot/tests/test_action.py", "original_string": "    def test_star_args_kwargs(self, logger):\n        \"\"\"C{@log_call} logs star args and kwargs.\"\"\"\n        @log_call\n        def myfunc(x, *y, **z):\n            return 6\n        myfunc(2, 3, 4, a=1, b=2)\n        self.assert_logged(\n            logger,\n            self.id() + \".<locals>.myfunc\",\n            {\"x\": 2, \"y\": (3, 4), \"z\": {\"a\": 1, \"b\": 2}},\n            6,\n        )\n", "docstring": "C{@log_call} logs star args and kwargs.\n"}
{"repo": "eliot-master/eliot/tests/test_action.py", "original_string": "    def test_whitelist_args(self, logger):\n        \"\"\"C{@log_call} only includes whitelisted arguments.\"\"\"\n        @log_call(include_args=(\"x\", \"z\"))\n        def myfunc(x, y, z):\n            return 6\n        myfunc(2, 3, 4)\n        self.assert_logged(logger, self.id() + \".<locals>.myfunc\", {\"x\": 2, \"z\": 4}, 6)\n", "docstring": "C{@log_call} only includes whitelisted arguments.\n"}
{"repo": "eliot-master/eliot/tests/test_action.py", "original_string": "    def test_wrong_whitelist_args(self):\n        \"\"\"If C{include_args} doesn't match function, raise an exception.\"\"\"\n        with self.assertRaises(ValueError):\n            @log_call(include_args=[\"a\", \"x\", \"y\"])\n            def f(x, y):\n                pass\n", "docstring": "If C{include_args} doesn't match function, raise an exception.\n"}
{"repo": "eliot-master/eliot/tests/test_action.py", "original_string": "    def test_no_result(self, logger):\n        \"\"\"C{@log_call} can omit logging the result.\"\"\"\n        @log_call(include_result=False)\n        def myfunc(x, y):\n            return 6\n        myfunc(2, 3)\n        [tree] = Parser.parse_stream(logger.messages)\n        root = tree.root()\n        self.assertNotIn(\"result\", root.end_message.contents)\n        self.assertEqual(root.status, SUCCEEDED_STATUS)\n", "docstring": "C{@log_call} can omit logging the result.\n"}
{"repo": "eliot-master/eliot/tests/test_action.py", "original_string": "    def test_methods(self, logger):\n        \"\"\"self is not logged.\"\"\"\n        class C(object):\n            @log_call\n            def f(self, x):\n                pass\n        C().f(2)\n        self.assert_logged(logger, self.id() + \".<locals>.C.f\", {\"x\": 2}, None)\n", "docstring": "self is not logged.\n"}
{"repo": "eliot-master/eliot/tests/strategies.py", "original_string": "def sibling_task_level(message, n):\n    return message.task_level.parent().level.append(n)\n", "docstring": "return message.task_level.parent().level.append(n)"}
{"repo": "eliot-master/eliot/tests/strategies.py", "original_string": "    def fix_message(message):\n        return message.transform(\n            [\"_logged_dict\", TASK_LEVEL_FIELD],\n            lambda level: new_prefix + level[old_prefix_len:],\n        ).transform([\"_logged_dict\", TASK_UUID_FIELD], task_uuid)\n", "docstring": "return message.transform("}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def terminate_daemon(self):\n        \"\"\"Instruct the daemon to shut down\"\"\"\n        self.thread_shutdown_timer = timeit.default_timer()\n        self.logger.info(\"Received command to terminate daemon\")\n        self.daemon_run = False\n        while not self.terminated:\n            time.sleep(0.1)\n        return 1\n", "docstring": "Instruct the daemon to shut down\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def send_stats(self):\n        \"\"\"Collect and send statistics\"\"\"\n        # Check if stats file exists, recreate if not\n        try:\n            return_stat_file_dict(STATS_CSV)\n        except Exception as except_msg:\n            self.logger.exception(\"Error reading stats file: {err}\".format(err=except_msg))\n            try:\n                os.remove(STATS_CSV)\n            except OSError:\n                pass\n            recreate_stat_file()\n        # Send stats\n        try:\n            send_anonymous_stats(self.start_time, self.log_level_debug)\n        except Exception as except_msg:\n            self.logger.exception(\"Could not send statistics: {err}\".format(err=except_msg))\n", "docstring": "Collect and send statistics\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def lcd_backlight(self, lcd_id, state):\n        \"\"\"Turns an LCD backlight on or off\"\"\"\n        return self.mycodo.lcd_backlight(lcd_id, state)\n", "docstring": "Turns an LCD backlight on or off\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def lcd_flash(self, lcd_id, state):\n        \"\"\"Starts or stops an LCD from flashing (alarm)\"\"\"\n        return self.mycodo.lcd_flash(lcd_id, state)\n", "docstring": "Starts or stops an LCD from flashing (alarm)\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def controller_activate(self, cont_id):\n        \"\"\"Activates a controller\"\"\"\n        return self.mycodo.controller_activate(cont_id)\n", "docstring": "Activates a controller\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def controller_is_active(self, cont_id):\n        \"\"\"Checks if a controller is active\"\"\"\n        return self.mycodo.controller_is_active(cont_id)\n", "docstring": "Checks if a controller is active\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def function_status(self, function_id):\n        \"\"\"Get status of Function\"\"\"\n        return self.mycodo.function_status(function_id)\n", "docstring": "Get status of Function\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def pid_hold(self, pid_id):\n        \"\"\"Hold PID Controller operation\"\"\"\n        return self.mycodo.pid_hold(pid_id)\n", "docstring": "Hold PID Controller operation\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def pid_pause(self, pid_id):\n        \"\"\"Pause PID Controller operation\"\"\"\n        return self.mycodo.pid_pause(pid_id)\n", "docstring": "Pause PID Controller operation\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def pid_get(self, pid_id, setting):\n        \"\"\"Get PID setting\"\"\"\n        return self.mycodo.pid_get(pid_id, setting)\n", "docstring": "Get PID setting\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def refresh_daemon_camera_settings(self, ):\n        \"\"\"Instruct the daemon to refresh the camera settings\"\"\"\n        return self.mycodo.refresh_daemon_camera_settings()\n", "docstring": "Instruct the daemon to refresh the camera settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def refresh_daemon_misc_settings(self):\n        \"\"\"Instruct the daemon to refresh the misc settings\"\"\"\n        return self.mycodo.refresh_daemon_misc_settings()\n", "docstring": "Instruct the daemon to refresh the misc settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def output_state(self, output_id, output_channel):\n        \"\"\"Return the output state (on or off)\"\"\"\n        return self.mycodo.output_state(output_id, output_channel)\n", "docstring": "Return the output state (on or off)\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def output_sec_currently_on(self, output_id, output_channel=None):\n        \"\"\"Turns the amount of time a output has already been on\"\"\"\n        return self.mycodo.controller['Output'].output_sec_currently_on(\n            output_id, output_channel=output_channel)\n", "docstring": "Turns the amount of time a output has already been on\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def trigger_action(self, action_id, value=None, message='', single_action=False, debug=False):\n        \"\"\"Trigger action\"\"\"\n        return self.mycodo.trigger_action(\n            action_id,\n            value=value,\n            message=message,\n            single_action=single_action,\n            debug=debug)\n", "docstring": "Trigger action\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def terminate_daemon(self):\n        \"\"\"Instruct the daemon to shut down\"\"\"\n        return self.mycodo.terminate_daemon()\n", "docstring": "Instruct the daemon to shut down\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def widget_remove(self, unique_id):\n        \"\"\"Remove widget object\"\"\"\n        return self.mycodo.controller['Widget'].widget_remove(unique_id)\n", "docstring": "Remove widget object\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def is_in_virtualenv():\n        \"\"\"Returns True if this script is running in a virtualenv\"\"\"\n        return hasattr(sys, 'real_prefix') or sys.base_prefix != sys.prefix\n", "docstring": "Returns True if this script is running in a virtualenv\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def ram_use():\n        \"\"\"Return the amount of ram used by the daemon\"\"\"\n        return resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / float(1000)\n", "docstring": "Return the amount of ram used by the daemon\n"}
{"repo": "Mycodo-master/mycodo/mycodo_daemon.py", "original_string": "    def __init__(self, mycodo, debug):\n        threading.Thread.__init__(self)\n        self.logger = logging.getLogger('mycodo.pyro_daemon')\n        if debug:\n            self.logger.setLevel(logging.DEBUG)\n        else:\n            self.logger.setLevel(logging.WARNING)\n        self.mycodo = mycodo\n", "docstring": "threading.Thread.__init__(self)"}
{"repo": "Mycodo-master/mycodo/mycodo_client.py", "original_string": "    def output_on_off(self, output_id, state, output_type=None, amount=0.0, output_channel=None):\n        \"\"\" Turn an output on or off \"\"\"\n        if state in ['on', 1, True]:\n            return self.output_on(\n                output_id, amount=amount, output_type=output_type, output_channel=output_channel)\n        elif state in ['off', 0, False]:\n            return self.output_off(output_id, output_channel=output_channel)\n        else:\n            return 1, 'state not \"on\", 1, True, \"off\", 0, or False. Found: \"{}\"'.format(state)\n", "docstring": "Turn an output on or off \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_admin.py", "original_string": "def admin_dependency_install(device):\n    \"\"\" Install Dependencies \"\"\"\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": []\n    }\n    try:\n        device_unmet_dependencies, _ = utils_general.return_dependencies(device)\n        with open(DEPENDENCY_INIT_FILE, 'w') as f:\n            f.write('1')\n        install_deps = threading.Thread(\n            target=install_dependencies,\n            args=(device_unmet_dependencies,))\n        install_deps.start()\n        messages[\"success\"].append(\"Dependency install initiated\")\n    except Exception as err:\n        messages[\"error\"].append(\"Error: {}\".format(err))\n    return jsonify(data={\n        'messages': messages\n    })\n", "docstring": "Install Dependencies \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_admin.py", "original_string": "def admin_dependency_status():\n    \"\"\" Return the last 30 lines of the dependency log \"\"\"\n    if os.path.isfile(DEPENDENCY_LOG_FILE):\n        command = 'tail -n 40 {log}'.format(log=DEPENDENCY_LOG_FILE)\n        log = subprocess.Popen(\n            command, stdout=subprocess.PIPE, shell=True)\n        (log_output, _) = log.communicate()\n        log.wait()\n        log_output = log_output.decode(\"utf-8\")\n    else:\n        log_output = 'Dependency log not found. If a dependency install was ' \\\n                     'just initialized, please wait...'\n    response = make_response(log_output)\n    response.headers[\"content-type\"] = \"text/plain\"\n    return response\n", "docstring": "Return the last 30 lines of the dependency log \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_admin.py", "original_string": "def admin_statistics():\n    \"\"\" Display collected statistics \"\"\"\n    if not utils_general.user_has_permission('view_stats'):\n        return redirect(url_for('routes_general.home'))\n    try:\n        statistics = return_stat_file_dict(STATS_CSV)\n    except IOError:\n        statistics = {}\n    return render_template('admin/statistics.html',\n                           statistics=statistics)\n", "docstring": "Display collected statistics \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_admin.py", "original_string": "def admin_upgrade_status():\n    \"\"\" Return the last 30 lines of the upgrade log \"\"\"\n    if os.path.isfile(UPGRADE_TMP_LOG_FILE):\n        command = 'cat {log}'.format(log=UPGRADE_TMP_LOG_FILE)\n        log = subprocess.Popen(\n            command, stdout=subprocess.PIPE, shell=True)\n        (log_output, _) = log.communicate()\n        log.wait()\n        log_output = log_output.decode(\"utf-8\")\n    else:\n        log_output = 'Upgrade log not found. If an upgrade was just ' \\\n                     'initialized, please wait...'\n    response = make_response(log_output)\n    response.headers[\"content-type\"] = \"text/plain\"\n    return response\n", "docstring": "Return the last 30 lines of the upgrade log \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_settings.py", "original_string": "def settings_alerts():\n    \"\"\" Display alert settings \"\"\"\n    if not utils_general.user_has_permission('view_settings'):\n        return redirect(url_for('routes_general.home'))\n    smtp = SMTP.query.first()\n    form_email_alert = forms_settings.SettingsEmail()\n    if request.method == 'POST':\n        if not utils_general.user_has_permission('edit_settings'):\n            return redirect(url_for('routes_general.home'))\n        form_name = request.form['form-name']\n        if form_name == 'EmailAlert':\n            utils_settings.settings_alert_mod(form_email_alert)\n        return redirect(url_for('routes_settings.settings_alerts'))\n    return render_template('settings/alerts.html',\n                           smtp=smtp,\n                           form_email_alert=form_email_alert)\n", "docstring": "Display alert settings \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_settings.py", "original_string": "def settings_general_submit():\n    \"\"\" Submit form for General Settings page \"\"\"\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": []\n    }\n    form_settings_general = forms_settings.SettingsGeneral()\n    if not utils_general.user_has_permission('edit_settings'):\n        messages[\"error\"].append(\"Your permissions do not allow this action\")\n    if not messages[\"error\"]:\n        messages = utils_settings.settings_general_mod(form_settings_general)\n    return jsonify(data={\n        'messages': messages,\n    })\n", "docstring": "Submit form for General Settings page \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_settings.py", "original_string": "def settings_general():\n    \"\"\" Display general settings \"\"\"\n    if not utils_general.user_has_permission('view_settings'):\n        return redirect(url_for('routes_general.home'))\n    misc = Misc.query.first()\n    form_settings_general = forms_settings.SettingsGeneral()\n    return render_template('settings/general.html',\n                           misc=misc,\n                           form_settings_general=form_settings_general)\n", "docstring": "Display general settings \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_settings.py", "original_string": "def settings_function():\n    \"\"\" Display function settings \"\"\"\n    if not utils_general.user_has_permission('view_settings'):\n        return redirect(url_for('routes_general.home'))\n    form_controller = forms_settings.Controller()\n    form_controller_delete = forms_settings.ControllerDel()\n    # Get list of custom functions\n    excluded_files = ['__init__.py', '__pycache__']\n    if request.method == 'POST':\n        if not utils_general.user_has_permission('edit_controllers'):\n            return redirect(url_for('routes_general.home'))\n        if form_controller.import_controller_upload.data:\n            utils_settings.settings_function_import(form_controller)\n        elif form_controller_delete.delete_controller.data:\n            utils_settings.settings_function_delete(form_controller_delete)\n        return redirect(url_for('routes_settings.settings_function'))\n    dict_controllers = {}\n    for each_file in os.listdir(PATH_FUNCTIONS_CUSTOM):\n        if each_file not in excluded_files:\n            try:\n                full_path_file = os.path.join(PATH_FUNCTIONS_CUSTOM, each_file)\n                controller_info = load_module_from_file(full_path_file, 'functions')\n                if controller_info:\n                    func_info = controller_info.FUNCTION_INFORMATION\n                    dict_controllers[func_info['function_name_unique']] = {}\n                    dict_controllers[func_info['function_name_unique']]['function_name'] = func_info['function_name']\n            except:\n                pass\n    return render_template('settings/function.html',\n                           dict_controllers=dict_controllers,\n                           form_controller=form_controller,\n                           form_controller_delete=form_controller_delete)\n", "docstring": "Display function settings \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_settings.py", "original_string": "def settings_input():\n    \"\"\" Display measurement settings \"\"\"\n    if not utils_general.user_has_permission('view_settings'):\n        return redirect(url_for('routes_general.home'))\n    form_input = forms_settings.Input()\n    form_input_delete = forms_settings.InputDel()\n    dict_measurements = add_custom_measurements(Measurement.query.all())\n    dict_units = add_custom_units(Unit.query.all())\n    # Get list of custom inputs\n    excluded_files = ['__init__.py', '__pycache__']\n    if request.method == 'POST':\n        if not utils_general.user_has_permission('edit_controllers'):\n            return redirect(url_for('routes_general.home'))\n        if form_input.import_input_upload.data:\n            utils_settings.settings_input_import(form_input)\n        elif form_input_delete.delete_input.data:\n            utils_settings.settings_input_delete(form_input_delete)\n        return redirect(url_for('routes_settings.settings_input'))\n    dict_inputs = {}\n    for each_file in os.listdir(PATH_INPUTS_CUSTOM):\n        if each_file not in excluded_files:\n            try:\n                full_path_file = os.path.join(PATH_INPUTS_CUSTOM, each_file)\n                input_info = load_module_from_file(full_path_file, 'inputs')\n                if input_info:\n                    dict_inputs[input_info.INPUT_INFORMATION['input_name_unique']] = {}\n                    dict_inputs[input_info.INPUT_INFORMATION['input_name_unique']]['input_name'] = \\\n                        input_info.INPUT_INFORMATION['input_name']\n                    dict_inputs[input_info.INPUT_INFORMATION['input_name_unique']]['input_manufacturer'] = \\\n                        input_info.INPUT_INFORMATION['input_manufacturer']\n                    dict_inputs[input_info.INPUT_INFORMATION['input_name_unique']]['measurements_name'] = \\\n                        input_info.INPUT_INFORMATION['measurements_name']\n            except:\n                pass\n    return render_template('settings/input.html',\n                           dict_inputs=dict_inputs,\n                           dict_measurements=dict_measurements,\n                           dict_units=dict_units,\n                           form_input=form_input,\n                           form_input_delete=form_input_delete)\n", "docstring": "Display measurement settings \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_settings.py", "original_string": "def settings_output():\n    \"\"\" Display output settings \"\"\"\n    if not utils_general.user_has_permission('view_settings'):\n        return redirect(url_for('routes_general.home'))\n    form_output = forms_settings.Output()\n    form_output_delete = forms_settings.OutputDel()\n    dict_measurements = add_custom_measurements(Measurement.query.all())\n    dict_units = add_custom_units(Unit.query.all())\n    # Get list of custom outputs\n    excluded_files = ['__init__.py', '__pycache__']\n    if request.method == 'POST':\n        if not utils_general.user_has_permission('edit_controllers'):\n            return redirect(url_for('routes_general.home'))\n        if form_output.import_output_upload.data:\n            utils_settings.settings_output_import(form_output)\n        elif form_output_delete.delete_output.data:\n            utils_settings.settings_output_delete(form_output_delete)\n        return redirect(url_for('routes_settings.settings_output'))\n    dict_outputs = {}\n    for each_file in os.listdir(PATH_OUTPUTS_CUSTOM):\n        if each_file not in excluded_files:\n            try:\n                full_path_file = os.path.join(PATH_OUTPUTS_CUSTOM, each_file)\n                output_info = load_module_from_file(full_path_file, 'outputs')\n                if output_info:\n                    dict_outputs[output_info.OUTPUT_INFORMATION['output_name_unique']] = {}\n                    dict_outputs[output_info.OUTPUT_INFORMATION['output_name_unique']]['output_name'] = \\\n                        output_info.OUTPUT_INFORMATION['output_name']\n                    dict_outputs[output_info.OUTPUT_INFORMATION['output_name_unique']]['measurements_name'] = \\\n                        output_info.OUTPUT_INFORMATION['measurements_name']\n            except:\n                pass\n    return render_template('settings/output.html',\n                           dict_outputs=dict_outputs,\n                           dict_measurements=dict_measurements,\n                           dict_units=dict_units,\n                           form_output=form_output,\n                           form_output_delete=form_output_delete)\n", "docstring": "Display output settings \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_settings.py", "original_string": "def settings_widget():\n    \"\"\" Display widget settings \"\"\"\n    if not utils_general.user_has_permission('view_settings'):\n        return redirect(url_for('routes_general.home'))\n    form_widget = forms_settings.Widget()\n    form_widget_delete = forms_settings.WidgetDel()\n    dict_measurements = add_custom_measurements(Measurement.query.all())\n    dict_units = add_custom_units(Unit.query.all())\n    # Get list of custom widgets\n    excluded_files = ['__init__.py', '__pycache__']\n    if request.method == 'POST':\n        if not utils_general.user_has_permission('edit_controllers'):\n            return redirect(url_for('routes_general.home'))\n        if form_widget.import_widget_upload.data:\n            utils_settings.settings_widget_import(form_widget)\n        elif form_widget_delete.delete_widget.data:\n            utils_settings.settings_widget_delete(form_widget_delete)\n        return redirect(url_for('routes_settings.settings_widget'))\n    dict_widgets = {}\n    for each_file in os.listdir(PATH_WIDGETS_CUSTOM):\n        if each_file not in excluded_files:\n            try:\n                full_path_file = os.path.join(PATH_WIDGETS_CUSTOM, each_file)\n                widget_info = load_module_from_file(full_path_file, 'widgets')\n                if widget_info:\n                    dict_widgets[widget_info.WIDGET_INFORMATION['widget_name_unique']] = {}\n                    dict_widgets[widget_info.WIDGET_INFORMATION['widget_name_unique']]['widget_name'] = \\\n                        widget_info.WIDGET_INFORMATION['widget_name']\n                    dict_widgets[widget_info.WIDGET_INFORMATION['widget_name_unique']]['measurements_name'] = \\\n                        widget_info.WIDGET_INFORMATION['measurements_name']\n            except:\n                pass\n    return render_template('settings/widget.html',\n                           dict_widgets=dict_widgets,\n                           dict_measurements=dict_measurements,\n                           dict_units=dict_units,\n                           form_widget=form_widget,\n                           form_widget_delete=form_widget_delete)\n", "docstring": "Display widget settings \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_settings.py", "original_string": "def settings_measurement():\n    \"\"\" Display measurement settings \"\"\"\n    if not utils_general.user_has_permission('view_settings'):\n        return redirect(url_for('routes_general.home'))\n    measurement = Measurement.query.all()\n    unit = Unit.query.all()\n    conversion = Conversion.query.all()\n    form_add_measurement = forms_settings.MeasurementAdd()\n    form_mod_measurement = forms_settings.MeasurementMod()\n    form_add_unit = forms_settings.UnitAdd()\n    form_mod_unit = forms_settings.UnitMod()\n    form_add_conversion = forms_settings.ConversionAdd()\n    form_mod_conversion = forms_settings.ConversionMod()\n    choices_units = utils_general.choices_units(unit)\n    # Generate all measurement and units used\n    dict_measurements = add_custom_measurements(measurement)\n    dict_units = add_custom_units(unit)\n    if request.method == 'POST':\n        if not utils_general.user_has_permission('edit_controllers'):\n            return redirect(url_for('routes_general.home'))\n        if form_add_measurement.add_measurement.data:\n            utils_settings.settings_measurement_add(form_add_measurement)\n        elif form_mod_measurement.save_measurement.data:\n            utils_settings.settings_measurement_mod(form_mod_measurement)\n        elif form_mod_measurement.delete_measurement.data:\n            utils_settings.settings_measurement_del(form_mod_measurement.measurement_id.data)\n        elif form_add_unit.add_unit.data:\n            utils_settings.settings_unit_add(form_add_unit)\n        elif form_mod_unit.save_unit.data:\n            utils_settings.settings_unit_mod(form_mod_unit)\n        elif form_mod_unit.delete_unit.data:\n            utils_settings.settings_unit_del(form_mod_unit.unit_id.data)\n        elif form_add_conversion.add_conversion.data:\n            utils_settings.settings_convert_add(form_add_conversion)\n        elif form_mod_conversion.save_conversion.data:\n            utils_settings.settings_convert_mod(form_mod_conversion)\n        elif form_mod_conversion.delete_conversion.data:\n            utils_settings.settings_convert_del(form_mod_conversion.conversion_id.data)\n        return redirect(url_for('routes_settings.settings_measurement'))\n    return render_template('settings/measurement.html',\n                           dict_measurements=dict_measurements,\n                           dict_units=dict_units,\n                           choices_units=choices_units,\n                           measurement=measurement,\n                           unit=unit,\n                           conversion=conversion,\n                           form_add_measurement=form_add_measurement,\n                           form_mod_measurement=form_mod_measurement,\n                           form_add_unit=form_add_unit,\n                           form_mod_unit=form_mod_unit,\n                           form_add_conversion=form_add_conversion,\n                           form_mod_conversion=form_mod_conversion)\n", "docstring": "Display measurement settings \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_settings.py", "original_string": "def change_theme():\n    \"\"\" Change theme \"\"\"\n    if not utils_general.user_has_permission('view_settings'):\n        return redirect(url_for('routes_general.home'))\n    form_prefs = forms_settings.UserPreferences()\n    if request.method == 'POST':\n        if not utils_general.user_has_permission('edit_users'):\n            return redirect(url_for('routes_general.home'))\n        if form_prefs.user_preferences_save.data:\n            utils_settings.change_preferences(form_prefs)\n    return redirect(url_for('routes_general.home'))\n", "docstring": "Change theme \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_settings.py", "original_string": "def settings_users_submit():\n    \"\"\" Submit form for User Settings page \"\"\"\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": []\n    }\n    page_refresh = False\n    logout = False\n    user_id = None\n    role_id = None\n    user_generate_api_key = None\n    if not utils_general.user_has_permission('edit_users'):\n        messages[\"error\"].append(\"Your permissions do not allow this action\")\n    form_user = forms_settings.User()\n    form_mod_user = forms_settings.UserMod()\n    form_user_roles = forms_settings.UserRoles()\n    if not messages[\"error\"]:\n        if form_user.settings_user_save.data:\n            messages = utils_settings.user(form_user)\n        elif form_mod_user.user_generate_api_key.data:\n            (messages,\n             generated_api_key) = utils_settings.generate_api_key(\n                form_mod_user)\n            user_id = form_mod_user.user_id.data\n        elif form_mod_user.user_delete.data:\n            user_id = form_mod_user.user_id.data\n            messages = utils_settings.user_del(form_mod_user)\n        elif form_mod_user.user_save.data:\n            messages, logout = utils_settings.user_mod(form_mod_user)\n            if logout:\n                page_refresh = True\n        elif (form_user_roles.user_role_save.data or\n              form_user_roles.user_role_delete.data):\n            role_id = form_user_roles.role_id.data\n            messages, page_refresh = utils_settings.user_roles(form_user_roles)\n    if page_refresh:\n        for each_error in messages[\"error\"]:\n            flash(each_error, \"error\")\n        for each_warn in messages[\"warning\"]:\n            flash(each_warn, \"warning\")\n        for each_info in messages[\"info\"]:\n            flash(each_info, \"info\")\n        for each_success in messages[\"success\"]:\n            flash(each_success, \"success\")\n    return jsonify(data={\n        'generated_api_key': generated_api_key,\n        'user_id': user_id,\n        'role_id': role_id,\n        'messages': messages,\n        'logout': logout\n    })\n", "docstring": "Submit form for User Settings page \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_settings.py", "original_string": "def settings_users():\n    \"\"\" Display user settings \"\"\"\n    if not utils_general.user_has_permission('view_settings'):\n        return redirect(url_for('routes_general.home'))\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": []\n    }\n    misc = Misc.query.first()\n    users = User.query.all()\n    user_roles = Role.query.all()\n    form_user = forms_settings.User()\n    form_add_user = forms_settings.UserAdd()\n    form_mod_user = forms_settings.UserMod()\n    form_user_roles = forms_settings.UserRoles()\n    if request.method == 'POST':\n        if not utils_general.user_has_permission('edit_users'):\n            return redirect(url_for('routes_general.home'))\n        if form_add_user.user_add.data:\n            utils_settings.user_add(form_add_user)\n        elif form_user_roles.user_role_add.data:\n            messages, page_refresh = utils_settings.user_roles(form_user_roles)\n    for each_error in messages[\"error\"]:\n        flash(each_error, \"error\")\n    for each_warn in messages[\"warning\"]:\n        flash(each_warn, \"warning\")\n    for each_info in messages[\"info\"]:\n        flash(each_info, \"info\")\n    for each_success in messages[\"success\"]:\n        flash(each_success, \"success\")\n    return render_template('settings/users.html',\n                           misc=misc,\n                           themes=THEMES,\n                           users=users,\n                           user_roles=user_roles,\n                           form_add_user=form_add_user,\n                           form_mod_user=form_mod_user,\n                           form_user=form_user,\n                           form_user_roles=form_user_roles)\n", "docstring": "Display user settings \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_settings.py", "original_string": "def settings_pi():\n    \"\"\" Display general settings \"\"\"\n    if not utils_general.user_has_permission('view_settings'):\n        return redirect(url_for('routes_general.home'))\n    misc = Misc.query.first()\n    form_settings_pi = forms_settings.SettingsPi()\n    pi_settings = get_raspi_config_settings()\n    # Determine what state pigpiod is currently in\n    pigpiod_sample_rate = ''\n    if os.path.exists('/etc/systemd/system/pigpiod_uninstalled.service'):\n        pigpiod_sample_rate = 'uninstalled'\n    elif os.path.exists('/etc/systemd/system/pigpiod_disabled.service'):\n        pigpiod_sample_rate = 'disabled'\n    elif os.path.exists('/etc/systemd/system/pigpiod_low.service'):\n        pigpiod_sample_rate = 'low'\n    elif os.path.exists('/etc/systemd/system/pigpiod_high.service'):\n        pigpiod_sample_rate = 'high'\n    elif os.path.exists('/etc/systemd/system/pigpiod.service'):\n        pigpiod_sample_rate = 'low'\n    if request.method == 'POST':\n        if not utils_general.user_has_permission('edit_settings'):\n            return redirect(url_for('routes_general.home'))\n        form_name = request.form['form-name']\n        if form_name == 'Pi':\n            utils_settings.settings_pi_mod(form_settings_pi)\n        return redirect(url_for('routes_settings.settings_pi'))\n    return render_template('settings/pi.html',\n                           misc=misc,\n                           pi_settings=pi_settings,\n                           pigpiod_sample_rate=pigpiod_sample_rate,\n                           form_settings_pi=form_settings_pi)\n", "docstring": "Display general settings \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_settings.py", "original_string": "def settings_diagnostic():\n    \"\"\" Display general settings \"\"\"\n    if not utils_general.user_has_permission('view_settings'):\n        return redirect(url_for('routes_general.home'))\n    form_settings_diagnostic = forms_settings.SettingsDiagnostic()\n    if request.method == 'POST':\n        if not utils_general.user_has_permission('edit_settings'):\n            return redirect(url_for('routes_general.home'))\n        if form_settings_diagnostic.delete_dashboard_elements.data:\n            utils_settings.settings_diagnostic_delete_dashboard_elements()\n        elif form_settings_diagnostic.delete_inputs.data:\n            utils_settings.settings_diagnostic_delete_inputs()\n        elif form_settings_diagnostic.delete_maths.data:\n            utils_settings.settings_diagnostic_delete_maths()\n        elif form_settings_diagnostic.delete_notes_tags.data:\n            utils_settings.settings_diagnostic_delete_notes_tags()\n        elif form_settings_diagnostic.delete_outputs.data:\n            utils_settings.settings_diagnostic_delete_outputs()\n        elif form_settings_diagnostic.delete_settings_database.data:\n            utils_settings.settings_diagnostic_delete_settings_database()\n        elif form_settings_diagnostic.delete_file_dependency.data:\n            utils_settings.settings_diagnostic_delete_file('dependency')\n        elif form_settings_diagnostic.delete_file_upgrade.data:\n            utils_settings.settings_diagnostic_delete_file('upgrade')\n        elif form_settings_diagnostic.reset_email_counter.data:\n            utils_settings.settings_diagnostic_reset_email_counter()\n        return redirect(url_for('routes_settings.settings_diagnostic'))\n    return render_template('settings/diagnostic.html',\n                           form_settings_diagnostic=form_settings_diagnostic)\n", "docstring": "Display general settings \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_authentication.py", "original_string": "def login_check():\n    \"\"\"Authenticate users of the web-UI\"\"\"\n    if not admin_exists():\n        return redirect('/create_admin')\n    elif flask_login.current_user.is_authenticated:\n        flash(gettext(\"Cannot access login page if you're already logged in\"),\n              \"error\")\n        return redirect(url_for('routes_general.home'))\n    settings = Misc.query.first()\n    if settings.default_login_page == \"password\":\n        return redirect(url_for('routes_authentication.login_password'))\n    elif settings.default_login_page == \"keypad\":\n        return redirect(url_for('routes_authentication.login_keypad'))\n    return redirect(url_for('routes_authentication.login_password'))\n", "docstring": "Authenticate users of the web-UI\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_authentication.py", "original_string": "def login_password():\n    \"\"\"Authenticate users of the web-UI\"\"\"\n    if not admin_exists():\n        return redirect('/create_admin')\n    elif flask_login.current_user.is_authenticated:\n        flash(gettext(\"Cannot access login page if you're already logged in\"),\n              \"error\")\n        return redirect(url_for('routes_general.home'))\n    form_login = forms_authentication.Login()\n    # Check if the user is banned from logging in (too many incorrect attempts)\n    if banned_from_login():\n        flash(gettext(\n            \"Too many failed login attempts. Please wait %(min)s \"\n            \"minutes before attempting to log in again\",\n            min=int((LOGIN_BAN_SECONDS - session['ban_time_left']) / 60) + 1),\n                \"info\")\n    else:\n        if request.method == 'POST':\n            username = form_login.username.data.lower()\n            user_ip = request.environ.get('HTTP_X_FORWARDED_FOR', 'unknown address')\n            user = User.query.filter(\n                func.lower(User.name) == username).first()\n            if not user:\n                login_log(username, 'NA', user_ip, 'NOUSER')\n                failed_login()\n            elif form_login.validate_on_submit():\n                matched_hash = User().check_password(\n                    form_login.password.data, user.password_hash)\n                # Encode stored password hash if it's a str\n                password_hash = user.password_hash\n                if isinstance(user.password_hash, str):\n                    password_hash = user.password_hash.encode('utf-8')\n                if matched_hash == password_hash:\n                    user = User.query.filter(User.name == username).first()\n                    role_name = Role.query.filter(Role.id == user.role_id).first().name\n                    login_log(username, role_name, user_ip, 'LOGIN')\n                    # flask-login user\n                    login_user = User()\n                    login_user.id = user.id\n                    remember_me = True if form_login.remember.data else False\n                    flask_login.login_user(login_user, remember=remember_me)\n                    return redirect(url_for('routes_general.home'))\n                else:\n                    user = User.query.filter(User.name == username).first()\n                    role_name = Role.query.filter(Role.id == user.role_id).first().name\n                    login_log(username, role_name, user_ip, 'FAIL')\n                    failed_login()\n            else:\n                login_log(username, 'NA', user_ip, 'FAIL')\n                failed_login()\n            return redirect('/login')\n    return render_template('login_password.html',\n                           dict_translation=TRANSLATIONS,\n                           form_login=form_login,\n                           host=socket.gethostname())\n", "docstring": "Authenticate users of the web-UI\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_authentication.py", "original_string": "def login_keypad():\n    \"\"\"Authenticate users of the web-UI (with keypad)\"\"\"\n    if not admin_exists():\n        return redirect('/create_admin')\n    elif flask_login.current_user.is_authenticated:\n        flash(gettext(\"Cannot access login page if you're already logged in\"),\n              \"error\")\n        return redirect(url_for('routes_general.home'))\n    # Check if the user is banned from logging in (too many incorrect attempts)\n    if banned_from_login():\n        flash(gettext(\n            \"Too many failed login attempts. Please wait %(min)s \"\n            \"minutes before attempting to log in again\",\n            min=int((LOGIN_BAN_SECONDS - session['ban_time_left']) / 60) + 1),\n                \"info\")\n    return render_template('login_keypad.html',\n                           dict_translation=TRANSLATIONS,\n                           host=socket.gethostname())\n", "docstring": "Authenticate users of the web-UI (with keypad)\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_authentication.py", "original_string": "def login_keypad_code_empty():\n    \"\"\"Forward to keypad when no code entered\"\"\"\n    time.sleep(2)\n    flash(\"Please enter a code\", \"error\")\n    return redirect('/login_keypad')\n", "docstring": "Forward to keypad when no code entered\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_authentication.py", "original_string": "def login_keypad_code(code):\n    \"\"\"Check code from keypad\"\"\"\n    if not admin_exists():\n        return redirect('/create_admin')\n    elif flask_login.current_user.is_authenticated:\n        flash(gettext(\"Cannot access login page if you're already logged in\"),\n              \"error\")\n        return redirect(url_for('routes_general.home'))\n    # Check if the user is banned from logging in (too many incorrect attempts)\n    if banned_from_login():\n        flash(gettext(\n            \"Too many failed login attempts. Please wait %(min)s \"\n            \"minutes before attempting to log in again\",\n            min=int((LOGIN_BAN_SECONDS - session['ban_time_left']) / 60) + 1),\n                \"info\")\n    else:\n        user = User.query.filter(User.code == code).first()\n        user_ip = request.environ.get('HTTP_X_FORWARDED_FOR', 'unknown address')\n        if not user:\n            login_log(code, 'NA', user_ip, 'FAIL')\n            failed_login()\n            flash(\"Invalid Code\", \"error\")\n            time.sleep(2)\n        else:\n            role_name = Role.query.filter(Role.id == user.role_id).first().name\n            login_log(user.name, role_name, user_ip, 'LOGIN')\n            # flask-login user\n            login_user = User()\n            login_user.id = user.id\n            remember_me = True\n            flask_login.login_user(login_user, remember=remember_me)\n            return redirect(url_for('routes_general.home'))\n    return render_template('login_keypad.html',\n                           dict_translation=TRANSLATIONS,\n                           host=socket.gethostname())\n", "docstring": "Check code from keypad\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_authentication.py", "original_string": "def logout():\n    \"\"\"Log out of the web-ui\"\"\"\n    user = User.query.filter(User.name == flask_login.current_user.name).first()\n    role_name = Role.query.filter(Role.id == user.role_id).first().name\n    login_log(user.name,\n              role_name,\n              request.environ.get('REMOTE_ADDR', 'unknown address'),\n              'LOGOUT')\n    # flask-login logout\n    flask_login.logout_user()\n    response = clear_cookie_auth()\n    flash(gettext(\"Successfully logged out\"), 'success')\n    return response\n", "docstring": "Log out of the web-ui\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_authentication.py", "original_string": "def newremote():\n    \"\"\"Verify authentication as a client computer to the remote admin\"\"\"\n    username = request.args.get('user')\n    pass_word = request.args.get('passw')\n    user = User.query.filter(\n        User.name == username).first()\n    if user:\n        if User().check_password(\n                pass_word, user.password_hash) == user.password_hash:\n            try:\n                with open('/var/mycodo-root/mycodo/mycodo_flask/ssl_certs/cert.pem', 'r') as cert:\n                    certificate_data = cert.read()\n            except Exception:\n                certificate_data = None\n            return jsonify(status=0,\n                           error_msg=None,\n                           hash=str(user.password_hash),\n                           certificate=certificate_data)\n    return jsonify(status=1,\n                   error_msg=\"Unable to authenticate with user and password.\",\n                   hash=None,\n                   certificate=None)\n", "docstring": "Verify authentication as a client computer to the remote admin\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_authentication.py", "original_string": "def remote_admin_login():\n    \"\"\"Authenticate Remote Admin login\"\"\"\n    password_hash = request.form.get('password_hash', None)\n    username = request.form.get('username', None)\n    if username and password_hash:\n        user = User.query.filter(\n            func.lower(User.name) == username).first()\n    else:\n        user = None\n    if user and str(user.password_hash) == str(password_hash):\n        login_user = User()\n        login_user.id = user.id\n        flask_login.login_user(login_user, remember=False)\n        return \"Logged in via Remote Admin\"\n    else:\n        return \"ERROR\"\n", "docstring": "Authenticate Remote Admin login\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_authentication.py", "original_string": "def remote_auth():\n    \"\"\"Checks authentication for remote admin\"\"\"\n    return \"authenticated\"\n", "docstring": "Checks authentication for remote admin\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_authentication.py", "original_string": "def failed_login():\n    \"\"\"Count the number of failed login attempts\"\"\"\n    try:\n        session['failed_login_count'] += 1\n    except KeyError:\n        session['failed_login_count'] = 1\n    if session['failed_login_count'] > LOGIN_ATTEMPTS - 1:\n        session['failed_login_ban_time'] = time.time()\n        session['failed_login_count'] = 0\n    else:\n        flash('Failed Login ({}/{})'.format(\n            session['failed_login_count'], LOGIN_ATTEMPTS), \"error\")\n", "docstring": "Count the number of failed login attempts\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_static.py", "original_string": "def inject_variables():\n    \"\"\"Variables to send with every page request\"\"\"\n    form_dashboard = forms_dashboard.DashboardConfig()  # Dashboard configuration in layout\n    dashboards = Dashboard.query.all()\n    misc = Misc.query.first()\n    try:\n        if not current_app.config['TESTING']:\n            control = DaemonControl()\n            daemon_status = control.daemon_status()\n        else:\n            daemon_status = '0'\n    except Exception as e:\n        logger.debug(\"URL for 'inject_variables' raised and error: \"\n                     \"{err}\".format(err=e))\n        daemon_status = '0'\n    languages_sorted = sorted(LANGUAGES.items(), key=operator.itemgetter(1))\n    return dict(current_user=flask_login.current_user,\n                dark_themes=THEMES_DARK,\n                daemon_status=daemon_status,\n                dashboards=dashboards,\n                form_dashboard=form_dashboard,\n                hide_alert_info=misc.hide_alert_info,\n                hide_alert_success=misc.hide_alert_success,\n                hide_alert_warning=misc.hide_alert_warning,\n                hide_tooltips=misc.hide_tooltips,\n                host=socket.gethostname(),\n                languages=languages_sorted,\n                mycodo_version=MYCODO_VERSION,\n                permission_view_settings=user_has_permission('view_settings', silent=True),\n                dict_translation=TRANSLATIONS,\n                themes=THEMES,\n                upgrade_available=misc.mycodo_upgrade_available)\n", "docstring": "Variables to send with every page request\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_static.py", "original_string": "def static_from_root():\n    \"\"\"Return static robots.txt\"\"\"\n    return send_from_directory(current_app.static_folder, request.path[1:])\n", "docstring": "Return static robots.txt\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_static.py", "original_string": "def download_pdf_manual():\n    \"\"\"Return PDF Manual\"\"\"\n    path_manual = os.path.join(INSTALL_DIRECTORY, \"docs\")\n    return send_from_directory(path_manual, \"mycodo-manual.pdf\")\n", "docstring": "Return PDF Manual\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_static.py", "original_string": "def not_found(error):\n    return render_template('404.html', error=error), 404\n", "docstring": "return render_template('404.html', error=error), 404"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_password_reset.py", "original_string": "def reset_password():\n    \"\"\"Page to reset user password\"\"\"\n    error = []\n    form_reset_password = forms_authentication.ResetPassword()\n    if request.method == 'POST' and form_reset_password.submit.data:\n        if not form_reset_password.password_reset_code.data:\n            error.append(\"Must enter a reset code\")\n        if not form_reset_password.password.data or not form_reset_password.password_repeat.data:\n            error.append(\"Must enter a password\")\n        if form_reset_password.password.data != form_reset_password.password_repeat.data:\n            error.append(\"Passwords do not match\")\n        if not test_password(form_reset_password.password.data):\n            error.append(gettext(\n                \"Invalid password. Must be between 6 and 64 characters \"\n                \"and only contain letters, numbers, and symbols.\"))\n        if not error:\n            wrong_code_msg = gettext(\"Code expired or invalid\")\n            # Check if code exists\n            user = User.query.filter(User.password_reset_code == form_reset_password.password_reset_code.data).first()\n            if user:\n                # code found, now check if code has expired\n                if datetime.datetime.now() > user.password_reset_code_expiration:\n                    error.append(wrong_code_msg)\n                    user.password_reset_code_expiration = None\n                    user.password_reset_code = None\n                    user.password_reset_last_request = None\n                    db.session.commit()\n                else:\n                    user.set_password(form_reset_password.password.data)\n                    user.password_reset_code_expiration = None\n                    user.password_reset_code = None\n                    user.password_reset_last_request = None\n                    db.session.commit()\n                    flash(\"Password successfully reset\", \"success\")\n                    return redirect(url_for('routes_authentication.login_check'))\n            else:\n                error.append(wrong_code_msg)\n        if error:\n            for each_error in error:\n                flash(each_error, \"error\")\n    return render_template('reset_password.html',\n                           form_reset_password=form_reset_password)\n", "docstring": "Page to reset user password\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_input.py", "original_string": "def page_input_submit():\n    \"\"\" Submit form for Data page \"\"\"\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": []\n    }\n    page_refresh = False\n    input_id = None\n    dep_unmet = ''\n    dep_name = ''\n    dep_list = []\n    form_add_input = forms_input.InputAdd()\n    form_mod_input = forms_input.InputMod()\n    if not utils_general.user_has_permission('edit_controllers'):\n        messages[\"error\"].append(\"Your permissions do not allow this action\")\n    if not messages[\"error\"]:\n        if form_add_input.input_add.data:\n            (messages,\n             dep_name,\n             dep_list,\n             input_id) = utils_input.input_add(form_add_input)\n            if dep_list:\n                dep_unmet = form_add_input.input_type.data.split(',')[0]\n        elif form_mod_input.input_mod.data:\n            messages, page_refresh = utils_input.input_mod(\n                form_mod_input, request.form)\n            input_id = form_mod_input.input_id.data\n        elif form_mod_input.input_delete.data:\n            messages = utils_input.input_del(\n                form_mod_input.input_id.data)\n            input_id = form_mod_input.input_id.data\n        elif form_mod_input.input_activate.data:\n            messages = utils_input.input_activate(form_mod_input)\n            input_id = form_mod_input.input_id.data\n        elif form_mod_input.input_deactivate.data:\n            messages = utils_input.input_deactivate(form_mod_input)\n            input_id = form_mod_input.input_id.data\n        elif form_mod_input.input_acquire_measurements.data:\n            messages = utils_input.force_acquire_measurements(\n                form_mod_input.input_id.data)\n        # Custom action\n        else:\n            custom_button = False\n            for key in request.form.keys():\n                if key.startswith('custom_button_'):\n                    custom_button = True\n                    break\n            if custom_button:\n                messages = utils_general.custom_action(\n                    \"Input\",\n                    parse_input_information(),\n                    form_mod_input.input_id.data,\n                    request.form)\n            else:\n                messages[\"error\"].append(\"Unknown function directive\")\n    return jsonify(data={\n        'input_id': input_id,\n        'dep_name': dep_name,\n        'dep_list': dep_list,\n        'dep_unmet': dep_unmet,\n        'messages': messages,\n        \"page_refresh\": page_refresh\n    })\n", "docstring": "Submit form for Data page \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_input.py", "original_string": "def save_input_layout():\n    \"\"\"Save positions of inputs\"\"\"\n    if not utils_general.user_has_permission('edit_controllers'):\n        return redirect(url_for('routes_general.home'))\n    data = request.get_json()\n    keys = ('id', 'y')\n    for each_input in data:\n        if all(k in each_input for k in keys):\n            input_mod = Input.query.filter(\n                Input.unique_id == each_input['id']).first()\n            if input_mod:\n                input_mod.position_y = each_input['y']\n    db.session.commit()\n    return \"success\"\n", "docstring": "Save positions of inputs\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_dashboard.py", "original_string": "def save_dashboard_layout():\n    \"\"\"Save positions and sizes of widgets of a particular dashboard\"\"\"\n    if not utils_general.user_has_permission('edit_controllers'):\n        return redirect(url_for('routes_general.home'))\n    data = request.get_json()\n    keys = ('id', 'x', 'y', 'w', 'h')\n    for index, each_widget in enumerate(data):\n        if all(k in each_widget for k in keys):\n            widget_mod = Widget.query.filter(\n                Widget.unique_id == each_widget['id']).first()\n            if widget_mod:\n                widget_mod.position_x = each_widget['x']\n                widget_mod.position_y = each_widget['y']\n                widget_mod.width = each_widget['w']\n                widget_mod.height = each_widget['h']\n    db.session.commit()\n    return \"success\"\n", "docstring": "Save positions and sizes of widgets of a particular dashboard\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_dashboard.py", "original_string": "def page_dashboard_default():\n    \"\"\"Load default dashboard\"\"\"\n    dashboard = Dashboard.query.first()\n    return redirect(url_for(\n        'routes_dashboard.page_dashboard', dashboard_id=dashboard.unique_id))\n", "docstring": "Load default dashboard\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_dashboard.py", "original_string": "def page_dashboard_add():\n    \"\"\"Add a dashboard\"\"\"\n    if not utils_general.user_has_permission('edit_controllers'):\n        return redirect(url_for('routes_general.home'))\n    dashboard_id = utils_dashboard.dashboard_add()\n    return redirect(url_for(\n        'routes_dashboard.page_dashboard', dashboard_id=dashboard_id))\n", "docstring": "Add a dashboard\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_function.py", "original_string": "def save_function_layout():\n    \"\"\"Save positions of functions\"\"\"\n    if not utils_general.user_has_permission('edit_controllers'):\n        return redirect(url_for('routes_general.home'))\n    data = request.get_json()\n    keys = ('id', 'y')\n    for each_function in data:\n        if all(k in each_function for k in keys):\n            controller_type = determine_controller_type(each_function['id'])\n            if controller_type == \"Conditional\":\n                mod_device = Conditional.query.filter(\n                    Conditional.unique_id == each_function['id']).first()\n            elif controller_type == \"PID\":\n                mod_device = PID.query.filter(\n                    PID.unique_id == each_function['id']).first()\n            elif controller_type == \"Trigger\":\n                mod_device = Trigger.query.filter(\n                    Trigger.unique_id == each_function['id']).first()\n            elif controller_type == \"Function\":\n                mod_device = Function.query.filter(\n                    Function.unique_id == each_function['id']).first()\n            elif controller_type == \"Function_Custom\":\n                mod_device = CustomController.query.filter(\n                    CustomController.unique_id == each_function['id']).first()\n            else:\n                logger.info(\"Could not find controller with ID {}\".format(\n                    each_function['id']))\n                return \"error\"\n            if mod_device:\n                mod_device.position_y = each_function['y']\n    db.session.commit()\n    return \"success\"\n", "docstring": "Save positions of functions\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def home():\n    \"\"\"Load the default landing page\"\"\"\n    if flask_login.current_user.is_authenticated:\n        if flask_login.current_user.landing_page == 'live':\n            return redirect(url_for('routes_page.page_live'))\n        elif flask_login.current_user.landing_page == 'dashboard':\n            return redirect(url_for('routes_dashboard.page_dashboard_default'))\n        elif flask_login.current_user.landing_page == 'info':\n            return redirect(url_for('routes_page.page_info'))\n        return redirect(url_for('routes_page.page_live'))\n    return clear_cookie_auth()\n", "docstring": "Load the default landing page\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def index_page():\n    \"\"\"Load the index page\"\"\"\n    if not flask_login.current_user.index_page:\n        return home()\n    elif flask_login.current_user.index_page == 'landing':\n        return home()\n    else:\n        if flask_login.current_user.is_authenticated:\n            if flask_login.current_user.index_page == 'live':\n                return redirect(url_for('routes_page.page_live'))\n            elif flask_login.current_user.index_page == 'dashboard':\n                return redirect(url_for('routes_dashboard.page_dashboard_default'))\n            elif flask_login.current_user.index_page == 'info':\n                return redirect(url_for('routes_page.page_info'))\n            return redirect(url_for('routes_page.page_live'))\n    return clear_cookie_auth()\n", "docstring": "Load the index page\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def send_note_attachment(filename):\n    \"\"\"Return a file from the note attachment directory\"\"\"\n    file_path = os.path.join(PATH_NOTE_ATTACHMENTS, filename)\n    if file_path is not None:\n        try:\n            return send_file(file_path, as_attachment=True)\n        except Exception:\n            logger.exception(\"Send note attachment\")\n", "docstring": "Return a file from the note attachment directory\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def camera_img_return_path(camera_unique_id, img_type, filename):\n    \"\"\"Return an image from stills or time-lapses\"\"\"\n    camera = Camera.query.filter(Camera.unique_id == camera_unique_id).first()\n    camera_path = assure_path_exists(\n        os.path.join(PATH_CAMERAS, '{uid}'.format(uid=camera.unique_id)))\n    if img_type == 'still':\n        if camera.path_still:\n            path = camera.path_still\n        else:\n            path = os.path.join(camera_path, img_type)\n    elif img_type == 'timelapse':\n        if camera.path_timelapse:\n            path = camera.path_timelapse\n        else:\n            path = os.path.join(camera_path, img_type)\n    else:\n        return \"Unknown Image Type\"\n    if os.path.isdir(path):\n        files = (files for files in os.listdir(path)\n                 if os.path.isfile(os.path.join(path, files)))\n    else:\n        files = []\n    if filename in files:\n        path_file = os.path.join(path, filename)\n        return send_file(path_file, mimetype='image/jpeg')\n    return \"Image not found\"\n", "docstring": "Return an image from stills or time-lapses\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def camera_img_acquire(image_type, camera_unique_id, max_age):\n    \"\"\"Capture an image and return the filename\"\"\"\n    if image_type == 'new':\n        tmp_filename = None\n    elif image_type == 'tmp':\n        tmp_filename = '{id}_tmp.jpg'.format(id=camera_unique_id)\n    else:\n        return\n    path, filename = camera_record('photo', camera_unique_id, tmp_filename=tmp_filename)\n    image_path = os.path.join(path, filename)\n    time_max_age = datetime.datetime.now() - datetime.timedelta(seconds=int(max_age))\n    timestamp = os.path.getctime(image_path)\n    if datetime.datetime.fromtimestamp(timestamp) > time_max_age:\n        date_time = datetime.datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S')\n        return_values = '[\"{}\",\"{}\"]'.format(filename, date_time)\n    else:\n        return_values = '[\"max_age_exceeded\"]'\n    return Response(return_values, mimetype='text/json')\n", "docstring": "Capture an image and return the filename\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def camera_img_latest_timelapse(camera_unique_id, max_age):\n    \"\"\"Capture an image and/or return a filename\"\"\"\n    _, _, tl_ts, tl_path, _ = utils_general.get_camera_image_info()\n    if camera_unique_id in tl_path and tl_path[camera_unique_id]:\n        camera_path = assure_path_exists(\n            os.path.join(PATH_CAMERAS, '{uid}/timelapse'.format(\n                uid=camera_unique_id)))\n        image_path_full = os.path.join(camera_path, tl_path[camera_unique_id])\n        try:\n            timestamp = os.path.getctime(image_path_full)\n            time_max_age = datetime.datetime.now() - datetime.timedelta(seconds=int(max_age))\n            if datetime.datetime.fromtimestamp(timestamp) > time_max_age:\n                return_values = '[\"{}\",\"{}\"]'.format(tl_path[camera_unique_id],\n                                                     tl_ts[camera_unique_id])\n            else:\n                return_values = '[\"max_age_exceeded\"]'\n        except OSError:\n            return_values = '[\"file_not_found\"]'\n    else:\n        return_values = '[\"file_not_found\"]'\n    return Response(return_values, mimetype='text/json')\n", "docstring": "Capture an image and/or return a filename\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def video_feed(unique_id):\n    \"\"\"Video streaming route. Put this in the src attribute of an img tag.\"\"\"\n    camera_options = Camera.query.filter(Camera.unique_id == unique_id).first()\n    camera_stream = import_module('mycodo.mycodo_flask.camera.camera_' + camera_options.library).Camera\n    camera_stream.set_camera_options(camera_options)\n    return Response(gen(camera_stream(unique_id=unique_id)),\n                    mimetype='multipart/x-mixed-replace; boundary=frame')\n", "docstring": "Video streaming route. Put this in the src attribute of an img tag.\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def gpio_state():\n    \"\"\"Return all output states\"\"\"\n    return jsonify(get_all_output_states())\n", "docstring": "Return all output states\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def gpio_state_unique_id(unique_id, channel_id):\n    \"\"\"Return the GPIO state, for dashboard output \"\"\"\n    channel = OutputChannel.query.filter(OutputChannel.unique_id == channel_id).first()\n    daemon_control = DaemonControl()\n    state = daemon_control.output_state(unique_id, channel.channel)\n    return jsonify(state)\n", "docstring": "Return the GPIO state, for dashboard output \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def widget_execute(unique_id):\n    \"\"\"Return the response from the execution of widget code \"\"\"\n    daemon_control = DaemonControl()\n    return_value = daemon_control.widget_execute(unique_id)\n    return jsonify(return_value)\n", "docstring": "Return the response from the execution of widget code \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def get_time():\n    \"\"\" Return the current time \"\"\"\n    return jsonify(datetime.datetime.now().strftime('%m/%d %H:%M'))\n", "docstring": "Return the current time \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def download_file(dl_type, filename):\n    \"\"\"Serve log file to download\"\"\"\n    if dl_type == 'log':\n        return send_from_directory(LOG_PATH, filename, as_attachment=True)\n    return '', 204\n", "docstring": "Serve log file to download\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def generate_thermal_image_from_timestamp(unique_id, timestamp):\n    \"\"\"Return a file from the note attachment directory\"\"\"\n    ts_now = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')\n    camera_path = assure_path_exists(\n        os.path.join(PATH_CAMERAS, '{uid}'.format(uid=unique_id)))\n    filename = 'Still-{uid}-{ts}.jpg'.format(\n        uid=unique_id,\n        ts=ts_now).replace(\" \", \"_\")\n    save_path = assure_path_exists(os.path.join(camera_path, 'thermal'))\n    assure_path_exists(save_path)\n    path_file = os.path.join(save_path, filename)\n    dbcon = InfluxDBClient(\n        INFLUXDB_HOST,\n        INFLUXDB_PORT,\n        INFLUXDB_USER,\n        INFLUXDB_PASSWORD,\n        INFLUXDB_DATABASE)\n    input_dev = Input.query.filter(Input.unique_id == unique_id).first()\n    pixels = []\n    success = True\n    start = int(int(timestamp) / 1000.0)  # Round down\n    end = start + 1  # Round up\n    start_timestamp = time.strftime('%Y-%m-%dT%H:%M:%S.000000000Z', time.gmtime(start))\n    end_timestamp = time.strftime('%Y-%m-%dT%H:%M:%S.000000000Z', time.gmtime(end))\n    for each_channel in range(input_dev.channels):\n        measurement = 'channel_{chan}'.format(\n            chan=each_channel)\n        query_str = query_string(measurement, unique_id,\n                                 start_str=start_timestamp,\n                                 end_str=end_timestamp)\n        if query_str == 1:\n            logger.error('Invalid query string')\n            success = False\n        else:\n            raw_data = dbcon.query(query_str).raw\n            if not raw_data or 'series' not in raw_data or not raw_data['series']:\n                logger.error('No measurements to export in this time period')\n                success = False\n            else:\n                pixels.append(raw_data['series'][0]['values'][0][1])\n    # logger.error(\"generate_thermal_image_from_timestamp: success: {}, pixels: {}\".format(success, pixels))\n    if success:\n        generate_thermal_image_from_pixels(pixels, 8, 8, path_file)\n        return send_file(path_file, mimetype='image/jpeg')\n    else:\n        return \"Could not generate image\"\n", "docstring": "Return a file from the note attachment directory\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def output_mod(output_id, channel, state, output_type, amount):\n    \"\"\" Manipulate output (using non-unique ID) \"\"\"\n    if not utils_general.user_has_permission('edit_controllers'):\n        return 'Insufficient user permissions to manipulate outputs'\n    if is_int(channel):\n        # if an integer was returned\n        output_channel = int(channel)\n    else:\n        # if a channel ID was returned\n        channel_dev = db_retrieve_table(OutputChannel).filter(\n            OutputChannel.unique_id == channel).first()\n        if channel_dev:\n            output_channel = channel_dev.channel\n        else:\n            return \"Could not determine channel number from channel ID '{}'\".format(channel)\n    daemon = DaemonControl()\n    if (state in ['on', 'off'] and str_is_float(amount) and\n            (\n                (output_type in ['sec', 'pwm'] and float(amount) >= 0) or\n                output_type == 'vol' or\n                output_type == 'value'\n            )):\n        out_status = daemon.output_on_off(\n            output_id,\n            state,\n            output_type=output_type,\n            amount=float(amount),\n            output_channel=output_channel)\n        if out_status[0]:\n            return 'ERROR: {}'.format(out_status[1])\n        else:\n            return 'SUCCESS: {}'.format(out_status[1])\n    else:\n        return 'ERROR: unknown parameters: ' \\\n               'output_id: {}, channel: {}, state: {}, output_type: {}, amount: {}'.format(\n                output_id, channel, state, output_type, amount)\n", "docstring": "Manipulate output (using non-unique ID) \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def daemon_active():\n    \"\"\"Return 'alive' if the daemon is running\"\"\"\n    try:\n        control = DaemonControl()\n        return control.daemon_status()\n    except Exception as e:\n        logger.error(\"URL for 'daemon_active' raised and error: \"\n                     \"{err}\".format(err=e))\n        return '0'\n", "docstring": "Return 'alive' if the daemon is running\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def computer_command(action):\n    \"\"\"Execute one of several commands as root\"\"\"\n    if not utils_general.user_has_permission('edit_settings'):\n        return redirect(url_for('routes_general.home'))\n    try:\n        if action not in ['restart', 'shutdown', 'daemon_restart', 'frontend_reload']:\n            flash(\"Unrecognized command: {action}\".format(\n                action=action), \"success\")\n            return redirect('/settings')\n        if DOCKER_CONTAINER:\n            if action == 'daemon_restart':\n                control = DaemonControl()\n                control.terminate_daemon()\n                flash(gettext(\"Command to restart the daemon sent\"), \"success\")\n            elif action == 'frontend_reload':\n                subprocess.Popen('docker restart mycodo_flask 2>&1', shell=True)\n                flash(gettext(\"Command to reload the frontend sent\"), \"success\")\n        else:\n            cmd = '{path}/mycodo/scripts/mycodo_wrapper {action} 2>&1'.format(\n                    path=INSTALL_DIRECTORY, action=action)\n            subprocess.Popen(cmd, shell=True)\n        if action == 'restart':\n            flash(gettext(\"System rebooting in 10 seconds\"), \"success\")\n        elif action == 'shutdown':\n            flash(gettext(\"System shutting down in 10 seconds\"), \"success\")\n        elif action == 'daemon_restart':\n            flash(gettext(\"Command to restart the daemon sent\"), \"success\")\n        elif action == 'frontend_reload':\n            flash(gettext(\"Command to reload the frontend sent\"), \"success\")\n        return redirect('/settings')\n    except Exception as e:\n        logger.error(\"System command '{cmd}' raised and error: \"\n                     \"{err}\".format(cmd=action, err=e))\n        flash(\"System command '{cmd}' raised and error: \"\n              \"{err}\".format(cmd=action, err=e), \"error\")\n        return redirect(url_for('routes_general.home'))\n", "docstring": "Execute one of several commands as root\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def return_point_timestamp(dev_id, unit, period, measurement=None, channel=None):\n    dbcon = InfluxDBClient(\n        INFLUXDB_HOST,\n        INFLUXDB_PORT,\n        INFLUXDB_USER,\n        INFLUXDB_PASSWORD,\n        INFLUXDB_DATABASE)\n    query_str = query_string(\n        unit,\n        dev_id,\n        measure=measurement,\n        channel=channel,\n        value='LAST',\n        past_sec=period)\n    if query_str == 1:\n        return [None, None]\n    try:\n        raw_data = dbcon.query(query_str).raw\n        number = len(raw_data['series'][0]['values'])\n        time_raw = raw_data['series'][0]['values'][number - 1][0]\n        value = raw_data['series'][0]['values'][number - 1][1]\n        value = '{:.3f}'.format(float(value))\n        # Convert date-time to epoch (potential bottleneck for data)\n        dt = date_parse(time_raw)\n        timestamp = calendar.timegm(dt.timetuple()) * 1000\n        return [timestamp, value]\n    except KeyError:\n        return [None, None]\n    except Exception:\n        return [None, None]\n", "docstring": "dbcon = InfluxDBClient("}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_general.py", "original_string": "def pid_mod_unique_id(unique_id, state):\n    \"\"\" Manipulate output (using unique ID) \"\"\"\n    if not utils_general.user_has_permission('edit_controllers'):\n        return 'Insufficient user permissions to manipulate PID'\n    pid = PID.query.filter(PID.unique_id == unique_id).first()\n    daemon = DaemonControl()\n    if state == 'activate_pid':\n        pid.is_activated = True\n        pid.save()\n        _, return_str = daemon.controller_activate(pid.unique_id)\n        return return_str\n    elif state == 'deactivate_pid':\n        pid.is_activated = False\n        pid.is_paused = False\n        pid.is_held = False\n        pid.save()\n        _, return_str = daemon.controller_deactivate(pid.unique_id)\n        return return_str\n    elif state == 'pause_pid':\n        pid.is_paused = True\n        pid.save()\n        if pid.is_activated:\n            return_str = daemon.pid_pause(pid.unique_id)\n        else:\n            return_str = \"PID Paused (Note: PID is not currently active)\"\n        return return_str\n    elif state == 'hold_pid':\n        pid.is_held = True\n        pid.save()\n        if pid.is_activated:\n            return_str = daemon.pid_hold(pid.unique_id)\n        else:\n            return_str = \"PID Held (Note: PID is not currently active)\"\n        return return_str\n    elif state == 'resume_pid':\n        pid.is_held = False\n        pid.is_paused = False\n        pid.save()\n        if pid.is_activated:\n            return_str = daemon.pid_resume(pid.unique_id)\n        else:\n            return_str = \"PID Resumed (Note: PID is not currently active)\"\n        return return_str\n    elif 'set_setpoint_pid' in state:\n        pid.setpoint = state.split('|')[1]\n        pid.save()\n        if pid.is_activated:\n            return_str = daemon.pid_set(pid.unique_id, 'setpoint', float(state.split('|')[1]))\n        else:\n            return_str = \"PID Setpoint changed (Note: PID is not currently active)\"\n        return return_str\n", "docstring": "Manipulate output (using unique ID) \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_remote_admin.py", "original_string": "def remote_input():\n    \"\"\"Returns input information for remote administration\"\"\"\n    if not utils_general.user_has_permission('edit_settings'):\n        return redirect(url_for('routes_general.home'))\n    remote_hosts = Remote.query.all()\n    display_order_unsplit = DisplayOrder.query.first().remote_host\n    if display_order_unsplit:\n        display_order = display_order_unsplit.split(\",\")\n    else:\n        display_order = []\n    host_auth = {}\n    host_inputs = {}\n    for each_host in remote_hosts:\n        # Return input information about each host\n        headers = remote_log_in(\n            each_host.host, each_host.username, each_host.password_hash)\n        _, host_inputs[each_host.host] = remote_host_page(\n            each_host.host, headers, 'remote_get_inputs')\n        host_inputs[each_host.host] = json.loads(host_inputs[each_host.host])\n    return render_template('remote/input.html',\n                           display_order=display_order,\n                           remote_hosts=remote_hosts,\n                           host_auth=host_auth,\n                           host_inputs=host_inputs)\n", "docstring": "Returns input information for remote administration\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_remote_admin.py", "original_string": "def remote_setup():\n    \"\"\"Return pages for remote administration\"\"\"\n    if not utils_general.user_has_permission('edit_settings'):\n        return redirect(url_for('routes_general.home'))\n    remote_hosts = Remote.query.all()\n    display_order_unsplit = DisplayOrder.query.first().remote_host\n    if display_order_unsplit:\n        display_order = display_order_unsplit.split(\",\")\n    else:\n        display_order = []\n    form_setup = forms_authentication.RemoteSetup()\n    if request.method == 'POST':\n        if form_setup.add.data:\n            utils_remote_host.remote_host_add(form_setup,\n                                              display_order)\n        elif form_setup.delete.data:\n            utils_remote_host.remote_host_del(form_setup)\n        return redirect('/remote/setup')\n    host_auth = {}\n    for each_host in remote_hosts:\n        headers = remote_log_in(\n            each_host.host, each_host.username, each_host.password_hash)\n        _, host_auth[each_host.host] = remote_host_page(\n            each_host.host, headers, 'auth')\n    return render_template('remote/setup.html',\n                           form_setup=form_setup,\n                           display_order=display_order,\n                           remote_hosts=remote_hosts,\n                           host_auth=host_auth)\n", "docstring": "Return pages for remote administration\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_method.py", "original_string": "def method_list():\n    \"\"\" List all methods on one page with a graph for each \"\"\"\n    form_create_method = forms_method.MethodCreate()\n    method = Method.query.all()\n    method_all = MethodData.query.all()\n    return render_template('pages/method-list.html',\n                           method=method,\n                           method_all=method_all,\n                           method_info=METHOD_INFO,\n                           form_create_method=form_create_method)\n", "docstring": "List all methods on one page with a graph for each \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_output.py", "original_string": "def page_output_submit():\n    \"\"\" Submit form for Output page \"\"\"\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": []\n    }\n    page_refresh = False\n    output_id = None\n    dep_unmet = ''\n    dep_name = ''\n    dep_list = []\n    size_y = None\n    form_add_output = forms_output.OutputAdd()\n    form_mod_output = forms_output.OutputMod()\n    if not utils_general.user_has_permission('edit_controllers'):\n        messages[\"error\"].append(\"Your permissions do not allow this action\")\n    if not messages[\"error\"]:\n        if form_add_output.output_add.data:\n            (messages,\n             dep_name,\n             dep_list,\n             output_id,\n             size_y) = utils_output.output_add(\n                form_add_output, request.form)\n            if dep_list:\n                dep_unmet = form_add_output.output_type.data.split(',')[0]\n        elif form_mod_output.output_mod.data:\n            messages, page_refresh = utils_output.output_mod(\n                form_mod_output, request.form)\n            output_id = form_mod_output.output_id.data\n        elif form_mod_output.output_delete.data:\n            messages = utils_output.output_del(form_mod_output)\n            output_id = form_mod_output.output_id.data\n        # Custom action\n        else:\n            custom_button = False\n            for key in request.form.keys():\n                if key.startswith('custom_button_'):\n                    custom_button = True\n                    break\n            if custom_button:\n                messages = utils_general.custom_action(\n                    \"Output\",\n                    parse_output_information(),\n                    form_mod_output.output_id.data,\n                    request.form)\n            else:\n                messages[\"error\"].append(\"Unknown output directive\")\n    return jsonify(data={\n        'output_id': output_id,\n        'dep_name': dep_name,\n        'dep_list': dep_list,\n        'dep_unmet': dep_unmet,\n        'size_y': size_y,\n        'messages': messages,\n        \"page_refresh\": page_refresh\n    })\n", "docstring": "Submit form for Output page \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_output.py", "original_string": "def save_output_layout():\n    \"\"\"Save positions of outputs\"\"\"\n    if not utils_general.user_has_permission('edit_controllers'):\n        return redirect(url_for('routes_general.home'))\n    data = request.get_json()\n    keys = ('id', 'y')\n    for each_output in data:\n        if all(k in each_output for k in keys):\n            output_mod = Output.query.filter(\n                Output.unique_id == each_output['id']).first()\n            if output_mod:\n                output_mod.position_y = each_output['y']\n    db.session.commit()\n    return \"success\"\n", "docstring": "Save positions of outputs\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/app.py", "original_string": "def register_blueprints(app):\n    \"\"\" register blueprints to the app \"\"\"\n    app.register_blueprint(routes_admin.blueprint)  # register admin views\n    app.register_blueprint(routes_authentication.blueprint)  # register login/logout views\n    app.register_blueprint(routes_password_reset.blueprint)  # register password reset views\n    app.register_blueprint(routes_dashboard.blueprint)  # register dashboard views\n    app.register_blueprint(routes_function.blueprint)  # register function views\n    app.register_blueprint(routes_general.blueprint)  # register general routes\n    app.register_blueprint(routes_input.blueprint)  # register input routes\n    app.register_blueprint(routes_method.blueprint)  # register method views\n    app.register_blueprint(routes_output.blueprint)  # register output views\n    app.register_blueprint(routes_page.blueprint)  # register page views\n    app.register_blueprint(routes_remote_admin.blueprint)  # register remote admin views\n    app.register_blueprint(routes_settings.blueprint)  # register settings views\n    app.register_blueprint(routes_static.blueprint)  # register static routes\n", "docstring": "register blueprints to the app \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_page.py", "original_string": "def page_live():\n    \"\"\" Page of recent and updating input data \"\"\"\n    # Get what each measurement uses for a unit\n    function = CustomController.query.all()\n    device_measurements = DeviceMeasurements.query.all()\n    input_dev = Input.query.all()\n    output = Output.query.all()\n    math = Math.query.all()\n    activated_inputs = Input.query.filter(Input.is_activated).count()\n    activated_functions = CustomController.query.filter(CustomController.is_activated).count()\n    use_unit = utils_general.use_unit_generate(\n        device_measurements, input_dev, output, math, function)\n    # Display orders\n    display_order_input = csv_to_list_of_str(DisplayOrder.query.first().inputs)\n    display_order_function = csv_to_list_of_str(DisplayOrder.query.first().function)\n    # Generate all measurement and units used\n    dict_measurements = add_custom_measurements(Measurement.query.all())\n    dict_units = add_custom_units(Unit.query.all())\n    dict_controllers = parse_function_information()\n    custom_options_values_controllers = parse_custom_option_values(\n        function, dict_controller=dict_controllers)\n    dict_measure_measurements = {}\n    dict_measure_units = {}\n    for each_measurement in device_measurements:\n        conversion = Conversion.query.filter(\n            Conversion.unique_id == each_measurement.conversion_id).first()\n        _, unit, measurement = return_measurement_info(each_measurement, conversion)\n        dict_measure_measurements[each_measurement.unique_id] = measurement\n        dict_measure_units[each_measurement.unique_id] = unit\n    return render_template('pages/live.html',\n                           and_=and_,\n                           activated_inputs=activated_inputs,\n                           activated_functions=activated_functions,\n                           custom_options_values_controllers=custom_options_values_controllers,\n                           table_device_measurements=DeviceMeasurements,\n                           table_input=Input,\n                           table_function=CustomController,\n                           dict_measurements=dict_measurements,\n                           dict_units=dict_units,\n                           dict_measure_measurements=dict_measure_measurements,\n                           dict_measure_units=dict_measure_units,\n                           display_order_input=display_order_input,\n                           display_order_function=display_order_function,\n                           list_devices_adc=list_analog_to_digital_converters(),\n                           measurement_units=MEASUREMENTS,\n                           use_unit=use_unit)\n", "docstring": "Page of recent and updating input data \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/routes_page.py", "original_string": "def page_usage_reports():\n    \"\"\" Display output usage (duration and energy usage/cost) \"\"\"\n    if not utils_general.user_has_permission('view_stats'):\n        return redirect(url_for('routes_general.home'))\n    report_location = os.path.normpath(USAGE_REPORTS_PATH)\n    reports = [0, 0]\n    return render_template('pages/usage_reports.html',\n                           report_location=report_location,\n                           reports=reports)\n", "docstring": "Display output usage (duration and energy usage/cost) \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/measurement.py", "original_string": "    def post(self, unique_id, unit, channel, value):\n        \"\"\"Create a measurement\"\"\"\n        if not utils_general.user_has_permission('edit_controllers'):\n            abort(403)\n        if unit not in add_custom_units(Unit.query.all()):\n            abort(422, custom='Unit ID not found')\n        if channel < 0:\n            abort(422, custom='channel must be >= 0')\n        try:\n            value = float(value)\n        except:\n            abort(422, custom='value does not represent a float')\n        timestamp = None\n        if ns_measurement.payload and 'timestamp' in ns_measurement.payload:\n            ts = ns_measurement.payload[\"timestamp\"]\n            if ts is not None:\n                if valid_date_str(ts):\n                    timestamp = datetime.datetime.strptime(\n                        ts, '%Y-%m-%dT%H:%M:%S.%fZ')\n                else:\n                    abort(422, custom='Invalid timestamp format. Must be formatted as %Y-%m-%dT%H:%M:%S.%fZ')\n        try:\n            return_ = write_influxdb_value(\n                unique_id, unit, value, channel=channel, timestamp=timestamp)\n            if return_:\n                abort(500)\n            else:\n                return {'message': 'Success'}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Create a measurement\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/output.py", "original_string": "    def get(self):\n        \"\"\"Show all output settings and statuses\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(OutputSchema, Output)\n            list_channels = get_from_db(OutputChannelSchema, OutputChannel)\n            states = get_all_output_states()\n            # Change integer channel keys to strings (flask-restx limitation?)\n            new_state_dict = {}\n            for each_id in states:\n                new_state_dict[each_id] = {}\n                for each_channel in states[each_id]:\n                    new_state_dict[each_id][str(each_channel)] = states[each_id][each_channel]\n            if list_data:\n                return {'output devices': list_data,\n                        'output channels': list_channels,\n                        'output states': new_state_dict}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show all output settings and statuses\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/output.py", "original_string": "    def get(self, unique_id):\n        \"\"\"Show the settings and status for an output\"\"\"\n        if not utils_general.user_has_permission('edit_controllers'):\n            abort(403)\n        try:\n            list_data = get_from_db(OutputSchema, Output, unique_id=unique_id)\n            output_channel_schema = OutputChannelSchema()\n            list_channels = return_list_of_dictionaries(\n                output_channel_schema.dump(\n                    OutputChannel.query.filter_by(\n                        output_id=unique_id).all(), many=True))\n            states = get_all_output_states()\n            # Change integer channel keys to strings (flask-restx limitation?)\n            new_state_dict = {}\n            for each_channel in states[unique_id]:\n                new_state_dict[str(each_channel)] = states[unique_id][each_channel]\n            return {'output device': list_data,\n                    'output device channels': list_channels,\n                    'output device channel states': new_state_dict}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show the settings and status for an output\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/math.py", "original_string": "    def get(self):\n        \"\"\"Show all math settings\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(MathSchema, Math)\n            if list_data:\n                return {'math settings': list_data}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show all math settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/input.py", "original_string": "    def get(self):\n        \"\"\"Show all input settings\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(InputSchema, Input)\n            list_channels = get_from_db(InputChannelSchema, InputChannel)\n            if list_data:\n                return {'input settings': list_data,\n                        'input channels': list_channels}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show all input settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/input.py", "original_string": "    def get(self, unique_id):\n        \"\"\"Show the settings for an input\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(InputSchema, Input, unique_id=unique_id)\n            measure_schema = InputChannelSchema()\n            list_channels = return_list_of_dictionaries(\n                measure_schema.dump(\n                    InputChannel.query.filter_by(\n                        input_id=unique_id).all(), many=True))\n            measure_schema = DeviceMeasurementsSchema()\n            list_measurements = return_list_of_dictionaries(\n                measure_schema.dump(\n                    DeviceMeasurements.query.filter_by(\n                        device_id=unique_id).all(), many=True))\n            return {'input settings': list_data,\n                    'input channels': list_channels,\n                    'device measurements': list_measurements}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show the settings for an input\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/pid.py", "original_string": "    def get(self):\n        \"\"\"Show all pid settings\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(PIDSchema, PID)\n            if list_data:\n                return {'pid settings': list_data}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show all pid settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/daemon.py", "original_string": "    def get(self):\n        \"\"\"Get the status of the daemon\"\"\"\n        if not utils_general.user_has_permission('edit_controllers'):\n            abort(403)\n        try:\n            control = DaemonControl()\n            status = control.daemon_status()\n            ram = control.ram_use()\n            virtualenv = control.is_in_virtualenv()\n            if status == 'alive':\n                return {\n                   'is_running': True,\n                   'RAM': ram,\n                   'python_virtual_env': virtualenv\n                }, 200\n        except Exception:\n            return {\n               'is_running': False,\n               'RAM': None,\n               'python_virtual_env': None\n            }, 200\n", "docstring": "Get the status of the daemon\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/function.py", "original_string": "    def get(self):\n        \"\"\"Show all function settings\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(FunctionSchema, CustomController)\n            list_channels = get_from_db(FunctionChannelSchema, FunctionChannel)\n            if list_data:\n                return {'function settings': list_data,\n                        'function channels': list_channels}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show all function settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self):\n        \"\"\"Show all device measurement settings\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(\n                DeviceMeasurementsSchema, DeviceMeasurements)\n            if list_data:\n                return {'device measurement settings': list_data}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show all device measurement settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self, unique_id):\n        \"\"\"Show the settings for a device measurement with the unique_id\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            dict_data = get_from_db(\n                DeviceMeasurementsSchema,\n                DeviceMeasurements,\n                unique_id=unique_id)\n            if dict_data:\n                return dict_data, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show the settings for a device measurement with the unique_id\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self, device_id):\n        \"\"\"Show the settings for all device measurements with the device_id\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            measure_schema = DeviceMeasurementsSchema()\n            list_data = return_list_of_dictionaries(\n                measure_schema.dump(\n                    DeviceMeasurements.query.filter_by(\n                        device_id=device_id).all(), many=True))\n            if list_data:\n                return {'device measurement settings': list_data}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show the settings for all device measurements with the device_id\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self):\n        \"\"\"Show all input settings\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(InputSchema, Input)\n            if list_data:\n                return {'input settings': list_data}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show all input settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self, unique_id):\n        \"\"\"Show the settings for an input\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            dict_data = get_from_db(InputSchema, Input, unique_id=unique_id)\n            if dict_data:\n                return dict_data, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show the settings for an input\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self):\n        \"\"\"Show all math settings\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(MathSchema, Math)\n            if list_data:\n                return {'math settings': list_data}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show all math settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self, unique_id):\n        \"\"\"Show the settings for an math\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            dict_data = get_from_db(MathSchema, Math, unique_id=unique_id)\n            if dict_data:\n                return dict_data, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show the settings for an math\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self):\n        \"\"\"Show all measurement settings\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(MeasurementSchema, Measurement)\n            if list_data:\n                return {'measurement settings': list_data}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show all measurement settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self, unique_id):\n        \"\"\"Show the settings for a measurement with the unique_id\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            dict_data = get_from_db(\n                MeasurementSchema, Measurement, unique_id=unique_id)\n            if dict_data:\n                return dict_data, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show the settings for a measurement with the unique_id\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self):\n        \"\"\"Show all output settings\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(OutputSchema, Output)\n            if list_data:\n                return {'output settings': list_data}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show all output settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self, unique_id):\n        \"\"\"Show the settings for an output with the unique_id\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            dict_data = get_from_db(OutputSchema, Output, unique_id=unique_id)\n            if dict_data:\n                return dict_data, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show the settings for an output with the unique_id\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self):\n        \"\"\"Show all pid settings\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(PIDSchema, PID)\n            if list_data:\n                return {'pid settings': list_data}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show all pid settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self, unique_id):\n        \"\"\"Show the settings for a pid with the unique_id\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            dict_data = get_from_db(PIDSchema, PID, unique_id=unique_id)\n            if dict_data:\n                return dict_data, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show the settings for a pid with the unique_id\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self):\n        \"\"\"Show all trigger settings\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(TriggerSchema, Trigger)\n            if list_data:\n                return {'trigger settings': list_data}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show all trigger settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self, unique_id):\n        \"\"\"Show the settings for a trigger with the unique_id\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            dict_data = get_from_db(TriggerSchema, Trigger, unique_id=unique_id)\n            if dict_data:\n                return dict_data, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show the settings for a trigger with the unique_id\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self):\n        \"\"\"Show all unit settings\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(UnitSchema, Unit)\n            if list_data:\n                return {'unit settings': list_data}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show all unit settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self, unique_id):\n        \"\"\"Show the settings for a unit with the unique_id\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            dict_data = get_from_db(UnitSchema, Unit, unique_id=unique_id)\n            if dict_data:\n                return dict_data, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show the settings for a unit with the unique_id\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/settings.py", "original_string": "    def get(self):\n        \"\"\"Show all user settings\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            list_data = get_from_db(UserSchema, User)\n            if list_data:\n                return {'user settings': list_data}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show all user settings\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/controller.py", "original_string": "    def get(self, unique_id):\n        \"\"\"Get the status of a controller\"\"\"\n        if not utils_general.user_has_permission('edit_controllers'):\n            abort(403)\n        try:\n            control = DaemonControl()\n            active = control.controller_is_active(unique_id)\n            return {'is_active': active}, 200\n        except Exception:\n            abort(500, custom=traceback.format_exc())\n", "docstring": "Get the status of a controller\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/choices.py", "original_string": "    def get(self):\n        \"\"\"Show form choices for all controllers\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            choices_controllers = utils_general.choices_controller_ids()\n            return {'choices controllers': choices_controllers}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show form choices for all controllers\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/choices.py", "original_string": "    def get(self):\n        \"\"\"Show form choices for all input measurements\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            input_dev = Input.query.all()\n            dict_measurements = add_custom_measurements(\n                Measurement.query.all())\n            dict_units = add_custom_units(Unit.query.all())\n            input_choices = utils_general.choices_inputs(\n                input_dev, dict_units, dict_measurements)\n            if input_choices:\n                return {'choices inputs measurements': input_choices}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show form choices for all input measurements\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/choices.py", "original_string": "    def get(self):\n        \"\"\"Show form choices for all math measurements\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            math = Math.query.all()\n            dict_measurements = add_custom_measurements(\n                Measurement.query.all())\n            dict_units = add_custom_units(Unit.query.all())\n            math_choices = utils_general.choices_maths(\n                math, dict_units, dict_measurements)\n            if math_choices:\n                return {'choices maths measurements': math_choices}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show form choices for all math measurements\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/choices.py", "original_string": "    def get(self):\n        \"\"\"Show form choices for all output devices\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            choices_output_devices = utils_general.choices_output_devices(\n                Output.query.all())\n            return {'choices outputs devices': choices_output_devices}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show form choices for all output devices\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/api/choices.py", "original_string": "    def get(self):\n        \"\"\"Show form choices for all output measurements\"\"\"\n        if not utils_general.user_has_permission('view_settings'):\n            abort(403)\n        try:\n            output = Output.query.all()\n            dict_measurements = add_custom_measurements(\n                Measurement.query.all())\n            dict_units = add_custom_units(Unit.query.all())\n            output_choices = utils_general.choices_outputs(\n                output, dict_units, dict_measurements)\n            if output_choices:\n                return {'choices outputs measurements': output_choices}, 200\n        except Exception:\n            abort(500,\n                  message='An exception occurred',\n                  error=traceback.format_exc())\n", "docstring": "Show form choices for all output measurements\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/camera/base_camera.py", "original_string": "    def set(self):\n        \"\"\"Invoked by the camera thread when a new frame is available.\"\"\"\n        now = time.time()\n        remove = None\n        for ident, event in self.events.items():\n            if not event[0].isSet():\n                # if this client's event is not set, then set it\n                # also update the last set timestamp to now\n                event[0].set()\n                event[1] = now\n            else:\n                # if the client's event is already set, it means the client\n                # did not process a previous frame\n                # if the event stays set for more than 5 seconds, then assume\n                # the client is gone and remove it\n                if now - event[1] > 5:\n                    remove = ident\n        if remove:\n            del self.events[remove]\n", "docstring": "Invoked by the camera thread when a new frame is available.\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/camera/base_camera.py", "original_string": "    def __init__(self, unique_id=None):\n        \"\"\"Start the background camera thread if it isn't running yet.\"\"\"\n        self.unique_id = unique_id\n        BaseCamera.event[self.unique_id] = CameraEvent()\n        BaseCamera.running[self.unique_id] = True\n        if self.unique_id not in BaseCamera.thread:\n            BaseCamera.thread[self.unique_id] = None\n        if BaseCamera.thread[self.unique_id] is None:\n            BaseCamera.last_access[self.unique_id] = time.time()\n            # start background frame thread\n            BaseCamera.thread[self.unique_id] = threading.Thread(\n                target=self._thread, args=(self.unique_id,))\n            BaseCamera.thread[self.unique_id].start()\n            # wait until frames are available\n            while self.get_frame() is None:\n                time.sleep(0)\n", "docstring": "Start the background camera thread if it isn't running yet.\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/camera/base_camera.py", "original_string": "    def frames():\n        \"\"\"\"Generator that returns frames from the camera.\"\"\"\n        raise RuntimeError('Must be implemented by subclasses')\n", "docstring": "\"Generator that returns frames from the camera.\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/camera/base_camera.py", "original_string": "    def _thread(cls, unique_id):\n        \"\"\"Camera background thread.\"\"\"\n        logger.info('[{id}] Starting camera thread'.format(id=unique_id))\n        frames_iterator = cls.frames()\n        for frame in frames_iterator:\n            BaseCamera.frame[unique_id] = frame\n            BaseCamera.event[unique_id].set()  # send signal to clients\n            time.sleep(0)\n            # if there haven't been any clients asking for frames in\n            # the last 10 seconds then stop the thread\n            if time.time() - BaseCamera.last_access[unique_id] > 10:\n                frames_iterator.close()\n                logger.info('[{id}] Stopping camera thread due to '\n                            'inactivity'.format(id=unique_id))\n                break\n            if not BaseCamera.running[unique_id]:\n                frames_iterator.close()\n                logger.info('[{id}] Camera thread instructed to '\n                            'shut down'.format(id=unique_id))\n                break\n        BaseCamera.thread[unique_id] = None\n        BaseCamera.running[unique_id] = False\n", "docstring": "Camera background thread.\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_conditional.py", "original_string": "def conditional_mod(form):\n    \"\"\"Modify a Conditional\"\"\"\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": [],\n        \"page_refresh\": True,\n        \"return_text\": [],\n        \"name\": None\n    }\n    try:\n        if current_app.config['TESTING']:\n            cmd_status = None\n            pylint_message = \"\"\n        else:\n            messages[\"error\"], lines_code, cmd_status, cmd_out = save_conditional_code(\n                messages[\"error\"],\n                form.conditional_statement.data,\n                form.conditional_status.data,\n                form.function_id.data,\n                ConditionalConditions.query.all(),\n                Actions.query.all(),\n                timeout=form.pyro_timeout.data,\n                test=True)\n            pylint_message = Markup(\n                '<pre>\\n\\n'\n                'Full Conditional Statement code:\\n\\n{code}\\n\\n'\n                'Conditional Statement code analysis:\\n\\n{report}'\n                '</pre>'.format(\n                    code=lines_code, report=cmd_out.decode(\"utf-8\")))\n        cond_mod = Conditional.query.filter(\n            Conditional.unique_id == form.function_id.data).first()\n        cond_mod.name = form.name.data\n        messages[\"name\"] = form.name.data\n        cond_mod.conditional_statement = form.conditional_statement.data\n        cond_mod.conditional_status = form.conditional_status.data\n        cond_mod.period = form.period.data\n        cond_mod.log_level_debug = form.log_level_debug.data\n        cond_mod.message_include_code = form.message_include_code.data\n        cond_mod.start_offset = form.start_offset.data\n        cond_mod.pyro_timeout = form.pyro_timeout.data\n        if cmd_status:\n            messages[\"warning\"].append(\"pylint returned with status: {}\".format(cmd_status))\n        if pylint_message:\n            messages[\"info\"].append(\"Review your code for issues and test before putting it \"\n                  \"into a production environment.\")\n            messages[\"return_text\"].append(pylint_message)\n        if not messages[\"error\"]:\n            db.session.commit()\n            messages[\"success\"].append('{action} {controller}'.format(\n                action=TRANSLATIONS['modify']['title'],\n                controller=TRANSLATIONS['conditional']['title']))\n            if cond_mod.is_activated:\n                control = DaemonControl()\n                return_value = control.refresh_daemon_conditional_settings(\n                    form.function_id.data)\n                messages[\"success\"].append(gettext(\n                    \"Daemon response: %(resp)s\",\n                    resp=return_value))\n    except sqlalchemy.exc.OperationalError as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    except sqlalchemy.exc.IntegrityError as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    except Exception as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    return messages\n", "docstring": "Modify a Conditional\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_conditional.py", "original_string": "def conditional_condition_add(form):\n    \"\"\"Add a Conditional Condition\"\"\"\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": []\n    }\n    condition_id = None\n    cond = Conditional.query.filter(\n        Conditional.unique_id == form.function_id.data).first()\n    if cond.is_activated:\n        messages[\"error\"].append(\"Deactivate the Conditional before adding a Condition\")\n    if form.condition_type.data == '':\n        messages[\"error\"].append(\"Must select a condition\")\n    try:\n        new_condition = ConditionalConditions()\n        new_condition.conditional_id = form.function_id.data\n        new_condition.condition_type = form.condition_type.data\n        if new_condition.condition_type == 'measurement':\n            new_condition.max_age = 360\n        if not messages[\"error\"]:\n            new_condition.save()\n            condition_id = new_condition.unique_id\n            messages[\"success\"].append('{action} {controller}'.format(\n                action=TRANSLATIONS['add']['title'],\n                controller='{} {}'.format(TRANSLATIONS['conditional']['title'],\n                                          gettext(\"Condition\"))))\n    except sqlalchemy.exc.OperationalError as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    except sqlalchemy.exc.IntegrityError as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    except Exception as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    return messages, condition_id\n", "docstring": "Add a Conditional Condition\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_conditional.py", "original_string": "def conditional_condition_del(form):\n    \"\"\"Delete a Conditional Condition\"\"\"\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": []\n    }\n    condition = ConditionalConditions.query.filter(\n        ConditionalConditions.unique_id == form.conditional_condition_id.data).first()\n    if not condition:\n        messages[\"error\"].append(\"Condition not found\")\n    conditional = Conditional.query.filter(\n        Conditional.unique_id == condition.conditional_id).first()\n    if conditional.is_activated:\n        messages[\"error\"].append(\"Deactivate the Conditional before deleting a Condition\")\n    try:\n        if not messages[\"error\"]:\n            delete_entry_with_id(\n                ConditionalConditions, condition.unique_id, flash_message=False)\n            messages[\"success\"].append('{action} {controller}'.format(\n                action=TRANSLATIONS['delete']['title'],\n                controller='{} {}'.format(TRANSLATIONS['conditional']['title'],\n                                          gettext(\"Condition\"))))\n    except sqlalchemy.exc.OperationalError as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    except sqlalchemy.exc.IntegrityError as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    except Exception as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    return messages\n", "docstring": "Delete a Conditional Condition\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_conditional.py", "original_string": "def conditional_deactivate(cond_id):\n    \"\"\"Deactivate a Conditional\"\"\"\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": []\n    }\n    messages = controller_activate_deactivate(\n        messages, 'deactivate', 'Conditional', cond_id, flash_message=False)\n    if not messages[\"error\"]:\n        messages[\"success\"].append('{action} {controller}'.format(\n            action=TRANSLATIONS['deactivate']['title'],\n            controller=TRANSLATIONS['conditional']['title']))\n    return messages\n", "docstring": "Deactivate a Conditional\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_settings.py", "original_string": "def user_del(form):\n    \"\"\" Delete user from SQL database \"\"\"\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": []\n    }\n    if form.user_id.data == flask_login.current_user.id:\n        messages[\"error\"].append(\"Cannot delete the currently-logged in user\")\n    if not messages[\"error\"]:\n        try:\n            user = User.query.filter(\n                User.unique_id == form.user_id.data).first()\n            user.delete()\n            messages[\"success\"].append('{action} {controller} {user}'.format(\n                action=TRANSLATIONS['delete']['title'],\n                controller=TRANSLATIONS['user']['title'],\n                user=user.name))\n        except Exception as except_msg:\n            messages[\"error\"].append(except_msg)\n    return messages\n", "docstring": "Delete user from SQL database \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_settings.py", "original_string": "def settings_diagnostic_delete_inputs():\n    action = '{action} {controller}'.format(\n        action=TRANSLATIONS['delete']['title'],\n        controller=TRANSLATIONS['input']['title'])\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": []\n    }\n    inputs = db_retrieve_table(Input)\n    device_measurements = db_retrieve_table(DeviceMeasurements)\n    display_order = db_retrieve_table(DisplayOrder, entry='first')\n    if not messages[\"error\"]:\n        try:\n            for each_input in inputs:\n                # Deactivate any active controllers using the input\n                if each_input.is_activated:\n                    # messages = input_deactivate_associated_controllers(\n                    #     messages, each_input.unique_id)\n                    messages = controller_activate_deactivate(\n                        messages, 'deactivate', 'Input', each_input.unique_id)\n                # Delete all measurements associated with the input\n                for each_measurement in device_measurements:\n                    if each_measurement.device_id == each_input.unique_id:\n                        db.session.delete(each_measurement)\n                # Delete the input\n                db.session.delete(each_input)\n            display_order.input = ''  # Clear the order\n            db.session.commit()\n        except Exception as except_msg:\n            messages[\"error\"].append(str(except_msg))\n    flash_success_errors(\n        messages[\"error\"],\n        action,\n        url_for('routes_settings.settings_diagnostic'))\n", "docstring": "action = '{action} {controller}'.format("}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_function.py", "original_string": "def function_mod(form):\n    \"\"\"Modify a Function\"\"\"\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": [],\n        \"name\": None,\n        \"return_text\": []\n    }\n    try:\n        func_mod = Function.query.filter(\n            Function.unique_id == form.function_id.data).first()\n        func_mod.name = form.name.data\n        messages[\"name\"] = form.name.data\n        func_mod.log_level_debug = form.log_level_debug.data\n        if not messages[\"error\"]:\n            db.session.commit()\n            messages[\"success\"].append('{action} {controller}'.format(\n                action=TRANSLATIONS['modify']['title'],\n                controller=TRANSLATIONS['function']['title']))\n    except sqlalchemy.exc.OperationalError as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    except sqlalchemy.exc.IntegrityError as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    except Exception as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    return messages\n", "docstring": "Modify a Function\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_function.py", "original_string": "def action_del(form):\n    \"\"\"Delete an Action\"\"\"\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": []\n    }\n    conditional = Conditional.query.filter(\n        Conditional.unique_id == form.function_id.data).first()\n    trigger = Trigger.query.filter(\n        Trigger.unique_id == form.function_id.data).first()\n    if ((conditional and conditional.is_activated) or\n            (trigger and trigger.is_activated)):\n        messages[\"error\"].append(\n            \"Deactivate the Conditional before deleting an Action\")\n    try:\n        if not messages[\"error\"]:\n            function_action_id = Actions.query.filter(\n                Actions.unique_id == form.function_action_id.data).first().unique_id\n            delete_entry_with_id(\n                Actions, function_action_id, flash_message=False)\n            messages[\"success\"].append('{action} {controller}'.format(\n                action=TRANSLATIONS['delete']['title'],\n                controller=TRANSLATIONS['actions']['title']))\n    except sqlalchemy.exc.OperationalError as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    except sqlalchemy.exc.IntegrityError as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    except Exception as except_msg:\n        messages[\"error\"].append(str(except_msg))\n    return messages\n", "docstring": "Delete an Action\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_trigger.py", "original_string": "def trigger_activate(trigger_id):\n    \"\"\"Activate a Trigger\"\"\"\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": []\n    }\n    mod_trigger = Trigger.query.filter(\n        Trigger.unique_id == trigger_id).first()\n    # Check for errors in the Trigger settings\n    if mod_trigger.trigger_type == 'edge':\n        messages[\"error\"] = check_cond_edge(mod_trigger, messages[\"error\"])\n    elif mod_trigger.trigger_type == 'output':\n        messages[\"error\"] = check_cond_output(mod_trigger, messages[\"error\"])\n    actions = Actions.query.filter(\n        Actions.function_id == trigger_id)\n    if not actions.count() and mod_trigger.trigger_type != 'trigger_run_pwm_method':\n        messages[\"error\"].append(\n            \"No Actions found: Add at least one Action before activating.\")\n    for each_action in actions.all():\n        messages[\"error\"] = check_actions(each_action, messages[\"error\"])\n    messages = controller_activate_deactivate(\n        messages, 'activate', 'Trigger', trigger_id, flash_message=False)\n    if not messages[\"error\"]:\n        messages[\"success\"].append('{action} {controller}'.format(\n            action=TRANSLATIONS['activate']['title'],\n            controller=TRANSLATIONS['trigger']['title']))\n    return messages\n", "docstring": "Activate a Trigger\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_trigger.py", "original_string": "def check_cond_edge(form, error):\n    \"\"\"Checks if the saved variables have any errors\"\"\"\n    if not form.measurement or form.measurement == '':\n        error.append(\"Measurement must be set\")\n    return error\n", "docstring": "Checks if the saved variables have any errors\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_export.py", "original_string": "def thread_import_settings(tmp_folder):\n    # Upgrade database\n    cmd = \"{pth}/mycodo/scripts/mycodo_wrapper \" \\\n          \"upgrade_database\".format(\n        pth=INSTALL_DIRECTORY)\n    _, _, _ = cmd_output(cmd)\n    # Install/update dependencies (could take a while)\n    cmd = \"{pth}/mycodo/scripts/mycodo_wrapper update_dependencies\" \\\n          \" | ts '[%Y-%m-%d %H:%M:%S]' >> {log} 2>&1\".format(\n        pth=INSTALL_DIRECTORY,\n        log=DEPENDENCY_LOG_FILE)\n    _, _, _ = cmd_output(cmd)\n    # Initialize\n    cmd = \"{pth}/mycodo/scripts/mycodo_wrapper \" \\\n          \"initialize\".format(\n        pth=INSTALL_DIRECTORY)\n    _, _, _ = cmd_output(cmd)\n    # Generate widget HTML\n    generate_widget_html()\n    # Start Mycodo daemon (backend)\n    cmd = \"{pth}/mycodo/scripts/mycodo_wrapper \" \\\n          \"daemon_start\".format(\n        pth=INSTALL_DIRECTORY)\n    _, _, _ = cmd_output(cmd)\n    # Delete tmp directory if it exists\n    if os.path.isdir(tmp_folder):\n        shutil.rmtree(tmp_folder)\n", "docstring": "Upgrade database"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_export.py", "original_string": "def thread_import_influxdb(tmp_folder):\n    mycodo_db_backup = 'mycodo_db_bak'\n    client = InfluxDBClient(\n        INFLUXDB_HOST,\n        INFLUXDB_PORT,\n        INFLUXDB_USER,\n        INFLUXDB_PASSWORD,\n        mycodo_db_backup)\n    # Delete any backup database that may exist (can't copy over a current db)\n    try:\n        client.drop_database(mycodo_db_backup)\n    except Exception as msg:\n        print(\"Error while deleting db prior to restore: {}\".format(msg))\n    # Restore the backup to new database mycodo_db_bak\n    try:\n        logger.info(\"Creating tmp db with restore data\")\n        command = \"{pth}/mycodo/scripts/mycodo_wrapper \" \\\n                  \"influxdb_restore_mycodo_db {dir}\".format(\n            pth=INSTALL_DIRECTORY, dir=tmp_folder)\n        cmd = subprocess.Popen(\n            command,\n            stdout=subprocess.PIPE,\n            shell=True)\n        cmd_out, cmd_err = cmd.communicate()\n        cmd_status = cmd.wait()\n        logger.info(\"command output: {}\\nErrors: {}\\nStatus: {}\".format(\n            cmd_out.decode('utf-8'), cmd_err, cmd_status))\n    except Exception as msg:\n        logger.info(\"Error during restore of data to backup db: {}\".format(msg))\n    # Copy all measurements from backup to current database\n    try:\n        logger.info(\"Beginning restore of data from tmp db to main db. This could take a while...\")\n        query_str = \"SELECT * INTO {}..:MEASUREMENT FROM /.*/ GROUP BY *\".format(\n            INFLUXDB_DATABASE)\n        client.query(query_str)\n        logger.info(\"Restore of data from tmp db complete.\")\n    except Exception as msg:\n        logger.info(\"Error during copy of measurements from backup db to production db: {}\".format(msg))\n    # Delete backup database\n    try:\n        logger.info(\"Deleting tmp db\")\n        client.drop_database(mycodo_db_backup)\n    except Exception as msg:\n        logger.info(\"Error while deleting db after restore: {}\".format(msg))\n    # Delete tmp directory if it exists\n    try:\n        logger.info(\"Deleting influxdb restore tmp directory...\")\n        command = \"{pth}/mycodo/scripts/mycodo_wrapper \" \\\n                  \"influxdb_delete_restore_tmp_dir {dir}\".format(\n            pth=INSTALL_DIRECTORY, dir=tmp_folder)\n        cmd = subprocess.Popen(\n            command,\n            stdout=subprocess.PIPE,\n            shell=True)\n        cmd_out, cmd_err = cmd.communicate()\n        cmd_status = cmd.wait()\n        logger.info(\"Command output: {}\\nErrors: {}\\nStatus: {}\".format(\n            cmd_out.decode('utf-8'), cmd_err, cmd_status))\n    except Exception as msg:\n        logger.info(\"Error while deleting tmp file directory: {}\".format(msg))\n", "docstring": "mycodo_db_backup = 'mycodo_db_bak'"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_controller.py", "original_string": "def controller_activate(controller_id):\n    \"\"\"Activate a Conditional\"\"\"\n    messages = {\n        \"success\": [],\n        \"info\": [],\n        \"warning\": [],\n        \"error\": [],\n        \"period_status\": None\n    }\n    function = CustomController.query.filter(\n        CustomController.unique_id == controller_id).first()\n    if not function:\n        messages[\"error\"].append(\"Function not found\")\n    else:\n        dict_controllers = parse_function_information()\n        custom_options_values_controllers = parse_custom_option_values(\n            CustomController.query.all(), dict_controller=dict_controllers)\n        if (controller_id in custom_options_values_controllers and\n                'period_status' in custom_options_values_controllers[controller_id]):\n            messages[\"period_status\"] = custom_options_values_controllers[controller_id]['period_status']\n        if ('enable_channel_unit_select' in dict_controllers[function.device] and\n                dict_controllers[function.device]['enable_channel_unit_select']):\n            device_measurements = DeviceMeasurements.query.filter(\n                DeviceMeasurements.device_id == controller_id).all()\n            for each_measure in device_measurements:\n                if (None in [each_measure.measurement, each_measure.unit] or\n                        \"\" in [each_measure.measurement, each_measure.unit]):\n                    messages[\"error\"].append(\n                        \"Measurement CH{} ({}) measurement/unit not set. All Measurements need to have \"\n                        \"the measurement and unit set before the Function can be activated.\".format(\n                            each_measure.channel, each_measure.name))\n    messages = controller_activate_deactivate(\n        messages, 'activate', 'Function', controller_id, flash_message=False)\n    if not messages[\"error\"]:\n        messages[\"success\"].append('{action} {controller}'.format(\n            action=TRANSLATIONS['activate']['title'],\n            controller=TRANSLATIONS['controller']['title']))\n    return messages\n", "docstring": "Activate a Conditional\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_method.py", "original_string": "def method_create(form_create_method):\n    \"\"\" Create new method table entry (all data stored in method_data table) \"\"\"\n    action = '{action} {controller}'.format(\n        action=TRANSLATIONS['add']['title'],\n        controller=TRANSLATIONS['method']['title'])\n    error = []\n    dep_unmet, _ = return_dependencies(form_create_method.method_type.data)\n    if dep_unmet:\n        list_unmet_deps = []\n        for each_dep in dep_unmet:\n            list_unmet_deps.append(each_dep[0])\n        error.append(\n            \"The {dev} device you're trying to add has unmet dependencies: \"\n            \"{dep}\".format(dev=form_create_method.method_type.data,\n                           dep=', '.join(list_unmet_deps)))\n    try:\n        # Create method\n        new_method = Method()\n        new_method.name = form_create_method.name.data\n        new_method.method_type = form_create_method.method_type.data\n        db.session.add(new_method)\n        db.session.commit()\n        # Add new method line id to method display order\n        method_order = DisplayOrder.query.first()\n        display_order = csv_to_list_of_str(method_order.method)\n        method_order.method = add_display_order(display_order, new_method.unique_id)\n        db.session.commit()\n        # Add new method data line id to method_data display order\n        if new_method.method_type in ['DailyBezier', 'DailySine']:\n            # For tables that require only one entry to configure,\n            # create that single entry now with default values\n            new_method_data = MethodData()\n            new_method_data.method_id = new_method.unique_id\n            if new_method.method_type == 'DailySine':\n                new_method_data.amplitude = 1.0\n                new_method_data.frequency = 1.0\n                new_method_data.shift_angle = 0\n                new_method_data.shift_y = 1.0\n            elif new_method.method_type == 'DailyBezier':\n                new_method_data = MethodData()\n                new_method_data.method_id = new_method.unique_id\n                new_method_data.shift_angle = 0.0\n                new_method_data.x0 = 20.0\n                new_method_data.y0 = 20.0\n                new_method_data.x1 = 10.0\n                new_method_data.y1 = 13.5\n                new_method_data.x2 = 22.5\n                new_method_data.y2 = 30.0\n                new_method_data.x3 = 0.0\n                new_method_data.y3 = 20.0\n            db.session.add(new_method_data)\n            db.session.commit()\n            display_order = csv_to_list_of_str(new_method.method_order)\n            method = Method.query.filter(\n                Method.unique_id == new_method.unique_id).first()\n            method.method_order = add_display_order(\n                display_order, new_method_data.unique_id)\n            db.session.commit()\n    except Exception as except_msg:\n        error.append(except_msg)\n    flash_success_errors(error, action, url_for('routes_method.method_list'))\n    if dep_unmet:\n        return 1\n", "docstring": "Create new method table entry (all data stored in method_data table) \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def choices_controller_ids():\n    \"\"\" populate form multi-select choices from Controller IDS \"\"\"\n    choices = []\n    for each_input in Input.query.all():\n        display = '[Input {id:02d}] {name}'.format(\n            id=each_input.id,\n            name=each_input.name)\n        choices.append({'value': each_input.unique_id, 'item': display})\n    for each_math in Math.query.all():\n        display = '[Math {id:02d}] {name}'.format(\n            id=each_math.id,\n            name=each_math.name)\n        choices.append({'value': each_math.unique_id, 'item': display})\n    for each_pid in PID.query.all():\n        display = '[PID {id:02d}] {name}'.format(\n            id=each_pid.id,\n            name=each_pid.name)\n        choices.append({'value': each_pid.unique_id, 'item': display})\n    for each_cond in Conditional.query.all():\n        display = '[Conditional {id:02d}] {name}'.format(\n            id=each_cond.id,\n            name=each_cond.name)\n        choices.append({'value': each_cond.unique_id, 'item': display})\n    for each_trigger in Trigger.query.all():\n        display = '[Trigger {id:02d}] {name}'.format(\n            id=each_trigger.id,\n            name=each_trigger.name)\n        choices.append({'value': each_trigger.unique_id, 'item': display})\n    for each_custom in CustomController.query.all():\n        display = '[Function {id:02d}] {name}'.format(\n            id=each_custom.id,\n            name=each_custom.name)\n        choices.append({'value': each_custom.unique_id, 'item': display})\n    for each_lcd in LCD.query.all():\n        display = '[LCD {id:02d}] {name}'.format(\n            id=each_lcd.id,\n            name=each_lcd.name)\n        choices.append({'value': each_lcd.unique_id, 'item': display})\n    return choices\n", "docstring": "populate form multi-select choices from Controller IDS \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def choices_inputs(inputs, dict_units, dict_measurements):\n    \"\"\" populate form multi-select choices from Input entries \"\"\"\n    choices = []\n    for each_input in inputs:\n        choices = form_input_choices(\n            choices, each_input, dict_units, dict_measurements)\n    return choices\n", "docstring": "populate form multi-select choices from Input entries \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def choices_functions(functions, dict_units, dict_measurements):\n    \"\"\" populate form multi-select choices from Math entries \"\"\"\n    choices = []\n    for each_function in functions:\n        choices = form_function_choices(\n            choices, each_function, dict_units, dict_measurements)\n    return choices\n", "docstring": "populate form multi-select choices from Math entries \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def choices_output_devices(output):\n    \"\"\" populate form multi-select choices from Output entries \"\"\"\n    choices = []\n    for each_output in output:\n        choices = form_output_choices_devices(choices, each_output)\n    return choices\n", "docstring": "populate form multi-select choices from Output entries \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def choices_pids(pid, dict_units, dict_measurements):\n    \"\"\" populate form multi-select choices from PID entries \"\"\"\n    choices = []\n    for each_pid in pid:\n        choices = form_pid_choices(\n            choices, each_pid, dict_units, dict_measurements)\n    return choices\n", "docstring": "populate form multi-select choices from PID entries \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def choices_methods(method):\n    \"\"\" populate form multi-select choices from Method entries \"\"\"\n    choices = []\n    for each_method in method:\n        choices = form_method_choices(choices, each_method)\n    return choices\n", "docstring": "populate form multi-select choices from Method entries \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def choices_units(units):\n    \"\"\" populate form multi-select choices from Units entries \"\"\"\n    choices = []\n    for each_unit, each_info in UNITS.items():\n        if each_info['name']:\n            value = '{unit}'.format(\n                unit=each_unit)\n            unit = ''\n            if each_info['unit']:\n                unit = ' ({})'.format(each_info['unit'])\n            display = '{name}{unit}'.format(\n                name=each_info['name'],\n                unit=unit)\n            choices.append({'value': value, 'item': display})\n    for each_unit in units:\n        value = '{unit}'.format(\n            unit=each_unit.name_safe)\n        display = '{name} ({unit})'.format(\n            name=each_unit.name,\n            unit=each_unit.unit)\n        choices.append({'value': value, 'item': display})\n    choices.sort(key=lambda item: item.get(\"item\"))\n    return choices\n", "docstring": "populate form multi-select choices from Units entries \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def delete_entry_with_id(table, entry_id, flash_message=True):\n    \"\"\" Delete SQL database entry with specific id \"\"\"\n    try:\n        entries = table.query.filter(\n            table.unique_id == entry_id).first()\n        db.session.delete(entries)\n        db.session.commit()\n        msg = '{action} {table} with ID: {id}'.format(\n            action=TRANSLATIONS['delete']['title'],\n            table=table.__tablename__,\n            id=entry_id)\n        if flash_message:\n            flash(gettext(\"%(msg)s\", msg=msg), \"success\")\n        else:\n            logger.info(msg)\n        return 1\n    except sqlalchemy.orm.exc.NoResultFound:\n        msg = '{action} {id}: {err}'.format(\n            action=TRANSLATIONS['delete']['title'],\n            id=entry_id,\n            err=gettext(\"Entry with ID %(id)s not found\",\n                id=entry_id))\n        if flash_message:\n            flash(gettext(\"%(msg)s\", msg=msg), \"error\")\n        else:\n            logger.error(msg)\n        return 0\n", "docstring": "Delete SQL database entry with specific id \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def form_error_messages(form, error):\n    \"\"\" Append form errors \"\"\"\n    for field, errors in form.errors.items():\n        for each_error in errors:\n            error.append(\n                gettext(\"Error in the %(field)s field - %(err)s\",\n                    field=getattr(form, field).label.text,\n                    err=each_error))\n    return error\n", "docstring": "Append form errors \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def add_display_order(display_order, device_id):\n    \"\"\" Add integer ID to list of string IDs \"\"\"\n    if display_order:\n        display_order.append(device_id)\n        return ','.join(display_order)\n    return device_id\n", "docstring": "Add integer ID to list of string IDs \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def reorder_list(modified_list, item, direction):\n    \"\"\" Reorder entry in a comma-separated list either up or down \"\"\"\n    from_position = modified_list.index(item)\n    if direction == \"up\":\n        if from_position == 0:\n            return 'error', gettext('Cannot move above the first item in the list')\n        to_position = from_position - 1\n    elif direction == 'down':\n        if from_position == len(modified_list) - 1:\n            return 'error', gettext('Cannot move below the last item in the list')\n        to_position = from_position + 1\n    else:\n        return 'error', []\n    modified_list.insert(to_position, modified_list.pop(from_position))\n    return 'success', modified_list\n", "docstring": "Reorder entry in a comma-separated list either up or down \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def get_camera_image_info():\n    \"\"\" Retrieve information about the latest camera images \"\"\"\n    latest_img_still_ts = {}\n    latest_img_still = {}\n    latest_img_tl_ts = {}\n    latest_img_tl = {}\n    time_lapse_imgs = {}\n    camera = Camera.query.all()\n    for each_camera in camera:\n        camera_path = os.path.join(PATH_CAMERAS, '{uid}'.format(\n            uid=each_camera.unique_id))\n        if each_camera.path_still:\n            still_path = each_camera.path_still\n        else:\n            still_path = os.path.join(camera_path, 'still')\n        try:\n            latest_still_img_full_path = max(glob.iglob(\n                '{path}/Still-{cam_id}-*.jpg'.format(\n                    path=still_path,\n                    cam_id=each_camera.id)),\n                key=os.path.getmtime)\n        except ValueError:\n            latest_still_img_full_path = None\n        if latest_still_img_full_path:\n            ts = os.path.getmtime(latest_still_img_full_path)\n            latest_img_still_ts[each_camera.unique_id] = datetime.fromtimestamp(\n                ts).strftime(\"%Y-%m-%d %H:%M:%S\")\n            latest_img_still[each_camera.unique_id] = os.path.basename(\n                latest_still_img_full_path)\n        else:\n            latest_img_still[each_camera.unique_id] = None\n        try:\n            # Get list of timelapse filename sets for generating a video from images\n            time_lapse_imgs[each_camera.unique_id] = []\n            if each_camera.path_timelapse:\n                tl_path = each_camera.path_timelapse\n            else:\n                tl_path = os.path.join(camera_path, 'timelapse')\n            for i in os.listdir(tl_path):\n                if (os.path.isfile(os.path.join(tl_path, i)) and\n                        i[:-10] not in time_lapse_imgs[each_camera.unique_id]):\n                    time_lapse_imgs[each_camera.unique_id].append(i[:-10])\n            time_lapse_imgs[each_camera.unique_id].sort()\n        except Exception:\n            pass\n        if each_camera.path_timelapse:\n            tl_path = each_camera.path_timelapse\n        else:\n            tl_path = os.path.join(camera_path, 'timelapse')\n        try:\n            latest_time_lapse_img_full_path = max(glob.iglob(\n                '{path}/Timelapse-{cam_id}-*.jpg'.format(\n                    path=tl_path,\n                    cam_id=each_camera.id)), key=os.path.getmtime)\n        except ValueError:\n            latest_time_lapse_img_full_path = None\n        if latest_time_lapse_img_full_path:\n            ts = os.path.getmtime(latest_time_lapse_img_full_path)\n            latest_img_tl_ts[each_camera.unique_id] = datetime.fromtimestamp(\n                ts).strftime(\"%Y-%m-%d %H:%M:%S\")\n            latest_img_tl[each_camera.unique_id] = os.path.basename(\n                latest_time_lapse_img_full_path)\n        else:\n            latest_img_tl[each_camera.unique_id] = None\n    return (latest_img_still_ts, latest_img_still,\n            latest_img_tl_ts, latest_img_tl, time_lapse_imgs)\n", "docstring": "Retrieve information about the latest camera images \n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def use_unit_generate(device_measurements, input_dev, output, math, function):\n    \"\"\"Generate dictionary of units to convert to\"\"\"\n    use_unit = {}\n    # Input and Math controllers have measurement tables with the same schema\n    list_devices_with_measurements = [\n        input_dev, math, function\n    ]\n    for devices in list_devices_with_measurements:\n        for each_device in devices:\n            use_unit[each_device.unique_id] = {}\n            for each_meas in device_measurements:\n                if each_meas.device_id == each_device.unique_id:\n                    if each_meas.measurement not in use_unit[each_device.unique_id]:\n                        use_unit[each_device.unique_id][each_meas.measurement] = {}\n                    if each_meas.unit not in use_unit[each_device.unique_id][each_meas.measurement]:\n                        use_unit[each_device.unique_id][each_meas.measurement][each_meas.unit] = OrderedDict()\n                    use_unit[each_device.unique_id][each_meas.measurement][each_meas.unit][each_meas.channel] = None\n    for each_output in output:\n        use_unit[each_output.unique_id] = {}\n        if each_output.output_type == 'wired':\n            use_unit[each_output.unique_id]['duration_time'] = 'second'\n    return use_unit\n", "docstring": "Generate dictionary of units to convert to\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def generate_form_controller_list(dict_controllers):\n    # Sort dictionary entries by function_name\n    # Results in list of sorted dictionary keys\n    list_tuples_sorted = sorted(dict_controllers.items(), key=lambda x: x[1]['function_name'])\n    list_controllers_sorted = []\n    for each_controller in list_tuples_sorted:\n        list_controllers_sorted.append(each_controller[0])\n    return list_controllers_sorted\n", "docstring": "Sort dictionary entries by function_name"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_general.py", "original_string": "def generate_form_output_list(dict_outputs):\n    # Sort dictionary entries by output_name\n    # Results in list of sorted dictionary keys\n    list_tuples_sorted = sorted(dict_outputs.items(), key=lambda x: (x[1]['output_name']))\n    list_outputs_sorted = []\n    for each_output in list_tuples_sorted:\n        list_outputs_sorted.append(each_output[0])\n    return list_outputs_sorted\n", "docstring": "Sort dictionary entries by output_name"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_input.py", "original_string": "def input_deactivate_associated_controllers(messages, input_id):\n    # Deactivate any activated PIDs using this input\n    sensor_unique_id = Input.query.filter(\n        Input.unique_id == input_id).first().unique_id\n    pid = PID.query.filter(PID.is_activated.is_(True)).all()\n    for each_pid in pid:\n        if sensor_unique_id in each_pid.measurement:\n            messages = controller_activate_deactivate(\n                messages, 'deactivate', 'PID', each_pid.unique_id)\n    return messages\n", "docstring": "Deactivate any activated PIDs using this input"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_dashboard.py", "original_string": "def dashboard_add():\n    \"\"\"Add a dashboard\"\"\"\n    error = []\n    last_dashboard = Dashboard.query.order_by(\n        Dashboard.id.desc()).first()\n    new_dash = Dashboard()\n    new_dash.name = '{} {}'.format(TRANSLATIONS['dashboard']['title'], last_dashboard.id + 1)\n    if not error:\n        new_dash.save()\n        flash(gettext(\n            \"Dashboard with ID %(id)s successfully added\", id=new_dash.id),\n            \"success\")\n    return new_dash.unique_id\n", "docstring": "Add a dashboard\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_dashboard.py", "original_string": "def dashboard_lock(dashboard_id, lock):\n    \"\"\"Lock a dashboard\"\"\"\n    action = '{action} {controller}'.format(\n        action=TRANSLATIONS['lock']['title'],\n        controller=TRANSLATIONS['dashboard']['title'])\n    error = []\n    try:\n        dash_mod = Dashboard.query.filter(\n            Dashboard.unique_id == dashboard_id).first()\n        dash_mod.locked = lock\n        if not error:\n            db.session.commit()\n    except Exception as msg:\n        error.append(msg)\n        logger.exception(\"Duplicating dashboard\")\n    flash_success_errors(\n        error, action, url_for('routes_dashboard.page_dashboard_default'))\n", "docstring": "Lock a dashboard\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_dashboard.py", "original_string": "def dashboard_del(form):\n    \"\"\"Delete a dashboard\"\"\"\n    action = '{action} {controller}'.format(\n        action=TRANSLATIONS['delete']['title'],\n        controller=TRANSLATIONS['dashboard']['title'])\n    error = []\n    dashboards = Dashboard.query.all()\n    if len(dashboards) == 1:\n        flash('Cannot delete the only remaining dashboard.', 'error')\n        return\n    widgets = Widget.query.filter(\n        Widget.dashboard_id == form.dashboard_id.data).all()\n    for each_widget in widgets:\n        delete_entry_with_id(Widget, each_widget.unique_id)\n    delete_entry_with_id(Dashboard, form.dashboard_id.data)\n    flash_success_errors(\n        error, action, url_for('routes_dashboard.page_dashboard_default'))\n", "docstring": "Delete a dashboard\n"}
{"repo": "Mycodo-master/mycodo/mycodo_flask/utils/utils_dashboard.py", "original_string": "def widget_del(form_base):\n    \"\"\"Delete a widget from a dashboard\"\"\"\n    action = '{action} {controller}'.format(\n        action=TRANSLATIONS['delete']['title'],\n        controller=TRANSLATIONS['widget']['title'])\n    error = []\n    dict_widgets = parse_widget_information()\n    widget = Widget.query.filter(\n        Widget.unique_id == form_base.widget_id.data).first()\n    try:\n        if 'execute_at_deletion' in dict_widgets[widget.graph_type]:\n            dict_widgets[widget.graph_type]['execute_at_deletion'](form_base.widget_id.data)\n    except Exception as except_msg:\n        error.append(except_msg)\n    try:\n        delete_entry_with_id(Widget, form_base.widget_id.data)\n        control = DaemonControl()\n        control.widget_remove(form_base.widget_id.data)\n    except Exception as except_msg:\n        error.append(except_msg)\n    flash_success_errors(\n        error, action, url_for('routes_dashboard.page_dashboard',\n                               dashboard_id=form_base.dashboard_id.data))\n", "docstring": "Delete a widget from a dashboard\n"}
{"repo": "Mycodo-master/mycodo/outputs/pump_generic.py", "original_string": "    def dispense_volume_fastest(self, amount, total_dispense_seconds):\n        \"\"\" Dispense at fastest flow rate, a 100 % duty cycle \"\"\"\n        self.currently_dispensing = True\n        self.logger.debug(\"Output turned on\")\n        self.GPIO.output(self.options_channels['pin'][0], self.options_channels['on_state'][0])\n        timer_dispense = time.time() + total_dispense_seconds\n        timestamp_start = datetime.datetime.utcnow()\n        while time.time() < timer_dispense and self.currently_dispensing:\n            time.sleep(0.01)\n        self.GPIO.output(self.options_channels['pin'][0], not self.options_channels['on_state'][0])\n        self.currently_dispensing = False\n        self.logger.debug(\"Output turned off\")\n        self.record_dispersal(amount, total_dispense_seconds, total_dispense_seconds, timestamp=timestamp_start)\n", "docstring": "Dispense at fastest flow rate, a 100 % duty cycle \n"}
{"repo": "Mycodo-master/mycodo/outputs/base_output.py", "original_string": "    def __repr__(self):\n        \"\"\"  Representation of object \"\"\"\n        return_str = '<{cls}'.format(cls=type(self).__name__)\n        return_str += '>'\n        return return_str\n", "docstring": "Representation of object \n"}
{"repo": "Mycodo-master/mycodo/outputs/base_output.py", "original_string": "    def stop_output(self):\n        \"\"\" Called when Output is stopped \"\"\"\n        self.running = False\n        try:\n            # Release all locks\n            for lockfile, lock_state in self.lockfile.locked.items():\n                if lock_state:\n                    self.lock_release(lockfile)\n        except:\n            pass\n", "docstring": "Called when Output is stopped \n"}
{"repo": "Mycodo-master/mycodo/outputs/base_output.py", "original_string": "    def setup_on_off_output(self, output_information):\n        \"\"\"Deprecated TODO: Remove\"\"\"\n        self.setup_output_variables(output_information)\n", "docstring": "Deprecated TODO: Remove\n"}
{"repo": "Mycodo-master/mycodo/outputs/base_output.py", "original_string": "    def get_custom_option(self, option):\n        return self._get_custom_option(self.output.custom_options, option)\n", "docstring": "return self._get_custom_option(self.output.custom_options, option)"}
{"repo": "Mycodo-master/mycodo/outputs/kp303.py", "original_string": "    def stop_output(self):\n        \"\"\" Called when Output is stopped \"\"\"\n        if self.is_setup():\n            for channel in channels_dict:\n                if self.options_channels['state_shutdown'][channel] == 1:\n                    self.output_switch('on', output_channel=channel)\n                elif self.options_channels['state_shutdown'][channel] == 0:\n                    self.output_switch('off', output_channel=channel)\n        self.running = False\n", "docstring": "Called when Output is stopped \n"}
{"repo": "Mycodo-master/mycodo/outputs/pwm_pca9685.py", "original_string": "    def __init__(self, output, testing=False):\n        super(OutputModule, self).__init__(output, testing=testing, name=__name__)\n        self.pwm_duty_cycles = {}\n        for i in range(16):\n            self.pwm_duty_cycles[i] = 0\n        self.pwm_output = None\n        self.pwm_hertz = None\n        self.setup_custom_options(\n            OUTPUT_INFORMATION['custom_options'], output)\n        output_channels = db_retrieve_table_daemon(\n            OutputChannel).filter(OutputChannel.output_id == self.output.unique_id).all()\n        self.options_channels = self.setup_custom_channel_options_json(\n            OUTPUT_INFORMATION['custom_channel_options'], output_channels)\n", "docstring": "super(OutputModule, self).__init__(output, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/outputs/grove_motor_driver_v1_0.py", "original_string": "    def dispense_volume_fastest(self, channel, amount, total_dispense_seconds):\n        \"\"\" Dispense at fastest flow rate, a 100 % duty cycle \"\"\"\n        if amount < 0:\n            direction_reg = self.reg_write_run_ccw\n        else:\n            direction_reg = self.reg_write_run_cw\n        self.currently_dispensing[channel] = True\n        self.bus.write_i2c_block_data(\n            self.i2c_address, direction_reg,\n            [channel, self.options_channels['motor_speed'][channel]])\n        self.logger.debug(\"Output turned on\")\n        timer_dispense = time.time() + total_dispense_seconds\n        while time.time() < timer_dispense and self.currently_dispensing[channel]:\n            time.sleep(0.01)\n        self.bus.write_word_data(self.i2c_address, self.reg_write_off, channel)\n        self.currently_dispensing[channel] = False\n        self.logger.debug(\"Output turned off\")\n        self.record_dispersal(channel, amount, total_dispense_seconds, total_dispense_seconds)\n", "docstring": "Dispense at fastest flow rate, a 100 % duty cycle \n"}
{"repo": "Mycodo-master/mycodo/outputs/grove_motor_driver_v1_3.py", "original_string": "    def dispense_volume_fastest(self, amount, total_dispense_seconds):\n        \"\"\" Dispense at fastest flow rate, a 100 % duty cycle \"\"\"\n        self.currently_dispensing = True\n        self.logger.debug(\"Output turned on\")\n        self.motor.motor_speed_set_a_b(100, 100)\n        if amount > 0:\n            self.motor.motor_direction_set(\"cw\")\n        elif amount < 0:\n            self.motor.motor_direction_set(\"ccw\")\n        timer_dispense = time.time() + total_dispense_seconds\n        while time.time() < timer_dispense and self.currently_dispensing:\n            time.sleep(0.01)\n        self.motor.motor_speed_set_a_b(0, 0)\n        self.currently_dispensing = False\n        self.logger.debug(\"Output turned off\")\n        self.record_dispersal(amount, total_dispense_seconds, total_dispense_seconds)\n", "docstring": "Dispense at fastest flow rate, a 100 % duty cycle \n"}
{"repo": "Mycodo-master/mycodo/outputs/grove_motor_driver_v1_3.py", "original_string": "    def map_vals(self, value, leftMin, leftMax, rightMin, rightMax):\n        \"\"\"Map speed from 0-100 to 0-255\"\"\"\n        # http://stackoverflow.com/questions/1969240/mapping-a-range-of-values-to-another\n        # Figure out how 'wide' each range is\n        leftSpan = leftMax - leftMin\n        rightSpan = rightMax - rightMin\n        # Convert the left range into a 0-1 range (float)\n        valueScaled = float(value - leftMin) / float(leftSpan)\n        # Convert the 0-1 range into a value in the right range.\n        return int(rightMin + (valueScaled * rightSpan))\n", "docstring": "Map speed from 0-100 to 0-255\n"}
{"repo": "Mycodo-master/mycodo/outputs/examples/example_dummy_output.py", "original_string": "    def __init__(self, output, testing=False):\n        super(OutputModule, self).__init__(output, testing=testing, name=__name__)\n        # Initialize custom option variables to None\n        self.bool_value = None\n        self.float_value = None\n        self.range_value = None\n        # Set custom option variables to defaults or user-set values\n        self.setup_custom_options(\n            OUTPUT_INFORMATION['custom_options'], output)\n", "docstring": "Initialize custom option variables to None"}
{"repo": "Mycodo-master/mycodo/outputs/examples/example_dummy_output.py", "original_string": "    def is_setup(self):\n        \"\"\"Returns whether the output has successfully been set up\"\"\"\n        return self.output_setup\n", "docstring": "Returns whether the output has successfully been set up\n"}
{"repo": "Mycodo-master/mycodo/widgets/widget_python_code.py", "original_string": "def save_python_file(custom_options_json, unique_id):\n    \"\"\" Save python file \"\"\"\n    pre_statement_loop = \"\"\"import os\n", "docstring": "Save python file \n"}
{"repo": "Mycodo-master/mycodo/widgets/base_widget.py", "original_string": "    def __repr__(self):\n        \"\"\"  Representation of object \"\"\"\n        return_str = '<{cls}'.format(cls=type(self).__name__)\n        return_str += '>'\n        return return_str\n", "docstring": "Representation of object \n"}
{"repo": "Mycodo-master/mycodo/widgets/widget_gauge_angular.py", "original_string": "def generate_page_variables(widget_unique_id, widget_options):\n    # Retrieve custom colors for gauges\n    colors_gauge_angular = []\n    try:\n        if 'range_colors' in widget_options and widget_options['range_colors']:  # Split into list\n            color_areas = widget_options['range_colors']\n        else:\n            color_areas = []  # Create empty list\n        for each_range in color_areas:\n            colors_gauge_angular.append({\n                'low': each_range.split(',')[0],\n                'high': each_range.split(',')[1],\n                'hex': each_range.split(',')[2]})\n    except IndexError:\n        logger.exception(1)\n        flash(\"Colors Index Error\", \"error\")\n    return {\"colors_gauge_angular\": colors_gauge_angular}\n", "docstring": "Retrieve custom colors for gauges"}
{"repo": "Mycodo-master/mycodo/widgets/widget_gauge_solid.py", "original_string": "def generate_page_variables(widget_unique_id, widget_options):\n    # Retrieve custom colors for gauges\n    colors_gauge_solid = []\n    colors_gauge_solid_form = []\n    try:\n        if 'range_colors' in widget_options and widget_options['range_colors']:\n            color_areas = widget_options['range_colors']\n        else:  # Create empty list\n            color_areas = []\n        try:\n            gauge_low = widget_options['min']\n            gauge_high = widget_options['max']\n            gauge_difference = gauge_high - gauge_low\n            for each_range in color_areas:\n                percent_of_range = float((float(each_range.split(',')[0]) - gauge_low) / gauge_difference)\n                colors_gauge_solid.append({\n                    'stop': '{:.2f}'.format(percent_of_range),\n                    'hex': each_range.split(',')[1]})\n                colors_gauge_solid_form.append({\n                    'stop': each_range.split(',')[0],\n                    'hex': each_range.split(',')[1]})\n        except:\n            # Prevent mathematical errors from preventing proper page render\n            for each_range in color_areas:\n                colors_gauge_solid.append({\n                    'stop': '0',\n                    'hex': each_range.split(',')[1]})\n                colors_gauge_solid_form.append({\n                    'stop': '0',\n                    'hex': each_range.split(',')[1]})\n    except IndexError:\n        logger.exception(1)\n        flash(\"Colors Index Error\", \"error\")\n    dict_return = {\n        \"colors_gauge_solid\": colors_gauge_solid,\n        \"colors_gauge_solid_form\": colors_gauge_solid_form,\n    }\n    return dict_return\n", "docstring": "Retrieve custom colors for gauges"}
{"repo": "Mycodo-master/mycodo/widgets/widget_graph_synchronous.py", "original_string": "def execute_at_creation(error, new_widget, dict_widget):\n    # Create initial default values\n    custom_options_json = json.loads(new_widget.custom_options)\n    custom_options_json['enable_manual_y_axis'] = False\n    custom_options_json['enable_align_ticks'] = False\n    custom_options_json['enable_start_on_tick'] = False\n    custom_options_json['enable_end_on_tick'] = False\n    custom_options_json['enable_graph_legend'] = True\n    custom_options_json['disable_data_grouping'] = \"\"\n    custom_options_json['custom_yaxes'] = \"\"\n    custom_options_json['custom_colors'] = \"\"\n    new_widget.custom_options = json.dumps(custom_options_json)\n    return error, new_widget\n", "docstring": "Create initial default values"}
{"repo": "Mycodo-master/mycodo/controllers/controller_trigger.py", "original_string": "    def set_output_duty_cycle(self, duty_cycle):\n        \"\"\" Set PWM Output duty cycle \"\"\"\n        output_channel = db_retrieve_table_daemon(OutputChannel).filter(\n            OutputChannel.unique_id == self.trigger.unique_id_3).first()\n        output_channel = output_channel.channel if output_channel else 0\n        self.logger.debug(\"Set output duty cycle to {}\".format(duty_cycle))\n        self.control.output_on(\n            self.trigger.unique_id_2, output_type='pwm', amount=duty_cycle, output_channel=output_channel)\n", "docstring": "Set PWM Output duty cycle \n"}
{"repo": "Mycodo-master/mycodo/controllers/controller_input.py", "original_string": "    def custom_button_exec_function(self, button_id, args_dict, thread=True):\n        \"\"\"Execute function from custom action button press\"\"\"\n        try:\n            run_action = getattr(self.measure_input, button_id)\n            if thread:\n                thread_run_action = threading.Thread(\n                    target=run_action,\n                    args=(args_dict,))\n                thread_run_action.start()\n                return 0, \"Command sent to Input Controller and is running in the background.\"\n            else:\n                return_val = run_action(args_dict)\n                return 0, \"Command sent to Input Controller. Returned: {}\".format(return_val)\n        except Exception as err:\n            msg = \"Error executing button press function '{}': {}\".format(\n                button_id, err)\n            self.logger.exception(msg)\n            return 1, msg\n", "docstring": "Execute function from custom action button press\n"}
{"repo": "Mycodo-master/mycodo/controllers/controller_widget.py", "original_string": "    def widget_remove(self, unique_id):\n        \"\"\"Remove a widget\"\"\"\n        try:\n            timer = timeit.default_timer()\n            if unique_id in self.widget_loaded:\n                self.widget_ready.pop(unique_id, None)\n                self.widget_loaded.pop(unique_id, None)\n                self.logger.info(\"Widget object {id} removed in {time:.1f} ms\".format(\n                    id=unique_id.split('-')[0], time=(timeit.default_timer() - timer) * 1000))\n        except Exception:\n            self.logger.exception(\"Widget remove\")\n", "docstring": "Remove a widget\n"}
{"repo": "Mycodo-master/mycodo/controllers/controller_conditional.py", "original_string": "    def initialize_variables(self):\n        \"\"\" Define all settings \"\"\"\n        cond = db_retrieve_table_daemon(\n            Conditional, unique_id=self.unique_id)\n        self.is_activated = cond.is_activated\n        self.conditional_statement = cond.conditional_statement\n        self.conditional_status = cond.conditional_status\n        self.period = cond.period\n        self.start_offset = cond.start_offset\n        self.pyro_timeout = cond.pyro_timeout\n        self.log_level_debug = cond.log_level_debug\n        self.message_include_code = cond.message_include_code\n        self.sample_rate = db_retrieve_table_daemon(\n            Misc, entry='first').sample_rate_controller_conditional\n        self.set_log_level_debug(self.log_level_debug)\n        now = time.time()\n        self.timer_period = now + self.start_offset\n        self.file_run = '{}/conditional_{}.py'.format(\n            PATH_PYTHON_CODE_USER, self.unique_id)\n        # If the file to execute doesn't exist, generate it\n        if not os.path.exists(self.file_run):\n            save_conditional_code(\n                [],\n                self.conditional_statement,\n                self.conditional_status,\n                self.unique_id,\n                db_retrieve_table_daemon(ConditionalConditions, entry='all'),\n                db_retrieve_table_daemon(Actions, entry='all'),\n                timeout=self.pyro_timeout)\n        module_name = \"mycodo.conditional.{}\".format(\n            os.path.basename(self.file_run).split('.')[0])\n        spec = importlib.util.spec_from_file_location(\n            module_name, self.file_run)\n        conditional_run = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(conditional_run)\n        self.conditional_run = conditional_run.ConditionalRun(\n            self.logger, self.unique_id, '')\n        self.logger.debug(\n            \"Conditional Statement (pre-replacement):\\n{}\".format(\n                self.conditional_statement))\n        with open(self.file_run, 'r') as file:\n            self.logger.debug(\n                \"Conditional Statement (post-replacement):\\n{}\".format(\n                    file.read()))\n", "docstring": "Define all settings \n"}
{"repo": "Mycodo-master/mycodo/controllers/base_controller.py", "original_string": "    def run_finally(self):\n        \"\"\" Executed after loop() has finished \"\"\"\n        pass\n", "docstring": "Executed after loop() has finished \n"}
{"repo": "Mycodo-master/mycodo/controllers/controller_lcd.py", "original_string": "    def lcd_backlight(self, state):\n        \"\"\" Turn the backlight on or off \"\"\"\n        if state:\n            self.lcd_out.lcd_backlight(state)\n            self.lcd_is_on = True\n            self.timer = time.time() - 1  # Induce LCD to update after turning backlight on\n        else:\n            self.lcd_is_on = False  # Instruct LCD backlight to turn off\n", "docstring": "Turn the backlight on or off \n"}
{"repo": "Mycodo-master/mycodo/controllers/controller_pid.py", "original_string": "    def run_finally(self):\n        # Turn off output used in PID when the controller is deactivated\n        if self.raise_output_id and self.PID_Controller.direction in ['raise', 'both']:\n            self.control.output_off(\n                self.raise_output_id, output_channel=self.raise_output_channel, trigger_conditionals=True)\n        if self.lower_output_id and self.PID_Controller.direction in ['lower', 'both']:\n            self.control.output_off(\n                self.lower_output_id, output_channel=self.lower_output_channel, trigger_conditionals=True)\n", "docstring": "Turn off output used in PID when the controller is deactivated"}
{"repo": "Mycodo-master/mycodo/controllers/controller_pid.py", "original_string": "    def pid_parameters_str(self):\n        return \"Device ID: {did}, \" \\\n               \"Measurement ID: {mid}, \" \\\n               \"Direction: {dir}, \" \\\n               \"Period: {per}, \" \\\n               \"Setpoint: {sp}, \" \\\n               \"Band: {band}, \" \\\n               \"Kp: {kp}, \" \\\n               \"Ki: {ki}, \" \\\n               \"Kd: {kd}, \" \\\n               \"Integrator Min: {imn}, \" \\\n               \"Integrator Max {imx}, \" \\\n               \"Output Raise: {opr}, \" \\\n               \"Output Raise Channel: {oprc}, \" \\\n               \"Output Raise Type: {oprt}, \" \\\n               \"Output Raise Min On: {oprmnon}, \" \\\n               \"Output Raise Max On: {oprmxon}, \" \\\n               \"Output Raise Min Off: {oprmnoff}, \" \\\n               \"Output Raise Always Min: {opramn}, \" \\\n               \"Output Lower: {opl}, \" \\\n               \"Output Lower Channel: {oplc}, \" \\\n               \"Output Lower Type: {oplt}, \" \\\n               \"Output Lower Min On: {oplmnon}, \" \\\n               \"Output Lower Max On: {oplmxon}, \" \\\n               \"Output Lower Min Off: {oplmnoff}, \" \\\n               \"Output Lower Always Min: {oplamn}, \" \\\n               \"Setpoint Tracking Type: {sptt}, \" \\\n               \"Setpoint Tracking ID: {spt}\".format(\n                    did=self.device_id,\n                    mid=self.measurement_id,\n                    dir=self.PID_Controller.direction,\n                    per=self.period,\n                    sp=self.PID_Controller.setpoint,\n                    band=self.PID_Controller.band,\n                    kp=self.PID_Controller.Kp,\n                    ki=self.PID_Controller.Ki,\n                    kd=self.PID_Controller.Kd,\n                    imn=self.PID_Controller.integrator_min,\n                    imx=self.PID_Controller.integrator_max,\n                    opr=self.raise_output_id,\n                    oprc=self.raise_output_channel,\n                    oprt=self.raise_output_type,\n                    oprmnon=self.raise_min_duration,\n                    oprmxon=self.raise_max_duration,\n                    oprmnoff=self.raise_min_off_duration,\n                    opramn=self.raise_always_min_pwm,\n                    opl=self.lower_output_id,\n                    oplc=self.lower_output_channel,\n                    oplt=self.lower_output_type,\n                    oplmnon=self.lower_min_duration,\n                    oplmxon=self.lower_max_duration,\n                    oplmnoff=self.lower_min_off_duration,\n                    oplamn=self.lower_always_min_pwm,\n                    sptt=self.setpoint_tracking_type,\n                    spt=self.setpoint_tracking_id)\n", "docstring": "return \"Device ID: {did}, \" \\"}
{"repo": "Mycodo-master/mycodo/controllers/controller_pid.py", "original_string": "    def set_setpoint(self, setpoint):\n        \"\"\" Set the setpoint of PID \"\"\"\n        self.PID_Controller.setpoint = float(setpoint)\n        with session_scope(MYCODO_DB_PATH) as db_session:\n            mod_pid = db_session.query(PID).filter(PID.unique_id == self.unique_id).first()\n            mod_pid.setpoint = setpoint\n            db_session.commit()\n        return \"Setpoint set to {sp}\".format(sp=setpoint)\n", "docstring": "Set the setpoint of PID \n"}
{"repo": "Mycodo-master/mycodo/controllers/controller_pid.py", "original_string": "    def set_integrator(self, integrator):\n        \"\"\" Set the integrator of the controller \"\"\"\n        self.PID_Controller.integrator = float(integrator)\n        return \"Integrator set to {i}\".format(i=self.PID_Controller.integrator)\n", "docstring": "Set the integrator of the controller \n"}
{"repo": "Mycodo-master/mycodo/controllers/controller_pid.py", "original_string": "    def set_kp(self, p):\n        \"\"\" Set Kp gain of the controller \"\"\"\n        self.PID_Controller.Kp = float(p)\n        with session_scope(MYCODO_DB_PATH) as db_session:\n            mod_pid = db_session.query(PID).filter(PID.unique_id == self.unique_id).first()\n            mod_pid.p = p\n            db_session.commit()\n        return \"Kp set to {kp}\".format(kp=self.PID_Controller.Kp)\n", "docstring": "Set Kp gain of the controller \n"}
{"repo": "Mycodo-master/mycodo/controllers/controller_pid.py", "original_string": "    def set_kd(self, d):\n        \"\"\" Set Kd gain of the controller \"\"\"\n        self.PID_Controller.Kd = float(d)\n        with session_scope(MYCODO_DB_PATH) as db_session:\n            mod_pid = db_session.query(PID).filter(PID.unique_id == self.unique_id).first()\n            mod_pid.d = d\n            db_session.commit()\n        return \"Kd set to {kd}\".format(kd=self.PID_Controller.Kd)\n", "docstring": "Set Kd gain of the controller \n"}
{"repo": "Mycodo-master/mycodo/controllers/controller_output.py", "original_string": "    def loop(self):\n        \"\"\" Main loop of the output controller \"\"\"\n        for output_id in self.output:\n            for each_channel in self.output_unique_id[output_id]:\n                # Execute if past the time the output was supposed to turn off\n                if (self.output[output_id].output_setup and\n                        each_channel in self.output[output_id].output_on_until and\n                        self.output[output_id].output_on_until[each_channel] < datetime.datetime.now() and\n                        self.output[output_id].output_on_duration[each_channel] and\n                        not self.output[output_id].output_off_triggered[each_channel]):\n                    # Use a thread to prevent blocking the loop\n                    self.output[output_id].output_off_triggered[each_channel] = True\n                    turn_output_off = threading.Thread(\n                        target=self.output[output_id].output_on_off,\n                        args=('off',),\n                        kwargs={'output_channel': each_channel})\n                    turn_output_off.start()\n", "docstring": "Main loop of the output controller \n"}
{"repo": "Mycodo-master/mycodo/controllers/controller_output.py", "original_string": "    def all_outputs_initialize(self, outputs):\n        \"\"\" Initialize all output variables and classes \"\"\"\n        self.dict_outputs = parse_output_information()\n        self.output_types = output_types()\n        for each_output in outputs:\n            try:\n                self.output_type[each_output.unique_id] = each_output.output_type\n                self.output_unique_id[each_output.unique_id] = {}\n                if 'channels_dict' in self.dict_outputs[each_output.output_type]:\n                    for each_channel in self.dict_outputs[each_output.output_type]['channels_dict']:\n                        self.output_unique_id[each_output.unique_id][each_channel] = None\n                else:\n                    self.output_unique_id[each_output.unique_id][0] = None\n                if each_output.output_type in self.dict_outputs:\n                    if ('no_run' in self.dict_outputs[each_output.output_type] and\n                            self.dict_outputs[each_output.output_type]['no_run']):\n                        continue\n                    output_loaded = load_module_from_file(\n                        self.dict_outputs[each_output.output_type]['file_path'],\n                        'outputs')\n                    if output_loaded:\n                        self.output[each_output.unique_id] = output_loaded.OutputModule(each_output)\n                        self.output[each_output.unique_id].setup_output()\n                        self.output[each_output.unique_id].init_post()\n                self.logger.debug(\"{id} ({name}) Initialized\".format(\n                    id=each_output.unique_id.split('-')[0], name=each_output.name))\n            except:\n                self.logger.exception(\"Could not initialize output {}\".format(\n                    each_output.unique_id))\n", "docstring": "Initialize all output variables and classes \n"}
{"repo": "Mycodo-master/mycodo/controllers/controller_output.py", "original_string": "    def output_setup(self, action, output_id):\n        \"\"\" Add, delete, or modify a specific output \"\"\"\n        if action in ['Add', 'Modify']:\n            return self.add_mod_output(output_id)\n        elif action == 'Delete':\n            return self.del_output(output_id)\n        else:\n            return [1, 'Invalid output_setup action']\n", "docstring": "Add, delete, or modify a specific output \n"}
{"repo": "Mycodo-master/mycodo/controllers/controller_output.py", "original_string": "    def output_sec_currently_on(self, output_id, output_channel):\n        return self.output[output_id].output_sec_currently_on(output_channel)\n", "docstring": "return self.output[output_id].output_sec_currently_on(output_channel)"}
{"repo": "Mycodo-master/mycodo/scripts/create_admin_user.py", "original_string": "def set_password(new_password):\n    \"\"\" saves a password hash  \"\"\"\n    if isinstance(new_password, str):\n        new_password = new_password.encode('utf-8')\n    return bcrypt.hashpw(new_password, bcrypt.gensalt())\n", "docstring": "saves a password hash  \n"}
{"repo": "Mycodo-master/mycodo/functions/base_function.py", "original_string": "    def start_function(self):\n        \"\"\" Not used yet \"\"\"\n        self.running = True\n", "docstring": "Not used yet \n"}
{"repo": "Mycodo-master/mycodo/devices/atlas_scientific_uart.py", "original_string": "    def query(self, query_str):\n        \"\"\" Send command and return reply \"\"\"\n        lock_file_amend = '/var/lock/sensor-atlas.{dev}'.format(\n            dev=self.serial_device.replace(\"/\", \"-\"))\n        if self.lockfile.lock_acquire(lock_file_amend, timeout=3600):\n            try:\n                self.send_cmd(query_str)\n                time.sleep(1.3)\n                response = self.read_lines()\n                return 'success', response\n            finally:\n                self.lockfile.lock_release(lock_file_amend)\n        return None, None\n", "docstring": "Send command and return reply \n"}
{"repo": "Mycodo-master/mycodo/devices/atlas_scientific_i2c.py", "original_string": "    def read(self, num_of_bytes=50):\n        \"\"\" Read a specified number of bytes from I2C, then parse and display the result \"\"\"\n        res = self.file_read.read(num_of_bytes)  # read from the board\n        if res[0] == 1:  # if the response isn't an error\n            response = list(filter(lambda x: x != '\\x00', res.decode()))  # remove the null characters\n            # change MSB to 0 for all received characters except the first and get a list of characters\n            char_list = map(lambda x: chr(ord(x) & ~0x80), list(response[1:]))\n            # NOTE: having to change the MSB to 0 is a glitch in the raspberry pi, and you shouldn't have to do this!\n            return \"success\", ''.join(char_list)  # convert the char list to a string and returns it\n        else:\n            return \"error\", str(res[0])\n", "docstring": "Read a specified number of bytes from I2C, then parse and display the result \n"}
{"repo": "Mycodo-master/mycodo/devices/lcd_grove_lcd_rgb.py", "original_string": "    def lcd_backlight(self, state):\n        \"\"\" Turn the backlight on or off \"\"\"\n        if state:\n            self.setRGB(self.red, self.green, self.blue)\n        else:\n            self.setRGB(0,0,0)\n", "docstring": "Turn the backlight on or off \n"}
{"repo": "Mycodo-master/mycodo/devices/lcd_grove_lcd_rgb.py", "original_string": "    def lcd_byte(self, bits, mode, backlight=None):\n        \"\"\" Send byte to data pins \"\"\"\n        # bits = the data\n        # mode = 1 for data\n        #        0 for command\n        if mode == 0:\n            self.writeCommand(bits)\n        else:\n            self.writeData(bits)\n", "docstring": "Send byte to data pins \n"}
{"repo": "Mycodo-master/mycodo/devices/lcd_grove_lcd_rgb.py", "original_string": "    def lcd_string_write(self, message, line):\n        \"\"\" Send strings to display \"\"\"\n        self.setCursor(0, line)\n        for c in message:\n            self.writeData(ord(c))\n", "docstring": "Send strings to display \n"}
{"repo": "Mycodo-master/mycodo/devices/atlas_scientific_ftdi.py", "original_string": "    def atlas_write(self, cmd):\n        self.send_cmd(cmd)\n", "docstring": "self.send_cmd(cmd)"}
{"repo": "Mycodo-master/mycodo/devices/lcd_generic.py", "original_string": "    def lcd_backlight(self, state):\n        \"\"\" Turn the backlight on or off \"\"\"\n        if state:\n            self.lcd_byte(0x01, self.LCD_CMD, self.LCD_BACKLIGHT)\n        else:\n            self.lcd_byte(0x01, self.LCD_CMD, self.LCD_BACKLIGHT_OFF)\n", "docstring": "Turn the backlight on or off \n"}
{"repo": "Mycodo-master/mycodo/devices/lcd_generic.py", "original_string": "    def lcd_toggle_enable(self, bits):\n        \"\"\" Toggle enable \"\"\"\n        time.sleep(self.E_DELAY)\n        self.bus.write_byte(self.I2C_ADDR, (bits | self.ENABLE))\n        time.sleep(self.E_PULSE)\n        self.bus.write_byte(self.I2C_ADDR, (bits & ~self.ENABLE))\n        time.sleep(self.E_DELAY)\n", "docstring": "Toggle enable \n"}
{"repo": "Mycodo-master/mycodo/utils/stats.py", "original_string": "def get_count(q):\n    \"\"\"Count the number of rows from an SQL query\"\"\"\n    count_q = q.statement.with_only_columns([func.count()]).order_by(None)\n    count = q.session.execute(count_q).scalar()\n    return count\n", "docstring": "Count the number of rows from an SQL query\n"}
{"repo": "Mycodo-master/mycodo/utils/stats.py", "original_string": "def get_anonymous_id():\n    pid = \"0\"\n    try:\n        f = open('/proc/cpuinfo', 'r')\n        for line in f:\n            if line[0:6] == 'Serial':\n              pid = line[10:26]\n        f.close()\n    except:\n        pid = \"ER\"\n    em = \"0\"\n    try:\n        f = open('/sys/class/net/eth0/address', 'r')\n        for line in f:\n            em = line\n        f.close()\n    except:\n        em = \"ER\"\n    try:\n        hash_string = '{}_{}'.format(pid, em).encode('utf-8')\n        anon_id = hashlib.sha256(hash_string).hexdigest()[:10]\n    except:\n        anon_id = '0000000000'\n    return anon_id\n", "docstring": "pid = \"0\""}
{"repo": "Mycodo-master/mycodo/utils/sunriseset.py", "original_string": "    def get_current_uct():\n        \"\"\"Return day, month, and year of current UTC time\"\"\"\n        now = datetime.datetime.now()\n        return [now.day, now.month, now.year]\n", "docstring": "Return day, month, and year of current UTC time\n"}
{"repo": "Mycodo-master/mycodo/utils/sunriseset.py", "original_string": "    def force_range(v, maximum):\n        # force v to be >= 0 and < maximum\n        if v < 0:\n            return v + maximum\n        elif v >= maximum:\n            return v - maximum\n        return v\n", "docstring": "force v to be >= 0 and < maximum"}
{"repo": "Mycodo-master/mycodo/utils/system_pi.py", "original_string": "def parse_custom_option_values(controllers, dict_controller=None):\n    # Check if controllers is iterable or a single controller\n    try:\n        _ = iter(controllers)\n    except TypeError:\n        iter_controller = [controllers]  # Not iterable\n    else:\n        iter_controller = controllers  # iterable\n    custom_options_values = {}\n    for each_controller in iter_controller:\n        custom_options_values[each_controller.unique_id] = {}\n        if each_controller.custom_options:\n            # Determine if custom_options should be parsed as JSON or CSV\n            if each_controller.custom_options.startswith(\"{\"):\n                custom_options = parse_custom_option_values_json(\n                    controllers, dict_controller, unique_id=each_controller.unique_id)\n                custom_options_values.update({each_controller.unique_id: custom_options})\n            else:\n                custom_options = parse_custom_option_values_csv(\n                    controllers, dict_controller, unique_id=each_controller.unique_id)\n                custom_options_values.update({each_controller.unique_id: custom_options})\n    return custom_options_values\n", "docstring": "Check if controllers is iterable or a single controller"}
{"repo": "Mycodo-master/mycodo/utils/system_pi.py", "original_string": "def parse_custom_option_values_csv(controllers, dict_controller=None, unique_id=None):\n    # Check if controllers is iterable or a single controller\n    try:\n        _ = iter(controllers)\n    except TypeError:\n        iter_controller = [controllers]  # Not iterable\n    else:\n        iter_controller = controllers  # iterable\n    custom_options_values = {}\n    for each_controller in iter_controller:\n        custom_options_values[each_controller.unique_id] = {}\n        if each_controller.custom_options:\n            for each_option in each_controller.custom_options.split(';'):\n                option = each_option.split(',')[0]\n                if len(each_option.split(',')) > 2:\n                    value = ','.join(each_option.split(',')[1:])\n                elif len(each_option.split(',')) > 1:\n                    value = each_option.split(',')[1]\n                else:\n                    continue\n                custom_options_values[each_controller.unique_id][option] = value\n        if dict_controller:\n            # Set default values if option not saved in database entry\n            if each_controller.__tablename__ in ['custom_controller', 'input']:\n                dev_name = each_controller.device\n            elif each_controller.__tablename__ == 'output':\n                dev_name = each_controller.output_type\n            else:\n                logger.error(\"Table name not recognized: {}\".format(each_controller.__tablename__))\n                continue\n            if 'custom_options' in dict_controller[dev_name]:\n                dict_custom_options = dict_controller[dev_name]['custom_options']\n            else:\n                dict_custom_options = {}\n            for each_option in dict_custom_options:\n                if ('id' in each_option and\n                        'default_value' in each_option and\n                        each_option['id'] not in custom_options_values[each_controller.unique_id]):\n                    custom_options_values[each_controller.unique_id][each_option['id']] = each_option['default_value']\n    if unique_id:\n        return custom_options_values[unique_id]\n    return custom_options_values\n", "docstring": "Check if controllers is iterable or a single controller"}
{"repo": "Mycodo-master/mycodo/utils/system_pi.py", "original_string": "def return_measurement_info(device_measurement, conversion):\n    \"\"\" Return unit, measurement, and channel of a device measurement\"\"\"\n    try:\n        unit = None\n        measurement = None\n        channel = None\n        if device_measurement:\n            channel = device_measurement.channel\n        if (device_measurement and\n                device_measurement.conversion_id and\n                conversion):\n            unit = conversion.convert_unit_to\n        elif (device_measurement and\n                hasattr(device_measurement, 'rescaled_unit') and\n                hasattr(device_measurement, 'rescaled_measurement') and\n                device_measurement.rescaled_unit and\n                device_measurement.rescaled_measurement):\n            unit = device_measurement.rescaled_unit\n            measurement = device_measurement.rescaled_measurement\n        else:\n            if device_measurement:\n                unit = device_measurement.unit\n                measurement = device_measurement.measurement\n        return channel, unit, measurement\n    except Exception:\n        logger.exception(\"{}, {}\".format(device_measurement, conversion))\n        return None, None, None\n", "docstring": "Return unit, measurement, and channel of a device measurement\n"}
{"repo": "Mycodo-master/mycodo/utils/system_pi.py", "original_string": "def str_is_float(text):\n    \"\"\"Returns true if the string represents a float value\"\"\"\n    try:\n        if not text:\n            return False\n        if text.isalpha():\n            return False\n        float(text)\n        return True\n    except ValueError:\n        return False\n", "docstring": "Returns true if the string represents a float value\n"}
{"repo": "Mycodo-master/mycodo/utils/system_pi.py", "original_string": "def assure_path_exists(path):\n    \"\"\" Create path if it doesn't exist \"\"\"\n    if not os.path.exists(path):\n        os.makedirs(path)\n        os.chmod(path, 0o774)\n        set_user_grp(path, 'mycodo', 'mycodo')\n    return path\n", "docstring": "Create path if it doesn't exist \n"}
{"repo": "Mycodo-master/mycodo/utils/system_pi.py", "original_string": "def find_owner(filename):\n    \"\"\" Return the owner of a file \"\"\"\n    return pwd.getpwuid(os.stat(filename).st_uid).pw_name\n", "docstring": "Return the owner of a file \n"}
{"repo": "Mycodo-master/mycodo/utils/system_pi.py", "original_string": "def base64_encode_bytes(key_bytes):\n    encoded_bytes = base64.b64encode(key_bytes)\n    encoded_str = str(encoded_bytes, \"utf-8\")\n    return encoded_str\n", "docstring": "encoded_bytes = base64.b64encode(key_bytes)"}
{"repo": "Mycodo-master/mycodo/utils/method.py", "original_string": "    def get_plot(self, max_points_x=None):\n        result = []\n        for each_method in self.method_data_all:\n            if each_method.setpoint_end is None:\n                setpoint_end = each_method.setpoint_start\n            else:\n                setpoint_end = each_method.setpoint_end\n            start_time = datetime.datetime.strptime(\n                each_method.time_start, '%Y-%m-%d %H:%M:%S')\n            end_time = datetime.datetime.strptime(\n                each_method.time_end, '%Y-%m-%d %H:%M:%S')\n            is_dst = time.daylight and time.localtime().tm_isdst > 0\n            utc_offset_ms = (time.altzone if is_dst else time.timezone)\n            result.append(\n                [(int(start_time.strftime(\"%s\")) - utc_offset_ms) * 1000,\n                 each_method.setpoint_start])\n            result.append(\n                [(int(end_time.strftime(\"%s\")) - utc_offset_ms) * 1000,\n                 setpoint_end])\n            result.append(\n                [(int(start_time.strftime(\"%s\")) - utc_offset_ms) * 1000,\n                 None])\n        return result\n", "docstring": "result = []"}
{"repo": "Mycodo-master/mycodo/utils/method.py", "original_string": "    def get_plot(self, max_points_x=700):\n        result = []\n        seconds_in_day = 60 * 60 * 24\n        today = datetime.datetime(1900, 1, 1)\n        for n in range(max_points_x):\n            percent = n / float(max_points_x)\n            now = today + datetime.timedelta(seconds=percent * seconds_in_day)\n            y, ended = self.calculate_setpoint(now)\n            if not ended:\n                result.append([percent * seconds_in_day * 1000, y])\n        return result\n", "docstring": "result = []"}
{"repo": "Mycodo-master/mycodo/utils/method.py", "original_string": "    def calculate_setpoint(self, now, method_start_time=None):\n        # Calculate sine y-axis value from the x-axis (seconds of the day)\n        dt = datetime.timedelta(hours=now.hour,\n                                minutes=now.minute,\n                                seconds=now.second)\n        secs_per_day = 24 * 60 * 60\n        angle = dt.total_seconds() / secs_per_day * 360\n        new_setpoint = sine_wave_y_out(self.method_data_first.amplitude,\n                                       self.method_data_first.frequency,\n                                       self.method_data_first.shift_angle,\n                                       self.method_data_first.shift_y,\n                                       angle)\n        return new_setpoint, False\n", "docstring": "Calculate sine y-axis value from the x-axis (seconds of the day)"}
{"repo": "Mycodo-master/mycodo/utils/method.py", "original_string": "    def calculate_setpoint(self, now, method_start_time=None):\n        # Calculate Bezier curve y-axis value from the x-axis (seconds of the day)\n        dt = datetime.timedelta(hours=now.hour,\n                                minutes=now.minute,\n                                seconds=now.second)\n        new_setpoint = bezier_curve_y_out(\n            self.method_data_first.shift_angle,\n            (self.method_data_first.x0, self.method_data_first.y0),\n            (self.method_data_first.x1, self.method_data_first.y1),\n            (self.method_data_first.x2, self.method_data_first.y2),\n            (self.method_data_first.x3, self.method_data_first.y3),\n            dt.total_seconds())\n        return new_setpoint, False\n", "docstring": "Calculate Bezier curve y-axis value from the x-axis (seconds of the day)"}
{"repo": "Mycodo-master/mycodo/utils/method.py", "original_string": "    def calculate_setpoint(self, now, method_start_time=None):\n        # Calculate the duration in the method based on self.method_start_time\n        start_time = parse_db_time(method_start_time, datetime.datetime.min)\n        duration_in_seconds = self.cycle_duration()\n        seconds_from_start = (now - start_time).total_seconds()\n        if seconds_from_start >= duration_in_seconds:\n            repeat_duration = self.repeat_duration()\n            if repeat_duration is None:\n                # ended after one cycle\n                return None, True\n            if 0 < repeat_duration <= seconds_from_start:\n                # ended after configured repeat time\n                return None, True\n            else:\n                # still repeated\n                seconds_from_start = seconds_from_start % duration_in_seconds\n        total_sec = 0\n        previous_total_sec = 0\n        for each_method in self.method_data_all:\n            total_sec += each_method.duration_sec\n            if previous_total_sec <= seconds_from_start < total_sec:\n                row_since_start_sec = seconds_from_start - previous_total_sec\n                percent_row = row_since_start_sec / each_method.duration_sec\n                setpoint_start = each_method.setpoint_start\n                if each_method.setpoint_end is not None:\n                    setpoint_end = each_method.setpoint_end\n                else:\n                    setpoint_end = each_method.setpoint_start\n                setpoint_diff = abs(setpoint_end - setpoint_start)\n                if setpoint_start < setpoint_end:\n                    new_setpoint = setpoint_start + (setpoint_diff * percent_row)\n                else:\n                    new_setpoint = setpoint_start - (setpoint_diff * percent_row)\n                if self.logger:\n                    self.logger.debug(\n                        \"[Method] {sec_method:.1f}s/{sec_cycle:.1f}s/{sec_row:.1f}s \"\n                        \"since start of method/cycle/row\".format(\n                            sec_method=(now - start_time).total_seconds(),\n                            sec_cycle=seconds_from_start,\n                            sec_row=row_since_start_sec))\n                    self.logger.debug(\n                        \"[Method] Percent of row: {per:.2f}, new Setpoint {sp:.2f}\".format(\n                            per=percent_row, sp=new_setpoint))\n                return new_setpoint, False\n            previous_total_sec = total_sec\n        return previous_total_sec, False\n", "docstring": "Calculate the duration in the method based on self.method_start_time"}
{"repo": "Mycodo-master/mycodo/utils/influx.py", "original_string": "def get_last_measurement(device_id, measurement_id, max_age=None):\n    device_measurement = db_retrieve_table_daemon(\n        DeviceMeasurements).filter(\n        DeviceMeasurements.unique_id == measurement_id).first()\n    if device_measurement:\n        conversion = db_retrieve_table_daemon(\n            Conversion, unique_id=device_measurement.conversion_id)\n    else:\n        conversion = None\n    channel, unit, measurement = return_measurement_info(\n        device_measurement, conversion)\n    last_measurement = read_last_influxdb(\n        device_id,\n        unit,\n        channel,\n        measure=measurement,\n        duration_sec=max_age)\n    return last_measurement\n", "docstring": "device_measurement = db_retrieve_table_daemon("}
{"repo": "Mycodo-master/mycodo/utils/influx.py", "original_string": "def output_sec_on(output_id, past_seconds, output_channel=0):\n    \"\"\" Return the number of seconds a output has been ON in the past number of seconds \"\"\"\n    # Get the number of seconds ON stored in the database\n    output = db_retrieve_table_daemon(Output, unique_id=output_id)\n    client = InfluxDBClient(INFLUXDB_HOST, INFLUXDB_PORT, INFLUXDB_USER,\n                            INFLUXDB_PASSWORD, INFLUXDB_DATABASE, timeout=5)\n    if not output_id:\n        return None\n    # Get the number of seconds not stored in the database (if currently on)\n    output_time_on = 0\n    try:\n        control = DaemonControl()\n        if control.output_state(output_id, output_channel=output_channel) == 'on':\n            output_time_on = control.output_sec_currently_on(\n                output_id, output_channel=output_channel)\n    except Exception:\n        logger.exception(\"output_sec_on()\")\n    query = query_string('s', output.unique_id,\n                         measure='duration_time',\n                         channel=output_channel,\n                         value='SUM',\n                         past_sec=past_seconds)\n    query_output = client.query(query)\n    sec_recorded_on = 0\n    if query_output:\n        sec_recorded_on = query_output.raw['series'][0]['values'][0][1]\n    sec_currently_on = 0\n    if output_time_on:\n        sec_currently_on = min(output_time_on, past_seconds)\n    return sec_recorded_on + sec_currently_on\n", "docstring": "Return the number of seconds a output has been ON in the past number of seconds \n"}
{"repo": "Mycodo-master/mycodo/utils/influx.py", "original_string": "def average_start_end_seconds(unique_id, unit, channel, str_start, str_end, measure=None):\n    \"\"\"Return measurement average for a period of time\"\"\"\n    client = InfluxDBClient(\n        INFLUXDB_HOST, INFLUXDB_PORT, INFLUXDB_USER, INFLUXDB_PASSWORD,\n        INFLUXDB_DATABASE, timeout=5)\n    query = query_string(\n        unit, unique_id,\n        measure=measure,\n        channel=channel,\n        value='MEAN',\n        start_str=str_start,\n        end_str=str_end)\n    query_output = client.query(query)\n    if query_output:\n        return query_output.raw['series'][0]['values'][0][1]\n", "docstring": "Return measurement average for a period of time\n"}
{"repo": "Mycodo-master/mycodo/utils/influx.py", "original_string": "def influx_time_str_to_milliseconds(timestamp_str):\n    \"\"\" Converts InfluxDB time string with \"Z\" from nanoseconds to milliseconds and removes the Z \"\"\"\n    start_date_time = timestamp_str.split('Z')[0].split('.')[0]\n    start_milliseconds = timestamp_str.split('Z')[0].split('.')[1][:3]\n    return '{}.{}'.format(start_date_time, start_milliseconds)\n", "docstring": "Converts InfluxDB time string with \"Z\" from nanoseconds to milliseconds and removes the Z \n"}
{"repo": "Mycodo-master/mycodo/utils/utils.py", "original_string": "def query_yes_no(question, default=\"yes\"):\n    \"\"\"Ask a yes/no question via input() and return their answer.\n    \"question\" is a string that is presented to the user.\n    \"default\" is the presumed answer if the user just hits <Enter>.\n        It must be \"yes\" (the default), \"no\" or None (meaning\n        an answer is required of the user).\n    The \"answer\" return value is True for \"yes\" or False for \"no\".\n    \"\"\"\n    valid = {\"yes\": True, \"y\": True, \"ye\": True,\n             \"no\": False, \"n\": False}\n    if default is None:\n        prompt = \" [y/n] \"\n    elif default == \"yes\":\n        prompt = \" [Y/n] \"\n    elif default == \"no\":\n        prompt = \" [y/N] \"\n    else:\n        raise ValueError(\"invalid default answer: '%s'\" % default)\n    while True:\n        sys.stdout.write(question + prompt)\n        choice = input().lower()\n        if default is not None and choice == '':\n            return valid[default]\n        elif choice in valid:\n            return valid[choice]\n        else:\n            sys.stdout.write(\"Please respond with 'y' or 'n').\\n\")\n", "docstring": "Ask a yes/no question via input() and return their answer."}
{"repo": "Mycodo-master/mycodo/utils/github_release_info.py", "original_string": "    def github_latest_release(self, mycodo_releases):\n        \"\"\" Return the latest Mycodo release version \"\"\"\n        all_versions = []\n        for each_release in mycodo_releases:\n            if re.match('v.*(\\d\\.\\d\\.\\d)', each_release['name']):\n                all_versions.append(each_release['name'][1:])\n        try:\n            return self.sort_reverse_list(all_versions)[0]\n        except IndexError:\n            return None\n", "docstring": "Return the latest Mycodo release version \n"}
{"repo": "Mycodo-master/mycodo/utils/github_release_info.py", "original_string": "def parseargs(p):\n    p.add_argument('-c', '--currentversion', action='store_true',\n                   help='Return the currently-installed version.')\n    p.add_argument('-i', '--islatest', action='store_true',\n                   help='Return True if the currently-installed '\n                        'version is the latest.')\n    p.add_argument('-l', '--latest', action='store_true',\n                   help='Return the latest version URL.')\n    p.add_argument('-m', '--majornumber', type=int,\n                   help='Return the latest version URL with major '\n                        'version number x in x.y.z.')\n    p.add_argument('-v', '--version', action='store_true',\n                   help='Return the latest version number.')\n    return p.parse_args()\n", "docstring": "p.add_argument('-c', '--currentversion', action='store_true',"}
{"repo": "Mycodo-master/mycodo/utils/widget_generate_html.py", "original_string": "def set_user_grp(filepath, user, group):\n    \"\"\" Set the UID and GUID of a file \"\"\"\n    uid = pwd.getpwnam(user).pw_uid\n    gid = grp.getgrnam(group).gr_gid\n    os.chown(filepath, uid, gid)\n", "docstring": "Set the UID and GUID of a file \n"}
{"repo": "Mycodo-master/mycodo/utils/function_actions.py", "original_string": "def action_camera_timelapse_resume(cond_action, message):\n    \"\"\"Resumes a camera timelapse\"\"\"\n    unique_id = cond_action.do_unique_id.split(\",\")[0]\n    this_camera = db_retrieve_table_daemon(\n        Camera, unique_id=unique_id, entry='first')\n    message += \" Resume timelapse with Camera {unique_id} ({id}, {name}).\".format(\n        unique_id=unique_id,\n        id=this_camera.id,\n        name=this_camera.name)\n    with session_scope(MYCODO_DB_PATH) as new_session:\n        mod_camera = new_session.query(Camera).filter(\n            Camera.unique_id == unique_id).first()\n        mod_camera.timelapse_paused = False\n        new_session.commit()\n    return message\n", "docstring": "Resumes a camera timelapse\n"}
{"repo": "Mycodo-master/mycodo/utils/function_actions.py", "original_string": "def action_input_force_measurements(cond_action, message):\n    \"\"\"Forces measurements to be conducted for an input\"\"\"\n    control = DaemonControl()\n    unique_id = cond_action.do_unique_id.split(\",\")[0]\n    this_input = db_retrieve_table_daemon(\n        Input, unique_id=unique_id, entry='first')\n    message += \" Force measuring from Input {unique_id} ({id}, {name}).\".format(\n        unique_id=unique_id,\n        id=this_input.id,\n        name=this_input.name)\n    clear_volume = threading.Thread(\n        target=control.input_force_measurements,\n        args=(this_input.unique_id,))\n    clear_volume.start()\n    return message\n", "docstring": "Forces measurements to be conducted for an input\n"}
{"repo": "Mycodo-master/mycodo/utils/function_actions.py", "original_string": "def action_mqtt_publish(cond_action, message, value):\n    import paho.mqtt.publish as publish\n    try:\n        custom_options = json.loads(cond_action.custom_options)\n        auth_dict = None\n        if custom_options['login']:\n            auth_dict = {\n                \"username\": custom_options['username'],\n                \"password\": custom_options['password']\n            }\n        publish.single(\n            custom_options['topic'],\n            value,\n            hostname=custom_options['hostname'],\n            port=custom_options['port'],\n            client_id=custom_options['clientid'],\n            keepalive=custom_options['keepalive'],\n            auth=auth_dict)\n        message += \" MQTT Publish '{value}'.\".format(value=value)\n    except Exception as err:\n        msg = \" Could not execute MQTT Publish: Malformed JSON custom_options: {}\".format(err)\n        logger.error(msg)\n        message += msg\n    return message\n", "docstring": "import paho.mqtt.publish as publish"}
{"repo": "Mycodo-master/mycodo/utils/function_actions.py", "original_string": "def action_command(cond_action, message):\n    # Replace string variables with actual values\n    command_str = cond_action.do_action_string\n    user = cond_action.do_output_state\n    # TODO: Maybe get this working again with the new measurement system\n    # # Replace measurement variables\n    # if last_measurement:\n    #     command_str = command_str.replace(\n    #         \"((measure_{var}))\".format(\n    #             var=device_measurement), str(last_measurement))\n    # if device and device.period:\n    #     command_str = command_str.replace(\n    #         \"((measure_period))\", str(device.period))\n    # if input_dev:\n    #     command_str = command_str.replace(\n    #         \"((measure_location))\", str(input_dev.location))\n    # if input_dev and device_measurement == input_dev.measurements:\n    #     command_str = command_str.replace(\n    #         \"((measure_linux_command))\", str(last_measurement))\n    #\n    # # Replace output variables\n    # if output:\n    #     if output.pin:\n    #         command_str = command_str.replace(\n    #             \"((output_pin))\", str(output.pin))\n    #     if output_state:\n    #         command_str = command_str.replace(\n    #             \"((output_action))\", str(output_state))\n    #     if on_duration:\n    #         command_str = command_str.replace(\n    #             \"((output_duration))\", str(on_duration))\n    #     if duty_cycle:\n    #         command_str = command_str.replace(\n    #             \"((output_pwm))\", str(duty_cycle))\n    #\n    # # Replace edge variables\n    # if edge:\n    #     command_str = command_str.replace(\n    #         \"((edge_state))\", str(edge))\n    message += \" Execute '{com}' \".format(\n        com=command_str)\n    cmd_out, cmd_err, cmd_status = cmd_output(command_str, user=user)\n    message += \"(return out: {out}, err: {err}, status: {stat}).\".format(\n        out=cmd_out, err=cmd_err, stat=cmd_status)\n    return message\n", "docstring": "Replace string variables with actual values"}
{"repo": "Mycodo-master/mycodo/utils/PID_hirschmann/pid_autotune.py", "original_string": "    def state(self):\n        \"\"\"Get the current state.\"\"\"\n        return self._state\n", "docstring": "Get the current state.\n"}
{"repo": "Mycodo-master/mycodo/utils/PID_hirschmann/pid_autotune.py", "original_string": "    def output(self):\n        \"\"\"Get the last output value.\"\"\"\n        return self._output\n", "docstring": "Get the last output value.\n"}
{"repo": "Mycodo-master/mycodo/utils/PID_hirschmann/pid_autotune.py", "original_string": "    def tuning_rules(self):\n        \"\"\"Get a list of all available tuning rules.\"\"\"\n        return self._tuning_rules.keys()\n", "docstring": "Get a list of all available tuning rules.\n"}
{"repo": "Mycodo-master/mycodo/utils/PID_hirschmann/pid_kettle.py", "original_string": "    def temperature(self):\n        \"\"\"Get the content's temperature\"\"\"\n        return self._temp\n", "docstring": "Get the content's temperature\n"}
{"repo": "Mycodo-master/mycodo/databases/__init__.py", "original_string": "    def save(self):\n        \"\"\" creates the model in the database \"\"\"\n        try:\n            db.session.add(self)\n            db.session.commit()\n            return self\n        except Exception as error:\n            db.session.rollback()\n            current_app.logger.error(\"Failed to save {model} due to error: {err}\".format(model=self, err=error))\n", "docstring": "creates the model in the database \n"}
{"repo": "Mycodo-master/mycodo/databases/__init__.py", "original_string": "def set_api_key(length):\n    \"\"\" Generates an API key of specific length \"\"\"\n    return secrets.token_bytes(length)\n", "docstring": "Generates an API key of specific length \n"}
{"repo": "Mycodo-master/mycodo/databases/models/input.py", "original_string": "    def __repr__(self):\n        return \"<{cls}(id={s.id})>\".format(s=self, cls=self.__class__.__name__)\n", "docstring": "return \"<{cls}(id={s.id})>\".format(s=self, cls=self.__class__.__name__)"}
{"repo": "Mycodo-master/mycodo/databases/models/user.py", "original_string": "    def check_password(password, hashed_password):\n        \"\"\" validates a password \"\"\"\n        # Check type of password hashed_password to determine if it is a str\n        # and should be encoded\n        if isinstance(password, str):\n            password = password.encode('utf-8')\n        if isinstance(hashed_password, str):\n            hashed_password = hashed_password.encode('utf-8')\n        hashes_match = bcrypt.hashpw(password, hashed_password)\n        return hashes_match\n", "docstring": "validates a password \n"}
{"repo": "Mycodo-master/mycodo/databases/models/__init__.py", "original_string": "def alembic_upgrade_db():\n    \"\"\"Upgrade sqlite3 database with alembic\"\"\"\n    def upgrade_alembic():\n        \"\"\" Run alembic database upgrade \"\"\"\n        command = '/bin/bash {path}/mycodo/scripts/upgrade_commands.sh update-alembic'.format(path=INSTALL_DIRECTORY)\n        upgrade = subprocess.Popen(\n            command, stdout=subprocess.PIPE, shell=True)\n        (_, _) = upgrade.communicate()\n        upgrade.wait()\n    alembic = AlembicVersion.query.first()\n    if alembic:  # If alembic_version table has an entry\n        if alembic.version_num == '':\n            alembic.delete()  # Delete row with blank version_num\n            upgrade_alembic()\n        elif alembic.version_num != ALEMBIC_VERSION:  # Not current version\n            upgrade_alembic()\n    else:\n        upgrade_alembic()\n", "docstring": "Upgrade sqlite3 database with alembic\n"}
{"repo": "Mycodo-master/mycodo/databases/models/controller.py", "original_string": "    def __repr__(self):\n        return \"<{cls}(id={s.id})>\".format(s=self, cls=self.__class__.__name__)\n", "docstring": "return \"<{cls}(id={s.id})>\".format(s=self, cls=self.__class__.__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/htu21d.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the humidity and temperature \"\"\"\n        if not self.pi.connected:\n            self.logger.error(\"Could not connect to pigpiod. Ensure it is running and try again.\")\n            return None\n        self.return_dict = copy.deepcopy(measurements_dict)\n        self.htu_reset()\n        # wtreg = 0xE6\n        # rdreg = 0xE7\n        rdtemp = 0xE3\n        rdhumi = 0xE5\n        handle = self.pi.i2c_open(self.i2c_bus, self.i2c_address)  # open i2c bus\n        self.pi.i2c_write_byte(handle, rdtemp)  # send read temp command\n        time.sleep(0.055)  # readings take up to 50ms, lets give it some time\n        (_, byte_array) = self.pi.i2c_read_device(handle, 3)  # vacuum up those bytes\n        self.pi.i2c_close(handle)  # close the i2c bus\n        t1 = byte_array[0]  # most significant byte msb\n        t2 = byte_array[1]  # least significant byte lsb\n        temp_reading = (t1 * 256) + t2  # combine both bytes into one big integer\n        temp_reading = float(temp_reading)\n        temperature = ((temp_reading / 65536) * 175.72) - 46.85  # formula from datasheet\n        handle = self.pi.i2c_open(self.i2c_bus, self.i2c_address)  # open i2c bus\n        self.pi.i2c_write_byte(handle, rdhumi)  # send read humi command\n        time.sleep(0.055)  # readings take up to 50ms, lets give it some time\n        (_, byte_array) = self.pi.i2c_read_device(handle, 3)  # vacuum up those bytes\n        self.pi.i2c_close(handle)  # close the i2c bus\n        h1 = byte_array[0]  # most significant byte msb\n        h2 = byte_array[1]  # least significant byte lsb\n        humi_reading = (h1 * 256) + h2  # combine both bytes into one big integer\n        humi_reading = float(humi_reading)\n        uncomp_humidity = ((humi_reading / 65536) * 125) - 6  # formula from datasheet\n        humidity = ((25 - temperature) * -0.15) + uncomp_humidity\n        if self.is_enabled(0):\n            self.value_set(0, temperature)\n        if self.is_enabled(1):\n            self.value_set(1, humidity)\n        if self.is_enabled(2) and self.is_enabled(0) and self.is_enabled(1):\n            self.value_set(2, calculate_dewpoint(self.value_get(0), self.value_get(1)))\n        if self.is_enabled(3) and self.is_enabled(0) and self.is_enabled(1):\n            self.value_set(3, calculate_vapor_pressure_deficit(self.value_get(0), self.value_get(1)))\n        return self.return_dict\n", "docstring": "Gets the humidity and temperature \n"}
{"repo": "Mycodo-master/mycodo/inputs/rpi_signal_revolutions.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the revolutions \"\"\"\n        pi = self.pigpio.pi()\n        if not pi.connected:  # Check if pigpiod is running\n            self.logger.error(\"Could not connect to pigpiod. Ensure it is running and try again.\")\n            return None\n        self.return_dict = copy.deepcopy(measurements_dict)\n        read_revolutions = ReadRPM(pi, self.gpio, self.pigpio, self.rpm_pulses_per_rev, self.weighting)\n        time.sleep(self.sample_time)\n        rpm = read_revolutions.RPM()\n        read_revolutions.cancel()\n        pi.stop()\n        self.value_set(0, rpm)\n        return self.return_dict\n", "docstring": "Gets the revolutions \n"}
{"repo": "Mycodo-master/mycodo/inputs/anyleaf_orp.py", "original_string": "    def calibrate(self, args_dict):\n        \"\"\" Auto-calibrate \"\"\"\n        if 'calibration_orp' not in args_dict:\n            self.logger.error(\"Cannot conduct calibration without a buffer ORP value\")\n            return\n        if not isinstance(args_dict['calibration_orp'], float) and not isinstance(args_dict['calibration_orp'], int):\n            self.logger.error(\"buffer value does not represent a number: '{}', type: {}\".format(\n                args_dict['calibration_orp'], type(args_dict['calibration_orp'])))\n            return\n        # For this session\n        v = self.sensor.calibrate(args_dict['calibration_orp'])\n        # For future sessions\n        self.set_custom_option(\"cal_orp\", args_dict['calibration_orp'])\n        self.set_custom_option(\"cal_v\", v)\n", "docstring": "Auto-calibrate \n"}
{"repo": "Mycodo-master/mycodo/inputs/ttn_data_storage.py", "original_string": "    def __init__(self, input_dev, testing=False):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        self.first_run = True\n        self.application_id = None\n        self.app_api_key = None\n        self.device_id = None\n        if not testing:\n            self.setup_custom_options(\n                INPUT_INFORMATION['custom_options'], input_dev)\n            self.initialize_input()\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/atlas_pressure.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the Atlas Scientific pressure sensor measurement \"\"\"\n        if not self.atlas_device.setup:\n            self.logger.error(\"Input not set up\")\n            return\n        pressure = None\n        self.return_dict = copy.deepcopy(measurements_dict)\n        if self.led == 'measure':\n            self.atlas_device.query('L,1')\n        # Read sensor via FTDI or UART\n        if self.interface in ['FTDI', 'UART']:\n            press_status, press_list = self.atlas_device.query('R')\n            if press_list:\n                self.logger.debug(\"Returned list: {lines}\".format(lines=press_list))\n            # Find float value in list\n            float_value = None\n            for each_split in press_list:\n                if str_is_float(each_split):\n                    float_value = each_split\n                    break\n            if 'check probe' in press_list:\n                self.logger.error('\"check probe\" returned from sensor')\n            elif str_is_float(float_value):\n                pressure = float(float_value)\n                self.logger.debug('Found float value: {val}'.format(val=pressure))\n            else:\n                self.logger.error('Value or \"check probe\" not found in list: {val}'.format(val=press_list))\n        elif self.interface == 'I2C':\n            pressure_status, pressure_str = self.atlas_device.query('R')\n            if pressure_status == 'error':\n                self.logger.error(\"Sensor read unsuccessful: {err}\".format(err=pressure_str))\n            elif pressure_status == 'success':\n                pressure = float(pressure_str)\n        if self.led == 'measure':\n            self.atlas_device.query('L,0')\n        self.value_set(0, pressure)\n        return self.return_dict\n", "docstring": "Gets the Atlas Scientific pressure sensor measurement \n"}
{"repo": "Mycodo-master/mycodo/inputs/bmp280.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the measurement in units by reading the \"\"\"\n        if not self.sensor:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        if self.is_enabled(0):\n            self.value_set(0, self.read_pressure())\n        if self.is_enabled(1):\n            self.value_set(1, self.read_temperature())\n        if self.is_enabled(0):\n            self.value_set(2, calculate_altitude(self.value_get(0)))\n        return self.return_dict\n", "docstring": "Gets the measurement in units by reading the \n"}
{"repo": "Mycodo-master/mycodo/inputs/bmp280.py", "original_string": "    def _load_datasheet_calibration(self):\n        \"\"\"data from the datasheet example, useful for debug\"\"\"\n        self.cal_REGISTER_DIG_T1 = 27504\n        self.cal_REGISTER_DIG_T2 = 26435\n        self.cal_REGISTER_DIG_T3 = -1000\n        self.cal_REGISTER_DIG_P1 = 36477\n        self.cal_REGISTER_DIG_P2 = -10685\n        self.cal_REGISTER_DIG_P3 = 3024\n        self.cal_REGISTER_DIG_P4 = 2855\n        self.cal_REGISTER_DIG_P5 = 140\n        self.cal_REGISTER_DIG_P6 = -7\n        self.cal_REGISTER_DIG_P7 = 15500\n        self.cal_REGISTER_DIG_P8 = -14600\n        self.cal_REGISTER_DIG_P9 = 6000\n        # reading raw data from registers, and combining into one raw measurement\n", "docstring": "data from the datasheet example, useful for debug\n"}
{"repo": "Mycodo-master/mycodo/inputs/bmp280.py", "original_string": "    def read_raw_pressure(self):\n        \"\"\"Reads the raw (uncompensated) pressure level from the sensor.\"\"\"\n        self.sensor.write8(BMP280_REGISTER_CONTROL, BMP280_READCMD + (self._mode << 6))\n        if self._mode == BMP280_ULTRALOWPOWER:\n            time.sleep(0.005)\n        elif self._mode == BMP280_HIGHRES:\n            time.sleep(0.014)\n        elif self._mode == BMP280_ULTRAHIGHRES:\n            time.sleep(0.026)\n        else:\n            time.sleep(0.008)\n        msb = self.sensor.readU8(BMP280_REGISTER_PRESSUREDATA_MSB)\n        lsb = self.sensor.readU8(BMP280_REGISTER_PRESSUREDATA_LSB)\n        xlsb = self.sensor.readU8(BMP280_REGISTER_PRESSUREDATA_XLSB)\n        raw = ((msb << 8 | lsb) << 8 | xlsb) >> 4\n        self.logger.debug('Raw pressure 0x{0:04X} ({1})'.format(raw & 0xFFFF, raw))\n        return raw\n", "docstring": "Reads the raw (uncompensated) pressure level from the sensor.\n"}
{"repo": "Mycodo-master/mycodo/inputs/bmp280.py", "original_string": "    def read_pressure(self):\n        \"\"\"Gets the compensated pressure in Pascals.\"\"\"\n        # for pressure calculation we need a temperature, checking if we have one, and reading data if not\n        if self._tfine == 0:\n            self.read_temperature()\n        adc_P = self.read_raw_pressure()\n        var1 = self._tfine - 128000\n        var2 = var1 * var1 * self.cal_REGISTER_DIG_P6\n        var2 = var2 + ((var1 * self.cal_REGISTER_DIG_P5) << 17)\n        var2 = var2 + (self.cal_REGISTER_DIG_P4 << 35)\n        var1 = ((var1 * var1 * self.cal_REGISTER_DIG_P3) >> 8) + ((var1 * self.cal_REGISTER_DIG_P2) << 12)\n        var1 = ((1 << 47) + var1) * self.cal_REGISTER_DIG_P1 >> 33\n        if var1 == 0:\n            return 0\n        p = 1048576 - adc_P\n        p = int((((p << 31) - var2) * 3125) / var1)\n        var1 = (self.cal_REGISTER_DIG_P9 * (p >> 13) * (p >> 13)) >> 25\n        var2 = (self.cal_REGISTER_DIG_P8 * p) >> 19\n        p = ((p + var1 + var2) >> 8) + (self.cal_REGISTER_DIG_P7 << 4)\n        return p / 256.0\n", "docstring": "Gets the compensated pressure in Pascals.\n"}
{"repo": "Mycodo-master/mycodo/inputs/ds1822.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the DS1822's temperature in Celsius \"\"\"\n        if not self.sensor:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        temperature = None\n        n = 2\n        for i in range(n):\n            try:\n                temperature = self.sensor.get_temperature()\n                break\n            except Exception as e:\n                if i == n:\n                    self.logger.exception(\n                        \"{cls} raised an exception when taking a reading: {err}\".format(cls=type(self).__name__, err=e))\n                time.sleep(1)\n        if temperature == 85:\n            self.logger.error(\"Measurement returned 85 C, indicating an issue communicating with the sensor.\")\n            return None\n        elif temperature is not None and -55 > temperature > 125:\n            self.logger.error(\n                \"Measurement outside the expected range of -55 C to 125 C: {temp} C\".format(temp=temperature))\n            return None\n        self.value_set(0, temperature)\n        return self.return_dict\n", "docstring": "Gets the DS1822's temperature in Celsius \n"}
{"repo": "Mycodo-master/mycodo/inputs/sht31_smart_gadget.py", "original_string": "    def __init__(self, input_dev, testing=False):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        self.gadget = None\n        self.connected = False\n        self.connect_error = None\n        self.device_information = {}\n        self.initialized = False\n        self.last_downloaded_timestamp = None\n        self.download_stored_data = None\n        self.logging_interval_ms = None\n        self.logging_interval = None\n        if not testing:\n            self.setup_custom_options(\n                INPUT_INFORMATION['custom_options'], input_dev)\n            self.initialize_input()\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/sht31_smart_gadget.py", "original_string": "    def initialize(self):\n        \"\"\"Initialize the device by obtaining sensor information\"\"\"\n        self.logger.debug(\"Input Initializing (Initialized: {})\".format(self.initialized))\n        if not self.initialized:\n            for _ in range(3):\n                if not self.running:\n                    break\n                try:\n                    self.gadget = self.SHT31(\n                        addr=self.location,\n                        iface=self.bt_adapter,\n                        debug=self.log_level_debug)\n                    self.connected = True\n                    break\n                except self.btle.BTLEException as e:\n                    self.connect_error = e\n                time.sleep(0.1)\n            if self.connect_error:\n                self.logger.error(\"Initialize Error: {}\".format(self.connect_error))\n        if self.connected:\n            # Fill device information dictionary\n            self.device_information['manufacturer'] = self.gadget.readManufacturerNameString()\n            self.device_information['model'] = self.gadget.readModelNumberString()\n            self.device_information['serial_number'] = self.gadget.readSerialNumberString()\n            self.device_information['device_name'] = self.gadget.readDeviceName()\n            self.device_information['firmware_revision'] = self.gadget.readFirmwareRevisionString()\n            self.device_information['hardware_revision'] = self.gadget.readHardwareRevisionString()\n            self.device_information['software_revision'] = self.gadget.readSoftwareRevisionString()\n            self.device_information['logger_interval_ms'] = self.gadget.readLoggerIntervalMs()\n            self.device_information['info_timestamp'] = int(time.time() * 1000)\n            self.logger.info(\n                \"{man}, {mod}, SN: {sn}, Name: {name}, Firmware: {fw}, \"\n                \"Hardware: {hw}, Software: {sw}, Log Interval: {sec} sec\".format(\n                    man=self.device_information['manufacturer'],\n                    mod=self.device_information['model'],\n                    sn=self.device_information['serial_number'],\n                    name=self.device_information['device_name'],\n                    fw=self.device_information['firmware_revision'],\n                    hw=self.device_information['hardware_revision'],\n                    sw=self.device_information['software_revision'],\n                    sec=self.device_information['logger_interval_ms'] / 1000))\n            self.initialized = True\n", "docstring": "Initialize the device by obtaining sensor information\n"}
{"repo": "Mycodo-master/mycodo/inputs/mh_z19b.py", "original_string": "    def __init__(self, input_dev, testing=False):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        self.ser = None\n        self.measuring = None\n        self.calibrating = None\n        self.measure_range = None\n        self.abc_enable = False\n        if not testing:\n            self.setup_custom_options(\n                INPUT_INFORMATION['custom_options'], input_dev)\n            self.initialize_input()\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/mh_z19b.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the MH-Z19's CO2 concentration in ppmv \"\"\"\n        if not self.ser:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        while self.calibrating:\n            time.sleep(0.1)\n        self.measuring = True\n        try:\n            self.ser.flushInput()\n            self.ser.write(bytearray([0xff, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79]))\n            time.sleep(.01)\n            resp = self.ser.read(9)\n            if not resp:\n                self.logger.debug(\"No response\")\n            elif len(resp) < 4:\n                self.logger.debug(\"Too few values in response '{}'\".format(resp))\n            elif resp[0] != 0xff or resp[1] != 0x86:\n                self.logger.error(\"Bad checksum\")\n            elif len(resp) >= 4:\n                high = resp[2]\n                low = resp[3]\n                co2 = (high * 256) + low\n                self.value_set(0, co2)\n        except:\n            self.logger.exception(\"get_measurement()\")\n        finally:\n            self.measuring = False\n        return self.return_dict\n", "docstring": "Gets the MH-Z19's CO2 concentration in ppmv \n"}
{"repo": "Mycodo-master/mycodo/inputs/ina219x.py", "original_string": "    def __init__(self, input_dev, testing=False,):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        self.sensor = None\n        self.calibration = None\n        self.bus_voltage_range = None\n        self.bus_adc_resolution = None\n        self.shunt_adc_resolution = None\n        self.measurements_for_average = None\n        if not testing:\n            self.setup_custom_options(\n                INPUT_INFORMATION['custom_options'], input_dev)\n            self.initialize_input()\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/xiaomi_mijia_lywsd03mmc.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the battery. humidity, and temperature \"\"\"\n        if not self.sensor:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        if self.lock_acquire(self.lock_file, timeout=3600):\n            try:\n                self.sensor.run()\n                global measurement_values\n                self.logger.debug(\"Measurements: {}\".format(measurement_values))\n                if measurement_values:\n                    if self.is_enabled(0):\n                        self.value_set(0, measurement_values[\"hum\"])\n                    if self.is_enabled(1):\n                        self.value_set(1, measurement_values[\"temp\"])\n                    if self.is_enabled(2):\n                        self.value_set(2, measurement_values[\"bat_percent\"])\n                    if self.is_enabled(3):\n                        self.value_set(3, measurement_values[\"bat_volt\"])\n                return self.return_dict\n            except:\n                self.logger.exception(\"Acquiring measurements\")\n            finally:\n                self.lock_release(self.lock_file)\n", "docstring": "Gets the battery. humidity, and temperature \n"}
{"repo": "Mycodo-master/mycodo/inputs/xiaomi_mijia_lywsd03mmc.py", "original_string": "    def connect(self):\n        p = self.btle.Peripheral(self.device, iface=self.interface)\n        val = b'\\x01\\x00'\n        p.writeCharacteristic(0x0038, val, True)  # enable notifications of Temperature, Humidity and Battery voltage\n        p.writeCharacteristic(0x0046, b'\\xf4\\x01\\x00', True)\n        p.withDelegate(self.MyDelegate(self.btle))\n        return p\n", "docstring": "p = self.btle.Peripheral(self.device, iface=self.interface)"}
{"repo": "Mycodo-master/mycodo/inputs/atlas_humidity.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the Atlas Scientific humidity sensor measurement \"\"\"\n        if not self.atlas_device.setup:\n            self.logger.error(\"Input not set up\")\n            return\n        return_string = None\n        self.return_dict = copy.deepcopy(measurements_dict)\n        if self.led == 'measure':\n            self.atlas_device.query('L,1')\n        # Read sensor via FTDI or UART\n        if self.interface in ['FTDI', 'UART']:\n            hum_status, hum_list = self.atlas_device.query('R')\n            if hum_list:\n                self.logger.debug(\"Returned list: {lines}\".format(\n                    lines=hum_list))\n            if 'check probe' in hum_list:\n                self.logger.error('\"check probe\" returned from sensor')\n                return\n            # Find value(s) in list\n            for each_split in hum_list:\n                if \",\" in each_split or str_is_float(each_split):\n                    return_string = each_split\n                    break\n        elif self.interface == 'I2C':\n            hum_status, return_string = self.atlas_device.query('R')\n            if hum_status == 'error':\n                # try again\n                time.sleep(1)\n                hum_status, return_string = self.atlas_device.query('R')\n                if hum_status == 'error':\n                    self.logger.error(\"Sensor read unsuccessful (after 2 attempts): {err}\".format(\n                        err=return_string))\n            if hum_status == 'success':\n                self.logger.debug(\"Sensor returned: type: {}, value: {}\".format(\n                    type(return_string), return_string))\n        if self.led == 'measure':\n            self.atlas_device.query('L,0')\n        self.logger.debug(\"Sensor returned: Type: {}, Value: {}\".format(\n            type(return_string), return_string))\n        # Parse return string\n        if ',' in return_string:\n            index_place = 0\n            return_list = return_string.split(',')\n            if self.is_enabled(1):\n                self.value_set(1, return_list[index_place])\n                index_place += 1\n            if self.is_enabled(0):\n                self.value_set(0, return_list[index_place])\n                index_place += 1\n            if self.is_enabled(2):\n                self.value_set(2, return_list[index_place + 1])\n        elif self.is_enabled(0) and not self.is_enabled(1) and not self.is_enabled(2):\n            self.value_set(0, return_string)\n        elif not self.is_enabled(0) and self.is_enabled(1) and not self.is_enabled(2):\n            self.value_set(1, return_string)\n        return self.return_dict\n", "docstring": "Gets the Atlas Scientific humidity sensor measurement \n"}
{"repo": "Mycodo-master/mycodo/inputs/hall_flow.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the flow rate and volume \"\"\"\n        if not self.pi.connected:  # Check if pigpiod is running\n            self.logger.error(\"Could not connect to pigpiod. Ensure it is running and try again.\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        l_min, pulses = self.sensor.flow_period()\n        total_pulses = self.sensor.total_pulses()\n        total_volume = self.sensor.total_volume()\n        self.logger.debug(\n            \"fLow: {} l/min, pulses: {}, total pulses: {}, total volume: {}\".format(\n                l_min, pulses, total_pulses, total_volume))\n        self.value_set(0, l_min)\n        self.value_set(1, total_volume)\n        return self.return_dict\n", "docstring": "Gets the flow rate and volume \n"}
{"repo": "Mycodo-master/mycodo/inputs/hall_flow.py", "original_string": "    def flow_period(self):\n        \"\"\"Returns the Flow Rate in l/min\"\"\"\n        l_min = 0\n        pulses = self.period_pulses()\n        minutes = (time.time() - self._last_time) / 60\n        if pulses:\n            liters = pulses / self.pulses_per_l\n            l_min = float(liters / minutes)\n        self._last_time = time.time()\n        return l_min, pulses\n", "docstring": "Returns the Flow Rate in l/min\n"}
{"repo": "Mycodo-master/mycodo/inputs/hall_flow.py", "original_string": "    def total_pulses(self):\n        \"\"\"Returns the total pulses\"\"\"\n        return self._total_pulses\n", "docstring": "Returns the total pulses\n"}
{"repo": "Mycodo-master/mycodo/inputs/hall_flow.py", "original_string": "    def cancel(self):\n        \"\"\"Cancels the reader and releases resources\"\"\"\n        self.pi.set_watchdog(self.gpio, 0)  # cancel watchdog\n        self._cb.cancel()\n", "docstring": "Cancels the reader and releases resources\n"}
{"repo": "Mycodo-master/mycodo/inputs/atlas_flow.py", "original_string": "    def __init__(self, input_dev, testing=False):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        self.atlas_device = None\n        self.interface = None\n        self.sensor_is_measuring = False\n        self.sensor_is_clearing = False\n        self.flow_meter_type = None\n        self.flow_rate_unit = None\n        self.internal_resistor = None\n        self.custom_k_values = None\n        self.custom_k_value_time_base = None\n        if not testing:\n            self.setup_custom_options(\n                INPUT_INFORMATION['custom_options'], input_dev)\n            self.initialize_input()\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/mh_z19.py", "original_string": "    def __init__(self, input_dev, testing=False):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        self.ser = None\n        self.measuring = None\n        self.calibrating = None\n        self.measure_range = None\n        if not testing:\n            self.setup_custom_options(\n                INPUT_INFORMATION['custom_options'], input_dev)\n            self.initialize_input()\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/mh_z19.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the MH-Z19's CO2 concentration in ppmv \"\"\"\n        if not self.ser:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        while self.calibrating:\n            time.sleep(0.1)\n        self.measuring = True\n        try:\n            self.ser.flushInput()\n            self.ser.write(bytearray([0xff, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79]))\n            time.sleep(.01)\n            resp = self.ser.read(9)\n            if not resp:\n                self.logger.debug(\"No response\")\n            elif len(resp) < 4:\n                self.logger.debug(\"Too few values in response '{}'\".format(resp))\n            elif resp[0] != 0xff or resp[1] != 0x86:\n                self.logger.error(\"Bad checksum\")\n            elif len(resp) >= 4:\n                high = resp[2]\n                low = resp[3]\n                co2 = (high * 256) + low\n                self.value_set(0, co2)\n        except:\n            self.logger.exception(\"get_measurement()\")\n        finally:\n            self.measuring = False\n        return self.return_dict\n", "docstring": "Gets the MH-Z19's CO2 concentration in ppmv \n"}
{"repo": "Mycodo-master/mycodo/inputs/max31865.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the measurement in units by reading the \"\"\"\n        if not self.sensor:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        self.value_set(0, self.sensor.readTemp(self.thermocouple_type, self.ref_ohm))\n        return self.return_dict\n", "docstring": "Gets the measurement in units by reading the \n"}
{"repo": "Mycodo-master/mycodo/inputs/max31865.py", "original_string": "    def calcPTTemp(RTD_ADC_Code, device='PT100', resistor_ref=None):\n        # Reference Resistor\n        if resistor_ref:\n            R_REF = resistor_ref\n        elif device == 'PT100':\n            R_REF = 400.0\n        elif device == 'PT1000':\n            R_REF = 4000.0\n        else:\n            return\n        Res0 = 100.0  # Resistance at 0 degC for 400ohm R_Ref\n        a = .00390830\n        b = -.000000577500\n        # c = -0.00000000000418301  # for -200 <= T <= 0 (degC)\n        # c = 0  # for 0 <= T <= 850 (degC)\n        # print(\"RTD ADC Code: {}\".format(RTD_ADC_Code))\n        Res_RTD = (RTD_ADC_Code * R_REF) / 32768.0  # Probe Resistance\n        # print(\"{dev} Resistance: {res} ohms\".format(dev=device, res=Res_RTD))\n        # Callendar-Van Dusen equation\n        # Res_RTD = Res0 * (1 + a*T + b*T**2 + c*(T-100)*T**3)  # T <= -200\n        # Res_RTD = Res0 + a*Res0*T + b*Res0*T**2  # T >= 0\n        # (c*Res0)T**4 - (c*Res0)*100*T**3\n        # + (b*Res0)*T**2 + (a*Res0)*T + (Res0 - Res_RTD) = 0\n        # quadratic formula:\n        # for 0 <= T <= 850 (degC)\n        temp_C = -(a * Res0) + math.sqrt(a * a * Res0 * Res0 - 4 * (b * Res0) * (Res0 - Res_RTD))\n        temp_C = temp_C / (2 * (b * Res0))\n        # print(\"Callendar-Van Dusen Temp (degC > 0): {} degC\".format(temp_C))\n        # removing numpy.roots will greatly speed things up\n        # temp_C_numpy = numpy.roots([c*Res0, -c*Res0*100, b*Res0, a*Res0, (Res0 - Res_RTD)])\n        # temp_C_numpy = abs(temp_C_numpy[-1])\n        # print(\"Solving Full Callendar-Van Dusen using numpy: {}\".format(temp_C_numpy))\n        if temp_C < 0:  # use straight line approximation if less than 0\n            # Can also use python lib numpy to solve cubic\n            # Should never get here in this application\n            temp_C_line = (RTD_ADC_Code / 32.0) - 256.0\n            # print(\"Straight Line Approx. Temp: {} degC\".format(temp_C_line))\n            return temp_C_line\n        return temp_C\n", "docstring": "Reference Resistor"}
{"repo": "Mycodo-master/mycodo/inputs/bh1750.py", "original_string": "    def lux(self):\n        \"\"\" BH1750 luminosity in lux \"\"\"\n        if self._measurements is None:  # update if needed\n            self.read()\n        return self._measurements\n", "docstring": "BH1750 luminosity in lux \n"}
{"repo": "Mycodo-master/mycodo/inputs/bh1750.py", "original_string": "    def wait_for_result(self, additional=0):\n        basetime = 0.018 if (self.mode & 0x03) == 0x03 else 0.128\n        time.sleep(basetime * (self.mtreg / 69.0) + additional)\n", "docstring": "basetime = 0.018 if (self.mode & 0x03) == 0x03 else 0.128"}
{"repo": "Mycodo-master/mycodo/inputs/mh_z16.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the MH-Z16's CO2 concentration in ppmv \"\"\"\n        self.return_dict = copy.deepcopy(measurements_dict)\n        co2 = None\n        if self.input_dev.interface == 'UART':\n            if not self.ser:\n                self.logger.error(\"Input not set up\")\n                return\n            self.ser.flushInput()\n            time.sleep(1)\n            self.ser.write(bytearray([0xff, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79]))\n            time.sleep(.01)\n            resp = self.ser.read(9)\n            if len(resp) != 0:\n                high = resp[2]\n                low = resp[3]\n                co2 = (high * 256) + low\n        elif self.input_dev.interface == 'I2C':\n            if not self.i2c:\n                self.logger.error(\"Input not set up\")\n                return\n            self.write_register(self.FCR, 0x07)\n            self.send(self.cmd_measure)\n            try:\n                co2 = self.parse(self.receive())\n            except Exception:\n                co2 = None\n        self.value_set(0, co2)\n        return self.return_dict\n", "docstring": "Gets the MH-Z16's CO2 concentration in ppmv \n"}
{"repo": "Mycodo-master/mycodo/inputs/dht11.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the humidity and temperature \"\"\"\n        if not self.pi.connected:  # Check if pigpiod is running\n            self.logger.error(\"Could not connect to pigpiod. Ensure it is running and try again.\")\n            return None\n        self.return_dict = copy.deepcopy(measurements_dict)\n        import pigpio\n        self.pigpio = pigpio\n        # Try twice to get measurement. This prevents an anomaly where\n        # the first measurement fails if the sensor has just been powered\n        # for the first time.\n        for _ in range(2):\n            self.measure_sensor()\n            if self.temp_dew_point is not None:\n                self.value_set(0, self.temp_temperature)\n                self.value_set(1, self.temp_humidity)\n                self.value_set(2, self.temp_dew_point)\n                self.value_set(3, self.temp_vpd)\n                return self.return_dict  # success - no errors\n            time.sleep(2)\n        self.logger.error(\"Could not acquire a measurement\")\n        return None\n", "docstring": "Gets the humidity and temperature \n"}
{"repo": "Mycodo-master/mycodo/inputs/dht11.py", "original_string": "    def _edge_fall(self, tick, diff):\n        \"\"\" Handle Fall signal \"\"\"\n        self.high_tick = tick\n        if diff <= 250000:\n            return\n        self.bit = -2\n        self.checksum = 0\n        self.temp_temperature = 0\n        self.temp_humidity = 0\n", "docstring": "Handle Fall signal \n"}
{"repo": "Mycodo-master/mycodo/inputs/atlas_rgb.py", "original_string": "    def __init__(self, input_dev, testing=False):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        self.atlas_device = None\n        self.interface = None\n        self.enabled_rgb = False\n        self.led_only_while_reading = None\n        self.led_percentage = None\n        self.gamma_correction = None\n        if not testing:\n            self.setup_custom_options(\n                INPUT_INFORMATION['custom_options'], input_dev)\n            self.initialize_input()\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/rpi_signal_pwm.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the pwm \"\"\"\n        pi = self.pigpio.pi()\n        if not pi.connected:  # Check if pigpiod is running\n            self.logger.error(\"Could not connect to pigpiod. Ensure it is running and try again.\")\n            return None\n        self.return_dict = copy.deepcopy(measurements_dict)\n        read_pwm = ReadPWM(pi, self.gpio, self.pigpio, self.weighting)\n        time.sleep(self.sample_time)\n        if self.is_enabled(0):\n            self.value_set(0, read_pwm.frequency())\n        if self.is_enabled(1):\n            self.value_set(1, read_pwm.pulse_width())\n        if self.is_enabled(2):\n            self.value_set(2, read_pwm.duty_cycle())\n        read_pwm.cancel()\n        pi.stop()\n        return self.return_dict\n", "docstring": "Gets the pwm \n"}
{"repo": "Mycodo-master/mycodo/inputs/ads1x15.py", "original_string": "    def __init__(self, input_dev, testing=False,):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        self.adc = None\n        self.adc_gain = None\n        self.dict_gains = {\n            2/3: 0.1875,\n            1: 0.125,\n            2: 0.0625,\n            4: 0.03125,\n            8: 0.015625,\n            16: 0.0078125,\n        }\n        self.measurements_for_average = None\n        if not testing:\n            self.setup_custom_options(\n                INPUT_INFORMATION['custom_options'], input_dev)\n            self.initialize_input()\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/ads1115_circuitpython.py", "original_string": "    def __init__(self, input_dev, testing=False,):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        self.adc = None\n        self.adc_gain = None\n        self.dict_gains = {\n            2/3: 0.1875,\n            1: 0.125,\n            2: 0.0625,\n            4: 0.03125,\n            8: 0.015625,\n            16: 0.0078125,\n        }\n        self.measurements_for_average = None\n        if not testing:\n            self.setup_custom_options(\n                INPUT_INFORMATION['custom_options'], input_dev)\n            self.initialize_input()\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/ads1015_circuitpython.py", "original_string": "    def __init__(self, input_dev, testing=False,):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        self.adc = None\n        self.adc_gain = None\n        self.dict_gains = {\n            2/3: 0.1875,\n            1: 0.125,\n            2: 0.0625,\n            4: 0.03125,\n            8: 0.015625,\n            16: 0.0078125,\n        }\n        self.measurements_for_average = None\n        if not testing:\n            self.setup_custom_options(\n                INPUT_INFORMATION['custom_options'], input_dev)\n            self.initialize_input()\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/anyleaf_ph.py", "original_string": "    def calibrate(self, cal_slot, args_dict):\n        \"\"\"Calibration helper method\"\"\"\n        from anyleaf import CalSlot\n        if 'calibration_ph' not in args_dict:\n            self.logger.error(\"Cannot conduct calibration without a buffer pH value\")\n            return\n        if not isinstance(args_dict['calibration_ph'], float) and not isinstance(args_dict['calibration_ph'], int):\n            self.logger.error(\"buffer value does not represent a number: '{}', type: {}\".format(\n                args_dict['calibration_ph'], type(args_dict['calibration_ph'])))\n            return\n        temp_data = self.get_temp_data()\n        # For this session\n        v, t = self.sensor.calibrate(cal_slot, args_dict['calibration_ph'], temp_data)\n        # For future sessions\n        if cal_slot == CalSlot.ONE:\n            self.set_custom_option(\"cal1_v\", v)\n            self.set_custom_option(\"cal1_ph\", args_dict['calibration_ph'])\n            self.set_custom_option(\"cal1_t\", t)\n        elif cal_slot == CalSlot.TWO:\n            self.set_custom_option(\"cal2_v\", v)\n            self.set_custom_option(\"cal2_ph\", args_dict['calibration_ph'])\n            self.set_custom_option(\"cal2_t\", t)\n        else:\n            self.set_custom_option(\"cal3_v\", v)\n            self.set_custom_option(\"cal3_ph\", args_dict['calibration_ph'])\n            self.set_custom_option(\"cal3_t\", t)\n", "docstring": "Calibration helper method\n"}
{"repo": "Mycodo-master/mycodo/inputs/anyleaf_ph.py", "original_string": "    def calibrate_slot_2(self, args_dict):\n        \"\"\" Auto-calibrate \"\"\"\n        from anyleaf import CalSlot\n        self.calibrate(CalSlot.TWO, args_dict)\n", "docstring": "Auto-calibrate \n"}
{"repo": "Mycodo-master/mycodo/inputs/base_input.py", "original_string": "    def __repr__(self):\n        \"\"\"  Representation of object \"\"\"\n        return_str = '<{cls}'.format(cls=type(self).__name__)\n        if self._measurements:\n            for each_channel, channel_data in self._measurements.items():\n                return_str += '({ts},{chan},{meas},{unit},{val})'.format(\n                    ts=channel_data['time'],\n                    chan=each_channel,\n                    meas=channel_data['measurement'],\n                    unit=channel_data['unit'],\n                    val=channel_data['value'])\n            return_str += '>'\n            return return_str\n        else:\n            return \"Measurements dictionary empty\"\n", "docstring": "Representation of object \n"}
{"repo": "Mycodo-master/mycodo/inputs/base_input.py", "original_string": "    def measurements(self):\n        \"\"\" Store measurements \"\"\"\n        if self._measurements is None:  # update if needed\n            self.read()\n        return self._measurements\n", "docstring": "Store measurements \n"}
{"repo": "Mycodo-master/mycodo/inputs/base_input.py", "original_string": "    def start_input(self):\n        \"\"\" Not used yet \"\"\"\n        self.running = True\n", "docstring": "Not used yet \n"}
{"repo": "Mycodo-master/mycodo/inputs/base_input.py", "original_string": "    def set_custom_option(self, option, value):\n        return self._set_custom_option(Input, self.unique_id, option, value)\n", "docstring": "return self._set_custom_option(Input, self.unique_id, option, value)"}
{"repo": "Mycodo-master/mycodo/inputs/rpi_gpio_state.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the GPIO state via RPi.GPIO \"\"\"\n        self.return_dict = copy.deepcopy(measurements_dict)\n        self.value_set(0, self.gpio.input(self.location))\n        return self.return_dict\n", "docstring": "Gets the GPIO state via RPi.GPIO \n"}
{"repo": "Mycodo-master/mycodo/inputs/ds1825.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the DS1825's temperature in Celsius \"\"\"\n        if not self.sensor:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        temperature = None\n        n = 2\n        for i in range(n):\n            try:\n                temperature = self.sensor.get_temperature()\n                break\n            except Exception as e:\n                if i == n:\n                    self.logger.exception(\n                        \"{cls} raised an exception when taking a reading: {err}\".format(cls=type(self).__name__, err=e))\n                time.sleep(1)\n        if temperature == 85:\n            self.logger.error(\"Measurement returned 85 C, indicating an issue communicating with the sensor.\")\n            return None\n        elif temperature is not None and -55 > temperature > 125:\n            self.logger.error(\n                \"Measurement outside the expected range of -55 C to 125 C: {temp} C\".format(temp=temperature))\n            return None\n        self.value_set(0, temperature)\n        return self.return_dict\n", "docstring": "Gets the DS1825's temperature in Celsius \n"}
{"repo": "Mycodo-master/mycodo/inputs/ds28ea00.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the DS28EA00's temperature in Celsius \"\"\"\n        if not self.sensor:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        n = 2\n        for i in range(n):\n            try:\n                self.value_set(0, self.sensor.get_temperature())\n                return self.return_dict\n            except Exception as e:\n                if i == n:\n                    self.logger.exception(\n                        \"{cls} raised an exception when taking a reading: {err}\".format(cls=type(self).__name__, err=e))\n                time.sleep(1)\n", "docstring": "Gets the DS28EA00's temperature in Celsius \n"}
{"repo": "Mycodo-master/mycodo/inputs/as7262.py", "original_string": "    def get_measurement(self):\n        \"\"\" Get measurements and store in the database \"\"\"\n        if not self.sensor:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        self.sensor.set_measurement_mode(2)\n        self.sensor.set_indicator_led(int(self.indicator_led_mode))\n        self.sensor.set_illumination_led(int(self.illumination_led_mode))\n        values = self.sensor.get_calibrated_values()\n        self.sensor.set_measurement_mode(3)\n        self.sensor.set_indicator_led(0)\n        self.sensor.set_illumination_led(0)\n        self.logger.debug(\n            \"450 nm (Red): {}, \"\n            \"500 nm (Orange): {}, \"\n            \"550 nm (Yellow): {}, \"\n            \"570 nm (Green): {}, \"\n            \"600 nm (Blue): {}, \"\n            \"650 nm (Violet): {}\".format(*values))\n        for index, color_value in enumerate(values):\n            self.value_set(index, color_value)\n        return self.return_dict\n", "docstring": "Get measurements and store in the database \n"}
{"repo": "Mycodo-master/mycodo/inputs/mqtt_paho_json.py", "original_string": "    def connect(self):\n        \"\"\" Set up the connection to the MQTT Server \"\"\"\n        try:\n            self.client.connect(\n                self.mqtt_hostname,\n                port=self.mqtt_port,\n                keepalive=self.mqtt_keepalive)\n            self.logger.info(\"Connected to {} as {}\".format(\n                self.mqtt_hostname, self.mqtt_clientid))\n        except:\n            self.logger.error(\"Could not connect to mqtt host: {}:{}\".format(\n                self.mqtt_hostname, self.mqtt_port))\n", "docstring": "Set up the connection to the MQTT Server \n"}
{"repo": "Mycodo-master/mycodo/inputs/mqtt_paho_json.py", "original_string": "    def add_measurement_influxdb(self, channel, measurement):\n        # Convert value/unit is conversion_id present and valid\n        if self.channels_conversion[channel]:\n            conversion = db_retrieve_table_daemon(\n                Conversion,\n                unique_id=self.channels_measurement[channel].conversion_id)\n            if conversion:\n                meas = parse_measurement(\n                    self.channels_conversion[channel],\n                    self.channels_measurement[channel],\n                    measurement,\n                    channel,\n                    measurement[channel],\n                    timestamp=measurement[channel]['timestamp_utc'])\n                measurement[channel]['measurement'] = meas[channel]['measurement']\n                measurement[channel]['unit'] = meas[channel]['unit']\n                measurement[channel]['value'] = meas[channel]['value']\n        if measurement:\n            self.logger.debug(\n                \"Adding measurement to influxdb: {}\".format(measurement))\n            add_measurements_influxdb(\n                self.unique_id,\n                measurement,\n                use_same_timestamp=INPUT_INFORMATION['measurements_use_same_timestamp'])\n", "docstring": "Convert value/unit is conversion_id present and valid"}
{"repo": "Mycodo-master/mycodo/inputs/mqtt_paho.py", "original_string": "    def connect(self):\n        \"\"\" Set up the connection to the MQTT Server \"\"\"\n        try:\n            self.client.connect(\n                self.mqtt_hostname,\n                port=self.mqtt_port,\n                keepalive=self.mqtt_keepalive)\n            self.logger.info(\"Connected to {} as {}\".format(\n                self.mqtt_hostname, self.mqtt_clientid))\n        except:\n            self.logger.error(\"Could not connect to mqtt host: {}:{}\".format(\n                self.mqtt_hostname, self.mqtt_port))\n", "docstring": "Set up the connection to the MQTT Server \n"}
{"repo": "Mycodo-master/mycodo/inputs/mqtt_paho.py", "original_string": "    def add_measurement_influxdb(self, channel, measurement):\n        # Convert value/unit is conversion_id present and valid\n        if self.channels_conversion[channel]:\n            conversion = db_retrieve_table_daemon(\n                Conversion,\n                unique_id=self.channels_measurement[channel].conversion_id)\n            if conversion:\n                meas = parse_measurement(\n                    self.channels_conversion[channel],\n                    self.channels_measurement[channel],\n                    measurement,\n                    channel,\n                    measurement[channel],\n                    timestamp=measurement[channel]['timestamp_utc'])\n                measurement[channel]['measurement'] = meas[channel]['measurement']\n                measurement[channel]['unit'] = meas[channel]['unit']\n                measurement[channel]['value'] = meas[channel]['value']\n        if measurement:\n            self.logger.debug(\n                \"Adding measurement to influxdb: {}\".format(measurement))\n            add_measurements_influxdb(\n                self.unique_id,\n                measurement,\n                use_same_timestamp=INPUT_INFORMATION['measurements_use_same_timestamp'])\n", "docstring": "Convert value/unit is conversion_id present and valid"}
{"repo": "Mycodo-master/mycodo/inputs/max31856.py", "original_string": "    def get_measurement(self):\n        \"\"\" Get measurements and store in the database \"\"\"\n        if not self.sensor:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        if self.is_enabled(0):\n            self.value_set(0, self.sensor.readThermocoupleTemp())\n        if self.is_enabled(1):\n            self.value_set(1, self.sensor.readJunctionTemp())\n        return self.return_dict\n", "docstring": "Get measurements and store in the database \n"}
{"repo": "Mycodo-master/mycodo/inputs/atlas_co2.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the sensor's measurement \"\"\"\n        if not self.atlas_device.setup:\n            self.logger.error(\"Input not set up\")\n            return\n        co2 = None\n        self.return_dict = copy.deepcopy(measurements_dict)\n        # Read sensor via FTDI or UART\n        if self.interface in ['FTDI', 'UART']:\n            co2_status, co2_list = self.atlas_device.query('R')\n            self.logger.debug(\"Returned: {}\".format(co2_list))\n            # Find float value in list\n            float_value = None\n            for each_split in co2_list:\n                if str_is_float(each_split):\n                    float_value = each_split\n                    break\n            if 'check probe' in co2_list:\n                self.logger.error('\"check probe\" returned from sensor')\n            elif str_is_float(float_value):\n                co2 = float(float_value)\n                self.logger.debug('Found float value: {val}'.format(val=co2))\n            else:\n                self.logger.error('Value or \"check probe\" not found in list: {val}'.format(val=co2_list))\n        # Read sensor via I2C\n        elif self.interface == 'I2C':\n            co2_status, co2_str = self.atlas_device.query('R')\n            self.logger.debug(\"Returned: {}\".format(co2_str))\n            if co2_status == 'error':\n                self.logger.error(\"Sensor read unsuccessful: {err}\".format(err=co2_str))\n            elif co2_status == 'success':\n                if str_is_float(co2_str):\n                    co2 = float(co2_str)\n                else:\n                    self.logger.error(\"Could not determine co2 from returned string: '{}'\".format(co2_str))\n        self.value_set(0, co2)\n        return self.return_dict\n", "docstring": "Gets the sensor's measurement \n"}
{"repo": "Mycodo-master/mycodo/inputs/dht22.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the humidity and temperature \"\"\"\n        if not self.pi.connected:  # Check if pigpiod is running\n            self.logger.error('Could not connect to pigpiod. Ensure it is running and try again.')\n            return None\n        self.return_dict = copy.deepcopy(measurements_dict)\n        # Try twice to get measurement. This prevents an anomaly where\n        # the first measurement fails if the sensor has just been powered\n        # for the first time.\n        for _ in range(4):\n            self.measure_sensor()\n            if self.temp_dew_point is not None:\n                self.value_set(0, self.temp_temperature)\n                self.value_set(1, self.temp_humidity)\n                self.value_set(2, self.temp_dew_point)\n                self.value_set(3, self.temp_vpd)\n                return self.return_dict  # success - no errors\n            time.sleep(2)\n        self.logger.debug(\"Could not acquire a measurement\")\n        return None\n", "docstring": "Gets the humidity and temperature \n"}
{"repo": "Mycodo-master/mycodo/inputs/dht22.py", "original_string": "    def _edge_fall(self, tick, diff):\n        \"\"\" Handle Fall signal \"\"\"\n        # Edge length determines if bit is 1 or 0.\n        self.high_tick = tick\n        if diff <= 250000:\n            return\n        self.bit = -2\n        self.hH = 0\n        self.hL = 0\n        self.tH = 0\n        self.tL = 0\n        self.CS = 0\n", "docstring": "Handle Fall signal \n"}
{"repo": "Mycodo-master/mycodo/inputs/dht22.py", "original_string": "    def staleness(self):\n        \"\"\" Return time since measurement made \"\"\"\n        if self.tov is not None:\n            return time.time() - self.tov\n        else:\n            return -999\n", "docstring": "Return time since measurement made \n"}
{"repo": "Mycodo-master/mycodo/inputs/dht22.py", "original_string": "    def short_message(self):\n        \"\"\" Return count of short messages \"\"\"\n        return self.bad_SM\n", "docstring": "Return count of short messages \n"}
{"repo": "Mycodo-master/mycodo/inputs/dht22.py", "original_string": "    def sensor_resets(self):\n        \"\"\" Return count of power cycles because of sensor hangs \"\"\"\n        return self.bad_SR\n", "docstring": "Return count of power cycles because of sensor hangs \n"}
{"repo": "Mycodo-master/mycodo/inputs/ads1256_analog_ph_ec.py", "original_string": "    def __init__(self, input_dev, testing=False):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        self.sensor = None\n        self.CH_SEQUENCE = None\n        self.adc_gain = None\n        self.adc_sample_speed = None\n        self.adc_calibration = None\n        self.dict_gains = {\n            1: 0.125,\n            2: 0.0625,\n            4: 0.03125,\n            8: 0.015625,\n            16: 0.0078125,\n            32: 0.00390625,\n            64: 0.00195312,\n        }\n        self.adc_channel_ph = None\n        self.adc_channel_ec = None\n        self.temperature_comp_meas_device_id = None\n        self.temperature_comp_meas_measurement_id = None\n        self.max_age = None\n        self.ph_cal_v1 = None\n        self.ph_cal_ph1 = None\n        self.ph_cal_t1 = None\n        self.ph_cal_v2 = None\n        self.ph_cal_ph2 = None\n        self.ph_cal_t2 = None\n        self.ec_cal_v1 = None\n        self.ec_cal_ec1 = None\n        self.ec_cal_t1 = None\n        self.ec_cal_v2 = None\n        self.ec_cal_ec2 = None\n        self.ec_cal_t2 = None\n        self.slope = None\n        self.intercept = None\n        if not testing:\n            self.setup_custom_options(\n                INPUT_INFORMATION['custom_options'], input_dev)\n            self.initialize_input()\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/ads1256_analog_ph_ec.py", "original_string": "    def calibrate_ph(self, cal_slot, args_dict):\n        \"\"\"Calibration helper method\"\"\"\n        if 'calibration_ph' not in args_dict:\n            self.logger.error(\"Cannot conduct calibration without a buffer pH value\")\n            return\n        if (not isinstance(args_dict['calibration_ph'], float) and\n                not isinstance(args_dict['calibration_ph'], int)):\n            self.logger.error(\"buffer value does not represent a number: '{}', type: {}\".format(\n                args_dict['calibration_ph'], type(args_dict['calibration_ph'])))\n            return\n        v = self.get_volt_data(self.get_voltages(), int(self.adc_channel_ph))  # pH\n        temp = self.get_temp_data()\n        if temp is not None:\n            # Use measured temperature\n            t = temp\n        else:\n            # Assume room temperature of 25C\n            t = 25\n        self.logger.debug(\"Assigning voltage {} and temperature {} to pH {}\".format(\n            v, t, args_dict['calibration_ph']))\n        if cal_slot == 1:\n            # set values currently being used\n            self.ph_cal_v1 = v\n            self.ph_cal_ph1 = args_dict['calibration_ph']\n            self.ph_cal_t1 = t\n            # save values for next startup\n            self.set_custom_option(\"ph_cal_v1\", v)\n            self.set_custom_option(\"ph_cal_ph1\", args_dict['calibration_ph'])\n            self.set_custom_option(\"ph_cal_t1\", t)\n        elif cal_slot == 2:\n            # set values currently being used\n            self.ph_cal_v2 = v\n            self.ph_cal_ph2 = args_dict['calibration_ph']\n            self.ph_cal_t2 = t\n            # save values for next startup\n            self.set_custom_option(\"ph_cal_v2\", v)\n            self.set_custom_option(\"ph_cal_ph2\", args_dict['calibration_ph'])\n            self.set_custom_option(\"ph_cal_t2\", t)\n", "docstring": "Calibration helper method\n"}
{"repo": "Mycodo-master/mycodo/inputs/ads1256_analog_ph_ec.py", "original_string": "    def calibrate_ph_slot_2(self, args_dict):\n        \"\"\" Auto-calibrate \"\"\"\n        self.calibrate_ph(2, args_dict)\n", "docstring": "Auto-calibrate \n"}
{"repo": "Mycodo-master/mycodo/inputs/ads1256_analog_ph_ec.py", "original_string": "    def calibrate_ec(self, cal_slot, args_dict):\n        \"\"\"Calibration helper method\"\"\"\n        if 'calibration_ec' not in args_dict:\n            self.logger.error(\"Cannot conduct calibration without a standard EC value\")\n            return\n        if (not isinstance(args_dict['calibration_ec'], float) and\n                not isinstance(args_dict['calibration_ec'], int)):\n            self.logger.error(\"standard value does not represent a number: '{}', type: {}\".format(\n                args_dict['calibration_ec'], type(args_dict['calibration_ec'])))\n            return\n        v = self.get_volt_data(self.get_voltages(), int(self.adc_channel_ec))  # EC\n        temp = self.get_temp_data()\n        if temp is not None:\n            # Use measured temperature\n            t = temp\n        else:\n            # Assume room temperature of 25C\n            t = 25\n        self.logger.debug(\"Assigning voltage {} and temperature {} to EC {}\".format(\n            v, t, args_dict['calibration_ec']))\n        # For future sessions\n        if cal_slot == 1:\n            # set values currently being used\n            self.ec_cal_v1 = v\n            self.ec_cal_ec1 = args_dict['calibration_ec']\n            self.ec_cal_t1 = t\n            # save values for next startup\n            self.set_custom_option(\"ec_cal_v1\", v)\n            self.set_custom_option(\"ec_cal_ec1\", args_dict['calibration_ec'])\n            self.set_custom_option(\"ec_cal_t1\", t)\n        elif cal_slot == 2:\n            self.ec_cal_v2 = v\n            self.ec_cal_ec2 = args_dict['calibration_ec']\n            self.ec_cal_t2 = t\n            self.set_custom_option(\"ec_cal_v2\", v)\n            self.set_custom_option(\"ec_cal_ec2\", args_dict['calibration_ec'])\n            self.set_custom_option(\"ec_cal_t2\", t)\n", "docstring": "Calibration helper method\n"}
{"repo": "Mycodo-master/mycodo/inputs/ads1256_analog_ph_ec.py", "original_string": "    def calibrate_ec_slot_2(self, args_dict):\n        \"\"\" Auto-calibrate \"\"\"\n        self.calibrate_ec(2, args_dict)\n", "docstring": "Auto-calibrate \n"}
{"repo": "Mycodo-master/mycodo/inputs/ads1256_analog_ph_ec.py", "original_string": "    def nernst_correction(volt, temp):\n        \"\"\"Apply temperature correction for pH. This provides the voltage as if it were measured at 25C.\n        Based on the Nernst equation: E = E0 - ln(10) * RT/nF * pH; this gives E = E0 - 0.198 * T * pH.\n        The correction is a simple ratio of absolute temperature.\"\"\"\n        volt_25C = volt * 298/(temp+273)\n        return volt_25C\n", "docstring": "Apply temperature correction for pH. This provides the voltage as if it were measured at 25C."}
{"repo": "Mycodo-master/mycodo/inputs/ads1256_analog_ph_ec.py", "original_string": "    def viscosity_correction(volt, temp):\n        \"\"\"Apply temperature correction for EC. This provides the voltage as if it were measured at 25C.\n        Based on the Nernst-Einstein and Stokes-Einstein relations, related to viscosity: EC/EC25 = vis25/vis.\n        The correction is a linear approximation to the full curve, valid for 10-30C.\"\"\"\n        volt_25C = volt / (1 + 0.020 * (temp - 25))\n        return volt_25C\n", "docstring": "Apply temperature correction for EC. This provides the voltage as if it were measured at 25C."}
{"repo": "Mycodo-master/mycodo/inputs/ads1256_analog_ph_ec.py", "original_string": "    def get_temp_data(self):\n        \"\"\"Get the temperature.\"\"\"\n        if self.temperature_comp_meas_measurement_id:\n            self.logger.debug(\"Temperature corrections will be applied\")\n            last_measurement = self.get_last_measurement(\n                self.temperature_comp_meas_device_id,\n                self.temperature_comp_meas_measurement_id,\n                max_age=self.max_age\n            )\n            if last_measurement:\n                self.logger.debug(\"Latest temperature: {temp}\".format(\n                    temp=last_measurement[1]))\n                temp_data = last_measurement[1]\n            else:\n                self.logger.error(\n                    \"Temperature measurement not found within the \"\n                    \"past {} seconds\".format(self.max_age))\n                temp_data = None\n        else:\n            self.logger.debug(\"No temperature corrections applied\")\n            temp_data = None\n        return temp_data\n", "docstring": "Get the temperature.\n"}
{"repo": "Mycodo-master/mycodo/inputs/ads1256_analog_ph_ec.py", "original_string": "    def convert_volt_to_ph(self, volt, temp):\n        \"\"\"Convert voltage to pH\"\"\"\n        # Calculate slope and intercept from calibration points.\n        self.slope = ((self.ph_cal_ph1 - self.ph_cal_ph2) /\n                      (self.nernst_correction(self.ph_cal_v1, self.ph_cal_t1) -\n                       self.nernst_correction(self.ph_cal_v2, self.ph_cal_t2)))\n        self.intercept = (self.ph_cal_ph1 -\n                          self.slope *\n                          self.nernst_correction(self.ph_cal_v1, self.ph_cal_t1))\n        if temp is not None:\n            # Perform temperature corrections\n            ph = self.slope * self.nernst_correction(volt, temp) + self.intercept\n        else:\n            # Don't perform temperature corrections\n            ph = self.slope * volt + self.intercept\n        return ph\n", "docstring": "Convert voltage to pH\n"}
{"repo": "Mycodo-master/mycodo/inputs/chirp.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the light, moisture, and temperature \"\"\"\n        self.return_dict = copy.deepcopy(measurements_dict)\n        if self.is_enabled(0):\n            self.value_set(0, self.filter_average('lux', measurement=self.light()))\n        if self.is_enabled(1):\n            self.value_set(1, self.moist())\n        if self.is_enabled(2):\n            self.value_set(2, self.temp() / 10.0)\n        return self.return_dict\n", "docstring": "Gets the light, moisture, and temperature \n"}
{"repo": "Mycodo-master/mycodo/inputs/chirp.py", "original_string": "    def reset(self):\n        # To reset the sensor, write 6 to the device I2C address\n        self.bus.write_byte(self.i2c_address, 6)\n", "docstring": "To reset the sensor, write 6 to the device I2C address"}
{"repo": "Mycodo-master/mycodo/inputs/chirp.py", "original_string": "    def moist(self):\n        # To read soil moisture, read 2 bytes from register 0\n        return self.get_reg(0)\n", "docstring": "To read soil moisture, read 2 bytes from register 0"}
{"repo": "Mycodo-master/mycodo/inputs/atlas_pt1000.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the Atlas PT1000's temperature in Celsius \"\"\"\n        if not self.atlas_device.setup:\n            self.logger.error(\"Input not set up\")\n            return\n        temp = None\n        self.return_dict = copy.deepcopy(measurements_dict)\n        # Read sensor via FTDI or UART\n        if self.interface in ['FTDI', 'UART']:\n            temp_status, temp_list = self.atlas_device.query('R')\n            if temp_list:\n                self.logger.debug(\"Returned list: {lines}\".format(lines=temp_list))\n            # Find float value in list\n            float_value = None\n            for each_split in temp_list:\n                if str_is_float(each_split):\n                    float_value = each_split\n                    break\n            if 'check probe' in temp_list:\n                self.logger.error('\"check probe\" returned from sensor')\n            elif str_is_float(float_value):\n                temp = float(float_value)\n                self.logger.debug('Found float value: {val}'.format(val=temp))\n            else:\n                self.logger.error('Value or \"check probe\" not found in list: {val}'.format(val=temp_list))\n        # Read sensor via I2C\n        elif self.interface == 'I2C':\n            temp_status, temp_str = self.atlas_device.query('R')\n            if temp_status == 'error':\n                self.logger.error(\"Sensor read unsuccessful: {err}\".format(err=temp_str))\n            elif temp_status == 'success':\n                temp = float(temp_str)\n        if temp == -1023:  # Erroneous measurement\n            return\n        self.value_set(0, temp)\n        return self.return_dict\n", "docstring": "Gets the Atlas PT1000's temperature in Celsius \n"}
{"repo": "Mycodo-master/mycodo/inputs/ds18s20.py", "original_string": "    def __init__(self, input_dev, testing=False):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        self.sensor = None\n        if not testing:\n            self.initialize_input()\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/ds18s20.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the DS18S20's temperature in Celsius \"\"\"\n        if not self.sensor:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        n = 2\n        for i in range(n):\n            try:\n                self.value_set(0, self.sensor.get_temperature())\n                break\n            except Exception as e:\n                if i == n:\n                    self.logger.exception(\n                        \"{cls} raised an exception when taking a reading: {err}\".format(cls=type(self).__name__, err=e))\n                time.sleep(1)\n        return self.return_dict\n", "docstring": "Gets the DS18S20's temperature in Celsius \n"}
{"repo": "Mycodo-master/mycodo/inputs/winsen_zh03b.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the WINSEN_ZH03B's Particulate concentration in μg/m^3 \"\"\"\n        if not self.ser:\n            self.logger.error(\"Input not set up\")\n            return\n        pm_1_0 = []\n        pm_2_5 = []\n        pm_10_0 = []\n        self.return_dict = copy.deepcopy(measurements_dict)\n        if self.fan_modulate and not self.fan_is_on:\n            # Allow the fan to run for a duration before querying sensor\n            self.dormant_mode('run')\n            start_time = time.time()\n            while self.running and time.time() - start_time < self.fan_seconds:\n                time.sleep(0.01)\n        # Acquire measurements\n        for i in range(self.number_measurements):\n            self.logger.debug(\"Acquiring measurement {}\".format(i + 1))\n            pm_1_0_tmp, pm_2_5_tmp, pm_10_0_tmp = self.qa_read_sample()\n            self.logger.debug(\"Measurements: PM1 {}, PM2.5 {}, PM10 {}\".format(pm_1_0_tmp, pm_2_5_tmp, pm_10_0_tmp))\n            if pm_1_0_tmp > 1000:\n                self.logger.debug(\"PM1 out of range (over 1000 ug/m^3): {}. Discarding.\".format(pm_1_0_tmp))\n            else:\n                pm_1_0.append(pm_1_0_tmp)\n            if pm_2_5_tmp > 1000:\n                self.logger.debug(\"PM2.5 out of range (over 1000 ug/m^3): {}. Discarding.\".format(pm_2_5_tmp))\n            else:\n                pm_2_5.append(pm_2_5_tmp)\n            if pm_10_0_tmp > 1000:\n                self.logger.debug(\"PM10 out of range (over 1000 ug/m^3): {}. Discarding.\".format(pm_10_0_tmp))\n            else:\n                pm_10_0.append(pm_10_0_tmp)\n            time.sleep(0.1)\n        # Store measurements\n        if len(pm_1_0) < 1 or len(pm_2_5) < 1 or len(pm_10_0) < 1:\n            self.logger.debug(\"Error: Each particle size must have at least 1 valid measurement to store.\")\n        else:\n            self.value_set(0, sum(pm_1_0) / len(pm_1_0))\n            self.value_set(1, sum(pm_2_5) / len(pm_2_5))\n            self.value_set(2, sum(pm_10_0) / len(pm_10_0))\n        # Turn the fan off\n        if self.fan_modulate:\n            self.dormant_mode('sleep')\n        return self.return_dict\n", "docstring": "Gets the WINSEN_ZH03B's Particulate concentration in μg/m^3 \n"}
{"repo": "Mycodo-master/mycodo/inputs/ads1115_analog_ph_ec.py", "original_string": "    def calibrate_ph(self, cal_slot, args_dict):\n        \"\"\"Calibration helper method\"\"\"\n        if 'calibration_ph' not in args_dict:\n            self.logger.error(\"Cannot conduct calibration without a buffer pH value\")\n            return\n        if (not isinstance(args_dict['calibration_ph'], float) and\n                not isinstance(args_dict['calibration_ph'], int)):\n            self.logger.error(\"buffer value does not represent a number: '{}', type: {}\".format(\n                args_dict['calibration_ph'], type(args_dict['calibration_ph'])))\n            return\n        v = self.get_volt_data(int(self.adc_channel_ph))  # pH\n        temp = self.get_temp_data()\n        if temp is not None:\n            # Use measured temperature\n            t = temp\n        else:\n            # Assume room temperature of 25C\n            t = 25\n        self.logger.debug(\"Assigning voltage {} and temperature {} to pH {}\".format(\n            v, t, args_dict['calibration_ph']))\n        if cal_slot == 1:\n            # set values currently being used\n            self.ph_cal_v1 = v\n            self.ph_cal_ph1 = args_dict['calibration_ph']\n            self.ph_cal_t1 = t\n            # save values for next startup\n            self.set_custom_option(\"ph_cal_v1\", v)\n            self.set_custom_option(\"ph_cal_ph1\", args_dict['calibration_ph'])\n            self.set_custom_option(\"ph_cal_t1\", t)\n        elif cal_slot == 2:\n            # set values currently being used\n            self.ph_cal_v2 = v\n            self.ph_cal_ph2 = args_dict['calibration_ph']\n            self.ph_cal_t2 = t\n            # save values for next startup\n            self.set_custom_option(\"ph_cal_v2\", v)\n            self.set_custom_option(\"ph_cal_ph2\", args_dict['calibration_ph'])\n            self.set_custom_option(\"ph_cal_t2\", t)\n", "docstring": "Calibration helper method\n"}
{"repo": "Mycodo-master/mycodo/inputs/ads1115_analog_ph_ec.py", "original_string": "    def calibrate_ph_slot_2(self, args_dict):\n        \"\"\" Auto-calibrate \"\"\"\n        self.calibrate_ph(2, args_dict)\n", "docstring": "Auto-calibrate \n"}
{"repo": "Mycodo-master/mycodo/inputs/ads1115_analog_ph_ec.py", "original_string": "    def calibrate_ec(self, cal_slot, args_dict):\n        \"\"\"Calibration helper method\"\"\"\n        if 'calibration_ec' not in args_dict:\n            self.logger.error(\"Cannot conduct calibration without a standard EC value\")\n            return\n        if (not isinstance(args_dict['calibration_ec'], float) and\n                not isinstance(args_dict['calibration_ec'], int)):\n            self.logger.error(\"standard value does not represent a number: '{}', type: {}\".format(\n                args_dict['calibration_ec'], type(args_dict['calibration_ec'])))\n            return\n        v = self.get_volt_data(int(self.adc_channel_ec))  # EC\n        temp = self.get_temp_data()\n        if temp is not None:\n            # Use measured temperature\n            t = temp\n        else:\n            # Assume room temperature of 25C\n            t = 25\n        self.logger.debug(\"Assigning voltage {} and temperature {} to EC {}\".format(\n            v, t, args_dict['calibration_ec']))\n        # For future sessions\n        if cal_slot == 1:\n            # set values currently being used\n            self.ec_cal_v1 = v\n            self.ec_cal_ec1 = args_dict['calibration_ec']\n            self.ec_cal_t1 = t\n            # save values for next startup\n            self.set_custom_option(\"ec_cal_v1\", v)\n            self.set_custom_option(\"ec_cal_ec1\", args_dict['calibration_ec'])\n            self.set_custom_option(\"ec_cal_t1\", t)\n        elif cal_slot == 2:\n            self.ec_cal_v2 = v\n            self.ec_cal_ec2 = args_dict['calibration_ec']\n            self.ec_cal_t2 = t\n            self.set_custom_option(\"ec_cal_v2\", v)\n            self.set_custom_option(\"ec_cal_ec2\", args_dict['calibration_ec'])\n            self.set_custom_option(\"ec_cal_t2\", t)\n", "docstring": "Calibration helper method\n"}
{"repo": "Mycodo-master/mycodo/inputs/ads1115_analog_ph_ec.py", "original_string": "    def calibrate_ec_slot_2(self, args_dict):\n        \"\"\" Auto-calibrate \"\"\"\n        self.calibrate_ec(2, args_dict)\n", "docstring": "Auto-calibrate \n"}
{"repo": "Mycodo-master/mycodo/inputs/ads1115_analog_ph_ec.py", "original_string": "    def nernst_correction(volt, temp):\n        \"\"\"Apply temperature correction for pH. This provides the voltage as if it were measured at 25C.\n        Based on the Nernst equation: E = E0 - ln(10) * RT/nF * pH; this gives E = E0 - 0.198 * T * pH.\n        The correction is a simple ratio of absolute temperature.\"\"\"\n        volt_25C = volt * 298/(temp+273)\n        return volt_25C\n", "docstring": "Apply temperature correction for pH. This provides the voltage as if it were measured at 25C."}
{"repo": "Mycodo-master/mycodo/inputs/ads1115_analog_ph_ec.py", "original_string": "    def viscosity_correction(volt, temp):\n        \"\"\"Apply temperature correction for EC. This provides the voltage as if it were measured at 25C.\n        Based on the Nernst-Einstein and Stokes-Einstein relations, related to viscosity: EC/EC25 = vis25/vis.\n        The correction is a linear approximation to the full curve, valid for 10-30C.\"\"\"\n        volt_25C = volt / (1 + 0.020 * (temp - 25))\n        return volt_25C\n", "docstring": "Apply temperature correction for EC. This provides the voltage as if it were measured at 25C."}
{"repo": "Mycodo-master/mycodo/inputs/ads1115_analog_ph_ec.py", "original_string": "    def get_volt_data(self, channel):\n        \"\"\"Measure voltage at ADC channel.\"\"\"\n        chan = self.analog_in(self.adc, channel)\n        self.adc.gain = self.adc_gain\n        self.logger.debug(\"Channel {}: Gain {}, {} raw, {} volts\".format(\n            channel, self.adc_gain, chan.value, chan.voltage))\n        volt_data = chan.voltage\n        return volt_data\n", "docstring": "Measure voltage at ADC channel.\n"}
{"repo": "Mycodo-master/mycodo/inputs/ads1115_analog_ph_ec.py", "original_string": "    def convert_volt_to_ec(self, volt, temp):\n        \"\"\"Convert voltage to EC\"\"\"\n        # Calculate slope and intercept from calibration points.\n        self.slope = ((self.ec_cal_ec1 - self.ec_cal_ec2) /\n                      (self.viscosity_correction(self.ec_cal_v1, self.ec_cal_t1) -\n                       self.viscosity_correction(self.ec_cal_v2, self.ec_cal_t2)))\n        self.intercept = (self.ec_cal_ec1 -\n                          self.slope *\n                          self.viscosity_correction(self.ec_cal_v1, self.ec_cal_t1))\n        if temp is not None:\n            # Perform temperature corrections\n            ec = self.slope * self.viscosity_correction(volt, temp) + self.intercept\n        else:\n            # Don't perform temperature corrections\n            ec = self.slope * volt + self.intercept\n        return ec\n", "docstring": "Convert voltage to EC\n"}
{"repo": "Mycodo-master/mycodo/inputs/am2315.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the humidity and temperature \"\"\"\n        if not self.sensor:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        temperature = None\n        humidity = None\n        dew_point = None\n        measurements_success = False\n        # Try twice to get measurement. This prevents an anomaly where\n        # the first measurement fails if the sensor has just been powered\n        # for the first time.\n        for _ in range(2):\n            dew_point, humidity, temperature = self.return_measurements()\n            if dew_point is not None:\n                measurements_success = True\n                break\n            time.sleep(2)\n        if measurements_success:\n            self.value_set(0, temperature)\n            self.value_set(1, humidity)\n            if self.is_enabled(0) and self.is_enabled(1):\n                self.value_set(2, dew_point)\n                self.value_set(3, calculate_vapor_pressure_deficit(self.value_get(0), self.value_get(1)))\n            return self.return_dict\n        else:\n            self.logger.debug(\"Could not acquire a measurement\")\n", "docstring": "Gets the humidity and temperature \n"}
{"repo": "Mycodo-master/mycodo/inputs/am2315.py", "original_string": "    def humidity(self):\n        \"\"\"Read humidity data from the sensor.\n        Returns:\n            float = humidity reading, None if error\n        \"\"\"\n        time.sleep(.25)\n        data = self.data()\n        if data is not None:\n            return self.data()[0]\n        return None\n", "docstring": "Read humidity data from the sensor."}
{"repo": "Mycodo-master/mycodo/inputs/am2315.py", "original_string": "    def verify_crc(char):\n        \"\"\"Returns the 16-bit CRC of sensor data\"\"\"\n        crc = 0xFFFF\n        for l in char:\n            crc = crc ^ l\n            for _ in range(1,9):\n                if crc & 0x01:\n                    crc = crc >> 1\n                    crc = crc ^ 0xA001\n                else:\n                    crc = crc >> 1\n        return crc\n", "docstring": "Returns the 16-bit CRC of sensor data\n"}
{"repo": "Mycodo-master/mycodo/inputs/bme680.py", "original_string": "    def __init__(self, input_dev, testing=False):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        self.sensor = None\n        self.humidity_oversample = None\n        self.temperature_oversample = None\n        self.pressure_oversample = None\n        self.iir_filter = None\n        self.gas_heater_temperature = None\n        self.gas_heater_duration = None\n        self.gas_heater_profile = None\n        self.temp_offset = None\n        if not testing:\n            self.setup_custom_options(\n                INPUT_INFORMATION['custom_options'], input_dev)\n            self.initialize_input()\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/hdc1000.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the humidity and temperature \"\"\"\n        if not self.HDC1000_fr or not self.HDC1000_fw:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        if self.is_enabled(0):\n            self.value_set(0, self.read_temperature())\n        if self.is_enabled(1):\n            self.value_set(1, self.read_humidity())\n        if self.is_enabled(2) and self.is_enabled(0) and self.is_enabled(1):\n            self.value_set(2, calculate_dewpoint(self.value_get(0), self.value_get(1)))\n        if self.is_enabled(3) and self.is_enabled(0) and self.is_enabled(1):\n            self.value_set(3, calculate_vapor_pressure_deficit(self.value_get(0), self.value_get(1)))\n        return self.return_dict\n", "docstring": "Gets the humidity and temperature \n"}
{"repo": "Mycodo-master/mycodo/inputs/hdc1000.py", "original_string": "    def read_humidity(self):\n        # Send humidity measurement command, 0x01(01)\n        time.sleep(0.015)  # From the data sheet\n        s = [HDC1000_HUMIDITY_REGISTER]  # hum\n        s2 = bytearray(s)\n        self.HDC1000_fw.write(s2)\n        time.sleep(0.0625)  # From the data sheet\n        data = self.HDC1000_fr.read(2)  # read 2 byte humidity data\n        buf = array.array('B', data)\n        # print ( \"Humidity: %f 0x%X %X \" % (  ((((buf[0]<<8) + (buf[1]))/65536.0)*100.0 ),  buf[0], buf[1] ) )\n        humidity = (buf[0] * 256) + buf[1]\n        humidity = (humidity / 65536.0) * 100.0\n        return humidity\n", "docstring": "Send humidity measurement command, 0x01(01)"}
{"repo": "Mycodo-master/mycodo/inputs/hdc1000.py", "original_string": "    def turn_heater_on(self):\n        # Read config register\n        config = self.read_config_register()\n        config = config | HDC1000_CONFIG_HEATER_ENABLE\n        s = [HDC1000_CONFIGURATION_REGISTER, config >> 8, 0x00]\n        s2 = bytearray(s)\n        self.HDC1000_fw.write(s2)  # sending config register bytes\n        time.sleep(0.015)  # From the data sheet\n        return\n", "docstring": "Read config register"}
{"repo": "Mycodo-master/mycodo/inputs/hdc1000.py", "original_string": "    def set_humidity_resolution(self, resolution):\n        # Read config register\n        config = self.read_config_register()\n        config = (config & ~0x0300) | resolution\n        s = [HDC1000_CONFIGURATION_REGISTER, config >> 8, 0x00]\n        s2 = bytearray(s)\n        self.HDC1000_fw.write(s2)  # sending config register bytes\n        time.sleep(0.015)  # From the data sheet\n        return\n", "docstring": "Read config register"}
{"repo": "Mycodo-master/mycodo/inputs/hdc1000.py", "original_string": "    def read_battery_status(self):\n        # Read config register\n        config = self.read_config_register()\n        config = config & ~ HDC1000_CONFIG_HEATER_ENABLE\n        return config == 0\n", "docstring": "Read config register"}
{"repo": "Mycodo-master/mycodo/inputs/ds18b20.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the DS18B20's temperature in Celsius \"\"\"\n        if not self.sensor:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        temperature = None\n        n = 2\n        for i in range(n):\n            try:\n                temperature = self.sensor.get_temperature()\n            except Exception as e:\n                if i == n:\n                    self.logger.exception(\n                        \"{cls} raised an exception when taking a reading: {err}\".format(cls=type(self).__name__, err=e))\n                    return None\n                time.sleep(1)\n        if temperature == 85:\n            self.logger.error(\"Measurement returned 85 C, indicating an issue communicating with the sensor.\")\n            return None\n        elif temperature is not None and not -55 < temperature < 125:\n            self.logger.error(\n                \"Measurement outside the expected range of -55 C to 125 C: {temp} C\".format(temp=temperature))\n            return None\n        elif temperature is not None:\n            self.value_set(0, temperature)\n        return self.return_dict\n", "docstring": "Gets the DS18B20's temperature in Celsius \n"}
{"repo": "Mycodo-master/mycodo/inputs/max31850k.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the MAX31850K's temperature in Celsius \"\"\"\n        if not self.sensor:\n            self.logger.error(\"Input not set up\")\n            return\n        self.return_dict = copy.deepcopy(measurements_dict)\n        n = 2\n        for i in range(n):\n            try:\n                self.value_set(0, self.sensor.get_temperature())\n                return self.return_dict\n            except Exception as e:\n                if i == n:\n                    self.logger.exception(\n                        \"{cls} raised an exception when taking a reading: {err}\".format(cls=type(self).__name__, err=e))\n                time.sleep(1)\n", "docstring": "Gets the MAX31850K's temperature in Celsius \n"}
{"repo": "Mycodo-master/mycodo/inputs/examples/minimal_humidity_temperature.py", "original_string": "    def get_measurement(self):\n        \"\"\" Measures temperature and humidity \"\"\"\n        # Resetting these values ensures old measurements aren't mistaken for new measurements\n        self.return_dict = copy.deepcopy(measurements_dict)\n        # Actual input measurement code\n        try:\n            humidity = self.random.randint(0, 100)\n            temperature = self.random.randint(0, 50)\n            self.logger.info(\"Option one value is {}\".format(self.option_one))\n            self.logger.info(\n                \"This INFO message will always be displayed. \"\n                \"Acquiring measurements...\")\n            if self.is_enabled(0):  # Only store the measurement if it's enabled\n                self.value_set(0, temperature)\n            if self.is_enabled(1):  # Only store the measurement if it's enabled\n                self.value_set(1, humidity)\n            # Only store the measurement if measurements 0, 1, and 2 are enabled\n            # Since the calculation of measurement 2 depend on measurements 0 and 1\n            if (self.is_enabled(2) and\n                    self.is_enabled(0) and\n                    self.is_enabled(1)):\n                dewpoint = calculate_dewpoint(\n                    self.value_get(0), self.value_get(1))\n                self.value_set(2, dewpoint)\n            self.logger.debug(\n                \"This DEBUG message will only be displayed if the Debug \"\n                \"option is enabled. {}\".format(self.return_dict))\n            return self.return_dict\n        except Exception as msg:\n            self.logger.error(\"Exception: {}\".format(msg))\n", "docstring": "Measures temperature and humidity \n"}
{"repo": "Mycodo-master/mycodo/inputs/examples/example_all_options_temperature.py", "original_string": "    def __init__(self, input_dev, testing=False):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        #\n        # Initialize variables (set to None)\n        #\n        self.random = None\n        self.interface = None\n        self.resolution = None\n        self.i2c_address = None\n        self.i2c_bus = None\n        #\n        # Set variables to custom options\n        #\n        # Initialize custom option variables to None\n        self.fan_modulate = None\n        self.fan_seconds = None\n        self.measure_range = None\n        if not testing:\n            # Set custom option variables to defaults or user-set values\n            self.setup_custom_options(\n                INPUT_INFORMATION['custom_options'], input_dev)\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/examples/example_all_options_temperature.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the temperature and humidity \"\"\"\n        #\n        # Copy measurements dictionary\n        #\n        self.return_dict = copy.deepcopy(measurements_dict)\n        #\n        # Begin sensor measurement code\n        #\n        self.value_set(0, self.random.randint(50, 70))\n        #\n        # End sensor measurement code\n        #\n        self.logger.info(\n            \"This INFO message will always be displayed. \"\n            \"self.fan_modulate: {}, \"\n            \"self.fan_seconds: {}, \"\n            \"self.measure_range: {}.\".format(\n                self.fan_modulate, self.fan_seconds, self.measure_range))\n        self.logger.debug(\n            \"This DEBUG message will only be displayed if the \"\n            \"Debug option is enabled.\")\n        return self.return_dict\n", "docstring": "Gets the temperature and humidity \n"}
{"repo": "Mycodo-master/mycodo/inputs/examples/example_all_options_temperature_with_channel_options.py", "original_string": "    def __init__(self, input_dev, testing=False):\n        super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)\n        #\n        # Initialize variables (set to None)\n        #\n        self.random = None\n        self.interface = None\n        self.resolution = None\n        self.i2c_address = None\n        self.i2c_bus = None\n        #\n        # Set variables to custom options\n        #\n        # Initialize custom option variables to None\n        self.fan_modulate = None\n        self.fan_seconds = None\n        self.measure_range = None\n        if not testing:\n            # Set custom option variables to defaults or user-set values\n            self.setup_custom_options(\n                INPUT_INFORMATION['custom_options'], input_dev)\n            self.initialize_input()\n", "docstring": "super(InputModule, self).__init__(input_dev, testing=testing, name=__name__)"}
{"repo": "Mycodo-master/mycodo/inputs/examples/example_all_options_temperature_with_channel_options.py", "original_string": "    def get_measurement(self):\n        \"\"\" Gets the temperature and humidity \"\"\"\n        #\n        # Initialize measurements dictionary\n        #\n        measurements = {}\n        for channel in self.channels_measurement:\n            if self.is_enabled(channel):\n                # Initialize channel dictionary\n                measurements[channel] = {}\n                #\n                # Set the measurement and unit\n                #\n                measurements[channel]['measurement'] = self.channels_measurement[channel].measurement\n                measurements[channel]['unit'] = self.channels_measurement[channel].unit\n                #\n                # Set the measurement value\n                #\n                measurements[channel]['value'] = self.random.randint(50, 70)\n                self.logger.info(\n                    \"Channel {} is enabled and storing a value of {} \"\n                    \"with measurement {} and unit {}\".format(\n                        channel,\n                        measurements[channel]['value'],\n                        measurements[channel]['measurement'],\n                        measurements[channel]['unit']))\n                # Convert value/unit is conversion_id present and valid\n                if self.channels_conversion[channel]:\n                    conversion = db_retrieve_table_daemon(\n                        Conversion, unique_id=self.channels_measurement[channel].conversion_id)\n                    if conversion:\n                        meas = parse_measurement(\n                            self.channels_conversion[channel],\n                            self.channels_measurement[channel],\n                            measurements,\n                            channel,\n                            measurements[channel])\n                        measurements[channel]['measurement'] = meas[channel]['measurement']\n                        measurements[channel]['unit'] = meas[channel]['unit']\n                        measurements[channel]['value'] = meas[channel]['value']\n        if measurements:\n            self.logger.debug(\"Adding measurements to influxdb: {}\".format(measurements))\n            add_measurements_influxdb(\n                self.unique_id, measurements,\n                use_same_timestamp=INPUT_INFORMATION['measurements_use_same_timestamp'])\n        else:\n            self.logger.debug(\"No measurements to add to influxdb.\")\n        self.logger.info(\n            \"This INFO message will always be displayed. \"\n            \"self.fan_modulate: {}, \"\n            \"self.fan_seconds: {}, \"\n            \"self.measure_range: {}.\".format(\n                self.fan_modulate, self.fan_seconds, self.measure_range))\n        self.logger.debug(\n            \"This DEBUG message will only be displayed if the \"\n            \"Debug option is enabled.\")\n        return self.return_dict\n", "docstring": "Gets the temperature and humidity \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/conftest.py", "original_string": "def app():\n    \"\"\" creates a flask instance \"\"\"\n    _app = create_app(config=TestConfig)\n    ctx = _app.test_request_context()\n    ctx.push()\n    yield _app\n    ctx.pop()\n", "docstring": "creates a flask instance \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/conftest.py", "original_string": "def testapp(app):\n    \"\"\" creates a webtest fixture \"\"\"\n    with app.app_context():\n        populate_db()\n        create_admin_user()\n        create_guest_user()\n    return TestApp(app)\n", "docstring": "creates a webtest fixture \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/conftest.py", "original_string": "def db(app):\n    \"\"\" Creates a config object to setup and databases during tests \"\"\"\n    _db.app = app\n    with app.app_context():\n        _db.create_all()\n    yield _db\n    _db.drop_all()\n", "docstring": "Creates a config object to setup and databases during tests \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/conftest.py", "original_string": "def create_guest_user():\n    \"\"\" Create a guest user if it doesn't exist \"\"\"\n    if not User.query.filter_by(name='guest').count():\n        user = UserFactory()\n        user.name = 'guest'\n        user.email = 'guest@email.com'\n        user.set_password('53CR3t_p4zZW0rD')\n        user.api_key = b'secret_guest_api_key'\n        user.role_id = Role.query.filter_by(name='Guest').first().id\n        user.language = 'en'\n        user.save()\n", "docstring": "Create a guest user if it doesn't exist \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_fixtures.py", "original_string": "def app_fixture_test(app):\n    \"\"\" verify that we can generate a flaks app fixture \"\"\"\n    assert app and isinstance(app, Flask)\n", "docstring": "verify that we can generate a flaks app fixture \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_mycodo_flask/test_endpoints.py", "original_string": "def redirects_to_login_page(testapp, endpoint):\n    \"\"\" helper function that verifies that we see the login page \"\"\"\n    response = testapp.get(endpoint, expect_errors=True).maybe_follow()\n    assert response.status_code == 200, \"Response Status Failure: {}\".format(endpoint)\n    assert \"Mycodo Login\" in response\n", "docstring": "helper function that verifies that we see the login page \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_mycodo_flask/test_endpoints.py", "original_string": "def test_sees_admin_creation_form(testapp):\n    \"\"\" No Admin user exists: user sees the admin creation page \"\"\"\n    print(\"\\nTest: test_sees_admin_creation_form\")\n    # Delete all admin users to show the admin creation form\n    for each_admin in User.query.filter_by(role_id=1).all():\n        each_admin.delete()\n    expected_body_msg = \"<!-- Route: /create_admin -->\"\n    assert expected_body_msg in testapp.get('/').maybe_follow()\n", "docstring": "No Admin user exists: user sees the admin creation page \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_mycodo_flask/test_endpoints.py", "original_string": "def test_api_logged_in_as_admin(_, testapp):\n    \"\"\" Verifies behavior of these API endpoints for a logged in admin user \"\"\"\n    print(\"\\nTest: test_api_logged_in_as_admin\")\n    print(\"test_routes_logged_in_as_admin: login_user(testapp, 'admin', '53CR3t_p4zZW0rD')\")\n    login_user(testapp, 'admin', '53CR3t_p4zZW0rD')\n    # Test all endpoints\n    for index, route in enumerate(api_endpoints):\n        print(\"test_routes_logged_in_as_admin: Test Route ({}/{}): testapp.get('/api/{}')\".format(\n            index + 1, len(api_endpoints), route[0]))\n        response = testapp.get(\n            '/api/{add}'.format(add=route[0]),\n            headers={'Accept': 'application/vnd.mycodo.v1+json'})\n        assert response.status_code == 200, \"Endpoint Tested: {page}\".format(page=route[0])\n        assert route[1] in response, \"Unexpected HTTP Response: \\n{body}\".format(body=response.body)\n", "docstring": "Verifies behavior of these API endpoints for a logged in admin user \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_mycodo_flask/test_endpoints.py", "original_string": "def test_api_with_admin_apikey_in_header(_, testapp):\n    \"\"\" Verifies behavior of these API endpoints with an apikey in the header \"\"\"\n    print(\"\\nTest: test_api_with_admin_apikey_in_header\")\n    # Test all endpoints\n    for index, route in enumerate(api_endpoints):\n        print(\"test_api_with_admin_apikey_in_header: Test Route ({}/{}): testapp.get('/api/{}')\".format(\n            index + 1, len(api_endpoints), route[0]))\n        response = testapp.get(\n            '/api/{add}'.format(add=route[0]),\n            headers={\n                'Accept': 'application/vnd.mycodo.v1+json',\n                'X-API-KEY': base64.b64encode(b'secret_admin_api_key')\n            }\n        )\n        assert response.status_code == 200, \"Endpoint Tested: {page}\".format(page=route[0])\n        assert route[1] in response, \"Unexpected HTTP Response: \\n{body}\".format(body=response.body)\n", "docstring": "Verifies behavior of these API endpoints with an apikey in the header \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_mycodo_flask/test_endpoints.py", "original_string": "def test_api_with_guest_apikey_in_header_403_forbidden(_, testapp):\n    \"\"\" Verifies behavior of these API endpoints with an apikey in the header \"\"\"\n    print(\"\\nTest: test_api_with_guest_apikey_in_header_403_forbidden\")\n    # Test all endpoints\n    for index, route in enumerate(api_endpoints):\n        print(\"test_api_with_guest_apikey_in_header_403_forbidden: Test Route ({}/{}): testapp.get('/api/{}')\".format(\n            index + 1, len(api_endpoints), route[0]))\n        response = testapp.get(\n            '/api/{add}'.format(add=route[0]),\n            headers={\n                'Accept': 'application/vnd.mycodo.v1+json',\n                'X-API-KEY': base64.b64encode(b'secret_guest_api_key')\n            },\n            expect_errors=True\n        ).maybe_follow()\n        assert response.status_code == 403, \"Endpoint Tested: {page}\".format(page=route[0])\n", "docstring": "Verifies behavior of these API endpoints with an apikey in the header \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_mycodo_flask/test_endpoints.py", "original_string": "def test_routes_logged_in_as_admin(_, testapp):\n    \"\"\" Verifies behavior of these endpoints for a logged in admin user \"\"\"\n    print(\"\\nTest: test_routes_logged_in_as_admin\")\n    print(\"test_routes_logged_in_as_admin: login_user(testapp, 'admin', '53CR3t_p4zZW0rD')\")\n    login_user(testapp, 'admin', '53CR3t_p4zZW0rD')\n    # Test if the navigation bar is seen on the main page\n    sees_navbar(testapp)\n    # Test all endpoints\n    routes = [\n        ('api', 'Mycodo API'),\n        ('admin/backup', '<!-- Route: /admin/backup -->'),\n        ('admin/statistics', '<!-- Route: /admin/statistics -->'),\n        ('admin/upgrade', '<!-- Route: /admin/upgrade -->'),\n        ('settings/alerts', '<!-- Route: /settings/alerts -->'),\n        ('settings/general', '<!-- Route: /settings/general -->'),\n        ('settings/input', '<!-- Route: /settings/input -->'),\n        ('settings/measurement', '<!-- Route: /settings/measurement -->'),\n        ('settings/users', '<!-- Route: /settings/users -->'),\n        ('camera', '<!-- Route: /camera -->'),\n        ('dashboard', '<!-- Route: /dashboard -->'),\n        ('input', '<!-- Route: /input -->'),\n        ('export', '<!-- Route: /export -->'),\n        ('forgot_password', '<!-- Route: /forgot_password -->'),\n        ('function', '<!-- Route: /function -->'),\n        ('graph-async', '<!-- Route: /graph-async -->'),\n        ('info', '<!-- Route: /info -->'),\n        ('lcd', '<!-- Route: /lcd -->'),\n        ('live', '<!-- Route: /live -->'),\n        ('logview', '<!-- Route: /logview -->'),\n        ('method', '<!-- Route: /method -->'),\n        ('method-build/-1', 'admin logged in'),\n        ('notes', '<!-- Route: /notes -->'),\n        ('note_edit/0', 'admin logged in'),\n        ('output', '<!-- Route: /output -->'),\n        ('remote/setup', '<!-- Route: /remote/setup -->'),\n        ('reset_password', '<!-- Route: /reset_password -->'),\n        ('usage', '<!-- Route: /usage -->'),\n        ('usage_reports', '<!-- Route: /usage_reports -->')\n    ]\n    for index, route in enumerate(routes):\n        print(\"test_routes_logged_in_as_admin: Test Route ({}/{}): testapp.get('/{}').maybe_follow()\".format(\n            index + 1, len(routes), route[0]))\n        response = testapp.get('/{add}'.format(add=route[0])).maybe_follow()\n        assert response.status_code == 200, \"Endpoint Tested: {page}\".format(page=route[0])\n        assert route[1] in response, \"Unexpected HTTP Response: \\n{body}\".format(body=response.body)\n", "docstring": "Verifies behavior of these endpoints for a logged in admin user \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_mycodo_flask/test_endpoints.py", "original_string": "def test_add_all_input_devices_logged_in_as_admin(_, testapp):\n    \"\"\" Verifies adding all inputs as a logged in admin user \"\"\"\n    print(\"\\nTest: test_add_all_input_devices_logged_in_as_admin\")\n    login_user(testapp, 'admin', '53CR3t_p4zZW0rD')\n    # Add All Inputs\n    input_count = 0\n    dict_inputs = parse_input_information()\n    list_inputs_sorted = generate_form_input_list(dict_inputs)\n    choices_input = []\n    for each_input in list_inputs_sorted:\n        if 'interfaces' not in dict_inputs[each_input]:\n            choices_input.append('{inp},'.format(inp=each_input))\n        else:\n            for each_interface in dict_inputs[each_input]['interfaces']:\n                choices_input.append('{inp},{int}'.format(inp=each_input, int=each_interface))\n    for index, each_input in enumerate(choices_input):\n        choice_name = each_input.split(',')[0]\n        print(\"test_add_all_input_devices_logged_in_as_admin: Adding, saving, and deleting Input ({}/{}): {}\".format(\n            index + 1, len(choices_input), each_input))\n        response = add_data(testapp, input_type=each_input)\n        assert 'data' in response.json\n        assert 'messages' in response.json['data']\n        assert 'error' in response.json['data']['messages']\n        assert response.json['data']['messages']['error'] == []\n        assert 'success' in response.json['data']['messages']\n        assert len(response.json['data']['messages']['success']) == 1\n        # Verify data was entered into the database\n        input_count += 1\n        assert Input.query.count() == input_count, \"Number of Inputs doesn't match: In DB {}, Should be: {}\".format(\n            Input.query.count(), input_count)\n        input_dev = Input.query.filter(Input.id == input_count).first()\n        assert choice_name == input_dev.device, \"Input name doesn't match: {}\".format(choice_name)\n        # Save input\n        response = save_data(testapp, 'input', device_dev=input_dev)\n        assert 'data' in response.json\n        assert 'messages' in response.json['data']\n        assert 'error' in response.json['data']['messages']\n        assert response.json['data']['messages']['error'] == []\n        assert 'success' in response.json['data']['messages']\n        assert len(response.json['data']['messages']['success']) == 1\n        # Delete input (speeds up further input addition checking)\n        response = delete_data(testapp, 'input', device_dev=input_dev)\n        assert 'data' in response.json\n        assert 'messages' in response.json['data']\n        assert 'error' in response.json['data']['messages']\n        assert response.json['data']['messages']['error'] == []\n        assert 'success' in response.json['data']['messages']\n        assert len(response.json['data']['messages']['success']) == 1\n        input_count -= 1\n        assert Input.query.count() == input_count, \"Number of Inputs doesn't match: In DB {}, Should be: {}\".format(\n            Input.query.count(), input_count)\n", "docstring": "Verifies adding all inputs as a logged in admin user \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_mycodo_flask/test_endpoints.py", "original_string": "def test_add_all_output_devices_logged_in_as_admin(_, testapp):\n    \"\"\" Verifies adding all outputs as a logged in admin user \"\"\"\n    print(\"\\nTest: test_add_all_output_devices_logged_in_as_admin\")\n    login_user(testapp, 'admin', '53CR3t_p4zZW0rD')\n    # Add All Inputs\n    output_count = 0\n    dict_outputs = parse_output_information()\n    list_outputs_sorted = generate_form_output_list(dict_outputs)\n    choices_output = []\n    for each_output in list_outputs_sorted:\n        if 'interfaces' not in dict_outputs[each_output]:\n            choices_output.append('{inp},'.format(inp=each_output))\n        else:\n            for each_interface in dict_outputs[each_output]['interfaces']:\n                choices_output.append('{inp},{int}'.format(inp=each_output, int=each_interface))\n    for index, each_output in enumerate(choices_output):\n        print(\"test_add_all_output_devices_logged_in_as_admin: Adding, saving, and deleting Output ({}/{}): {}\".format(\n            index + 1, len(choices_output), each_output))\n        response = add_output(testapp, output_type=each_output)\n        assert 'data' in response.json\n        assert 'messages' in response.json['data']\n        assert 'error' in response.json['data']['messages']\n        assert response.json['data']['messages']['error'] == []\n        assert 'success' in response.json['data']['messages']\n        assert len(response.json['data']['messages']['success']) == 1\n        # Verify data was entered into the database\n        output_count += 1\n        assert Output.query.count() == output_count, \"Number of Outputs doesn't match: In DB {}, Should be: {}\".format(\n            Output.query.count(), output_count)\n        output = Output.query.filter(Output.id == output_count).first()\n        # Save output\n        response = save_data(testapp, 'output', device_dev=output)\n        assert 'data' in response.json\n        assert 'messages' in response.json['data']\n        assert 'error' in response.json['data']['messages']\n        assert response.json['data']['messages']['error'] == []\n        assert 'success' in response.json['data']['messages']\n        assert len(response.json['data']['messages']['success']) == 1\n        # Delete output (speeds up further output addition checking)\n        response = delete_data(testapp, 'output', device_dev=output)\n        assert 'data' in response.json\n        assert 'messages' in response.json['data']\n        assert 'error' in response.json['data']['messages']\n        assert response.json['data']['messages']['error'] == []\n        assert 'success' in response.json['data']['messages']\n        assert len(response.json['data']['messages']['success']) == 1\n        output_count -= 1\n        assert Output.query.count() == output_count, \"Number of Outputs doesn't match: In DB {}, Should be: {}\".format(\n            Output.query.count(), output_count)\n", "docstring": "Verifies adding all outputs as a logged in admin user \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_mycodo_flask/test_endpoints.py", "original_string": "def test_routes_logged_in_as_guest(_, testapp):\n    \"\"\" Verifies behavior of these endpoints for a logged in guest user \"\"\"\n    print(\"\\nTest: test_routes_logged_in_as_guest\")\n    print(\"test_routes_logged_in_as_guest: login_user(testapp, 'guest', '53CR3t_p4zZW0rD')\")\n    login_user(testapp, 'guest', '53CR3t_p4zZW0rD')\n    # Test if the navigation bar is seen on the main page\n    sees_navbar(testapp)\n    # Test all endpoints\n    routes = [\n        ('admin/backup', '<!-- Route: /live -->'),\n        ('admin/upgrade', '<!-- Route: /live -->'),\n        ('admin/statistics', '<!-- Route: /live -->'),\n        ('remote/setup', '<!-- Route: /live -->'),\n        ('settings/alerts', '<!-- Route: /live -->'),\n        ('settings/diagnostic', '<!-- Route: /live -->'),\n        ('settings/general', '<!-- Route: /live -->'),\n        ('settings/measurement', '<!-- Route: /live -->'),\n        ('settings/users', '<!-- Route: /live -->'),\n        ('systemctl/restart', '<!-- Route: /live -->'),\n        ('systemctl/shutdown', '<!-- Route: /live -->')\n    ]\n    for index, route in enumerate(routes):\n        print(\"test_routes_logged_in_as_guest: Test Route ({}/{}): testapp.get('/{}').maybe_follow()\".format(\n            index + 1, len(routes), route[0]))\n        response = testapp.get('/{add}'.format(add=route[0])).maybe_follow()\n        assert response.status_code == 200, \"Endpoint Tested: {page}\".format(page=route[0])\n        assert route[1] in response, \"Unexpected HTTP Response: \\n{body}\".format(body=response.body)\n", "docstring": "Verifies behavior of these endpoints for a logged in guest user \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_mycodo_flask/test_endpoints.py", "original_string": "def add_data(testapp, input_type='RPi'):\n    \"\"\" Go to the data page and create input \"\"\"\n    form = testapp.get('/input').maybe_follow().forms['new_input_form']\n    form_dict = {}\n    for each_field in form.fields.items():\n        if each_field[0]:\n            form_dict[each_field[0]] = form[each_field[0]].value\n    form_dict['input_add'] = 'Add'\n    form_dict['input_type'] = input_type\n    response = testapp.post('/input_submit', form_dict)\n    # response.showbrowser()\n    return response\n", "docstring": "Go to the data page and create input \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_mycodo_flask/test_endpoints.py", "original_string": "def add_function(testapp, function_type=''):\n    \"\"\" Go to the function page and add function \"\"\"\n    form = testapp.get('/function').maybe_follow().forms['new_function_form']\n    form_dict = {}\n    for each_field in form.fields.items():\n        if each_field[0]:\n            form_dict[each_field[0]] = form[each_field[0]].value\n    form_dict['function_add'] = 'Add'\n    form_dict['function_type'] = function_type\n    response = testapp.post('/function_submit', form_dict)\n    # response.showbrowser()\n    return response\n", "docstring": "Go to the function page and add function \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_mycodo_flask/test_endpoints.py", "original_string": "def save_data(testapp, data_type, device_dev=None):\n    \"\"\" Go to the page and save input/output/function \"\"\"\n    response = None\n    if data_type == 'input':\n        form = testapp.get('/input').maybe_follow().forms['mod_input_form']\n        form_dict = {}\n        for each_field in form.fields.items():\n            if each_field[0]:\n                form_dict[each_field[0]] = form[each_field[0]].value\n        form_dict['input_mod'] = 'Save'\n        response = testapp.post('/input_submit', form_dict)\n    elif data_type == 'output':\n        form = testapp.get('/output').maybe_follow().forms['mod_output_form']\n        form_dict = {}\n        for each_field in form.fields.items():\n            if each_field[0]:\n                form_dict[each_field[0]] = form[each_field[0]].value\n        form_dict['output_mod'] = 'Save'\n        response = testapp.post('/output_submit', form_dict)\n    elif data_type == 'function':\n        form = testapp.get('/function').maybe_follow().forms['mod_function_form']\n        form_dict = {}\n        for each_field in form.fields.items():\n            if each_field[0]:\n                form_dict[each_field[0]] = form[each_field[0]].value\n        form_dict['function_mod'] = 'Save'\n        response = testapp.post('/function_submit', form_dict)\n    # response.showbrowser()\n    return response\n", "docstring": "Go to the page and save input/output/function \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_inputs/test_inputs.py", "original_string": "def test_inputs_have_depreciated_stop_input():\n    \"\"\" Verify that the input objects have the stop_input() method \"\"\"\n    print(\"\\nTest: test_inputs_have_depreciated_stop_input\")\n    for index, each_class in enumerate(input_classes):\n        print(\"test_inputs_have_depreciated_stop_input: Testing Class ({}/{}): {}\".format(\n            index + 1, len(input_classes), each_class))\n        assert hasattr(each_class, 'stop_input')\n", "docstring": "Verify that the input objects have the stop_input() method \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_inputs/test_inputs.py", "original_string": "def test_read_updates_measurement():\n    \"\"\"  Verify that read() gets the average temp \"\"\"\n    print(\"\\nTest: test_read_updates_measurement\")\n    for index, each_class in enumerate(input_classes):\n        full_path = inspect.getfile(each_class.__class__)\n        filename = os.path.splitext(os.path.basename(full_path))[0]\n        print(\"test_read_updates_measurement: Testing Input ({}/{}): {}\".format(\n            index + 1, len(input_classes), filename))\n        with mock.patch('mycodo.inputs.{fn}.InputModule.get_measurement'.format(fn=filename)) as mock_measure:\n            mock_measure.side_effect = [\n                {\n                   0: {\n                       'measurement': 'temperature',\n                       'unit': 'C',\n                       'value': 24,\n                       'time': 1556199975\n                   },\n                   1: {\n                       'measurement': 'humidity',\n                       'unit': 'percent',\n                       'value': 55,\n                       'time': 1556199975\n                   }\n                },\n                {\n                   0: {\n                       'measurement': 'temperature',\n                       'unit': 'C',\n                       'value': 25,\n                       'time': 1556199975\n                   },\n                   1: {\n                       'measurement': 'humidity',\n                       'unit': 'percent',\n                       'value': 76,\n                       'time': 1556199975\n                   }\n                }\n            ]\n            assert each_class._measurements is None\n            assert each_class._measurements is None\n            assert not each_class.read()\n            assert each_class.measurements[0]['measurement'] == 'temperature'\n            assert each_class.measurements[0]['unit'] == 'C'\n            assert each_class.measurements[0]['time'] == 1556199975\n            assert each_class.measurements[0]['value'] == 24\n            assert each_class.measurements[1]['measurement'] == 'humidity'\n            assert each_class.measurements[1]['unit'] == 'percent'\n            assert each_class.measurements[1]['time'] == 1556199975\n            assert each_class.measurements[1]['value'] == 55\n            assert not each_class.read()\n            assert each_class.measurements[0]['value'] == 25\n            assert each_class.measurements[1]['value'] == 76\n", "docstring": "Verify that read() gets the average temp \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_inputs/test_inputs.py", "original_string": "def test_special_method_repr():\n    \"\"\" expect a __repr__ format \"\"\"\n    print(\"\\nTest: test_special_method_repr\")\n    for index, each_class in enumerate(input_classes):\n        full_path = inspect.getfile(each_class.__class__)\n        filename = os.path.splitext(os.path.basename(full_path))[0]\n        with mock.patch('mycodo.inputs.{fn}.InputModule.get_measurement'.format(fn=filename)) as mock_measure:\n            mock_measure.side_effect = [\n                {\n                   0: {\n                       'measurement': 'temperature',\n                       'unit': 'C',\n                       'value': 24,\n                       'time': 1556199975\n                   },\n                   1: {\n                       'measurement': 'humidity',\n                       'unit': 'percent',\n                       'value': 55,\n                       'time': 1556199975\n                   }\n                }\n            ]\n            print(\"test_special_method_repr: Testing Input ({}/{}): {}\".format(index + 1, len(input_classes), filename))\n            each_class.read()\n            assert \"<InputModule\" in repr(each_class)\n            assert \"(1556199975,0,temperature,C,24)\" in repr(each_class)\n            assert \"(1556199975,1,humidity,percent,55)\" in repr(each_class)\n            assert \">\" in repr(each_class)\n", "docstring": "expect a __repr__ format \n"}
{"repo": "Mycodo-master/mycodo/tests/software_tests/test_inputs/test_inputs.py", "original_string": "def test_read_returns_1_on_exception():\n    \"\"\" Verify the read() method returns true on error \"\"\"\n    print(\"\\nTest: test_read_returns_1_on_exception\")\n    for index, each_class in enumerate(input_classes):\n        full_path = inspect.getfile(each_class.__class__)\n        filename = os.path.splitext(os.path.basename(full_path))[0]\n        print(\"test_read_returns_1_on_exception: Testing Input ({}/{}): {}\".format(index + 1, len(input_classes), filename))\n        with mock.patch('mycodo.inputs.{fn}.InputModule.get_measurement'.format(fn=filename), side_effect=Exception):\n            assert each_class.read()\n", "docstring": "Verify the read() method returns true on error \n"}
{"repo": "Mycodo-master/mycodo/tests/manual_tests/test_i2c_LCD.py", "original_string": "def lcd_byte(bits, mode, backlight=LCD_BACKLIGHT):\n    \"\"\"Send byte to data pins\"\"\"\n    # bits = the data\n    # mode = 1 for data\n    #        0 for command\n    bits_high = mode | (bits & 0xF0) | backlight\n    bits_low = mode | ((bits << 4) & 0xF0) | backlight\n    # High bits\n    bus.write_byte(I2C_ADDR, bits_high)\n    lcd_toggle_enable(bits_high)\n    # Low bits\n    bus.write_byte(I2C_ADDR, bits_low)\n    lcd_toggle_enable(bits_low)\n", "docstring": "Send byte to data pins\n"}
{"repo": "Mycodo-master/mycodo/tests/manual_tests/test_i2c_LCD.py", "original_string": "def lcd_string_write(message, line):\n    \"\"\"Send string to display\"\"\"\n    message = message.ljust(LCD_WIDTH, \" \")\n    lcd_byte(line, LCD_CMD)\n    for i in range(LCD_WIDTH):\n        lcd_byte(ord(message[i]), LCD_CHR)\n", "docstring": "Send string to display\n"}
{"repo": "Mycodo-master/mycodo/tests/manual_tests/test_i2c_Atlas_PT1000.py", "original_string": "    def __init__(self, address=default_address, bus=default_bus):\n        # open two file streams, one for reading and one for writing\n        # the specific I2C channel is selected with bus\n        # it is usually 1, except for older revisions where its 0\n        # wb and rb indicate binary read and write\n        self.file_read = io.open(\"/dev/i2c-\" + str(bus), \"rb\", buffering=0)\n        self.file_write = io.open(\"/dev/i2c-\" + str(bus), \"wb\", buffering=0)\n        # initializes I2C to either a user specified or default address\n        self.set_i2c_address(address)\n", "docstring": "open two file streams, one for reading and one for writing"}
{"repo": "Mycodo-master/mycodo/tests/manual_tests/test_i2c_Atlas_PT1000.py", "original_string": "    def write(self, cmd):\n        # appends the null character and sends the string over I2C\n        cmd += \"\\00\"\n        self.file_write.write(cmd)\n", "docstring": "appends the null character and sends the string over I2C"}
{"repo": "Mycodo-master/mycodo/tests/manual_tests/test_i2c_Atlas_PT1000.py", "original_string": "    def query(self, string):\n        # write a command to the board, wait the correct timeout, and read the response\n        self.write(string)\n        # the read and calibration commands require a longer timeout\n        if ((string.upper().startswith(\"R\")) or\n                (string.upper().startswith(\"CAL\"))):\n            time.sleep(self.long_timeout)\n        elif string.upper().startswith(\"SLEEP\"):\n            return \"sleep mode\"\n        else:\n            time.sleep(self.short_timeout)\n        return self.read()\n", "docstring": "write a command to the board, wait the correct timeout, and read the response"}
{"repo": "Mycodo-master/mycodo/tests/manual_tests/test_miflora.py", "original_string": "def poll(args):\n    \"\"\"Poll data from the sensor.\"\"\"\n    poller = MiFloraPoller(args.mac, BluepyBackend)\n    print(\"Getting data from Mi Flora\")\n    print(\"FW: {}\".format(poller.firmware_version()))\n    print(\"Name: {}\".format(poller.name()))\n    print(\"Temperature: {}\".format(poller.parameter_value(MI_TEMPERATURE)))\n    print(\"Moisture: {}\".format(poller.parameter_value(MI_MOISTURE)))\n    print(\"Light: {}\".format(poller.parameter_value(MI_LIGHT)))\n    print(\"Conductivity: {}\".format(poller.parameter_value(MI_CONDUCTIVITY)))\n    print(\"Battery: {}\".format(poller.parameter_value(MI_BATTERY)))\n", "docstring": "Poll data from the sensor.\n"}
{"repo": "Mycodo-master/mycodo/tests/manual_tests/test_miflora.py", "original_string": "def valid_miflora_mac(mac, pat=re.compile(r\"C4:7C:8D:[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}\")):\n    \"\"\"Check for valid mac adresses.\"\"\"\n    if not pat.match(mac.upper()):\n        raise argparse.ArgumentTypeError('The MAC address \"{}\" seems to be in the wrong format'.format(mac))\n    return mac\n", "docstring": "Check for valid mac adresses.\n"}
{"repo": "Mycodo-master/databases/alembic/env.py", "original_string": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n    Calls to context.execute() here emit the given string to the\n    script output.\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url, target_metadata=target_metadata, literal_binds=True)\n    with context.begin_transaction():\n        context.run_migrations()\n", "docstring": "Run migrations in 'offline' mode."}
{"repo": "Mycodo-master/databases/alembic/versions/69960a0722a7_rename_dashboard_table.py", "original_string": "def upgrade():\n    # import sys\n    # import os\n    # sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    # from databases.alembic_post_utils import write_revision_post_alembic\n    # write_revision_post_alembic(revision)\n    op.rename_table('dashboard', 'widget')\n    op.rename_table('dashboard_layout', 'dashboard')\n", "docstring": "import sys"}
{"repo": "Mycodo-master/databases/alembic/versions/7f4c173f644d_add_dashboard_placement_columns.py", "original_string": "def upgrade():\n    # import sys\n    # import os\n    # sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    # from databases.alembic_post_utils import write_revision_post_alembic\n    # write_revision_post_alembic(revision)\n    with op.batch_alter_table(\"dashboard\") as batch_op:\n        batch_op.add_column(sa.Column('position_x', sa.Integer))\n        batch_op.add_column(sa.Column('position_y', sa.Integer))\n    op.execute(\n        '''\n        UPDATE dashboard\n        SET position_x=0\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE dashboard\n        SET position_y=0\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE dashboard\n        SET width=6\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE dashboard\n        SET height=6\n        '''\n    )\n", "docstring": "import sys"}
{"repo": "Mycodo-master/databases/alembic/versions/a6ec4e059470_add_table_custom_controller.py", "original_string": "def upgrade():\n    # import sys\n    # import os\n    # sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    # from databases.alembic_post_utils import write_revision_post_alembic\n    # write_revision_post_alembic(revision)\n    op.create_table(\n        'custom_controller',\n        sa.Column('id', sa.Integer, nullable=False, unique=True),\n        sa.Column('unique_id', sa.String, nullable=False, unique=True),\n        sa.Column('name', sa.Text),\n        sa.Column('device', sa.Text),\n        sa.Column('is_activated', sa.Boolean),\n        sa.Column('log_level_debug', sa.Boolean),\n        sa.Column('custom_options', sa.Text),\n        sa.PrimaryKeyConstraint('id'),\n        keep_existing=True)\n", "docstring": "import sys"}
{"repo": "Mycodo-master/databases/alembic/versions/20174b717c2e_add_widget_options.py", "original_string": "def upgrade():\n    # import sys\n    # import os\n    # sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    # from databases.alembic_post_utils import write_revision_post_alembic\n    # write_revision_post_alembic(revision)\n    with op.batch_alter_table(\"widget\") as batch_op:\n        batch_op.add_column(sa.Column('enable_status', sa.Boolean))\n        batch_op.add_column(sa.Column('enable_value', sa.Boolean))\n        batch_op.add_column(sa.Column('enable_name', sa.Boolean))\n        batch_op.add_column(sa.Column('enable_unit', sa.Boolean))\n        batch_op.add_column(sa.Column('enable_measurement', sa.Boolean))\n        batch_op.add_column(sa.Column('enable_channel', sa.Boolean))\n    op.execute(\n        '''\n        UPDATE widget\n        SET enable_status=1\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE widget\n        SET enable_value=1\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE widget\n        SET enable_name=1\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE widget\n        SET enable_unit=1\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE widget\n        SET enable_measurement=1\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE widget\n        SET enable_channel=1\n        '''\n    )\n", "docstring": "import sys"}
{"repo": "Mycodo-master/databases/alembic/versions/802cc65f734e_ensure_pyro5_is_installed.py", "original_string": "def upgrade():\n    # No database schema changes, just need to execute post-alembic code\n    import sys\n    import os\n    sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    from databases.alembic_post_utils import write_revision_post_alembic\n    write_revision_post_alembic(revision)\n", "docstring": "No database schema changes, just need to execute post-alembic code"}
{"repo": "Mycodo-master/databases/alembic/versions/24dbd0b8c8d1_add_function_channels.py", "original_string": "def upgrade():\n    # import sys\n    # import os\n    # sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    # from databases.alembic_post_utils import write_revision_post_alembic\n    # write_revision_post_alembic(revision)\n    op.create_table(\n        'function_channel',\n        sa.Column('id', sa.Integer, nullable=False, unique=True),\n        sa.Column('unique_id', sa.String, nullable=False, unique=True),\n        sa.Column('function_id', sa.Text),\n        sa.Column('channel', sa.Integer),\n        sa.Column('name', sa.Text),\n        sa.Column('custom_options', sa.Text),\n        sa.PrimaryKeyConstraint('id'),\n        keep_existing=True)\n", "docstring": "import sys"}
{"repo": "Mycodo-master/databases/alembic/versions/4b5f6207cbdf_add_camera_options.py", "original_string": "def upgrade():\n    # import sys\n    # import os\n    # sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    # from databases.alembic_post_utils import write_revision_post_alembic\n    # write_revision_post_alembic(revision)\n    with op.batch_alter_table(\"camera\") as batch_op:\n        batch_op.add_column(sa.Column('url_still', sa.Text))\n        batch_op.add_column(sa.Column('url_stream', sa.Text))\n", "docstring": "import sys"}
{"repo": "Mycodo-master/databases/alembic/versions/4b619edb9a8f_add_more_camera_options.py", "original_string": "def upgrade():\n    # import sys\n    # import os\n    # sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    # from databases.alembic_post_utils import write_revision_post_alembic\n    # write_revision_post_alembic(revision)\n    with op.batch_alter_table(\"camera\") as batch_op:\n        batch_op.add_column(sa.Column('hide_still', sa.Boolean))\n        batch_op.add_column(sa.Column('hide_timelapse', sa.Boolean))\n        batch_op.add_column(sa.Column('resolution_stream_width', sa.Integer))\n        batch_op.add_column(sa.Column('resolution_stream_height', sa.Integer))\n    op.execute(\n        '''\n        UPDATE camera\n        SET hide_still=0\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE camera\n        SET hide_timelapse=0\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE camera\n        SET resolution_stream_width=1024\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE camera\n        SET resolution_stream_height=768\n        '''\n    )\n", "docstring": "import sys"}
{"repo": "Mycodo-master/databases/alembic/versions/f4bd467eb5fe_add_ip_and_port_options_for_internet_.py", "original_string": "def upgrade():\n    # import sys\n    # import os\n    # sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    # from databases.alembic_post_utils import write_revision_post_alembic\n    # write_revision_post_alembic(revision)\n    with op.batch_alter_table(\"misc\") as batch_op:\n        batch_op.add_column(sa.Column('net_test_ip', sa.String))\n        batch_op.add_column(sa.Column('net_test_port', sa.Integer))\n        batch_op.add_column(sa.Column('net_test_timeout', sa.Integer))\n    op.execute(\n        '''\n        UPDATE misc\n        SET net_test_ip='8.8.8.8'\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE misc\n        SET net_test_port=53\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE misc\n        SET net_test_timeout=3\n        '''\n    )\n", "docstring": "import sys"}
{"repo": "Mycodo-master/databases/alembic/versions/c1cb0775f7ce_add_widget_options.py", "original_string": "def upgrade():\n    # import sys\n    # import os\n    # sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    # from databases.alembic_post_utils import write_revision_post_alembic\n    # write_revision_post_alembic(revision)\n    with op.batch_alter_table(\"dashboard\") as batch_op:\n        batch_op.add_column(sa.Column('enable_drag_handle', sa.Boolean))\n        batch_op.add_column(sa.Column('enable_header_buttons', sa.Boolean))\n        batch_op.add_column(sa.Column('font_em_name', sa.Float))\n    with op.batch_alter_table(\"misc\") as batch_op:\n        batch_op.add_column(sa.Column('grid_cell_height', sa.Integer))\n    op.execute(\n        '''\n        UPDATE dashboard\n        SET enable_drag_handle=1\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE dashboard\n        SET enable_header_buttons=1\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE dashboard\n        SET font_em_name=1\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE misc\n        SET grid_cell_height=30\n        '''\n    )\n", "docstring": "import sys"}
{"repo": "Mycodo-master/databases/alembic/versions/9f6bc3a1a450_add_line_text_to_lcd_table_and_delete_.py", "original_string": "def upgrade():\n    # import sys\n    # import os\n    # sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    # from databases.alembic_post_utils import write_revision_post_alembic\n    # write_revision_post_alembic(revision)\n    with op.batch_alter_table(\"lcd_data\") as batch_op:\n        batch_op.add_column(sa.Column('line_1_text', sa.Text))\n        batch_op.add_column(sa.Column('line_2_text', sa.Text))\n        batch_op.add_column(sa.Column('line_3_text', sa.Text))\n        batch_op.add_column(sa.Column('line_4_text', sa.Text))\n        batch_op.add_column(sa.Column('line_5_text', sa.Text))\n        batch_op.add_column(sa.Column('line_6_text', sa.Text))\n        batch_op.add_column(sa.Column('line_7_text', sa.Text))\n        batch_op.add_column(sa.Column('line_8_text', sa.Text))\n        batch_op.drop_column('line_1_type')\n        batch_op.drop_column('line_2_type')\n        batch_op.drop_column('line_3_type')\n        batch_op.drop_column('line_4_type')\n        batch_op.drop_column('line_5_type')\n        batch_op.drop_column('line_6_type')\n        batch_op.drop_column('line_7_type')\n        batch_op.drop_column('line_8_type')\n", "docstring": "import sys"}
{"repo": "Mycodo-master/databases/alembic/versions/440d382bfaa6_add_more_picamera_options.py", "original_string": "def upgrade():\n    # import sys\n    # import os\n    # sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    # from databases.alembic_post_utils import write_revision_post_alembic\n    # write_revision_post_alembic(revision)\n    with op.batch_alter_table(\"camera\") as batch_op:\n        batch_op.add_column(sa.Column('picamera_shutter_speed', sa.Integer))\n        batch_op.add_column(sa.Column('picamera_sharpness', sa.Integer))\n        batch_op.add_column(sa.Column('picamera_iso', sa.Integer))\n        batch_op.add_column(sa.Column('picamera_exposure_mode', sa.Text))\n        batch_op.add_column(sa.Column('picamera_meter_mode', sa.Text))\n        batch_op.add_column(sa.Column('picamera_image_effect', sa.Text))\n    op.execute(\n        '''\n        UPDATE camera\n        SET picamera_shutter_speed=0\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE camera\n        SET picamera_sharpness=0\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE camera\n        SET picamera_iso=0\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE camera\n        SET picamera_exposure_mode='auto'\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE camera\n        SET picamera_meter_mode='average'\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE camera\n        SET picamera_image_effect='none'\n        '''\n    )\n", "docstring": "import sys"}
{"repo": "Mycodo-master/databases/alembic/versions/daa60c17e66e_add_white_balance_options_to_picamera.py", "original_string": "def upgrade():\n    # import sys\n    # import os\n    # sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    # from databases.alembic_post_utils import write_revision_post_alembic\n    # write_revision_post_alembic(revision)\n    with op.batch_alter_table(\"camera\") as batch_op:\n        batch_op.add_column(sa.Column('picamera_awb', sa.Text))\n        batch_op.add_column(sa.Column('picamera_awb_gain_red', sa.Float))\n        batch_op.add_column(sa.Column('picamera_awb_gain_blue', sa.Float))\n    op.execute(\n        '''\n        UPDATE camera\n        SET picamera_awb='auto'\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE camera\n        SET picamera_awb_gain_red=0.5\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE camera\n        SET picamera_awb_gain_blue=0.5\n        '''\n    )\n", "docstring": "import sys"}
{"repo": "Mycodo-master/databases/alembic/versions/b6e332156961_change_start_stop_state_from_bool_to_str.py", "original_string": "def upgrade():\n    # import sys\n    # import os\n    # sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    # from databases.alembic_post_utils import write_revision_post_alembic\n    # write_revision_post_alembic(revision)\n    with op.batch_alter_table(\"output\") as batch_op:\n        batch_op.add_column(sa.Column('state_startup', sa.Text))\n        batch_op.add_column(sa.Column('state_shutdown', sa.Text))\n        batch_op.add_column(sa.Column('startup_value', sa.Float))\n        batch_op.add_column(sa.Column('shutdown_value', sa.Float))\n    op.execute(\n        '''\n        UPDATE output\n        SET startup_value=0\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE output\n        SET shutdown_value=0\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE output\n        SET state_startup=state_at_startup\n        '''\n    )\n    op.execute(\n        '''\n        UPDATE output\n        SET state_shutdown=state_at_shutdown\n        '''\n    )\n    with op.batch_alter_table(\"output\") as batch_op:\n        batch_op.drop_column('state_at_startup')\n        batch_op.drop_column('state_at_shutdown')\n", "docstring": "import sys"}
{"repo": "Mycodo-master/databases/alembic/versions/267dc913a062_add_log_level_debug_to_function_table.py", "original_string": "def upgrade():\n    # import sys\n    # import os\n    # sys.path.append(os.path.abspath(os.path.join(__file__, \"../../../..\")))\n    # from databases.alembic_post_utils import write_revision_post_alembic\n    # write_revision_post_alembic(revision)\n    with op.batch_alter_table(\"function\") as batch_op:\n        batch_op.add_column(sa.Column('log_level_debug', sa.Boolean))\n    with op.batch_alter_table(\"conditional\") as batch_op:\n        batch_op.add_column(sa.Column('message_include_code', sa.Boolean))\n    with op.batch_alter_table(\"output\") as batch_op:\n        batch_op.add_column(sa.Column('force_command', sa.Boolean))\n", "docstring": "import sys"}
{"repo": "ripozo-master/ripozo_tests/bases/manager.py", "original_string": "    def assertValuesNotEqualsModel(self, model, values):\n        # TODO docs\n        raise NotImplementedError\n", "docstring": "TODO docs"}
{"repo": "ripozo-master/ripozo_tests/bases/manager.py", "original_string": "    def get_model(self, values):\n        # TODO docs\n        # Should raise exception when not found\n        raise NotImplementedError\n", "docstring": "TODO docs"}
{"repo": "ripozo-master/ripozo_tests/bases/manager.py", "original_string": "    def get_values(self, defaults=None):\n        # TODO docs\n        raise NotImplementedError\n", "docstring": "TODO docs"}
{"repo": "ripozo-master/ripozo_tests/bases/manager.py", "original_string": "    def get_random_pks(self):\n        pks_dict = dict()\n        for pk in self.model_pks:\n            pks_dict[pk] = uuid.uuid4()\n        return pks_dict\n", "docstring": "pks_dict = dict()"}
{"repo": "ripozo-master/ripozo_tests/unit/tests_utilities.py", "original_string": "    def test_get_or_pop(self):\n        \"\"\"Simple test to ensure that the get_or_pop\n        returns the value and appropriately updates the\n        dictionary if necessary\"\"\"\n        x = dict(x=1)\n        val = get_or_pop(x, 'x', pop=False)\n        self.assertDictEqual(x, dict(x=1))\n        self.assertEqual(val, 1)\n        val = get_or_pop(x, 'x', pop=True)\n        self.assertDictEqual(x, dict())\n        self.assertEqual(val, 1)\n", "docstring": "Simple test to ensure that the get_or_pop"}
{"repo": "ripozo-master/ripozo_tests/unit/decorators.py", "original_string": "            def fake(cls):\n                return cls\n", "docstring": "return cls"}
{"repo": "ripozo-master/ripozo_tests/unit/decorators.py", "original_string": "            def fake(cls, first, second):\n                return cls, first, second\n", "docstring": "return cls, first, second"}
{"repo": "ripozo-master/ripozo_tests/unit/decorators.py", "original_string": "            def fake(cls, first, second):\n                return cls, first, second\n", "docstring": "return cls, first, second"}
{"repo": "ripozo-master/ripozo_tests/unit/decorators.py", "original_string": "    def test_class_property(self):\n        class Fake(object):\n            x = 'hi'\n            @classproperty\n            def hello(cls):\n                return cls.x\n        self.assertEqual(Fake.hello, 'hi')\n        Fake.x = 'another'\n        self.assertEqual(Fake.hello, 'another')\n        f = Fake()\n        self.assertEqual(f.hello, 'another')\n        self.assertEqual(getattr(f, 'hello'), 'another')\n        self.assertEqual(getattr(Fake, 'hello'), 'another')\n", "docstring": "class Fake(object):"}
{"repo": "ripozo-master/ripozo_tests/unit/decorators.py", "original_string": "            def fake(cls, *args, **kwargs):\n                return cls, args, kwargs\n", "docstring": "return cls, args, kwargs"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/base.py", "original_string": "    def test_resource_name(self):\n        \"\"\"Tests whether the resource_name is properly constructed\"\"\"\n        resourcename = 'myresource'\n        class T1(TestResource):\n            resource_name = resourcename\n        self.assertEqual(resourcename, T1.resource_name)\n", "docstring": "Tests whether the resource_name is properly constructed\n"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/base.py", "original_string": "    def test_base_url(self):\n        \"\"\"Tests whether the base_url is properly constructed\"\"\"\n        class T1(TestResource):\n            pks = ['something', 'another_thing']\n        self.assertIsInstance(T1.base_url, six.text_type)\n        self.assertIn(name_space, T1.base_url)\n        self.assertIn(T1.resource_name, T1.base_url)\n        for pk in T1.pks:\n            self.assertIn(pk, T1.base_url)\n", "docstring": "Tests whether the base_url is properly constructed\n"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/base.py", "original_string": "    def test_messed_up_slashes_on_base_url(self):\n        \"\"\"Tests whether the ResourceBase always appropriately replaces\n        forward slashes on urls\"\"\"\n        class DoubleSlash(ResourceBase):\n            namespace = '/'\n            resource_name = '/'\n        self.assertEqual('/', DoubleSlash.base_url)\n        ResourceMetaClass.registered_resource_classes.clear()\n        class DoublSlash2(ResourceBase):\n            namespace = '//'\n            resource_name = '/double_slash'\n        self.assertEqual('/double_slash', DoublSlash2.base_url)\n        ResourceMetaClass.registered_resource_classes.clear()\n        class DoubleMiddleSlash(ResourceBase):\n            namespace = 'api/'\n            resource_name = '//another_resource/'\n        self.assertEqual('/api/another_resource/', DoubleMiddleSlash.base_url)\n", "docstring": "Tests whether the ResourceBase always appropriately replaces"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/base.py", "original_string": "    def test_register_endpoint(self):\n        \"\"\"Tests whether the endpoint is registered on the class\"\"\"\n        class T1(TestResource):\n            @apimethod(methods=['GET'])\n            def my_api_method1(self):\n                pass\n        # for python 3.3  Otherwise it never gets registered for some reason\n        print(T1.__name__)\n        self.assertIn('my_api_method1', T1.endpoint_dictionary())\n", "docstring": "Tests whether the endpoint is registered on the class\n"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/base.py", "original_string": "    def test_url_property(self):\n        \"\"\"Tests whether the url for an individual resource is properly created\"\"\"\n        class T1(TestResource):\n            namespace = '/api'\n            pks = ['pk']\n            resource_name = 'my_resource'\n        x = T1(properties={'pk': 1})\n        self.assertEqual(x.url, '/api/my_resource/1')\n", "docstring": "Tests whether the url for an individual resource is properly created\n"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/base.py", "original_string": "            def fake(cls, request, *args, **kwargs):\n                return cls, request\n", "docstring": "return cls, request"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/base.py", "original_string": "            def fake(cls, *args, **kwargs):\n                args = (cls,) + args\n                return args, kwargs\n", "docstring": "args = (cls,) + args"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/restmixins.py", "original_string": "            def fake(cls, request):\n                return cls()\n", "docstring": "return cls()"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/relationships/relationship.py", "original_string": "    def test_return_none(self):\n        \"\"\"Tests that the private _should_return_none appropriately\n        returns according to the expected behavior\"\"\"\n        class MyResource(ResourceBase):\n            pks = 'id',\n        res = MyResource(no_pks=True)\n        rel = Relationship('related')\n        self.assertFalse(rel._should_return_none(res))\n        res = MyResource(properties=dict(id=1))\n        self.assertFalse(rel._should_return_none(res))\n        res = MyResource(properties=dict())\n        self.assertTrue(rel._should_return_none(res))\n        rel.templated = True\n        self.assertFalse(rel._should_return_none(res))\n", "docstring": "Tests that the private _should_return_none appropriately"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/relationships/list_relationship.py", "original_string": "    def test_empty_list(self,):\n        class RelatedResource2(ResourceBase):\n            pass\n        list_name = 'mylist'\n        lr = ListRelationship(list_name, relation='RelatedResource')\n        res_list = lr.construct_resource(dict(some='thing', another='thing'))\n        self.assertIsInstance(res_list, list)\n        self.assertEqual(len(res_list), 0)\n", "docstring": "class RelatedResource2(ResourceBase):"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/fields/field.py", "original_string": "    def test_instantiate_ifield_error(self):\n        \"\"\"Ensure that the abstract base class raises a TypeError\n        if you try to instantiate it directly\"\"\"\n        self.assertRaises(TypeError, IField, 'f')\n", "docstring": "Ensure that the abstract base class raises a TypeError"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/fields/validations.py", "original_string": "    def test_validate_type(self):\n        \"\"\"Success case for validate_type\"\"\"\n        f = Field('f')\n        obj = object()\n        resp = validate_type(f, object, obj)\n        self.assertIs(resp, obj)\n", "docstring": "Success case for validate_type\n"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/fields/validations.py", "original_string": "    def test_validate_size(self):\n        \"\"\"Success case for validate size\"\"\"\n        f = Field('blah')\n        obj = 10\n        resp = validate_size(f, obj, obj, minimum=10, maximum=10)\n        self.assertEqual(resp, obj)\n", "docstring": "Success case for validate size\n"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/fields/validations.py", "original_string": "    def test_validate_size_too_large(self):\n        f = Field('blah')\n        obj = 10\n        self.assertRaises(ValidationException, validate_size, f, obj, obj, maximum=9)\n", "docstring": "f = Field('blah')"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/fields/validations.py", "original_string": "    def test_validate_regex_failure(self):\n        \"\"\"Failure case for validate_regex\"\"\"\n        regex = re.compile(r'something')\n        f = Field('f')\n        obj = 'notthatsome'\n        self.assertRaises(ValidationException, validate_regex, f, obj, regex)\n", "docstring": "Failure case for validate_regex\n"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/fields/validations.py", "original_string": "    def test_basic_validation(self):\n        \"\"\"Success case for basic_validation\"\"\"\n        f = Field('f', required=True)\n        obj = object()\n        resp = basic_validation(f, obj, skip_required=False)\n        self.assertIs(resp, obj)\n", "docstring": "Success case for basic_validation\n"}
{"repo": "ripozo-master/ripozo_tests/unit/resources/fields/validations.py", "original_string": "    def test_basic_validation_none_object(self, validate_type):\n        \"\"\"Check that validate_type is not called when object is None\"\"\"\n        f = Field('f')\n        basic_validation(f, None)\n        self.assertFalse(validate_type.called)\n        # Also ensure that it is called\n        basic_validation(f, object())\n        self.assertTrue(validate_type.called)\n", "docstring": "Check that validate_type is not called when object is None\n"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/dispatch_base.py", "original_string": "    def test_overriding_adapters(self):\n        \"\"\"Tests whether overriding adapters raises an exception\"\"\"\n        adapters = (SirenAdapter, HalAdapter)\n        self.dispatcher.register_adapters(*adapters)\n        # This will have the same formats as the SirenAdapter\n        class TempAdapter(SirenAdapter):\n            pass\n        self.assertRaises(AdapterFormatAlreadyRegisteredException, self.dispatcher.register_adapters, TempAdapter)\n", "docstring": "Tests whether overriding adapters raises an exception\n"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/dispatch_base.py", "original_string": "    def test_register_mutiple_resource_classes(self, mck):\n        mockKlass = Mock(relationships=[], links=[])\n        mockKlass.endpoint_dictionary = Mock(return_value=dict(\n            first=[dict(route='/2/first', methods=['GET'])],\n            second=[\n                dict(route='/2/second', methods=['GET'], other='something', andanother='skdfmsdkf'),\n            ]\n        ))\n        mockKlass.__name__ = 'mockKlass2'\n        self.dispatcher.register_resources(mockKlass, self.mockKlass)\n        self.assertEqual(mck.call_count, 5)\n", "docstring": "mockKlass = Mock(relationships=[], links=[])"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/adapters/siren.py", "original_string": "    def test_relationship_single(self):\n        class RelationshipResource(ResourceBase):\n            _relationships = [\n                Relationship('first_link', relation='RelatedResource'),\n                Relationship('second_link', relation='RelatedResource', embedded=True)\n            ]\n        class RelatedResource(ResourceBase):\n            pks = ['id']\n        properties = dict(\n            first_link=dict(\n                id=1,\n                prop='another'\n            ),\n            second_link=dict(\n                id=2,\n                prop='value'\n            )\n        )\n        lr = RelationshipResource(properties=properties)\n        adapter = SirenAdapter(lr)\n        data = json.loads(adapter.formatted_body)\n        entities = data['entities']\n        has_second = False\n        has_first = False\n        for ent in entities:\n            if 'second_link' in ent['rel']:\n                self.assertIn('properties', ent)\n                self.assertEqual(ent['properties']['id'], 2)\n                self.assertEqual(ent['properties']['prop'], 'value')\n                has_second = True\n            elif 'first_link' in ent['rel']:\n                assert 'properties' not in ent\n                self.assertEqual(ent['href'], '/related_resource/1')\n                has_first = True\n        self.assertTrue(has_first)\n        self.assertTrue(has_second)\n", "docstring": "class RelationshipResource(ResourceBase):"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/adapters/siren.py", "original_string": "    def test_generate_entity_not_all_pks(self):\n        class Fake(ResourceBase):\n            pks = ('id',)\n        f = Fake(properties=dict(val='something'))\n        adapter = SirenAdapter(f)\n        resp = adapter.generate_entity(f, 'blah', True)\n        # Ensure that it is an empty generator\n        for r in resp:\n            assert False\n", "docstring": "class Fake(ResourceBase):"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/adapters/hal.py", "original_string": "    def test_embedded_relationships(self):\n        class Fake(ResourceBase):\n            pass\n        props = dict(\n            _embedded={},\n            _links=dict(self=dict(href='/fake')),\n            val=1, val2=2\n        )\n        rel = Fake(properties=props)\n        adapter = HalAdapter(None)\n        resp = adapter._generate_relationship(rel, True)\n        self.assertEqual(resp, props)\n", "docstring": "class Fake(ResourceBase):"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/adapters/boring_json.py", "original_string": "    def test_format_request(self):\n        \"\"\"Dumb test for format_request\"\"\"\n        request = RequestContainer()\n        response = BasicJSONAdapter.format_request(request)\n        self.assertIs(response, request)\n", "docstring": "Dumb test for format_request\n"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/adapters/jsonapi.py", "original_string": "    def test_construct_pks_no_pks(self):\n        \"\"\"When there are no ids\"\"\"\n        class MyResource(ResourceBase):\n            pks = tuple()\n        response = JSONAPIAdapter._construct_id(MyResource())\n        self.assertEqual(response, '')\n", "docstring": "When there are no ids\n"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/adapters/jsonapi.py", "original_string": "    def test_construct_pks_multiple_pks(self):\n        \"\"\"Constructing a single id from multiple\"\"\"\n        class MyResource(ResourceBase):\n            pks = 'id', 'pk'\n        response = JSONAPIAdapter._construct_id(MyResource(properties=dict(id=1, pk=2)))\n        self.assertEqual(response, '1/2')\n", "docstring": "Constructing a single id from multiple\n"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/adapters/jsonapi.py", "original_string": "    def test_construct_data_embedded(self):\n        \"\"\"Ensures that reltionships, links, and attributes are included\"\"\"\n        class MyResource(ResourceBase):\n            pks = 'id',\n        res = MyResource(properties=dict(id=1, field='value'))\n        adapter = JSONAPIAdapter(resource=res)\n        resp = adapter._construct_data(res, embedded=True)\n        self.assertDictEqual(resp['relationships'], dict())\n        self.assertDictEqual(resp['attributes'], res.properties)\n        self.assertDictEqual(dict(self='/my_resource/1'), resp['links'])\n        self.assertEqual('1', resp['id'])\n        self.assertEqual('my_resource', resp['type'])\n", "docstring": "Ensures that reltionships, links, and attributes are included\n"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/adapters/jsonapi.py", "original_string": "    def test_construct_links_no_links(self):\n        \"\"\"Constructing links when there are not any\"\"\"\n        class MyResource(ResourceBase):\n            pks = 'id',\n        res = MyResource(properties=dict(id=1, field='value'))\n        adapter = JSONAPIAdapter(resource=res)\n        resp = adapter._construct_links(res)\n        self.assertDictEqual(dict(self='/my_resource/1'), resp)\n", "docstring": "Constructing links when there are not any\n"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/adapters/jsonapi.py", "original_string": "    def test_format_request(self):\n        \"\"\"Expected case\"\"\"\n        req = RequestContainer(body_args=dict(data=dict(attributes=dict(id=1))))\n        resp = JSONAPIAdapter.format_request(req)\n        self.assertDictEqual(resp.body_args, dict(id=1))\n", "docstring": "Expected case\n"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/adapters/jsonapi.py", "original_string": "    def test_parse_id_invalid_type(self):\n        \"\"\"Asserts exception raised when resource_name is not valid\"\"\"\n        self.assertRaises(JSONAPIFormatException, JSONAPIAdapter._parse_id, 'id', 'fake_resource')\n", "docstring": "Asserts exception raised when resource_name is not valid\n"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/adapters/jsonapi.py", "original_string": "    def test_parse_id(self):\n        \"\"\"Normal case\"\"\"\n        class MyResource(ResourceBase):\n            pks = 'pk', 'id',\n        id_ = '1/2'\n        resp = JSONAPIAdapter._parse_id(id_, 'my_resource')\n        self.assertDictEqual(dict(pk='1', id='2'), resp)\n", "docstring": "Normal case\n"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/adapters/jsonapi.py", "original_string": "    def test_format_exception(self):\n        \"\"\"For when a non ripozo exception is passed in\"\"\"\n        exc = Exception('some message')\n        body, content_type, status_code = JSONAPIAdapter.format_exception(exc)\n        body = json.loads(body)\n        expected = dict(\n            errors=[\n                dict(status=500, title='Exception', detail='some message')\n            ]\n        )\n        self.assertDictEqual(expected, body)\n        self.assertEqual(content_type, 'application/vnd.api+json')\n        self.assertEqual(status_code, 500)\n", "docstring": "For when a non ripozo exception is passed in\n"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/adapters/jsonapi.py", "original_string": "    def test_construct_relationship_list(self):\n        \"\"\"A ListRelationship instance\"\"\"\n        class MyResource(ResourceBase):\n            _relationships = ListRelationship('related', relation='RelatedResource'),\n        class RelatedResource(ResourceBase):\n            pks = 'id',\n        res = MyResource(properties=dict(related=[dict(id=2), dict(id=1)]))\n        adapter = JSONAPIAdapter(res, base_url='/blah')\n        resp = adapter._construct_relationships(res)\n        self.assertIn('related', resp)\n        self.assertIn('data', resp['related'])\n        data = resp['related']['data']\n        self.assertEqual(len(data), 2)\n        for related in data:\n            self.assertEqual(related['type'], 'related_resource')\n            self.assertTrue(related['links']['self'].startswith('/blah/related_resource'))\n", "docstring": "A ListRelationship instance\n"}
{"repo": "ripozo-master/ripozo_tests/unit/dispatch/adapters/jsonapi.py", "original_string": "    def test_formatted_body(self):\n        \"\"\"Simple explosion test\"\"\"\n        class MyResource(ResourceBase):\n            pks = 'id',\n        res = MyResource(properties=dict(id=1))\n        adapter = JSONAPIAdapter(res)\n        resp = adapter.formatted_body\n        body = json.loads(resp)\n        self.assertIn('data', body)\n        body = body['data']\n        self.assertEqual(body['id'], '1')\n        self.assertEqual(body['type'], 'my_resource')\n        self.assertDictEqual(body['links'], dict(self='/my_resource/1'))\n        self.assertDictEqual(body['attributes'], dict(id=1))\n", "docstring": "Simple explosion test\n"}
{"repo": "ripozo-master/ripozo_tests/integration/relationships.py", "original_string": "    def test_link_to_list_of_child_resources(self):\n        \"\"\"Tests whether there can be a relationship\n        That simply provides a link to a list of the children of\n        the resource.  In otherwords, they are not embedded in any\n        way.  Not even the child links\"\"\"\n        class Parent(ResourceBase):\n            pks = 'id',\n            _relationships = Relationship('children', relation='Child',\n                                          property_map=dict(id='parent_id'),\n                                          query_args=['parent_id'], no_pks=True,\n                                          remove_properties=False),\n        class Child(ResourceBase):\n            resource_name = 'child'\n            pks = 'id',\n        props = dict(id=1, name='something')\n        parent = Parent(properties=props)\n        link_to_children = parent.related_resources[0].resource\n        self.assertEqual(link_to_children.url, '/child?parent_id=1')\n        self.assertEqual(parent.url, '/parent/1')\n", "docstring": "Tests whether there can be a relationship"}
{"repo": "ripozo-master/ripozo_tests/integration/manager_base.py", "original_string": "    def test_abstact_method_pissing_me_off(self):\n        class Manager(InMemoryManager):\n            pass\n        self.assertIsInstance(super(Manager, Manager()).get_field_type('blah'), BaseField)\n", "docstring": "class Manager(InMemoryManager):"}
{"repo": "ripozo-master/ripozo_tests/integration/restmixins.py", "original_string": "    def assertListEquivalent(self, l1, l2):\n        \"\"\"Getting some weird issue in pypy where\n        a list is getting flipped.  It is not critical\n        to be ordered so this is a temporary fix\"\"\"\n        # TODO figure out what is going on in pypy\n        self.assertEqual(len(l1), len(l2))\n        for item in l1:\n            self.assertIn(item, l2)\n", "docstring": "Getting some weird issue in pypy where"}
{"repo": "ripozo-master/ripozo_tests/integration/restmixins.py", "original_string": "    def test_retrieve(self):\n        id_ = uuid.uuid4()\n        model = dict(id=id_, first=1, second=2)\n        self.manager.objects[model['id']] = model\n        req = RequestContainer(url_params=dict(id=id_))\n        resource = self.resource_class.retrieve(req)\n        self.assertDictEqual(resource.properties, model)\n", "docstring": "id_ = uuid.uuid4()"}
{"repo": "ripozo-master/ripozo_tests/integration/restmixins.py", "original_string": "    def test_list_translate_fields(self):\n        \"\"\"Ensures that only the create_fields\n        are available\"\"\"\n        class ListManager(InMemoryManager):\n            fields = 'id', 'first', 'second',\n            list_fields = 'first', 'second',\n        class ListResource(self.resource_base):\n            manager = ListManager()\n            pks = 'id',\n        names = [f.name for f in ListResource.retrieve_list.fields(ListResource.manager)]\n        self.assertListEquivalent(('second', 'first',), tuple(names))\n", "docstring": "Ensures that only the create_fields"}
{"repo": "ripozo-master/ripozo_tests/integration/restmixins.py", "original_string": "    def test_update_translate_fields(self):\n        \"\"\"Ensures that only the update_fields\n        are available\"\"\"\n        class UpdateManager(InMemoryManager):\n            fields = 'id', 'first', 'second',\n            update_fields = 'first', 'second',\n        class UpdateResource(self.resource_base):\n            manager = UpdateManager()\n            pks = 'id',\n        names = [f.name for f in UpdateResource.update.fields(UpdateResource.manager)]\n        self.assertListEquivalent(('second', 'first',), tuple(names))\n", "docstring": "Ensures that only the update_fields"}
{"repo": "ripozo-master/ripozo/decorators.py", "original_string": "            def hello(cls, request):\n                id_ = request.query_args['id']\n                print(id_)\n", "docstring": "id_ = request.query_args['id']"}
{"repo": "ripozo-master/ripozo/decorators.py", "original_string": "    def __init__(self, fields=None, skip_required=False,\n                 validate=False, fields_attr='fields'):\n        \"\"\"A special case translation that inspects the manager\n        to get the relevant fields.  This is purely for ease of use\n        and may not be maintained\n        :param list[ripozo.resources.fields.base.BaseField] fields: A\n            list of fields to translate\n        :param bool skip_required: If true, it will not require\n            any of the fields.  Only relevant when validate is True\n        :param bool validate: A flag that indicates whether validation\n            should occur.\n        :param str|unicode fields_attr: The name of the attribute\n            to access on the manager to get the fields that are necessary.\n            e.g. `'create_fields'`, `'list_fields'` or whatever you want.\n            The attribute should be a list of strings\n        \"\"\"\n        self.original_fields = fields or []\n        self.skip_required = skip_required\n        self.validate = validate\n        self.fields_attr = fields_attr\n        self.cls = None\n", "docstring": "A special case translation that inspects the manager"}
{"repo": "ripozo-master/ripozo/utilities.py", "original_string": "        def my_preprocessor(resource_class, func_name, request):\n            # Do something\n", "docstring": "Do something"}
{"repo": "ripozo-master/ripozo/resources/request.py", "original_string": "    def url_params(self, value):\n        self._url_params = value\n", "docstring": "self._url_params = value"}
{"repo": "ripozo-master/ripozo/resources/request.py", "original_string": "    def query_args(self, value):\n        self._query_args = value\n", "docstring": "self._query_args = value"}
{"repo": "ripozo-master/ripozo/resources/request.py", "original_string": "    def body_args(self, value):\n        self._body_args = value\n", "docstring": "self._body_args = value"}
{"repo": "ripozo-master/ripozo/resources/request.py", "original_string": "    def headers(self, value):\n        self._headers = value\n", "docstring": "self._headers = value"}
{"repo": "ripozo-master/ripozo/resources/request.py", "original_string": "    def content_type(self, value):\n        self._headers['Content-Type'] = value\n", "docstring": "self._headers['Content-Type'] = value"}
{"repo": "ripozo-master/ripozo/resources/restmixins.py", "original_string": "    def get_base_links(actual_class):\n        return (Relationship('created', relation=actual_class.__name__, embedded=True), )\n", "docstring": "return (Relationship('created', relation=actual_class.__name__, embedded=True), )"}
{"repo": "ripozo-master/ripozo/resources/fields/common.py", "original_string": "    def field_type(self):\n        raise NotImplementedError\n", "docstring": "raise NotImplementedError"}
{"repo": "ripozo-master/ripozo/resources/fields/common.py", "original_string": "    def _translate(self, obj, skip_required=False):\n        if not hasattr(obj, 'get'):\n            raise TranslationException(self.error_message or\n                                       'A dictionary field must have a get method '\n                                       'that allows for retrieving an item with a default. '\n                                       'For example a dictionary.')\n        return obj\n", "docstring": "if not hasattr(obj, 'get'):"}
{"repo": "Anime-InPainting-master/scripts/fid_score.py", "original_string": "def calculate_fid_given_paths(paths, batch_size, cuda, dims):\n    \"\"\"Calculates the FID of two paths\"\"\"\n    for p in paths:\n        if not os.path.exists(p):\n            raise RuntimeError('Invalid path: %s' % p)\n    block_idx = InceptionV3.BLOCK_INDEX_BY_DIM[dims]\n    model = InceptionV3([block_idx])\n    if cuda:\n        model.cuda()\n    print('calculate path1 statistics...')\n    m1, s1 = _compute_statistics_of_path(paths[0], model, batch_size, dims, cuda)\n    print('calculate path2 statistics...')\n    m2, s2 = _compute_statistics_of_path(paths[1], model, batch_size, dims, cuda)\n    print('calculate frechet distance...')\n    fid_value = calculate_frechet_distance(m1, s1, m2, s2)\n    return fid_value\n", "docstring": "Calculates the FID of two paths\n"}
{"repo": "Anime-InPainting-master/src/utils.py", "original_string": "def canny_edge(img, mask, sigma=2, training=False):\n    # in test mode images are masked (with masked regions),\n    # using 'mask' parameter prevents canny to detect edges for the masked regions\n    mask = None if training else (1 - mask / 255).astype(np.bool)\n    # canny\n    # no edge\n    if sigma == -1:\n        return np.zeros(img.shape).astype(np.float)\n    # random sigma\n    if sigma == 0:\n        sigma = random.randint(1, 4)\n    return canny(img, sigma=sigma, mask=mask).astype(np.float)\n", "docstring": "in test mode images are masked (with masked regions),"}
{"repo": "Anime-InPainting-master/src/loss.py", "original_string": "    def __call__(self, x, y):\n        # Compute features\n        x_vgg, y_vgg = self.vgg(x), self.vgg(y)\n        # Compute loss\n        style_loss = 0.0\n        style_loss += self.criterion(self.compute_gram(x_vgg['relu2_2']), self.compute_gram(y_vgg['relu2_2']))\n        style_loss += self.criterion(self.compute_gram(x_vgg['relu3_4']), self.compute_gram(y_vgg['relu3_4']))\n        style_loss += self.criterion(self.compute_gram(x_vgg['relu4_4']), self.compute_gram(y_vgg['relu4_4']))\n        style_loss += self.criterion(self.compute_gram(x_vgg['relu5_2']), self.compute_gram(y_vgg['relu5_2']))\n        return style_loss\n", "docstring": "Compute features"}
{"repo": "arlo-master/arlo.py", "original_string": "    def __init__(self, username, password, google_credential_file=None):\n        # signals only work in main thread\n        try:\n            signal.signal(signal.SIGINT, self.interrupt_handler)\n        except:\n            pass\n        self.event_stream = None\n        self.request = None\n        if google_credential_file:\n          self.LoginMFA(username, password, google_credential_file)\n        else:\n          self.Login(username, password)\n", "docstring": "signals only work in main thread"}
{"repo": "arlo-master/arlo.py", "original_string": "    def Logout(self):\n        self.Unsubscribe()\n        return self.request.put(f'https://{self.BASE_URL}/hmsweb/logout')\n", "docstring": "self.Unsubscribe()"}
{"repo": "arlo-master/arlo.py", "original_string": "    def Unsubscribe(self):\n        \"\"\" This method stops the EventStream subscription and removes it from the event_stream collection. \"\"\"\n        if self.event_stream and self.event_stream.connected:\n            self.request.get(f'https://{self.BASE_URL}/hmsweb/client/unsubscribe')\n            self.event_stream.Disconnect()\n        self.event_stream = None\n", "docstring": "This method stops the EventStream subscription and removes it from the event_stream collection. \n"}
{"repo": "arlo-master/arlo.py", "original_string": "    def GetCameraState(self, basestation):\n        return self.NotifyAndGetResponse(basestation, {\"action\":\"get\",\"resource\":\"cameras\",\"publishResponse\":False})\n", "docstring": "return self.NotifyAndGetResponse(basestation, {\"action\":\"get\",\"resource\":\"cameras\",\"publishResponse\":False})"}
{"repo": "arlo-master/arlo.py", "original_string": "    def GetCalendar(self, basestation):\n        return self.NotifyAndGetResponse(basestation, {\"action\":\"get\",\"resource\":\"schedule\",\"publishResponse\":False})\n", "docstring": "return self.NotifyAndGetResponse(basestation, {\"action\":\"get\",\"resource\":\"schedule\",\"publishResponse\":False})"}
{"repo": "arlo-master/arlo.py", "original_string": "    def GetModes(self, basestation):\n        \"\"\" DEPRECATED: This is the older API for getting the \"mode\". It still works, but GetModesV2 is the way the Arlo software does it these days. \"\"\"\n        return self.NotifyAndGetResponse(basestation, {\"action\":\"get\",\"resource\":\"modes\",\"publishResponse\":False})\n", "docstring": "DEPRECATED: This is the older API for getting the \"mode\". It still works, but GetModesV2 is the way the Arlo software does it these days. \n"}
{"repo": "arlo-master/arlo.py", "original_string": "    def CustomMode(self, device, mode, schedules=[]):\n        \"\"\" device can be any object that has parentId == deviceId. i.e., not a camera \"\"\"\n        if(device[\"deviceType\"].startswith(\"arloq\")):\n            return self.NotifyAndGetResponse(device, {\"from\":self.user_id+\"_web\", \"to\": device.get(\"parentId\"), \"action\":\"set\",\"resource\":\"modes\", \"transId\": self.genTransId(),\"publishResponse\":True,\"properties\":{\"active\":mode}})\n        else:\n            return self.request.post(f'https://{self.BASE_URL}/hmsweb/users/devices/automation/active', {'activeAutomations':[{'deviceId':device.get('deviceId'),'timestamp':self.to_timestamp(datetime.now()),'activeModes':[mode],'activeSchedules':schedules}]})\n", "docstring": "device can be any object that has parentId == deviceId. i.e., not a camera \n"}
{"repo": "arlo-master/arlo.py", "original_string": "    def SetMotionAlertsOn(self, basestation, sensitivity=5):\n        return self.NotifyAndGetResponse(basestation, {\"action\":\"set\",\"resource\":\"cameras/\"+basestation.get('deviceId'),\"publishResponse\":True,\"properties\":{\"motionDetection\":{\"armed\":True,\"sensitivity\":sensitivity,\"zones\":[]}}})\n", "docstring": "return self.NotifyAndGetResponse(basestation, {\"action\":\"set\",\"resource\":\"cameras/\"+basestation.get('deviceId'),\"publishResponse\":True,\"properties\":{\"motionDetection\":{\"armed\":True,\"sensitivity\":sensitivity,\"zones\":[]}}})"}
{"repo": "arlo-master/arlo.py", "original_string": "    def AlertNotificationMethods(self, basestation, action=\"disabled\", email=False, push=False):\n        \"\"\" action : disabled OR recordSnapshot OR recordVideo \"\"\"\n        return self.NotifyAndGetResponse(basestation, {\"action\":\"set\",\"resource\":\"cameras/\"+basestation.get('deviceId'),\"publishResponse\":True,\"properties\":{\"eventAction\":{\"actionType\":action,\"stopType\":\"timeout\",\"timeout\":15,\"emailNotification\":{\"enabled\":email,\"emailList\":[\"__OWNER_EMAIL__\"]},\"pushNotification\":push}}})\n", "docstring": "action : disabled OR recordSnapshot OR recordVideo \n"}
{"repo": "arlo-master/arlo.py", "original_string": "    def GetServiceLevelV2(self):\n        \"\"\" DEPRECATED: This API still works, but I don't see it being called in the web UI anymore. \"\"\"\n        return self.request.get(f'https://{self.BASE_URL}/hmsweb/users/serviceLevel/v2')\n", "docstring": "DEPRECATED: This API still works, but I don't see it being called in the web UI anymore. \n"}
{"repo": "arlo-master/arlo.py", "original_string": "    def GetPaymentOffersV2(self):\n        \"\"\" DEPRECATED: This API still works, but I don't see it being called in the web UI anymore. \"\"\"\n        return self.request.get(f'https://{self.BASE_URL}/hmsweb/users/payment/offers/v2')\n", "docstring": "DEPRECATED: This API still works, but I don't see it being called in the web UI anymore. \n"}
{"repo": "arlo-master/arlo.py", "original_string": "        def is_device(device):\n            return device['deviceName'] == device_name\n", "docstring": "return device['deviceName'] == device_name"}
{"repo": "arlo-master/arlo.py", "original_string": "    def GetDeviceCapabilities(self, device):\n        model = device.get('modelId').lower()\n        return self.request.get(f'https://{self.BASE_URL}/resources/capabilities/'+model+'/'+model+'_'+device.get('interfaceVersion')+'.json', raw=True)\n", "docstring": "model = device.get('modelId').lower()"}
{"repo": "arlo-master/arlo.py", "original_string": "    def UpdateDeviceName(self, device, name):\n        return self.request.put(f'https://{self.BASE_URL}/hmsweb/users/devices/renameDevice', {'deviceId':device.get('deviceId'), 'deviceName':name, 'parentId':device.get('parentId')})\n", "docstring": "return self.request.put(f'https://{self.BASE_URL}/hmsweb/users/devices/renameDevice', {'deviceId':device.get('deviceId'), 'deviceName':name, 'parentId':device.get('parentId')})"}
{"repo": "arlo-master/arlo.py", "original_string": "        def trigger(self):\n            nl.stream_url_dict = self.request.post(f'https://{self.BASE_URL}/hmsweb/users/devices/startStream', {\"to\":camera.get('parentId'),\"from\":self.user_id+\"_web\",\"resource\":\"cameras/\"+camera.get('deviceId'),\"action\":\"set\",\"responseUrl\":\"\", \"publishResponse\":True,\"transId\":self.genTransId(),\"properties\":{\"activityState\":\"startUserStream\",\"cameraId\":camera.get('deviceId')}}, headers={\"xcloudId\":camera.get('xCloudId')})\n", "docstring": "nl.stream_url_dict = self.request.post(f'https://{self.BASE_URL}/hmsweb/users/devices/startStream', {\"to\":camera.get('parentId'),\"from\":self.user_id+\"_web\",\"resource\":\"cameras/\"+camera.get('deviceId'),\"action\":\"set\",\"responseUrl\":\"\", \"publishResponse\":True,\"transId\":self.genTransId(),\"properties\":{\"activityState\":\"startUserStream\",\"cameraId\":camera.get('deviceId')}}, headers={\"xcloudId\":camera.get('xCloudId')})"}
{"repo": "arlo-master/arlo.py", "original_string": "    def StopStream(self, basestation, camera):\n        # nonlocal variable hack for Python 2.x.\n        class nl:\n            stream_url_dict = None\n        def trigger(self):\n            self.request.post(f'https://{self.BASE_URL}/hmsweb/users/devices/stopStream', {\"to\":camera.get('parentId'),\"from\":self.user_id+\"_web\",\"resource\":\"cameras/\"+camera.         get('deviceId'),\"action\":\"set\",\"responseUrl\":\"\", \"publishResponse\":True,\"transId\":self.genTransId(),\"properties\":{\"activityState\":\"stopUserStream\",\"cameraId\":camera.get('deviceId')}}, headers={\"xcloudId\": camera.get('xCloudId')})\n        def callback(self, event):\n            if event.get(\"from\") == basestation.get(\"deviceId\") and event.get(\"resource\") == \"cameras/\"+camera.get(\"deviceId\") and event.get(\"properties\", {}).get(\"activityState\") == \"userStreamActive\":\n                return nl.stream_url_dict['url'].replace(\"rtsp://\", \"rtsps://\")\n            return None\n        return self.TriggerAndHandleEvent(basestation, trigger, callback)\n", "docstring": "nonlocal variable hack for Python 2.x."}
{"repo": "arlo-master/examples/arlo-motiondetect.py", "original_string": "    def callback(arlo, event):\n        # Here you will have access to self, basestation_id, xcloud_id, and the event schema.\n        print(\"motion event detected!\")\n", "docstring": "Here you will have access to self, basestation_id, xcloud_id, and the event schema."}
{"repo": "arlo-master/dev/html2text.py", "original_string": "def onlywhite(line):\n    \"\"\"Return true if the line does only consist of whitespace characters.\"\"\"\n    for c in line:\n        if c is not ' ' and c is not '  ':\n            return c is ' '\n    return line\n", "docstring": "Return true if the line does only consist of whitespace characters.\n"}
{"repo": "arlo-master/dev/html2text.py", "original_string": "def dumb_property_dict(style):\n    \"\"\"returns a hash of css attributes\"\"\"\n    return dict([(x.strip(), y.strip()) for x, y in [z.split(':', 1) for z in style.split(';') if ':' in z]]);\n", "docstring": "returns a hash of css attributes\n"}
{"repo": "arlo-master/dev/html2text.py", "original_string": "def element_style(attrs, style_def, parent_style):\n    \"\"\"returns a hash of the 'final' style attributes of the element\"\"\"\n    style = parent_style.copy()\n    if 'class' in attrs:\n        for css_class in attrs['class'].split():\n            css_style = style_def['.' + css_class]\n            style.update(css_style)\n    if 'style' in attrs:\n        immediate_style = dumb_property_dict(attrs['style'])\n        style.update(immediate_style)\n    return style\n", "docstring": "returns a hash of the 'final' style attributes of the element\n"}
{"repo": "arlo-master/dev/html2text.py", "original_string": "def google_has_height(style):\n    \"\"\"check if the style of the element has the 'height' attribute explicitly defined\"\"\"\n    if 'height' in style:\n        return True\n    return False\n", "docstring": "check if the style of the element has the 'height' attribute explicitly defined\n"}
{"repo": "arlo-master/dev/html2text.py", "original_string": "def google_fixed_width_font(style):\n    \"\"\"check if the css of the current element defines a fixed width font\"\"\"\n    font_family = ''\n    if 'font-family' in style:\n        font_family = style['font-family']\n    if 'Courier New' == font_family or 'Consolas' == font_family:\n        return True\n    return False\n", "docstring": "check if the css of the current element defines a fixed width font\n"}
{"repo": "arlo-master/dev/html2text.py", "original_string": "    def optwrap(self, text):\n        \"\"\"Wrap all paragraphs in the provided text.\"\"\"\n        if not self.body_width:\n            return text\n        assert wrap, \"Requires Python 2.3.\"\n        result = ''\n        newlines = 0\n        for para in text.split(\"\\n\"):\n            if len(para) > 0:\n                if not skipwrap(para):\n                    result += \"\\n\".join(wrap(para, self.body_width))\n                    if para.endswith('  '):\n                        result += \"  \\n\"\n                        newlines = 1\n                    else:\n                        result += \"\\n\\n\"\n                        newlines = 2\n                else:\n                    if not onlywhite(para):\n                        result += para + \"\\n\"\n                        newlines = 1\n            else:\n                if newlines < 2:\n                    result += \"\\n\"\n                    newlines += 1\n        return result\n", "docstring": "Wrap all paragraphs in the provided text.\n"}
{"repo": "arlo-master/dev/html2text.py", "original_string": "def skipwrap(para):\n    # If the text begins with four spaces or one tab, it's a code block; don't wrap\n    if para[0:4] == '    ' or para[0] == '\\t':\n        return True\n    # If the text begins with only two \"--\", possibly preceded by whitespace, that's\n    # an emdash; so wrap.\n    stripped = para.lstrip()\n    if stripped[0:2] == \"--\" and len(stripped) > 2 and stripped[2] != \"-\":\n        return False\n    # I'm not sure what this is for; I thought it was to detect lists, but there's\n    # a <br>-inside-<span> case in one of the tests that also depends upon it.\n    if stripped[0:1] == '-' or stripped[0:1] == '*':\n        return True\n    # If the text begins with a single -, *, or +, followed by a space, or an integer,\n    # followed by a ., followed by a space (in either case optionally preceeded by\n    # whitespace), it's a list; don't wrap.\n    if ordered_list_matcher.match(stripped) or unordered_list_matcher.match(stripped):\n        return True\n    return False\n", "docstring": "If the text begins with four spaces or one tab, it's a code block; don't wrap"}
{"repo": "arlo-master/dev/html2text.py", "original_string": "def escape_md(text):\n    \"\"\"Escapes markdown-sensitive characters within other markdown constructs.\"\"\"\n    return md_chars_matcher.sub(r\"\\\\\\1\", text)\n", "docstring": "Escapes markdown-sensitive characters within other markdown constructs.\n"}
{"repo": "unicorn-binance-websocket-api-master/example_process_streams.py", "original_string": "    def aggtrade(stream_data):\n        # print `aggTrade` data\n        print(stream_data)\n", "docstring": "print `aggTrade` data"}
{"repo": "unicorn-binance-websocket-api-master/example_process_streams.py", "original_string": "    def trade(stream_data):\n        # print `trade` data\n        print(stream_data)\n", "docstring": "print `trade` data"}
{"repo": "unicorn-binance-websocket-api-master/example_process_streams.py", "original_string": "    def kline(stream_data):\n        # print `kline` data\n        print(stream_data)\n", "docstring": "print `kline` data"}
{"repo": "unicorn-binance-websocket-api-master/example_process_streams.py", "original_string": "    def miniticker(stream_data):\n        # print `miniTicker` data\n        print(stream_data)\n", "docstring": "print `miniTicker` data"}
{"repo": "unicorn-binance-websocket-api-master/example_process_streams.py", "original_string": "    def ticker(stream_data):\n        # print `ticker` data\n        print(stream_data)\n", "docstring": "print `ticker` data"}
{"repo": "unicorn-binance-websocket-api-master/example_process_streams.py", "original_string": "    def depth(stream_data):\n        # print `depth` data\n        print(stream_data)\n", "docstring": "print `depth` data"}
{"repo": "unicorn-binance-websocket-api-master/example_process_streams.py", "original_string": "    def outboundAccountInfo(stream_data):\n        # print `outboundAccountInfo` data from userData stream\n        print(stream_data)\n", "docstring": "print `outboundAccountInfo` data from userData stream"}
{"repo": "unicorn-binance-websocket-api-master/example_process_streams.py", "original_string": "    def executionReport(stream_data):\n        # print `executionReport` data from userData stream\n        print(stream_data)\n", "docstring": "print `executionReport` data from userData stream"}
{"repo": "unicorn-binance-websocket-api-master/unicorn_binance_websocket_api/unicorn_binance_websocket_api_manager.py", "original_string": "        def redirect_to_wiki():\n            logging.info(\"BinanceWebSocketApiManager._start_monitoring_api_thread() 200 - \"\n                         \"Visit https://github.com/oliver-zehentleitner/unicorn-binance-websocket-api/wiki/UNICORN-\"\n                         \"Monitoring-API-Service for further information!\")\n            return redirect(\"https://github.com/oliver-zehentleitner/unicorn-binance-websocket-api/wiki/\"\n                            \"UNICORN-Monitoring-API-Service\", code=302)\n", "docstring": "logging.info(\"BinanceWebSocketApiManager._start_monitoring_api_thread() 200 - \""}
{"repo": "unicorn-binance-websocket-api-master/unicorn_binance_websocket_api/unicorn_binance_websocket_api_restclient.py", "original_string": "    def _init_vars(self,\n                   stream_id,\n                   api_key=False,\n                   api_secret=False,\n                   symbol=False,\n                   listen_key=False,\n                   last_static_ping_listen_key=False):\n        \"\"\"\n        set default values and load values from stream_list\n        :param stream_id: provide a stream_id (only needed for userData Streams (acquiring a listenKey)\n        :type stream_id: uuid\n        :param api_key: provide a valid Binance API key\n        :type api_key: str\n        :param api_secret: provide a valid Binance API secret\n        :type api_secret: str\n        :param symbol: provide the symbol for isolated_margin user_data listen_key\n        :type symbol: str\n        :param listen_key: provide the listen_key\n        :type listen_key: str\n        :param listen_key: the `last_static_ping_listen_key` variable of the `listen_key` you want to keepalive\n        :type listen_key: int\n        :return: bool\n        \"\"\"\n        self.api_key = api_key\n        self.api_secret = api_secret\n        self.listen_key = listen_key\n        self.symbol = symbol\n        self.last_static_ping_listen_key = last_static_ping_listen_key\n        self.listen_key_output = self.manager.replaced_secrets_text\n        try:\n            if self.api_key is False:\n                self.api_key = self.manager.stream_list[stream_id]['api_key']\n            if self.api_secret is False:\n                self.api_secret = self.manager.stream_list[stream_id]['api_secret']\n            if self.symbol is False:\n                self.symbol = self.manager.stream_list[stream_id]['symbols']\n            if self.listen_key is False:\n                self.listen_key = self.manager.stream_list[stream_id]['listen_key']\n            if self.last_static_ping_listen_key is False:\n                self.last_static_ping_listen_key = self.manager.stream_list[stream_id]['last_static_ping_listen_key']\n            if self.manager.show_secrets_in_logs is True:\n                self.listen_key_output = self.listen_key\n        except KeyError as error_msg:\n            logging.error(f\"BinanceWebSocketApiRestclient.init_vars() - TypeError - error_msg: {str(error_msg)}\")\n            return False\n        return True\n", "docstring": "stream_id,"}
{"repo": "fuzzyfinder-master/fuzzyfinder/__init__.py", "original_string": "def export(defn):\n    \"\"\"Decorator to explicitly mark functions that are exposed in a lib.\"\"\"\n    globals()[defn.__name__] = defn\n    __all__.append(defn.__name__)\n    return defn\n", "docstring": "Decorator to explicitly mark functions that are exposed in a lib.\n"}
{"repo": "calibre-master/bypy/macos/sign.py", "original_string": "def sign_MacOS(contents_dir='.'):\n    # Sign everything in MacOS except the main executable\n    # which will be signed automatically by codesign when\n    # signing the app bundles\n    with current_dir(os.path.join(contents_dir, 'MacOS')):\n        exe = get_executable('../Info.plist')\n        items = {x for x in os.listdir('.') if x != exe and not os.path.islink(x)}\n        if items:\n            codesign(items)\n", "docstring": "Sign everything in MacOS except the main executable"}
{"repo": "calibre-master/bypy/macos/site.py", "original_string": "def nuke_stdout():\n    # Redirect stdout, stdin and stderr to /dev/null\n    from calibre_extensions.speedup import detach\n    detach(os.devnull)\n", "docstring": "Redirect stdout, stdin and stderr to /dev/null"}
{"repo": "calibre-master/bypy/macos/__main__.py", "original_string": "    def ff(*args, **kwargs):\n        sys.stdout.flush()\n        sys.stderr.flush()\n        ret = func(*args, **kwargs)\n        sys.stdout.flush()\n        sys.stderr.flush()\n        return ret\n", "docstring": "sys.stdout.flush()"}
{"repo": "calibre-master/bypy/macos/__main__.py", "original_string": "    def makedmg(self, d, volname):\n        ''' Copy a directory d into a dmg named volname '''\n        print('\\nSigning...')\n        sys.stdout.flush()\n        destdir = OUTPUT_DIR\n        try:\n            shutil.rmtree(destdir)\n        except EnvironmentError as err:\n            if err.errno != errno.ENOENT:\n                raise\n        os.mkdir(destdir)\n        dmg = join(destdir, volname + '.dmg')\n        if os.path.exists(dmg):\n            os.unlink(dmg)\n        tdir = tempfile.mkdtemp()\n        appdir = join(tdir, os.path.basename(d))\n        shutil.copytree(d, appdir, symlinks=True)\n        if self.sign_installers or self.notarize:\n            with timeit() as times:\n                sign_app(appdir, self.notarize)\n            print('Signing completed in %d minutes %d seconds' % tuple(times))\n        os.symlink('/Applications', join(tdir, 'Applications'))\n        size_in_mb = int(subprocess.check_output(['du', '-s', '-k', tdir]).decode('utf-8').split()[0]) / 1024.\n        # UDBZ gives the best compression, better than ULFO\n        cmd = ['/usr/bin/hdiutil', 'create', '-srcfolder', tdir, '-volname', volname, '-format', 'UDBZ']\n        if 190 < size_in_mb < 250:\n            # We need -size 255m because of a bug in hdiutil. When the size of\n            # srcfolder is close to 200MB hdiutil fails with\n            # diskimages-helper: resize request is above maximum size allowed.\n            cmd += ['-size', '255m']\n        print('\\nCreating dmg...')\n        with timeit() as times:\n            subprocess.check_call(cmd + [dmg])\n        print('dmg created in %d minutes and %d seconds' % tuple(times))\n        shutil.rmtree(tdir)\n        size = os.stat(dmg).st_size / (1024 * 1024.)\n        print('\\nInstaller size: %.2fMB\\n' % size)\n        return dmg\n", "docstring": "Copy a directory d into a dmg named volname '''"}
{"repo": "calibre-master/bypy/windows/__main__.py", "original_string": "    def build(src, name, subsys='CONSOLE', libs='setupapi.lib'.split()):\n        printf('Building ' + name)\n        obj = j(env.obj_dir, os.path.basename(src) + '.obj')\n        cflags = '/c /EHsc /MD /W3 /Ox /nologo /D_UNICODE'.split()\n        ftype = '/T' + ('c' if src.endswith('.c') else 'p')\n        cmd = [CL] + cflags + ['/Fo' + obj, ftype + src]\n        run_compiler(env, *cmd)\n        exe = j(env.dll_dir, name)\n        mf = exe + '.manifest'\n        with open(mf, 'wb') as f:\n            f.write(EXE_MANIFEST.encode('utf-8'))\n        cmd = [LINK] + [\n            '/MACHINE:' + machine,\n            '/SUBSYSTEM:' + subsys, '/RELEASE', '/MANIFEST:EMBED', '/MANIFESTINPUT:' + mf,\n            '/OUT:' + exe] + [embed_resources(env, exe), obj] + libs\n        run(*cmd)\n", "docstring": "printf('Building ' + name)"}
{"repo": "calibre-master/bypy/linux/__main__.py", "original_string": "def strip_files(files, argv_max=(256 * 1024)):\n    \"\"\" Strip a list of files \"\"\"\n    while files:\n        cmd = list(STRIPCMD)\n        pathlen = sum(len(s) + 1 for s in cmd)\n        while pathlen < argv_max and files:\n            f = files.pop()\n            cmd.append(f)\n            pathlen += len(f) + 1\n        if len(cmd) > len(STRIPCMD):\n            all_files = cmd[len(STRIPCMD):]\n            unwritable_files = tuple(filter(None, (None if os.access(x, os.W_OK) else (x, os.stat(x).st_mode) for x in all_files)))\n            [os.chmod(x, stat.S_IWRITE | old_mode) for x, old_mode in unwritable_files]\n            subprocess.check_call(cmd)\n            [os.chmod(x, old_mode) for x, old_mode in unwritable_files]\n", "docstring": "Strip a list of files \n"}
{"repo": "calibre-master/setup/linux-installer.py", "original_string": "    def __init__(self, term_stream=sys.stdout):\n        # Curses isn't available on all platforms\n        try:\n            import curses\n        except:\n            return\n        # If the stream isn't a tty, then assume it has no capabilities.\n        if not hasattr(term_stream, 'isatty') or not term_stream.isatty():\n            return\n        # Check the terminal type.  If we fail, then assume that the\n        # terminal has no capabilities.\n        try:\n            curses.setupterm()\n        except:\n            return\n        # Look up numeric capabilities.\n        self.COLS = curses.tigetnum('cols')\n        self.LINES = curses.tigetnum('lines')\n        # Look up string capabilities.\n        for capability in self._STRING_CAPABILITIES:\n            (attrib, cap_name) = capability.split('=')\n            setattr(self, attrib, self._escape_code(self._tigetstr(cap_name)))\n        # Colors\n        set_fg = self._tigetstr('setf')\n        if set_fg:\n            if not isinstance(set_fg, bytes):\n                set_fg = set_fg.encode('utf-8')\n            for i,color in zip(range(len(self._COLORS)), self._COLORS):\n                setattr(self, color,\n                        self._escape_code(curses.tparm((set_fg), i)))\n        set_fg_ansi = self._tigetstr('setaf')\n        if set_fg_ansi:\n            if not isinstance(set_fg_ansi, bytes):\n                set_fg_ansi = set_fg_ansi.encode('utf-8')\n            for i,color in zip(range(len(self._ANSICOLORS)), self._ANSICOLORS):\n                setattr(self, color,\n                        self._escape_code(curses.tparm((set_fg_ansi),\n                            i)))\n        set_bg = self._tigetstr('setb')\n        if set_bg:\n            if not isinstance(set_bg, bytes):\n                set_bg = set_bg.encode('utf-8')\n            for i,color in zip(range(len(self._COLORS)), self._COLORS):\n                setattr(self, 'BG_'+color,\n                        self._escape_code(curses.tparm((set_bg), i)))\n        set_bg_ansi = self._tigetstr('setab')\n        if set_bg_ansi:\n            if not isinstance(set_bg_ansi, bytes):\n                set_bg_ansi = set_bg_ansi.encode('utf-8')\n            for i,color in zip(range(len(self._ANSICOLORS)), self._ANSICOLORS):\n                setattr(self, 'BG_'+color,\n                        self._escape_code(curses.tparm((set_bg_ansi),\n                            i)))\n", "docstring": "Curses isn't available on all platforms"}
{"repo": "calibre-master/setup/linux-installer.py", "original_string": "    def _tigetstr(self, cap_name):\n        # String capabilities can include \"delays\" of the form \"$<2>\".\n        # For any modern terminal, we should be able to just ignore\n        # these, so strip them out.\n        import curses\n        if isinstance(cap_name, bytes):\n            cap_name = cap_name.decode('utf-8')\n        cap = self._escape_code(curses.tigetstr(cap_name))\n        return re.sub(r'\\$<\\d+>[/*]?', '', cap)\n", "docstring": "String capabilities can include \"delays\" of the form \"$<2>\"."}
{"repo": "calibre-master/setup/linux-installer.py", "original_string": "    def http_error_206(self, req, fp, code, msg, hdrs):\n        # 206 Partial Content Response\n        r = addinfourl(fp, hdrs, req.get_full_url())\n        r.code = code\n        r.msg = msg\n        return r\n", "docstring": "206 Partial Content Response"}
{"repo": "calibre-master/setup/linux-installer.py", "original_string": "def _dnsname_match(dn, hostname, max_wildcards=1):\n    \"\"\"Matching according to RFC 6125, section 6.4.3\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\n    \"\"\"\n    pats = []\n    if not dn:\n        return False\n    parts = dn.split(r'.')\n    leftmost, remainder = parts[0], parts[1:]\n    wildcards = leftmost.count('*')\n    if wildcards > max_wildcards:\n        # Issue #17980: avoid denials of service by refusing more\n        # than one wildcard per fragment.  A survery of established\n        # policy among SSL implementations showed it to be a\n        # reasonable choice.\n        raise CertificateError(\n            \"too many wildcards in certificate DNS name: \" + repr(dn))\n    # speed up common case w/o wildcards\n    if not wildcards:\n        return dn.lower() == hostname.lower()\n    # RFC 6125, section 6.4.3, subitem 1.\n    # The client SHOULD NOT attempt to match a presented identifier in which\n    # the wildcard character comprises a label other than the left-most label.\n    if leftmost == '*':\n        # When '*' is a fragment by itself, it matches a non-empty dotless\n        # fragment.\n        pats.append('[^.]+')\n    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n        # RFC 6125, section 6.4.3, subitem 3.\n        # The client SHOULD NOT attempt to match a presented identifier\n        # where the wildcard character is embedded within an A-label or\n        # U-label of an internationalized domain name.\n        pats.append(re.escape(leftmost))\n    else:\n        # Otherwise, '*' matches any dotless string, e.g. www*\n        pats.append(re.escape(leftmost).replace(r'\\*', '[^.]*'))\n    # add the remaining fragments, ignore any wildcards\n    for frag in remainder:\n        pats.append(re.escape(frag))\n    pat = re.compile(r'\\A' + r'\\.'.join(pats) + r'\\Z', re.IGNORECASE)\n    return pat.match(hostname)\n", "docstring": "Matching according to RFC 6125, section 6.4.3"}
{"repo": "calibre-master/setup/linux-installer.py", "original_string": "def extract_tarball(raw, destdir):\n    prints('Extracting application files...')\n    with open('/dev/null', 'w') as null:\n        p = subprocess.Popen(\n            list(map(encode_for_subprocess, ['tar', 'xJof', '-', '-C', destdir])),\n            stdout=null, stdin=subprocess.PIPE, close_fds=True, preexec_fn=lambda:\n            signal.signal(signal.SIGPIPE, signal.SIG_DFL))\n        p.stdin.write(raw)\n        p.stdin.close()\n        if p.wait() != 0:\n            prints('Extracting of application files failed with error code: %s' % p.returncode)\n            raise SystemExit(1)\n", "docstring": "prints('Extracting application files...')"}
{"repo": "calibre-master/setup/linux-installer.py", "original_string": "def update_intaller_wrapper():\n    # To run: python3 -c \"import runpy; runpy.run_path('setup/linux-installer.py', run_name='update_wrapper')\"\n    with open(__file__, 'rb') as f:\n        src = f.read().decode('utf-8')\n    wrapper = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'linux-installer.sh')\n    with open(wrapper, 'r+b') as f:\n        raw = f.read().decode('utf-8')\n        nraw = re.sub(r'^# HEREDOC_START.+^# HEREDOC_END', lambda m: '# HEREDOC_START\\n{}\\n# HEREDOC_END'.format(src), raw, flags=re.MULTILINE | re.DOTALL)\n        if 'update_intaller_wrapper()' not in nraw:\n            raise SystemExit('regex substitute of HEREDOC failed')\n        f.seek(0), f.truncate()\n        f.write(nraw.encode('utf-8'))\n", "docstring": "To run: python3 -c \"import runpy; runpy.run_path('setup/linux-installer.py', run_name='update_wrapper')\""}
{"repo": "calibre-master/setup/upload.py", "original_string": "def upload_to_fosshub():\n    # https://devzone.fosshub.com/dashboard/restApi\n    # fosshub has no API to do partial uploads, so we always upload all files.\n    api_key = get_fosshub_data()\n    def request(path, data=None):\n        r = Request('https://api.fosshub.com/rest/' + path.lstrip('/'),\n                headers={\n                    'Content-Type': 'application/json',\n                    'X-auth-key': api_key,\n                    'User-Agent': 'calibre'\n        })\n        res = urlopen(r, data=data)\n        ans = json.loads(res.read())\n        if ans.get('error'):\n            raise SystemExit(ans['error'])\n        if res.getcode() != 200:\n            raise SystemExit('Request to {} failed with response code: {}'.format(path, res.getcode()))\n        # from pprint import pprint\n        # pprint(ans)\n        return ans['status'] if 'status' in ans else ans['data']\n    print('Sending upload request to fosshub...')\n    project_id = None\n    for project in request('projects'):\n        if project['name'].lower() == 'calibre':\n            project_id = project['id']\n            break\n    else:\n        raise SystemExit('No calibre project found')\n    files = set(installers())\n    entries = []\n    for fname in files:\n        desc = installer_description(fname)\n        url = 'https://download.calibre-ebook.com/%s/%s' % (\n            __version__, os.path.basename(fname)\n        )\n        entries.append({\n            'fileUrl': url,\n            'type': desc,\n            'version': __version__,\n        })\n    jq = {\n        'version': __version__,\n        'files': entries,\n        'publish': True,\n        'isOldRelease': False,\n    }\n    data = json.dumps(jq)\n    # print(data)\n    data = data.encode('utf-8')\n    if not request('projects/{}/releases/'.format(project_id), data=data):\n        raise SystemExit('Failed to queue publish job with fosshub')\n", "docstring": "https://devzone.fosshub.com/dashboard/restApi"}
{"repo": "calibre-master/setup/__init__.py", "original_string": "    def warn(self, *args, **kwargs):\n        print('\\n'+'_'*20, 'WARNING','_'*20)\n        prints(*args, **kwargs)\n        print('_'*50)\n        warnings.append((args, kwargs))\n        sys.stdout.flush()\n", "docstring": "print('\\n'+'_'*20, 'WARNING','_'*20)"}
{"repo": "calibre-master/setup/gui.py", "original_string": "    def form_to_compiled_form(cls, form):\n        # We do not use the calibre function form_to_compiled_form as\n        # importing calibre.gui2 may not work\n        return form.rpartition('.')[0]+'_ui.py'\n", "docstring": "We do not use the calibre function form_to_compiled_form as"}
{"repo": "calibre-master/setup/build.py", "original_string": "    def check_call(self, *args, **kwargs):\n        \"\"\"print cmdline if an error occured\n        If something is missing (qmake e.g.) you get a non-informative error\n         self.check_call(qmc + [ext.name+'.pro'])\n         so you would have to look at the source to see the actual command.\n        \"\"\"\n        try:\n            subprocess.check_call(*args, **kwargs)\n        except:\n            cmdline = ' '.join(['\"%s\"' % (arg) if ' ' in arg else arg for arg in args[0]])\n            print(\"Error while executing: %s\\n\" % (cmdline))\n            raise\n", "docstring": "print cmdline if an error occured"}
{"repo": "calibre-master/src/sgmllib.py", "original_string": "    def __init__(self, verbose=0):\n        \"\"\"Initialize and reset this instance.\"\"\"\n        self.verbose = verbose\n        self.reset()\n", "docstring": "Initialize and reset this instance.\n"}
{"repo": "calibre-master/src/sgmllib.py", "original_string": "    def setnomoretags(self):\n        \"\"\"Enter literal mode (CDATA) till EOF.\n        Intended for derived classes only.\n        \"\"\"\n        self.nomoretags = self.literal = 1\n", "docstring": "Enter literal mode (CDATA) till EOF."}
{"repo": "calibre-master/src/sgmllib.py", "original_string": "    def feed(self, data):\n        \"\"\"Feed some data to the parser.\n        Call this as often as you want, with as little or as much text\n        as you want (may include '\\n').  (This just saves the text,\n        all the processing is done by goahead().)\n        \"\"\"\n        self.rawdata = self.rawdata + data\n        self.goahead(0)\n", "docstring": "Feed some data to the parser."}
{"repo": "calibre-master/src/sgmllib.py", "original_string": "    def convert_entityref(self, name):\n        \"\"\"Convert entity references.\n        As an alternative to overriding this method; one can tailor the\n        results by setting up the self.entitydefs mapping appropriately.\n        \"\"\"\n        table = self.entitydefs\n        if name in table:\n            return table[name]\n        else:\n            return\n", "docstring": "Convert entity references."}
{"repo": "calibre-master/src/calibre/live.py", "original_string": "        def setUp(self):\n            global db_path, fetcher\n            fd, db_path = tempfile.mkstemp()\n            os.close(fd)\n            fetcher = self.fetch_module\n            self.fetched_module_version = 99999\n            self.sentinel_value = 1\n            self.fetch_counter = 0\n            self.orig_old_interval = old_interval\n", "docstring": "global db_path, fetcher"}
{"repo": "calibre-master/src/calibre/libunzip.py", "original_string": "def sort_key(filename):\n    bn, ext = filename.rpartition('.')[::2]\n    if not bn and ext:\n        bn, ext = ext, bn\n    return (numeric_sort_key(bn), numeric_sort_key(ext))\n", "docstring": "bn, ext = filename.rpartition('.')[::2]"}
{"repo": "calibre-master/src/calibre/constants.py", "original_string": "def get_version():\n    '''Return version string for display to user '''\n    if git_version is not None:\n        v = git_version\n    else:\n        v = __version__\n        if numeric_version[-1] == 0:\n            v = v[:-2]\n    if is_running_from_develop:\n        v += '*'\n    if iswindows and is64bit:\n        v += ' [64bit]'\n    return v\n", "docstring": "Return version string for display to user '''"}
{"repo": "calibre-master/src/calibre/rpdb.py", "original_string": "    def __init__(self, addr=\"127.0.0.1\", port=4444, skip=None):\n        # Open a reusable socket to allow for reloads\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n        self.sock.bind((addr, port))\n        self.sock.listen(1)\n        with suppress(OSError):\n            print(\"pdb is running on %s:%d\" % (addr, port), file=sys.stderr)\n        clientsocket, address = self.sock.accept()\n        clientsocket.setblocking(True)\n        self.clientsocket = clientsocket\n        self.handle = clientsocket.makefile('rw')\n        pdb.Pdb.__init__(self, completekey='tab', stdin=self.handle, stdout=self.handle, skip=skip)\n        self.prompt = PROMPT\n", "docstring": "Open a reusable socket to allow for reloads"}
{"repo": "calibre-master/src/calibre/__init__.py", "original_string": "def setup_cli_handlers(logger, level):\n    import logging\n    if hasenv('CALIBRE_WORKER') and logger.handlers:\n        return\n    logger.setLevel(level)\n    if level == logging.WARNING:\n        handler = logging.StreamHandler(sys.stdout)\n        handler.setFormatter(logging.Formatter('%(levelname)s: %(message)s'))\n        handler.setLevel(logging.WARNING)\n    elif level == logging.INFO:\n        handler = logging.StreamHandler(sys.stdout)\n        handler.setFormatter(logging.Formatter())\n        handler.setLevel(logging.INFO)\n    elif level == logging.DEBUG:\n        handler = logging.StreamHandler(sys.stderr)\n        handler.setLevel(logging.DEBUG)\n        handler.setFormatter(logging.Formatter('[%(levelname)s] %(filename)s:%(lineno)s: %(message)s'))\n    logger.addHandler(handler)\n", "docstring": "import logging"}
{"repo": "calibre-master/src/calibre/__init__.py", "original_string": "    def __init__(self, path):\n        self.path = path\n        self.cwd = None\n", "docstring": "self.path = path"}
{"repo": "calibre-master/src/calibre/__init__.py", "original_string": "def walk(dir):\n    ''' A nice interface to os.walk '''\n    for record in os.walk(dir):\n        for f in record[-1]:\n            yield os.path.join(record[0], f)\n", "docstring": "A nice interface to os.walk '''"}
{"repo": "calibre-master/src/calibre/__init__.py", "original_string": "def ipython(user_ns=None):\n    from calibre.utils.ipython import ipython\n    ipython(user_ns=user_ns)\n", "docstring": "from calibre.utils.ipython import ipython"}
{"repo": "calibre-master/src/calibre/customize/zipplugin.py", "original_string": "def load_translations(namespace, zfp):\n    null = object()\n    trans = _translations_cache.get(zfp, null)\n    if trans is None:\n        return\n    if trans is null:\n        from calibre.utils.localization import get_lang\n        lang = get_lang()\n        if not lang or lang == 'en':  # performance optimization\n            _translations_cache[zfp] = None\n            return\n        with zipfile.ZipFile(zfp) as zf:\n            try:\n                mo = zf.read('translations/%s.mo' % lang)\n            except KeyError:\n                mo = None  # No translations for this language present\n        if mo is None:\n            _translations_cache[zfp] = None\n            return\n        from gettext import GNUTranslations\n        from io import BytesIO\n        trans = _translations_cache[zfp] = GNUTranslations(BytesIO(mo))\n    namespace['_'] = trans.gettext\n    namespace['ngettext'] = trans.ngettext\n", "docstring": "null = object()"}
{"repo": "calibre-master/src/calibre/customize/builtins.py", "original_string": "    def create_widget(self, *args, **kwargs):\n        # The DOC Input plugin tries to override this\n        self.config_widget = 'calibre.gui2.preferences.conversion:InputOptions'\n        return PreferencesPlugin.create_widget(self, *args, **kwargs)\n", "docstring": "The DOC Input plugin tries to override this"}
{"repo": "calibre-master/src/calibre/customize/conversion.py", "original_string": "    def help(self):\n        return self.option.help\n", "docstring": "return self.option.help"}
{"repo": "calibre-master/src/calibre/customize/conversion.py", "original_string": "    def gui_configuration_widget(self, parent, get_option_by_name,\n            get_option_help, db, book_id=None):\n        '''\n        Called to create the widget used for configuring this plugin in the\n        calibre GUI. The widget must be an instance of the PluginWidget class.\n        See the builtin input plugins for examples.\n        '''\n        name = self.name.lower().replace(' ', '_')\n        return gui_configuration_widget(name, parent, get_option_by_name,\n                get_option_help, db, book_id, for_output=False)\n", "docstring": "get_option_help, db, book_id=None):"}
{"repo": "calibre-master/src/calibre/customize/conversion.py", "original_string": "    def description(self):\n        return _('Convert e-books to the %s format')%self.file_type.upper()\n", "docstring": "return _('Convert e-books to the %s format')%self.file_type.upper()"}
{"repo": "calibre-master/src/calibre/customize/conversion.py", "original_string": "    def is_periodical(self):\n        return self.oeb.metadata.publication_type and \\\n            unicode_type(self.oeb.metadata.publication_type[0]).startswith('periodical:')\n", "docstring": "return self.oeb.metadata.publication_type and \\"}
{"repo": "calibre-master/src/calibre/customize/__init__.py", "original_string": "    def __init__(self, *args, **kwargs):\n        Plugin.__init__(self, *args, **kwargs)\n        self.quick = False\n", "docstring": "Plugin.__init__(self, *args, **kwargs)"}
{"repo": "calibre-master/src/calibre/customize/__init__.py", "original_string": "    def get_output_fields(self, db, opts):\n        # Return a list of requested fields\n        all_std_fields = {'author_sort','authors','comments','cover','formats',\n                           'id','isbn','library_name','ondevice','pubdate','publisher',\n                           'rating','series_index','series','size','tags','timestamp',\n                           'title_sort','title','uuid','languages','identifiers'}\n        all_custom_fields = set(db.custom_field_keys())\n        for field in list(all_custom_fields):\n            fm = db.field_metadata[field]\n            if fm['datatype'] == 'series':\n                all_custom_fields.add(field+'_index')\n        all_fields = all_std_fields.union(all_custom_fields)\n        if opts.fields != 'all':\n            # Make a list from opts.fields\n            of = [x.strip() for x in opts.fields.split(',')]\n            requested_fields = set(of)\n            # Validate requested_fields\n            if requested_fields - all_fields:\n                from calibre.library import current_library_name\n                invalid_fields = sorted(list(requested_fields - all_fields))\n                print(\"invalid --fields specified: %s\" % ', '.join(invalid_fields))\n                print(\"available fields in '%s': %s\" %\n                      (current_library_name(), ', '.join(sorted(list(all_fields)))))\n                raise ValueError(\"unable to generate catalog with specified fields\")\n            fields = [x for x in of if x in all_fields]\n        else:\n            fields = sorted(all_fields, key=self._field_sorter)\n        if not opts.connected_device['is_device_connected'] and 'ondevice' in fields:\n            fields.pop(int(fields.index('ondevice')))\n        return fields\n", "docstring": "Return a list of requested fields"}
{"repo": "calibre-master/src/calibre/customize/__init__.py", "original_string": "    def __init__(self, *args, **kwargs):\n        Plugin.__init__(self, *args, **kwargs)\n        self.actual_plugin_ = None\n", "docstring": "Plugin.__init__(self, *args, **kwargs)"}
{"repo": "calibre-master/src/calibre/customize/__init__.py", "original_string": "    def config_widget(self):\n        if getattr(self, 'actual_plugin_object', None) is not None:\n            return self.actual_plugin_object.config_widget()\n        raise NotImplementedError()\n", "docstring": "if getattr(self, 'actual_plugin_object', None) is not None:"}
{"repo": "calibre-master/src/calibre/spell/import_from.py", "original_string": "def uniq(vals, kmap=lambda x:x):\n    ''' Remove all duplicates from vals, while preserving order. kmap must be a\n    callable that returns a hashable value for every item in vals '''\n    vals = vals or ()\n    lvals = (kmap(x) for x in vals)\n    seen = set()\n    seen_add = seen.add\n    return tuple(x for x, k in zip(vals, lvals) if k not in seen and not seen_add(k))\n", "docstring": "Remove all duplicates from vals, while preserving order. kmap must be a"}
{"repo": "calibre-master/src/calibre/web/feeds/news.py", "original_string": "    def cloned_browser(self):\n        if hasattr(self.get_browser, 'is_base_class_implementation'):\n            # We are using the default get_browser, which means no need to\n            # clone\n            br = BasicNewsRecipe.get_browser(self)\n        else:\n            br = self.clone_browser(self.browser)\n        return br\n", "docstring": "We are using the default get_browser, which means no need to"}
{"repo": "calibre-master/src/calibre/web/feeds/news.py", "original_string": "    def soup(cls, raw):\n        return BeautifulSoup(raw)\n", "docstring": "return BeautifulSoup(raw)"}
{"repo": "calibre-master/src/calibre/web/feeds/news.py", "original_string": "    def download(self):\n        index = os.path.abspath(self.custom_index())\n        url = 'file:'+index if iswindows else 'file://'+index\n        self.web2disk_options.browser = self.clone_browser(self.browser)\n        fetcher = RecursiveFetcher(self.web2disk_options, self.log)\n        fetcher.base_dir = self.output_dir\n        fetcher.current_dir = self.output_dir\n        fetcher.show_progress = False\n        res = fetcher.start_fetch(url)\n        self.create_opf()\n        return res\n", "docstring": "index = os.path.abspath(self.custom_index())"}
{"repo": "calibre-master/src/calibre/library/caches.py", "original_string": "    def break_cycles(self):\n        # Break cycles so that this object doesn't hold references to db\n        self.do_write = self.get_metadata_for_dump = self.clear_dirtied = \\\n            self.set_dirtied = self.db = None\n", "docstring": "Break cycles so that this object doesn't hold references to db"}
{"repo": "calibre-master/src/calibre/library/caches.py", "original_string": "    def get_dates_matches(self, location, query, candidates):\n        matches = set()\n        if len(query) < 2:\n            return matches\n        if location == 'date':\n            location = 'timestamp'\n        loc = self.field_metadata[location]['rec_index']\n        if query == 'false':\n            for id_ in candidates:\n                item = self._data[id_]\n                if item is None:\n                    continue\n                v = item[loc]\n                if isinstance(v, (bytes, unicode_type)):\n                    v = parse_date(v)\n                if v is None or v <= UNDEFINED_DATE:\n                    matches.add(item[0])\n            return matches\n        if query == 'true':\n            for id_ in candidates:\n                item = self._data[id_]\n                if item is None:\n                    continue\n                v = item[loc]\n                if isinstance(v, (bytes, unicode_type)):\n                    v = parse_date(v)\n                if v is not None and v > UNDEFINED_DATE:\n                    matches.add(item[0])\n            return matches\n        relop = None\n        for k in self.date_search_relops.keys():\n            if query.startswith(k):\n                (p, relop) = self.date_search_relops[k]\n                query = query[p:]\n        if relop is None:\n            (p, relop) = self.date_search_relops['=']\n        if query in self.local_today:\n            qd = now()\n            field_count = 3\n        elif query in self.local_yesterday:\n            qd = now() - timedelta(1)\n            field_count = 3\n        elif query in self.local_thismonth:\n            qd = now()\n            field_count = 2\n        elif query.endswith(self.local_daysago) or query.endswith(self.untrans_daysago):\n            num = query[0:-(self.untrans_daysago_len if query.endswith(self.untrans_daysago) else self.local_daysago_len)]\n            try:\n                qd = now() - timedelta(int(num))\n            except:\n                raise ParseException(_('Number conversion error: {0}').format(num))\n            field_count = 3\n        else:\n            try:\n                qd = parse_date(query, as_utc=False)\n            except:\n                raise ParseException(_('Date conversion error: {0}').format(query))\n            if '-' in query:\n                field_count = query.count('-') + 1\n            else:\n                field_count = query.count('/') + 1\n        for id_ in candidates:\n            item = self._data[id_]\n            if item is None or item[loc] is None:\n                continue\n            v = item[loc]\n            if isinstance(v, (bytes, unicode_type)):\n                v = parse_date(v)\n            if relop(v, qd, field_count):\n                matches.add(item[0])\n        return matches\n", "docstring": "matches = set()"}
{"repo": "calibre-master/src/calibre/library/caches.py", "original_string": "    def books_deleted(self, ids):\n        for id in ids:\n            self.remove(id)\n", "docstring": "for id in ids:"}
{"repo": "calibre-master/src/calibre/library/caches.py", "original_string": "    def __init__(self, orders, values):\n        self.orders, self.values = orders, values\n", "docstring": "self.orders, self.values = orders, values"}
{"repo": "calibre-master/src/calibre/library/database2.py", "original_string": "    def library_id(self):\n        '''The UUID for this library. As long as the user only operates on libraries with calibre, it will be unique'''\n        if self._library_id_ is None:\n            ans = self.conn.get('SELECT uuid FROM library_id', all=False)\n            if ans is None:\n                ans = unicode_type(uuid.uuid4())\n                self.library_id = ans\n            else:\n                self._library_id_ = ans\n        return self._library_id_\n", "docstring": "The UUID for this library. As long as the user only operates on libraries with calibre, it will be unique'''"}
{"repo": "calibre-master/src/calibre/library/database2.py", "original_string": "    def last_modified(self):\n        ''' Return last modified time as a UTC datetime object'''\n        return utcfromtimestamp(os.stat(self.dbpath).st_mtime)\n", "docstring": "Return last modified time as a UTC datetime object'''"}
{"repo": "calibre-master/src/calibre/library/database2.py", "original_string": "    def normpath(self, path):\n        path = os.path.abspath(os.path.realpath(path))\n        if not self.is_case_sensitive:\n            path = os.path.normcase(path).lower()\n        return path\n", "docstring": "path = os.path.abspath(os.path.realpath(path))"}
{"repo": "calibre-master/src/calibre/library/database2.py", "original_string": "    def cover(self, index, index_is_id=False, as_file=False, as_image=False,\n            as_path=False):\n        '''\n        Return the cover image as a bytestring (in JPEG format) or None.\n        WARNING: Using as_path will copy the cover to a temp file and return\n        the path to the temp file. You should delete the temp file when you are\n        done with it.\n        :param as_file: If True return the image as an open file object (a SpooledTemporaryFile)\n        :param as_image: If True return the image as a QImage object\n        '''\n        id = index if index_is_id else self.id(index)\n        path = os.path.join(self.library_path, self.path(id, index_is_id=True), 'cover.jpg')\n        if os.access(path, os.R_OK):\n            try:\n                f = lopen(path, 'rb')\n            except (IOError, OSError):\n                time.sleep(0.2)\n                f = lopen(path, 'rb')\n            with f:\n                if as_path:\n                    pt = PersistentTemporaryFile('_dbcover.jpg')\n                    with pt:\n                        shutil.copyfileobj(f, pt)\n                    return pt.name\n                if as_file:\n                    ret = SpooledTemporaryFile(SPOOL_SIZE)\n                    shutil.copyfileobj(f, ret)\n                    ret.seek(0)\n                else:\n                    ret = f.read()\n                    if as_image:\n                        from qt.core import QImage\n                        i = QImage()\n                        i.loadFromData(ret)\n                        ret = i\n            return ret\n", "docstring": "as_path=False):"}
{"repo": "calibre-master/src/calibre/library/database2.py", "original_string": "    def get_field(self, idx, key, default=None, index_is_id=False):\n        mi = self.get_metadata(idx, index_is_id=index_is_id,\n                               get_cover=key == 'cover')\n        return mi.get(key, default)\n", "docstring": "mi = self.get_metadata(idx, index_is_id=index_is_id,"}
{"repo": "calibre-master/src/calibre/library/database2.py", "original_string": "    def update_last_modified(self, book_ids, commit=False, now=None):\n        if now is None:\n            now = nowf()\n        if book_ids:\n            self.conn.executemany(\n                'UPDATE books SET last_modified=? WHERE id=?',\n                [(now, book) for book in book_ids])\n            for book_id in book_ids:\n                self.data.set(book_id, self.FIELD_MAP['last_modified'], now, row_is_id=True)\n            if commit:\n                self.conn.commit()\n", "docstring": "if now is None:"}
{"repo": "calibre-master/src/calibre/library/database2.py", "original_string": "    def has_id(self, id_):\n        return self.data._data[id_] is not None\n", "docstring": "return self.data._data[id_] is not None"}
{"repo": "calibre-master/src/calibre/library/database2.py", "original_string": "    def set_has_cover(self, id, val):\n        dval = 1 if val else 0\n        now = nowf()\n        self.conn.execute(\n                'UPDATE books SET has_cover=?,last_modified=? WHERE id=?',\n                (dval, now, id))\n        self.data.set(id, self.FIELD_MAP['cover'], val, row_is_id=True)\n        self.data.set(id, self.FIELD_MAP['last_modified'], now, row_is_id=True)\n", "docstring": "dval = 1 if val else 0"}
{"repo": "calibre-master/src/calibre/library/database2.py", "original_string": "    def formats(self, index, index_is_id=False, verify_formats=True):\n        ''' Return available formats as a comma separated list or None if there are no available formats '''\n        id_ = index if index_is_id else self.id(index)\n        formats = self.data.get(id_, self.FIELD_MAP['formats'], row_is_id=True)\n        if not formats:\n            return None\n        if not verify_formats:\n            return formats\n        formats = formats.split(',')\n        ans = []\n        for fmt in formats:\n            if self.format_abspath(id_, fmt, index_is_id=True) is not None:\n                ans.append(fmt)\n        if not ans:\n            return None\n        return ','.join(ans)\n", "docstring": "Return available formats as a comma separated list or None if there are no available formats '''"}
{"repo": "calibre-master/src/calibre/library/database2.py", "original_string": "    def copy_cover_to(self, index, dest, index_is_id=False,\n            windows_atomic_move=None, use_hardlink=False):\n        '''\n        Copy the cover to the file like object ``dest``. Returns False\n        if no cover exists or dest is the same file as the current cover.\n        dest can also be a path in which case the cover is\n        copied to it iff the path is different from the current path (taking\n        case sensitivity into account).\n        If use_hardlink is True, a hard link will be created instead of the\n        file being copied. Use with care, because a hard link means that\n        modifying any one file will cause both files to be modified.\n        windows_atomic_move is an internally used parameter. You should not use\n        it in any code outside this module.\n        '''\n        id = index if index_is_id else self.id(index)\n        path = os.path.join(self.library_path, self.path(id, index_is_id=True), 'cover.jpg')\n        if windows_atomic_move is not None:\n            if not isinstance(dest, string_or_bytes):\n                raise Exception(\"Error, you must pass the dest as a path when\"\n                        \" using windows_atomic_move\")\n            if os.access(path, os.R_OK) and dest and not samefile(dest, path):\n                windows_atomic_move.copy_path_to(path, dest)\n                return True\n        else:\n            if os.access(path, os.R_OK):\n                try:\n                    f = lopen(path, 'rb')\n                except (IOError, OSError):\n                    time.sleep(0.2)\n                f = lopen(path, 'rb')\n                with f:\n                    if hasattr(dest, 'write'):\n                        shutil.copyfileobj(f, dest)\n                        if hasattr(dest, 'flush'):\n                            dest.flush()\n                        return True\n                    elif dest and not samefile(dest, path):\n                        if use_hardlink:\n                            try:\n                                hardlink_file(path, dest)\n                                return True\n                            except:\n                                pass\n                        with lopen(dest, 'wb') as d:\n                            shutil.copyfileobj(f, d)\n                        return True\n        return False\n", "docstring": "windows_atomic_move=None, use_hardlink=False):"}
{"repo": "calibre-master/src/calibre/library/database2.py", "original_string": "    def add_format_with_hooks(self, index, format, fpath, index_is_id=False,\n                              path=None, notify=True, replace=True):\n        npath = self.run_import_plugins(fpath, format)\n        format = os.path.splitext(npath)[-1].lower().replace('.', '').upper()\n        stream = lopen(npath, 'rb')\n        format = check_ebook_format(stream, format)\n        id = index if index_is_id else self.id(index)\n        retval = self.add_format(id, format, stream, replace=replace,\n                               index_is_id=True, path=path, notify=notify)\n        run_plugins_on_postimport(self, id, format)\n        return retval\n", "docstring": "path=None, notify=True, replace=True):"}
{"repo": "calibre-master/src/calibre/library/database2.py", "original_string": "        def __init__(self, name, sort):\n            self.n = name\n            self.s = sort\n            self.c  = 0\n            self.id_set = set()\n            self.rt = 0\n            self.rc = 0\n            self.id = None\n", "docstring": "self.n = name"}
{"repo": "calibre-master/src/calibre/library/database2.py", "original_string": "    def rename_tag(self, old_id, new_name):\n        # It is possible that new_name is in fact a set of names. Split it on\n        # comma to find out. If it is, then rename the first one and append the\n        # rest\n        new_names = [t.strip() for t in new_name.strip().split(',') if t.strip()]\n        new_name = new_names[0]\n        new_names = new_names[1:]\n        # get the list of books that reference the tag being changed\n        books = self.conn.get('''SELECT book from books_tags_link\n                                 WHERE tag=?''', (old_id,))\n        books = [b[0] for b in books]\n        new_id = self.conn.get(\n                    '''SELECT id from tags\n                       WHERE name=?''', (new_name,), all=False)\n        if new_id is None or old_id == new_id:\n            # easy cases. Simply rename the tag. Do it even if equal, in case\n            # there is a change of case\n            self.conn.execute('''UPDATE tags SET name=?\n                                 WHERE id=?''', (new_name, old_id))\n            new_id = old_id\n        else:\n            # It is possible that by renaming a tag, the tag will appear\n            # twice on a book. This will throw an integrity error, aborting\n            # all the changes. To get around this, we first delete any links\n            # to the new_id from books referencing the old_id, so that\n            # renaming old_id to new_id will be unique on the book\n            for book_id in books:\n                self.conn.execute('''DELETE FROM books_tags_link\n                                     WHERE book=? and tag=?''', (book_id, new_id))\n            # Change the link table to point at the new tag\n            self.conn.execute('''UPDATE books_tags_link SET tag=?\n                                 WHERE tag=?''',(new_id, old_id,))\n            # Get rid of the no-longer used publisher\n            self.conn.execute('DELETE FROM tags WHERE id=?', (old_id,))\n        if new_names:\n            # have some left-over names to process. Add them to the book.\n            for book_id in books:\n                self.set_tags(book_id, new_names, append=True, notify=False,\n                              commit=False)\n        self.dirtied(books, commit=False)\n        self.clean_standard_field('tags', commit=False)\n        self.conn.commit()\n", "docstring": "It is possible that new_name is in fact a set of names. Split it on"}
{"repo": "calibre-master/src/calibre/library/database.py", "original_string": "    def sizeof_old_database(path):\n        conn = sqlite.connect(path)\n        ans  = conn.execute('SELECT COUNT(id) from books_meta').fetchone()[0]\n        conn.close()\n        return ans\n", "docstring": "conn = sqlite.connect(path)"}
{"repo": "calibre-master/src/calibre/library/database.py", "original_string": "    def id(self, index):\n        return self.data[index][0]\n", "docstring": "return self.data[index][0]"}
{"repo": "calibre-master/src/calibre/library/database.py", "original_string": "    def cover(self, index, index_is_id=False):\n        '''Cover as a data string or None'''\n        id = index if index_is_id else self.id(index)\n        data = self.conn.get('SELECT data FROM covers WHERE book=?', (id,), all=False)\n        if not data:\n            return None\n        return(decompress(data))\n", "docstring": "Cover as a data string or None'''"}
{"repo": "calibre-master/src/calibre/library/database.py", "original_string": "    def formats(self, index, index_is_id=False):\n        ''' Return available formats as a comma separated list '''\n        id = index if index_is_id else self.id(index)\n        return self.conn.get('SELECT concat(format) FROM data WHERE data.book=?', (id,), all=False)\n", "docstring": "Return available formats as a comma separated list '''"}
{"repo": "calibre-master/src/calibre/library/database.py", "original_string": "    def format(self, index, format, index_is_id=False):\n        id = index if index_is_id else self.id(index)\n        return decompress(self.conn.get('SELECT data FROM data WHERE book=? AND format=?', (id, format), all=False))\n", "docstring": "id = index if index_is_id else self.id(index)"}
{"repo": "calibre-master/src/calibre/library/database.py", "original_string": "    def set_title(self, id, title):\n        if not title:\n            return\n        self.conn.execute('UPDATE books SET title=? WHERE id=?', (title, id))\n        self.conn.commit()\n", "docstring": "if not title:"}
{"repo": "calibre-master/src/calibre/library/database.py", "original_string": "    def remove_unused_series(self):\n        for id, in self.conn.get('SELECT id FROM series'):\n            if not self.conn.get('SELECT id from books_series_link WHERE series=?', (id,)):\n                self.conn.execute('DELETE FROM series WHERE id=?', (id,))\n        self.conn.commit()\n", "docstring": "for id, in self.conn.get('SELECT id FROM series'):"}
{"repo": "calibre-master/src/calibre/library/database.py", "original_string": "    def index(self, id, cache=False):\n        data = self.cache if cache else self.data\n        for i in range(len(data)):\n            if data[i][0] == id:\n                return i\n", "docstring": "data = self.cache if cache else self.data"}
{"repo": "calibre-master/src/calibre/library/database.py", "original_string": "    def all_ids(self):\n        return [i[0] for i in self.conn.get('SELECT id FROM books')]\n", "docstring": "return [i[0] for i in self.conn.get('SELECT id FROM books')]"}
{"repo": "calibre-master/src/calibre/library/comments.py", "original_string": "def merge_comments(one, two):\n    return comments_to_html(one) + '\\n\\n' + comments_to_html(two)\n", "docstring": "return comments_to_html(one) + '\\n\\n' + comments_to_html(two)"}
{"repo": "calibre-master/src/calibre/library/schema_upgrades.py", "original_string": "    def __init__(self):\n        # Upgrade database\n        while True:\n            uv = self.user_version\n            meth = getattr(self, 'upgrade_version_%d'%uv, None)\n            if meth is None:\n                break\n            else:\n                print('Upgrading database to version %d...'%(uv+1))\n                meth()\n                self.user_version = uv+1\n", "docstring": "Upgrade database"}
{"repo": "calibre-master/src/calibre/library/schema_upgrades.py", "original_string": "    def upgrade_version_2(self):\n        ''' Fix Foreign key constraints for deleting from link tables. '''\n        script = '''\\\n        DROP TRIGGER IF EXISTS fkc_delete_books_%(ltable)s_link;\n        CREATE TRIGGER fkc_delete_on_%(table)s\n        BEFORE DELETE ON %(table)s\n        BEGIN\n            SELECT CASE\n                WHEN (SELECT COUNT(id) FROM books_%(ltable)s_link WHERE %(ltable_col)s=OLD.id) > 0\n                THEN RAISE(ABORT, 'Foreign key violation: %(table)s is still referenced')\n            END;\n        END;\n        DELETE FROM %(table)s WHERE (SELECT COUNT(id) FROM books_%(ltable)s_link WHERE %(ltable_col)s=%(table)s.id) < 1;\n        '''\n        self.conn.executescript(script%dict(ltable='authors', table='authors', ltable_col='author'))\n        self.conn.executescript(script%dict(ltable='publishers', table='publishers', ltable_col='publisher'))\n        self.conn.executescript(script%dict(ltable='tags', table='tags', ltable_col='tag'))\n        self.conn.executescript(script%dict(ltable='series', table='series', ltable_col='series'))\n", "docstring": "Fix Foreign key constraints for deleting from link tables. '''"}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def _kf_author_to_author_sort(self, author):\n        \"\"\" Compute author_sort value from author\n        Tokenize author string, return capitalized string with last token first\n        Args:\n         author (str): author, e.g. 'John Smith'\n        Return:\n         (str): 'Smith, john'\n        \"\"\"\n        tokens = author.split()\n        tokens = tokens[-1:] + tokens[:-1]\n        if len(tokens) > 1:\n            tokens[0] += ','\n        return ' '.join(tokens).capitalize()\n", "docstring": "Compute author_sort value from author"}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def _kf_books_by_author_sorter_author_sort(self, book, longest_author_sort=60):\n        \"\"\" Generate book sort key with supplied author_sort.\n        Generate a sort key of author_sort, title.\n        Bang, tilde included to force series to sort after non-series books.\n        Args:\n         book (dict): book metadata\n        Return:\n         (str): sort key\n        \"\"\"\n        if not book['series']:\n            fs = '{:<%d}!{!s}' % longest_author_sort\n            key = fs.format(capitalize(book['author_sort']),\n                            capitalize(book['title_sort']))\n        else:\n            index = book['series_index']\n            integer = int(index)\n            fraction = index - integer\n            series_index = '%04d%s' % (integer, unicode_type('%0.4f' % fraction).lstrip('0'))\n            fs = '{:<%d}~{!s}{!s}' % longest_author_sort\n            key = fs.format(capitalize(book['author_sort']),\n                            self.generate_sort_title(book['series']),\n                            series_index)\n        return key\n", "docstring": "Generate book sort key with supplied author_sort."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def build_sources(self):\n        \"\"\" Generate catalog source files.\n        Assemble OPF, HTML and NCX files reflecting catalog options.\n        Generated source is OEB compliant.\n        Called from gui2.convert.gui_conversion:gui_catalog()\n        Args:\n        Exceptions:\n            AuthorSortMismatchException\n            EmptyCatalogException\n        Results:\n         error: problems reported during build\n        \"\"\"\n        self.fetch_books_by_title()\n        self.fetch_books_by_author()\n        self.fetch_bookmarks()\n        if self.opts.generate_descriptions:\n            self.generate_thumbnails()\n            self.generate_html_descriptions()\n        if self.opts.generate_authors:\n            self.generate_html_by_author()\n        if self.opts.generate_titles:\n            self.generate_html_by_title()\n        if self.opts.generate_series:\n            self.generate_html_by_series()\n        if self.opts.generate_genres:\n            self.generate_html_by_genres()\n            # If this is the only Section, and there are no genres, bail\n            if self.opts.section_list == ['Genres'] and not self.genres:\n                error_msg = _(\"No genres to catalog.\\n\")\n                if not self.opts.cli_environment:\n                    error_msg += _(\"Check 'Excluded genres' regex in the E-book options.\\n\")\n                self.opts.log.error(error_msg)\n                self.error.append(_('No books available to catalog'))\n                self.error.append(error_msg)\n                raise EmptyCatalogException(\"No genres to catalog\")\n        if self.opts.generate_recently_added:\n            self.generate_html_by_date_added()\n            if self.generate_recently_read:\n                self.generate_html_by_date_read()\n        self.generate_opf()\n        self.generate_ncx_header()\n        if self.opts.generate_authors:\n            self.generate_ncx_by_author(_(\"Authors\"))\n        if self.opts.generate_titles:\n            self.generate_ncx_by_title(_(\"Titles\"))\n        if self.opts.generate_series:\n            self.generate_ncx_by_series(ngettext('Series', 'Series', 2))\n        if self.opts.generate_genres:\n            self.generate_ncx_by_genre(_(\"Genres\"))\n        if self.opts.generate_recently_added:\n            self.generate_ncx_by_date_added(_(\"Recently Added\"))\n            if self.generate_recently_read:\n                self.generate_ncx_by_date_read(_(\"Recently Read\"))\n        if self.opts.generate_descriptions:\n            self.generate_ncx_descriptions(_(\"Descriptions\"))\n        self.write_ncx()\n", "docstring": "Generate catalog source files."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def compute_total_steps(self):\n        \"\"\" Calculate number of build steps to generate catalog.\n        Calculate total number of build steps based on enabled sections.\n        Inputs:\n         opts.generate_* (bool): enabled sections\n        Outputs:\n         total_steps (int): updated\n        \"\"\"\n        # Tweak build steps based on optional sections:  1 call for HTML, 1 for NCX\n        incremental_jobs = 0\n        if self.opts.generate_authors:\n            incremental_jobs += 2\n        if self.opts.generate_titles:\n            incremental_jobs += 2\n        if self.opts.generate_recently_added:\n            incremental_jobs += 2\n            if self.generate_recently_read:\n                incremental_jobs += 2\n        if self.opts.generate_series:\n            incremental_jobs += 2\n        if self.opts.generate_descriptions:\n            # +1 thumbs\n            incremental_jobs += 3\n        self.total_steps += incremental_jobs\n", "docstring": "Calculate number of build steps to generate catalog."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def convert_html_entities(self, s):\n        \"\"\" Convert string containing HTML entities to its unicode equivalent.\n        Convert a string containing HTML entities of the form '&amp;' or '&97;'\n        to a normalized unicode string. E.g., 'AT&amp;T' converted to 'AT&T'.\n        Args:\n         s (str): str containing one or more HTML entities.\n        Return:\n         s (str): converted string\n        \"\"\"\n        return replace_entities(s)\n", "docstring": "Convert string containing HTML entities to its unicode equivalent."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def create_catalog_directory_structure(self):\n        \"\"\" Create subdirs in catalog output dir.\n        Create /content and /images in self.catalog_path\n        Inputs:\n         catalog_path (path): path to catalog output dir\n        Output:\n         /content, /images created\n        \"\"\"\n        if not os.path.isdir(self.catalog_path):\n            os.makedirs(self.catalog_path)\n        content_path = self.catalog_path + \"/content\"\n        if not os.path.isdir(content_path):\n            os.makedirs(content_path)\n        images_path = self.catalog_path + \"/images\"\n        if not os.path.isdir(images_path):\n            os.makedirs(images_path)\n", "docstring": "Create subdirs in catalog output dir."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def establish_equivalencies(self, item_list, key=None):\n        \"\"\" Return icu equivalent sort letter.\n        Returns base sort letter for accented characters. Code provided by\n        chaley, modified to force unaccented base letters for A, O & U when\n        an accented version would otherwise be returned.\n        Args:\n         item_list (list): list of items, sorted by icu_sort\n        Return:\n         cl_list (list): list of equivalent leading chars, 1:1 correspondence to item_list\n        \"\"\"\n        # Hack to force the cataloged leading letter to be\n        # an unadorned character if the accented version sorts before the unaccented\n        exceptions = {\n                        'Ä':   'A',\n                        'Ö':   'O',\n                        'Ü':   'U'\n                     }\n        if key is not None:\n            sort_field = key\n        cl_list = [None] * len(item_list)\n        last_ordnum = 0\n        for idx, item in enumerate(item_list):\n            if key:\n                c = item[sort_field]\n            else:\n                c = item\n            ordnum, ordlen = collation_order(c)\n            if ismacos and platform.mac_ver()[0] < '10.8':\n                # Hackhackhackhackhack\n                # icu returns bogus results with curly apostrophes, maybe others under OS X 10.6.x\n                # When we see the magic combo of 0/-1 for ordnum/ordlen, special case the logic\n                last_c = ''\n                if ordnum == 0 and ordlen == -1:\n                    if icu_upper(c[0]) != last_c:\n                        last_c = icu_upper(c[0])\n                        if last_c in exceptions.keys():\n                            last_c = exceptions[unicode_type(last_c)]\n                        last_ordnum = ordnum\n                    cl_list[idx] = last_c\n                else:\n                    if last_ordnum != ordnum:\n                        last_c = icu_upper(c[0:ordlen])\n                        if last_c in exceptions.keys():\n                            last_c = exceptions[unicode_type(last_c)]\n                        last_ordnum = ordnum\n                    else:\n                        last_c = cl_list[idx-1]\n                    cl_list[idx] = last_c\n            else:\n                if last_ordnum != ordnum:\n                    last_c = icu_upper(c[0:ordlen])\n                    if last_c in exceptions.keys():\n                        last_c = exceptions[unicode_type(last_c)]\n                    last_ordnum = ordnum\n                else:\n                    last_c = cl_list[idx-1]\n                cl_list[idx] = last_c\n        if self.DEBUG and self.opts.verbose:\n            print(\"     establish_equivalencies():\")\n            if key:\n                for idx, item in enumerate(item_list):\n                    print(\"      %s %s\" % (cl_list[idx], item[sort_field]))\n            else:\n                print(\"      %s %s\" % (cl_list[idx], item))\n        return cl_list\n", "docstring": "Return icu equivalent sort letter."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def fetch_books_by_title(self):\n        \"\"\" Generate a list of books sorted by title.\n        Sort the database by title.\n        Inputs:\n         self.books_to_catalog (list): database\n        Outputs:\n         books_by_title: database, sorted by title\n        Return:\n         True: no errors\n         False: author_sort mismatch detected while building MOBI\n        \"\"\"\n        self.update_progress_full_step(_(\"Sorting titles\"))\n        # Re-sort based on title_sort\n        if len(self.books_to_catalog):\n            self.books_by_title = sorted(self.books_to_catalog, key=lambda x: sort_key(x['title_sort'].upper()))\n            if self.DEBUG and self.opts.verbose:\n                self.opts.log.info(\"fetch_books_by_title(): %d books\" % len(self.books_by_title))\n                self.opts.log.info(\" %-40s %-40s\" % ('title', 'title_sort'))\n                for title in self.books_by_title:\n                    self.opts.log.info((u\" %-40s %-40s\" % (title['title'][0:40],\n                                                            title['title_sort'][0:40])).encode('utf-8'))\n        else:\n            error_msg = _(\"No books to catalog.\\nCheck 'Excluded books' rules in the E-book options.\\n\")\n            self.opts.log.error('*** ' + error_msg + ' ***')\n            self.error.append(_('No books available to include in catalog'))\n            self.error.append(error_msg)\n            raise EmptyCatalogException(error_msg)\n", "docstring": "Generate a list of books sorted by title."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def filter_excluded_genres(self, tags, regex):\n        \"\"\" Remove excluded tags from a tag list\n        Run regex against list of tags, remove matching tags. Return filtered list.\n        Args:\n         tags (list): list of tags\n        Return:\n         tag_list(list): filtered list of tags\n        \"\"\"\n        tag_list = []\n        try:\n            for tag in tags:\n                tag = self.convert_html_entities(tag)\n                if re.search(regex, tag):\n                    continue\n                else:\n                    tag_list.append(tag)\n        except:\n            self.opts.log.error(\"\\tfilter_excluded_genres(): malformed --exclude-genre regex pattern: %s\" % regex)\n            return tags\n        return tag_list\n", "docstring": "Remove excluded tags from a tag list"}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def format_prefix(self, prefix_char):\n        \"\"\" Generate HTML snippet with prefix character.\n        Return a <code> snippet for Kindle, <span> snippet for EPUB.\n        Optimized to preserve first-column alignment for MOBI, EPUB.\n        Args:\n         prefix_char (str): prefix character or None\n        Return:\n         (str): BeautifulSoup HTML snippet to be inserted into <p> line item entry.\n        \"\"\"\n        soup = BeautifulSoup('')\n        if self.opts.fmt == 'mobi':\n            codeTag = soup.new_tag(\"code\")\n            if prefix_char is None:\n                codeTag.insert(0, NavigableString(NBSP))\n            else:\n                codeTag.insert(0, NavigableString(prefix_char))\n            return codeTag\n        else:\n            spanTag = soup.new_tag(\"span\")\n            spanTag['class'] = \"prefix\"\n            if prefix_char is None:\n                prefix_char = NBSP\n            spanTag.insert(0, NavigableString(prefix_char))\n            return spanTag\n", "docstring": "Generate HTML snippet with prefix character."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def generate_format_args(self, book):\n        \"\"\" Generate the format args for template substitution.\n        self.load_section_templates imports string formatting templates of the form\n        'by_*_template.py' for use in the various sections. The templates are designed to use\n        format args, supplied by this method.\n        Args:\n         book (dict): book metadata\n        Return:\n         (dict): formatted args for templating\n        \"\"\"\n        series_index = unicode_type(book['series_index'])\n        if series_index.endswith('.0'):\n            series_index = series_index[:-2]\n        args = dict(\n                title=book['title'],\n                series=book['series'],\n                series_index=series_index,\n                rating=self.generate_rating_string(book),\n                rating_parens='(%s)' % self.generate_rating_string(book) if 'rating' in book else '',\n                pubyear=book['date'].split()[1] if book['date'] else '',\n                pubyear_parens=\"(%s)\" % book['date'].split()[1] if book['date'] else '')\n        return args\n", "docstring": "Generate the format args for template substitution."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def generate_html_empty_header(self, title):\n        \"\"\" Return a boilerplate HTML header.\n        Generate an HTML header with document title.\n        Args:\n         title (str): document title\n        Return:\n         soup (BeautifulSoup): HTML header with document title inserted\n        \"\"\"\n        header = '''\n            <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n            <html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:calibre=\"http://calibre.kovidgoyal.net/2009/metadata\">\n            <head>\n            <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n                <link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\" />\n            <title></title>\n            </head>\n            <body>\n            </body>\n            </html>\n            '''\n        # Insert the supplied title\n        soup = BeautifulSoup(header)\n        titleTag = soup.find('title')\n        titleTag.insert(0, NavigableString(title))\n        return soup\n", "docstring": "Return a boilerplate HTML header."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def generate_masthead_image(self, out_path):\n        \"\"\" Generate a Kindle masthead image.\n        Generate a Kindle masthead image, used with Kindle periodical format.\n        Args:\n         out_path (str): path to write generated masthead image\n        Input:\n         opts.catalog_title (str): Title to render\n         masthead_font: User-specified font preference (MOBI output option)\n        Output:\n         out_path (file): masthead image (GIF)\n        \"\"\"\n        from calibre.ebooks.conversion.config import load_defaults\n        MI_WIDTH = 600\n        MI_HEIGHT = 60\n        font_path = default_font = P('fonts/liberation/LiberationSerif-Bold.ttf')\n        recs = load_defaults('mobi_output')\n        masthead_font_family = recs.get('masthead_font', 'Default')\n        if masthead_font_family != 'Default':\n            from calibre.utils.fonts.scanner import font_scanner\n            faces = font_scanner.fonts_for_family(masthead_font_family)\n            if faces:\n                font_path = faces[0]['path']\n        if not font_path or not os.access(font_path, os.R_OK):\n            font_path = default_font\n        from PIL import Image, ImageDraw, ImageFont\n        img = Image.new('RGB', (MI_WIDTH, MI_HEIGHT), 'white')\n        draw = ImageDraw.Draw(img)\n        try:\n            font = ImageFont.truetype(font_path, 48)\n        except:\n            self.opts.log.error(\"     Failed to load user-specifed font '%s'\" % font_path)\n            font = ImageFont.truetype(default_font, 48)\n        text = self.opts.catalog_title.encode('utf-8')\n        width, height = draw.textsize(text, font=font)\n        left = max(int((MI_WIDTH - width) / 2), 0)\n        top = max(int((MI_HEIGHT - height) / 2), 0)\n        draw.text((left, top), text, fill=(0, 0, 0), font=font)\n        with open(out_path, 'wb') as f:\n            img.save(f, 'GIF')\n", "docstring": "Generate a Kindle masthead image."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def generate_ncx_by_genre(self, tocTitle):\n        \"\"\" Add Genres to the basic NCX file.\n        Generate the Genre NCX content, add to self.ncx_soup.\n        Inputs:\n         genres (list)\n        Updated:\n         play_order (int)\n        Outputs:\n         ncx_soup (file): updated\n        \"\"\"\n        self.update_progress_full_step(_(\"NCX for genres\"))\n        if not len(self.genres):\n            self.opts.log.warn(\" No genres found\\n\"\n                                \" No Genre section added to Catalog\")\n            return\n        # --- Construct the 'Books By Genre' *section* ---\n        file_ID = \"%s\" % tocTitle.lower()\n        file_ID = file_ID.replace(\" \", \"\")\n        section_header = '%s [%d]' % (tocTitle, len(self.genres))\n        if self.generate_for_kindle_mobi:\n            section_header = tocTitle\n        navPointTag = self.generate_ncx_section_header(\"%s-ID\" % file_ID, section_header, \"content/Genre_%s.html#section_start\" % self.genres[0]['tag'])\n        for genre in self.genres:\n            # Add an article for each genre\n            sec_id = \"genre-%s-ID\" % genre['tag']\n            # GwR *** Can this be optimized?\n            normalized_tag = None\n            for friendly_tag in self.genre_tags_dict:\n                if self.genre_tags_dict[friendly_tag] == genre['tag']:\n                    normalized_tag = self.genre_tags_dict[friendly_tag]\n                    break\n            sec_text = self.format_ncx_text(NavigableString(friendly_tag), dest='description')\n            content_src = \"content/Genre_%s.html#Genre_%s\" % (normalized_tag, normalized_tag)\n            if len(genre['titles_spanned']) > 1:\n                author_range = \"%s - %s\" % (genre['titles_spanned'][0][0], genre['titles_spanned'][1][0])\n            else:\n                author_range = \"%s\" % (genre['titles_spanned'][0][0])\n            titles = []\n            for title in genre['books']:\n                titles.append(title['title'])\n            titles = sorted(titles, key=lambda x: (self.generate_sort_title(x), self.generate_sort_title(x)))\n            titles_list = self.generate_short_description(\" • \".join(titles), dest=\"description\")\n            cm_tags = {'author': author_range, 'description': self.format_ncx_text(titles_list, dest='description')}\n            self.generate_ncx_subsection(navPointTag, sec_id, sec_text, content_src, cm_tags)\n", "docstring": "Add Genres to the basic NCX file."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def generate_rating_string(self, book):\n        \"\"\" Generate rating string for Descriptions.\n        Starting with database rating (0-10), return 5 stars, with 0-5 filled,\n        balance empty.\n        Args:\n         book (dict): book metadata\n        Return:\n         rating (str): 5 stars, 1-5 solid, balance empty. Empty str for no rating.\n        \"\"\"\n        rating = ''\n        try:\n            if 'rating' in book:\n                stars = int(book['rating']) // 2\n                if stars:\n                    star_string = self.SYMBOL_FULL_RATING * stars\n                    empty_stars = self.SYMBOL_EMPTY_RATING * (5 - stars)\n                    rating = '%s%s' % (star_string, empty_stars)\n        except:\n            # Rating could be None\n            pass\n        return rating\n", "docstring": "Generate rating string for Descriptions."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def generate_short_description(self, description, dest=None):\n        \"\"\" Generate a truncated version of the supplied string.\n        Given a string and NCX destination, truncate string to length specified\n        in self.opts.\n        Args:\n         description (str): string to truncate\n         dest (str): NCX destination\n           description  NCX summary\n           title        NCX title\n           author       NCX author\n        Return:\n         (str): truncated description\n        \"\"\"\n        def _short_description(description, limit):\n            short_description = \"\"\n            words = description.split()\n            for word in words:\n                short_description += word + \" \"\n                if len(short_description) > limit:\n                    short_description += \"...\"\n                    return short_description\n        if not description:\n            return None\n        if dest == 'title':\n            # No truncation for titles, let the device deal with it\n            return description\n        elif dest == 'author':\n            if self.opts.author_clip and len(description) < self.opts.author_clip:\n                return description\n            else:\n                return _short_description(description, self.opts.author_clip)\n        elif dest == 'description':\n            if self.opts.description_clip and len(description) < self.opts.description_clip:\n                return description\n            else:\n                return _short_description(description, self.opts.description_clip)\n        else:\n            print(\" returning description with unspecified destination '%s'\" % description)\n            raise RuntimeError\n", "docstring": "Generate a truncated version of the supplied string."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def generate_thumbnail(self, title, image_dir, thumb_file):\n        \"\"\" Create thumbnail of cover or return previously cached thumb.\n        Test thumb archive for currently cached cover. Return cached version, or create\n        and cache new version.\n        Args:\n         title (dict): book metadata\n         image_dir (str): directory to write thumb data to\n         thumb_file (str): filename to save thumb as\n        Output:\n         (file): thumb written to /images\n         (archive): current thumb archived under cover crc\n        \"\"\"\n        def _open_archive(mode='r'):\n            try:\n                return ZipFile(self.thumbs_path, mode=mode, allowZip64=True)\n            except:\n                # occurs under windows if the file is opened by another\n                # process\n                pass\n        # Generate crc for current cover\n        with lopen(title['cover'], 'rb') as f:\n            data = f.read()\n        cover_crc = hex(zlib.crc32(data))\n        # Test cache for uuid\n        uuid = title.get('uuid')\n        if uuid:\n            zf = _open_archive()\n            if zf is not None:\n                with zf:\n                    try:\n                        zf.getinfo(uuid + cover_crc)\n                    except:\n                        pass\n                    else:\n                        # uuid found in cache with matching crc\n                        thumb_data = zf.read(uuid + cover_crc)\n                        with open(os.path.join(image_dir, thumb_file), 'wb') as f:\n                            f.write(thumb_data)\n                        return\n            # Save thumb for catalog. If invalid data, error returns to generate_thumbnails()\n            thumb_data = scale_image(data,\n                    width=self.thumb_width, height=self.thumb_height)[-1]\n            with lopen(os.path.join(image_dir, thumb_file), 'wb') as f:\n                f.write(thumb_data)\n            # Save thumb to archive\n            if zf is not None:\n                # Ensure that the read succeeded\n                # If we failed to open the zip file for reading,\n                # we dont know if it contained the thumb or not\n                zf = _open_archive('a')\n                if zf is not None:\n                    with zf:\n                        zf.writestr(uuid + cover_crc, thumb_data)\n", "docstring": "Create thumbnail of cover or return previously cached thumb."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def generate_unicode_name(self, c):\n        \"\"\" Generate a legal XHTML anchor from unicode character.\n        Generate a legal XHTML anchor from unicode character.\n        Args:\n         c (unicode): character(s)\n        Return:\n         (str): legal XHTML anchor string of unicode character name\n        \"\"\"\n        fullname = ''.join(unicodedata.name(unicode_type(cc)) for cc in c)\n        terms = fullname.split()\n        return \"_\".join(terms)\n", "docstring": "Generate a legal XHTML anchor from unicode character."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def get_friendly_genre_tag(self, genre):\n        \"\"\" Return the first friendly_tag matching genre.\n        Scan self.genre_tags_dict[] for first friendly_tag matching genre.\n        genre_tags_dict[] populated in filter_genre_tags().\n        Args:\n         genre (str): genre to match\n        Return:\n         friendly_tag (str): friendly_tag matching genre\n        \"\"\"\n        # Find the first instance of friendly_tag matching genre\n        for friendly_tag in self.genre_tags_dict:\n            if self.genre_tags_dict[friendly_tag] == genre:\n                return friendly_tag\n", "docstring": "Return the first friendly_tag matching genre."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def get_prefix_rules(self):\n        \"\"\" Convert opts.prefix_rules to dict.\n        Convert opts.prefix_rules to dict format. The model for a prefix rule is\n        ('<rule name>','<#source_field_lookup>','<pattern>','<prefix>')\n        Input:\n         opts.prefix_rules (tuples): (name, field, pattern, prefix)\n        Return:\n         (list): list of prefix_rules dicts\n        \"\"\"\n        pr = []\n        if self.opts.prefix_rules:\n            try:\n                for rule in self.opts.prefix_rules:\n                    prefix_rule = {}\n                    prefix_rule['name'] = rule[0]\n                    prefix_rule['field'] = rule[1]\n                    prefix_rule['pattern'] = rule[2]\n                    prefix_rule['prefix'] = rule[3]\n                    pr.append(prefix_rule)\n            except:\n                self.opts.log.error(\"malformed prefix_rules: %s\" % repr(self.opts.prefix_rules))\n                raise\n        return pr\n", "docstring": "Convert opts.prefix_rules to dict."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def load_section_templates(self):\n        \"\"\" Add section templates to local namespace.\n        Load section templates from resource directory. If user has made local copies,\n        these will be used for individual section generation.\n        generate_format_args() builds args that populate templates.\n        Templates referenced in individual section builders, e.g.\n        generate_html_by_title().\n        Inputs:\n         (files): section template files from resource dir\n        Results:\n         (strs): section templates added to local namespace\n        \"\"\"\n        for line in P('catalog/section_list_templates.conf', data=True).decode('utf-8').splitlines():\n            line = line.lstrip()\n            if line.startswith('#'):\n                continue\n            if line.startswith('by_'):\n                key, val = line.split(' ', 1)\n                key, val = key.strip(), val.strip()\n                if key.endswith('_template'):\n                    setattr(self, key, val)\n", "docstring": "Add section templates to local namespace."}
{"repo": "calibre-master/src/calibre/library/catalogs/epub_mobi_builder.py", "original_string": "    def update_progress_full_step(self, description):\n        \"\"\" Update calibre's job status UI.\n        Call ProgessReporter() with updates.\n        Args:\n         description (str): text describing current step\n        Result:\n         (UI): Jobs UI updated\n        \"\"\"\n        self.current_step += 1\n        self.progress_string = description\n        self.progress_int = float((self.current_step - 1) / self.total_steps)\n        if not self.progress_int:\n            self.progress_int = 0.01\n        self.reporter(self.progress_int, self.progress_string)\n        if self.opts.cli_environment:\n            log_msg = \"%3.0f%% %s\" % (self.progress_int * 100, self.progress_string)\n            if self.opts.verbose:\n                log_msg += \" (%s)\" % unicode_type(datetime.timedelta(seconds=int(time.time() - self.opts.start_time)))\n        else:\n            log_msg = (\"%s (%s)\" % (self.progress_string,\n                unicode_type(datetime.timedelta(seconds=int(time.time() - self.opts.start_time)))))\n        self.opts.log(log_msg)\n", "docstring": "Update calibre's job status UI."}
{"repo": "calibre-master/src/calibre/srv/auth.py", "original_string": "    def H_A2(self, data):\n        \"\"\"Returns the H(A2) string. See :rfc:`2617` section 3.2.2.3.\"\"\"\n        # RFC 2617 3.2.2.3\n        # If the \"qop\" directive's value is \"auth\" or is unspecified,\n        # then A2 is:\n        #    A2 = method \":\" digest-uri-value\n        #\n        # If the \"qop\" value is \"auth-int\", then A2 is:\n        #    A2 = method \":\" digest-uri-value \":\" H(entity-body)\n        if self.qop == \"auth-int\":\n            a2 = \"%s:%s:%s\" % (data.method, self.uri, self.H(data.peek()))\n        else:\n            a2 = '%s:%s' % (data.method, self.uri)\n        return self.H(a2)\n", "docstring": "Returns the H(A2) string. See :rfc:`2617` section 3.2.2.3.\n"}
{"repo": "calibre-master/src/calibre/srv/auth.py", "original_string": "    def validate_request(self, pw, data, log=None):\n        # We should also be checking for replay attacks by using nonce_count,\n        # however, various HTTP clients, most prominently Firefox dont\n        # implement nonce-counts correctly, so we cannot do the check.\n        # https://bugzil.la/114451\n        path = parse_uri(self.uri.encode('utf-8'))[1]\n        if path != data.path:\n            if log is not None:\n                log.warn('Authorization URI mismatch: %s != %s from client: %s' % (\n                    data.path, path, data.remote_addr))\n            raise HTTPSimpleResponse(http_client.BAD_REQUEST, 'The uri in the Request Line and the Authorization header do not match')\n        return self.response is not None and data.path == path and self.request_digest(pw, data) == self.response\n", "docstring": "We should also be checking for replay attacks by using nonce_count,"}
{"repo": "calibre-master/src/calibre/srv/ajax.py", "original_string": "def search_result(ctx, rd, db, query, num, offset, sort, sort_order, vl=''):\n    multisort = [(sanitize_sort_field_name(db.field_metadata, s), ensure_val(o, 'asc', 'desc') == 'asc')\n                 for s, o in zip(sort.split(','), cycle(sort_order.split(',')))]\n    skeys = db.field_metadata.sortable_field_keys()\n    for sfield, sorder in multisort:\n        if sfield not in skeys:\n            raise HTTPNotFound('%s is not a valid sort field'%sort)\n    ids, parse_error = ctx.search(rd, db, query, vl=vl, report_restriction_errors=True)\n    ids = db.multisort(fields=multisort, ids_to_sort=ids)\n    total_num = len(ids)\n    ids = ids[offset:offset+num]\n    num_books = db.number_of_books_in_virtual_library(vl) if query else total_num\n    ans = {\n        'total_num': total_num, 'sort_order':sort_order,\n        'num_books_without_search': num_books,\n        'offset':offset, 'num':len(ids), 'sort':sort,\n        'base_url':ctx.url_for(search, library_id=db.server_library_id),\n        'query': query,\n        'library_id': db.server_library_id,\n        'book_ids':ids,\n        'vl': vl,\n    }\n    if parse_error is not None:\n        ans['bad_restriction'] = unicode_type(parse_error)\n    return ans\n", "docstring": "multisort = [(sanitize_sort_field_name(db.field_metadata, s), ensure_val(o, 'asc', 'desc') == 'asc')"}
{"repo": "calibre-master/src/calibre/srv/metadata.py", "original_string": "def create_toplevel_tree(category_data, items, field_metadata, opts):\n    # Create the basic tree, containing all top level categories , user\n    # categories and grouped search terms\n    last_category_node, category_node_map, root = None, {}, {'id':None, 'children':[]}\n    node_id_map = {}\n    category_nodes, recount_nodes = [], []\n    order = tweaks['tag_browser_category_order']\n    defvalue = order.get('*', 100)\n    categories = [category for category in field_metadata if category in category_data]\n    scats = sorted(categories, key=lambda x: order.get(x, defvalue))\n    for category in scats:\n        is_user_category = category.startswith('@')\n        is_gst, tooltip = (is_user_category and category[1:] in opts.grouped_search_terms), ''\n        cdata = category_data[category]\n        if is_gst:\n            tooltip = _('The grouped search term name is \"{0}\"').format(category)\n        elif category != 'news':\n            cust_desc = ''\n            fm = field_metadata[category]\n            if fm['is_custom']:\n                cust_desc = fm['display'].get('description', '')\n                if cust_desc:\n                    cust_desc = '\\n' + _('Description:') + ' ' + cust_desc\n            tooltip = _('The lookup/search name is \"{0}\"{1}').format(category, cust_desc)\n        if is_user_category:\n            path_parts = category.split('.')\n            path = ''\n            last_category_node = None\n            current_root = root\n            for i, p in enumerate(path_parts):\n                path += p\n                if path not in category_node_map:\n                    last_category_node = category_as_json(\n                        items, path, (p[1:] if i == 0 else p), len(cdata),\n                        parent=last_category_node, tooltip=tooltip,\n                        is_gst=is_gst, is_editable=((not is_gst) and (i == (len(path_parts)-1))),\n                        is_hierarchical=False if is_gst else 5, is_user_category=True\n                    )\n                    node_id_map[last_category_node] = category_node_map[path] = node = {'id':last_category_node, 'children':[]}\n                    category_nodes.append(last_category_node)\n                    recount_nodes.append(node)\n                    current_root['children'].append(node)\n                    current_root = node\n                else:\n                    current_root = category_node_map[path]\n                    last_category_node = current_root['id']\n                path += '.'\n        else:\n            last_category_node = category_as_json(\n                items, category, field_metadata[category]['name'], len(cdata),\n                tooltip=tooltip\n            )\n            category_node_map[category] = node_id_map[last_category_node] = node = {'id':last_category_node, 'children':[]}\n            root['children'].append(node)\n            category_nodes.append(last_category_node)\n            recount_nodes.append(node)\n    return root, node_id_map, category_nodes, recount_nodes\n", "docstring": "Create the basic tree, containing all top level categories , user"}
{"repo": "calibre-master/src/calibre/srv/metadata.py", "original_string": "    def create_tag_node(tag, parent):\n        # User categories contain references to items in other categories, so\n        # reflect that in the node structure as well.\n        node_data = tag_map.get(id(tag), None)\n        if node_data is None:\n            node_id = 'n%d' % len(tag_map)\n            node_data = items[node_id] = category_item_as_json(tag, clear_rating=clear_rating)\n            tag_map[id(tag)] = (node_id, node_data)\n            node_to_tag_map[node_id] = tag\n        else:\n            node_id, node_data = node_data\n        node = {'id':node_id, 'children':[]}\n        parent['children'].append(node)\n        return node, node_data\n", "docstring": "User categories contain references to items in other categories, so"}
{"repo": "calibre-master/src/calibre/srv/books.py", "original_string": "def set_last_read_position(ctx, rd, library_id, book_id, fmt):\n    db = get_db(ctx, rd, library_id)\n    user = rd.username or None\n    if not ctx.has_id(rd, db, book_id):\n        raise BookNotFound(book_id, db)\n    try:\n        data = jsonlib.load(rd.request_body_file)\n        device, cfi, pos_frac = data['device'], data['cfi'], data['pos_frac']\n    except Exception:\n        raise HTTPNotFound('Invalid data')\n    db.set_last_read_position(\n        book_id, fmt, user=user, device=device, cfi=cfi or None, pos_frac=pos_frac)\n    rd.outheaders['Content-type'] = 'text/plain'\n    return b''\n", "docstring": "db = get_db(ctx, rd, library_id)"}
{"repo": "calibre-master/src/calibre/srv/books.py", "original_string": "def update_annotations(ctx, rd, library_id, book_id, fmt):\n    db = get_db(ctx, rd, library_id)\n    user = rd.username or '*'\n    if not ctx.has_id(rd, db, book_id):\n        raise BookNotFound(book_id, db)\n    try:\n        amap = jsonlib.load(rd.request_body_file)\n    except Exception:\n        raise HTTPNotFound('Invalid data')\n    alist = []\n    for val in itervalues(amap):\n        if val:\n            alist.extend(val)\n    db.merge_annotations_for_book(book_id, fmt, alist, user_type='web', user=user)\n    return b''\n", "docstring": "db = get_db(ctx, rd, library_id)"}
{"repo": "calibre-master/src/calibre/srv/loop.py", "original_string": "    def recv_from(self, socket):\n        # Write into this buffer from socket, return number of bytes written\n        if self.read_pos == self.write_pos and self.full_state is READ:\n            return 0\n        if self.write_pos < self.read_pos:\n            num = socket.recv_into(self.buf[self.write_pos:self.read_pos])\n            self.write_pos += num\n        else:\n            num = socket.recv_into(self.buf[self.write_pos:])\n            self.write_pos = (self.write_pos + num) % len(self.buf)\n        if self.write_pos == self.read_pos:\n            self.full_state = READ\n        return num\n", "docstring": "Write into this buffer from socket, return number of bytes written"}
{"repo": "calibre-master/src/calibre/srv/loop.py", "original_string": "    def recv(self, amt):\n        # If there is data in the read buffer we have to return only that,\n        # since we dont know if the socket has signalled it is ready for\n        # reading\n        if self.read_buffer.has_data:\n            return self.read_buffer.read(amt)\n        # read buffer is empty, so read directly from socket\n        try:\n            data = self.socket.recv(amt)\n            self.last_activity = monotonic()\n            if not data:\n                # a closed connection is indicated by signaling\n                # a read condition, and having recv() return 0.\n                self.ready = False\n                return b''\n            return data\n        except ssl.SSLWantReadError:\n            return b''\n        except socket.error as e:\n            if e.errno in socket_errors_nonblocking or e.errno in socket_errors_eintr:\n                return b''\n            if e.errno in socket_errors_socket_closed:\n                self.ready = False\n                return b''\n            raise\n", "docstring": "If there is data in the read buffer we have to return only that,"}
{"repo": "calibre-master/src/calibre/srv/loop.py", "original_string": "    def serve_forever(self):\n        \"\"\" Listen for incoming connections. \"\"\"\n        self.initialize_socket()\n        self.serve()\n", "docstring": "Listen for incoming connections. \n"}
{"repo": "calibre-master/src/calibre/srv/loop.py", "original_string": "    def bind(self, family, atype, proto=0):\n        '''Create (or recreate) the actual socket object.'''\n        self.socket = socket.socket(family, atype, proto)\n        set_socket_inherit(self.socket, False)\n        self.setup_socket()\n        self.socket.bind(self.bind_address)\n", "docstring": "Create (or recreate) the actual socket object.'''"}
{"repo": "calibre-master/src/calibre/srv/utils.py", "original_string": "def error_codes(*errnames):\n    ''' Return error numbers for error names, ignoring non-existent names '''\n    ans = {getattr(errno, x, None) for x in errnames}\n    ans.discard(None)\n    return ans\n", "docstring": "Return error numbers for error names, ignoring non-existent names '''"}
{"repo": "calibre-master/src/calibre/srv/utils.py", "original_string": "def create_sock_pair():\n    '''Create socket pair. '''\n    client_sock, srv_sock = socket.socketpair()\n    set_socket_inherit(client_sock, False), set_socket_inherit(srv_sock, False)\n    return client_sock, srv_sock\n", "docstring": "Create socket pair. '''"}
{"repo": "calibre-master/src/calibre/srv/cdb.py", "original_string": "def cdb_delete_book(ctx, rd, book_ids, library_id):\n    db = get_db(ctx, rd, library_id)\n    if ctx.restriction_for(rd, db):\n        raise HTTPForbidden('Cannot use the delete book interface with a user who has per library restrictions')\n    try:\n        ids = {int(x) for x in book_ids.split(',')}\n    except Exception:\n        raise HTTPBadRequest('invalid book_ids: {}'.format(book_ids))\n    db.remove_books(ids)\n    ctx.notify_changes(db.backend.library_path, books_deleted(ids))\n    return {}\n", "docstring": "db = get_db(ctx, rd, library_id)"}
{"repo": "calibre-master/src/calibre/srv/render_book.py", "original_string": "def ensure_body(root):\n    # Make sure we have only a single <body>\n    bodies = list(root.iterchildren(XHTML('body')))\n    if len(bodies) != 1:\n        if not bodies:\n            root.append(root.makeelement(XHTML('body')))\n            return\n        body = bodies[0]\n        for b in bodies[1:]:\n            div = root.makeelement(XHTML('div'))\n            div.attrib.update(b.attrib)\n            div.text = b.text\n            for child in b:\n                div.append(child)\n            body.append(div)\n", "docstring": "Make sure we have only a single <body>"}
{"repo": "calibre-master/src/calibre/srv/code.py", "original_string": "def get_library_init_data(ctx, rd, db, num, sorts, orders, vl):\n    ans = {}\n    with db.safe_read_lock:\n        try:\n            ans['search_result'] = search_result(\n                ctx, rd, db,\n                rd.query.get('search', ''), num, 0, ','.join(sorts),\n                ','.join(orders), vl\n            )\n        except ParseException:\n            ans['search_result'] = search_result(\n                ctx, rd, db, '', num, 0, ','.join(sorts), ','.join(orders), vl\n            )\n        sf = db.field_metadata.ui_sortable_field_keys()\n        sf.pop('ondevice', None)\n        ans['sortable_fields'] = sorted(\n            ((sanitize_sort_field_name(db.field_metadata, k), v)\n             for k, v in iteritems(sf)),\n            key=lambda field_name: sort_key(field_name[1])\n        )\n        ans['field_metadata'] = db.field_metadata.all_metadata()\n        ans['virtual_libraries'] = db._pref('virtual_libraries', {})\n        ans['book_display_fields'] = get_field_list(db)\n        mdata = ans['metadata'] = {}\n        try:\n            extra_books = set(\n                int(x) for x in rd.query.get('extra_books', '').split(',')\n            )\n        except Exception:\n            extra_books = ()\n        for coll in (ans['search_result']['book_ids'], extra_books):\n            for book_id in coll:\n                if book_id not in mdata:\n                    data = book_as_json(db, book_id)\n                    if data is not None:\n                        mdata[book_id] = data\n    return ans\n", "docstring": "ans = {}"}
{"repo": "calibre-master/src/calibre/srv/http_response.py", "original_string": "def get_ranges(headervalue, content_length):  # {{{\n    ''' Return a list of ranges from the Range header. If this function returns\n    an empty list, it indicates no valid range was found. '''\n    if not headervalue:\n        return None\n    result = []\n    try:\n        bytesunit, byteranges = headervalue.split(\"=\", 1)\n    except Exception:\n        return None\n    if bytesunit.strip() != 'bytes':\n        return None\n    for brange in byteranges.split(\",\"):\n        start, stop = [x.strip() for x in brange.split(\"-\", 1)]\n        if start:\n            if not stop:\n                stop = content_length - 1\n            try:\n                start, stop = int(start), int(stop)\n            except Exception:\n                continue\n            if start >= content_length:\n                continue\n            if stop < start:\n                continue\n            stop = min(stop, content_length - 1)\n            result.append(Range(start, stop, stop - start + 1))\n        elif stop:\n            # Negative subscript (last N bytes)\n            try:\n                stop = int(stop)\n            except Exception:\n                continue\n            if stop > content_length:\n                result.append(Range(0, content_length-1, content_length))\n            else:\n                result.append(Range(content_length - stop, content_length - 1, stop))\n    return result\n", "docstring": "Return a list of ranges from the Range header. If this function returns"}
{"repo": "calibre-master/src/calibre/srv/http_response.py", "original_string": "def gzip_prefix():\n    # See http://www.gzip.org/zlib/rfc-gzip.html\n    return b''.join((\n        b'\\x1f\\x8b',       # ID1 and ID2: gzip marker\n        b'\\x08',           # CM: compression method\n        b'\\x00',           # FLG: none set\n        # MTIME: 4 bytes, set to zero so as not to leak timezone information\n        b'\\0\\0\\0\\0',\n        b'\\x02',           # XFL: max compression, slowest algo\n        b'\\xff',           # OS: unknown\n    ))\n", "docstring": "See http://www.gzip.org/zlib/rfc-gzip.html"}
{"repo": "calibre-master/src/calibre/srv/library_broker.py", "original_string": "    def prepare_for_gui_library_change(self, newloc):\n        # Must be called with lock held\n        for library_id, path in iteritems(self.lmap):\n            db = self.loaded_dbs.get(library_id)\n            if db is not None and samefile(newloc, path):\n                if library_id == self.gui_library_id:\n                    # Have to reload db\n                    self.loaded_dbs.pop(library_id, None)\n                    return\n                set_global_state(db)\n                return db\n", "docstring": "Must be called with lock held"}
{"repo": "calibre-master/src/calibre/srv/content.py", "original_string": "def create_file_copy(ctx, rd, prefix, library_id, book_id, ext, mtime, copy_func, extra_etag_data=''):\n    ''' We cannot copy files directly from the library folder to the output\n    socket, as this can potentially lock the library for an extended period. So\n    instead we copy out the data from the library folder into a temp folder. We\n    make sure to only do this copy once, using the previous copy, if there have\n    been no changes to the data for the file since the last copy. '''\n    global rename_counter\n    # Avoid too many items in a single directory for performance\n    base = os.path.join(rd.tdir, 'fcache', (('%x' % book_id)[-3:]))\n    if iswindows:\n        base = '\\\\\\\\?\\\\' + os.path.abspath(base)  # Ensure fname is not too long for windows' API\n    bname = '%s-%s-%x.%s' % (prefix, library_id, book_id, ext)\n    if '\\\\' in bname or '/' in bname:\n        raise ValueError('File components must not contain path separators')\n    fname = os.path.join(base, bname)\n    used_cache = 'no'\n    def safe_mtime():\n        with suppress(OSError):\n            return os.path.getmtime(fname)\n    mt = mtime if isinstance(mtime, (int, float)) else timestampfromdt(mtime)\n    with lock:\n        previous_mtime = safe_mtime()\n        if previous_mtime is None or previous_mtime < mt:\n            if previous_mtime is not None:\n                # File exists and may be open, so we cannot change its\n                # contents, as that would lead to corrupted downloads in any\n                # clients that are currently downloading the file.\n                if iswindows:\n                    # On windows in order to re-use bname, we have to rename it\n                    # before deleting it\n                    rename_counter += 1\n                    dname = os.path.join(base, '_%x' % rename_counter)\n                    atomic_rename(fname, dname)\n                    os.remove(dname)\n                else:\n                    os.remove(fname)\n            ans = open_for_write(fname)\n            copy_func(ans)\n            ans.seek(0)\n        else:\n            try:\n                ans = share_open(fname, 'rb')\n                used_cache = 'yes'\n            except EnvironmentError as err:\n                if err.errno != errno.ENOENT:\n                    raise\n                ans = open_for_write(fname)\n                copy_func(ans)\n                ans.seek(0)\n        if ctx.testing:\n            rd.outheaders['Used-Cache'] = used_cache\n            rd.outheaders['Tempfile'] = as_hex_unicode(fname)\n        return rd.filesystem_file_with_custom_etag(ans, prefix, library_id, book_id, mt, extra_etag_data)\n", "docstring": "We cannot copy files directly from the library folder to the output"}
{"repo": "calibre-master/src/calibre/srv/web_socket.py", "original_string": "    def send_websocket_message(self, buf, wakeup=True):\n        ''' Send a complete message. This class will take care of splitting it\n        into appropriate frames automatically. `buf` must be a file like object. '''\n        self.sendq.put(MessageWriter(buf))\n        self.wait_for = RDWR\n        if wakeup:\n            self.wakeup()\n", "docstring": "Send a complete message. This class will take care of splitting it"}
{"repo": "calibre-master/src/calibre/srv/web_socket.py", "original_string": "    def send_websocket_ping(self, data=b''):\n        ''' Send a PING to the remote client, it should reply with a PONG which\n        will be sent to the handle_websocket_pong callback in your handler. '''\n        if isinstance(data, unicode_type):\n            data = data.encode('utf-8')\n        frame = create_frame(True, PING, data)\n        with self.cf_lock:\n            self.control_frames.append(ReadOnlyFileBuffer(frame))\n", "docstring": "Send a PING to the remote client, it should reply with a PONG which"}
{"repo": "calibre-master/src/calibre/srv/http_request.py", "original_string": "def parse_request_uri(uri):\n    \"\"\"Parse a Request-URI into (scheme, authority, path).\n    Note that Request-URI's must be one of::\n        Request-URI    = \"*\" | absoluteURI | abs_path | authority\n    Therefore, a Request-URI which starts with a double forward-slash\n    cannot be a \"net_path\"::\n        net_path      = \"//\" authority [ abs_path ]\n    Instead, it must be interpreted as an \"abs_path\" with an empty first\n    path segment::\n        abs_path      = \"/\"  path_segments\n        path_segments = segment *( \"/\" segment )\n        segment       = *pchar *( \";\" param )\n        param         = *pchar\n    \"\"\"\n    if uri == b'*':\n        return None, None, uri\n    i = uri.find(b'://')\n    if i > 0 and b'?' not in uri[:i]:\n        # An absoluteURI.\n        # If there's a scheme (and it must be http or https), then:\n        # http_URL = \"http:\" \"//\" host [ \":\" port ] [ abs_path [ \"?\" query\n        # ]]\n        scheme, remainder = uri[:i].lower(), uri[i + 3:]\n        authority, path = remainder.partition(b'/')[::2]\n        path = b'/' + path\n        return scheme, authority, path\n    if uri.startswith(b'/'):\n        # An abs_path.\n        return None, None, uri\n    else:\n        # An authority.\n        return None, uri, None\n", "docstring": "Parse a Request-URI into (scheme, authority, path)."}
{"repo": "calibre-master/src/calibre/srv/tests/base.py", "original_string": "    def run(self, result=None):\n        # we retry failing server tests since they are flaky on CI\n        if result is None:\n            result = self.defaultTestResult()\n        max_retries = 1\n        for i in range(max_retries + 1):\n            failures_before = len(result.failures)\n            errors_before = len(result.errors)\n            super().run(result=result)\n            if len(result.failures) == failures_before and len(result.errors) == errors_before:\n                return\n            print(f'Retrying test {self._testMethodName} after failure/error')\n            q = result.failures if len(result.failures) > failures_before else result.errors\n            q.pop(-1)\n            time.sleep(1)\n", "docstring": "we retry failing server tests since they are flaky on CI"}
{"repo": "calibre-master/src/calibre/srv/tests/content.py", "original_string": "def setUpModule():\n    # Needed for cover generation\n    from calibre.gui2 import ensure_app, load_builtin_fonts\n    ensure_app(), load_builtin_fonts()\n", "docstring": "Needed for cover generation"}
{"repo": "calibre-master/src/calibre/devices/winusb.py", "original_string": "def get_storage_number_map(drive_types=(DRIVE_REMOVABLE, DRIVE_FIXED), debug=False):\n    ' Get a mapping of drive letters to storage numbers for all drives on system (of the specified types) '\n    mask = GetLogicalDrives()\n    type_map = {letter:GetDriveType(letter + ':' + os.sep) for i, letter in enumerate(string.ascii_uppercase) if mask & (1 << i)}\n    drives = (letter for letter, dt in iteritems(type_map) if dt in drive_types)\n    ans = defaultdict(list)\n    for letter in drives:\n        try:\n            sn = get_storage_number('\\\\\\\\.\\\\' + letter + ':')\n            ans[sn[:2]].append((sn[2], letter))\n        except OSError as err:\n            if debug:\n                prints('Failed to get storage number for drive: %s with error: %s' % (letter, as_unicode(err)))\n            continue\n    for val in itervalues(ans):\n        val.sort(key=itemgetter(0))\n    return dict(ans)\n", "docstring": "' Get a mapping of drive letters to storage numbers for all drives on system (of the specified types) '"}
{"repo": "calibre-master/src/calibre/devices/winusb.py", "original_string": "def get_device_descriptor(hub_handle, device_port, buf=None):\n    buf = alloc_descriptor_buf(buf)\n    def initbuf(b):\n        cast(b, POINTER(USB_NODE_CONNECTION_INFORMATION_EX)).contents.ConnectionIndex = device_port\n    buf, bytes_returned = device_io_control(hub_handle, IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX, buf, buf, initbuf)\n    return buf, USB_DEVICE_DESCRIPTOR.from_buffer_copy(cast(buf, POINTER(USB_NODE_CONNECTION_INFORMATION_EX)).contents.DeviceDescriptor)\n", "docstring": "buf = alloc_descriptor_buf(buf)"}
{"repo": "calibre-master/src/calibre/devices/cli.py", "original_string": "    def mode_string(self):\n        \"\"\" The mode string for this file. There are only two modes read-only and read-write \"\"\"\n        mode, x = \"-\", \"-\"\n        if self.is_dir:\n            mode, x = \"d\", \"x\"\n        if self.is_readonly:\n            mode += \"r-\"+x+\"r-\"+x+\"r-\"+x\n        else:\n            mode += \"rw\"+x+\"rw\"+x+\"rw\"+x\n        return mode\n", "docstring": "The mode string for this file. There are only two modes read-only and read-write \n"}
{"repo": "calibre-master/src/calibre/devices/cli.py", "original_string": "    def isdir_name(self):\n        '''Return self.name + '/' if self is a directory'''\n        name = self.name\n        if self.is_dir:\n            name += '/'\n        return name\n", "docstring": "Return self.name + '/' if self is a directory'''"}
{"repo": "calibre-master/src/calibre/devices/cli.py", "original_string": "    def name_in_color(self):\n        \"\"\" The name in ANSI text. Directories are blue, ebooks are green \"\"\"\n        cname = self.name\n        blue, green, normal = \"\", \"\", \"\"\n        if self.term:\n            blue, green, normal = self.term.BLUE, self.term.GREEN, self.term.NORMAL\n        if self.is_dir:\n            cname = blue + self.name + normal\n        else:\n            ext = self.name[self.name.rfind(\".\"):]\n            if ext in (\".pdf\", \".rtf\", \".lrf\", \".lrx\", \".txt\"):\n                cname = green + self.name + normal\n        return cname\n", "docstring": "The name in ANSI text. Directories are blue, ebooks are green \n"}
{"repo": "calibre-master/src/calibre/devices/cli.py", "original_string": "    def human_readable_size(self):\n        \"\"\" File size in human readable form \"\"\"\n        return human_readable(self.size)\n", "docstring": "File size in human readable form \n"}
{"repo": "calibre-master/src/calibre/devices/cli.py", "original_string": "    def modification_time(self):\n        \"\"\" Last modified time in the Linux ls -l format \"\"\"\n        return time.strftime(\"%Y-%m-%d %H:%M\", time.localtime(self.wtime))\n", "docstring": "Last modified time in the Linux ls -l format \n"}
{"repo": "calibre-master/src/calibre/devices/cli.py", "original_string": "    def creation_time(self):\n        \"\"\" Last modified time in the Linux ls -l format \"\"\"\n        return time.strftime(\"%Y-%m-%d %H:%M\", time.localtime(self.ctime))\n", "docstring": "Last modified time in the Linux ls -l format \n"}
{"repo": "calibre-master/src/calibre/devices/scanner.py", "original_string": "    def is_device_connected(self, device, debug=False, only_presence=False):\n        ''' If only_presence is True don't perform any expensive checks '''\n        return device.is_usb_connected(self.devices, debug=debug,\n                only_presence=only_presence)\n", "docstring": "If only_presence is True don't perform any expensive checks '''"}
{"repo": "calibre-master/src/calibre/devices/interface.py", "original_string": "    def reset(self, key='-1', log_packets=False, report_progress=None,\n            detected_device=None):\n        \"\"\"\n        :param key: The key to unlock the device\n        :param log_packets: If true the packet stream to/from the device is logged\n        :param report_progress: Function that is called with a % progress\n                                (number between 0 and 100) for various tasks\n                                If it is called with -1 that means that the\n                                task does not have any progress information\n        :param detected_device: Device information from the device scanner\n        \"\"\"\n        raise NotImplementedError()\n", "docstring": "detected_device=None):"}
{"repo": "calibre-master/src/calibre/devices/interface.py", "original_string": "    def upload_books(self, files, names, on_card=None, end_session=True,\n                     metadata=None):\n        '''\n        Upload a list of books to the device. If a file already\n        exists on the device, it should be replaced.\n        This method should raise a :class:`FreeSpaceError` if there is not enough\n        free space on the device. The text of the FreeSpaceError must contain the\n        word \"card\" if ``on_card`` is not None otherwise it must contain the word \"memory\".\n        :param files: A list of paths\n        :param names: A list of file names that the books should have\n                      once uploaded to the device. len(names) == len(files)\n        :param metadata: If not None, it is a list of :class:`Metadata` objects.\n                         The idea is to use the metadata to determine where on the device to\n                         put the book. len(metadata) == len(files). Apart from the regular\n                         cover (path to cover), there may also be a thumbnail attribute, which should\n                         be used in preference. The thumbnail attribute is of the form\n                         (width, height, cover_data as jpeg).\n        :return: A list of 3-element tuples. The list is meant to be passed\n                 to :meth:`add_books_to_metadata`.\n        '''\n        raise NotImplementedError()\n", "docstring": "metadata=None):"}
{"repo": "calibre-master/src/calibre/devices/interface.py", "original_string": "    def __init__(self):\n        self._device = None\n", "docstring": "self._device = None"}
{"repo": "calibre-master/src/calibre/devices/kobo/books.py", "original_string": "    def is_sideloaded(self):\n        # If we don't have a content Id, we don't know what type it is.\n        return self.contentID and self.contentID.startswith(\"file\")\n", "docstring": "If we don't have a content Id, we don't know what type it is."}
{"repo": "calibre-master/src/calibre/devices/kobo/bookmark.py", "original_string": "    def get_book_length(self):\n        # TL        self.book_length = 0\n        # TL        self.book_length = int(unpack('>I', record0[0x04:0x08])[0])\n        pass\n", "docstring": "TL        self.book_length = 0"}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def get_firmware_version(self):\n        # Determine the firmware version\n        try:\n            with lopen(self.normalize_path(self._main_prefix + '.kobo/version'), 'rb') as f:\n                fwversion = f.readline().split(b',')[2]\n                fwversion = tuple((int(x) for x in fwversion.split(b'.')))\n        except Exception:\n            debug_print(\"Kobo::get_firmware_version - didn't get firmware version from file'\")\n            fwversion = (0,0,0)\n        return fwversion\n", "docstring": "Determine the firmware version"}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def delete_via_sql(self, ContentID, ContentType):\n        # Delete Order:\n        #    1) shortcover_page\n        #    2) volume_shorcover\n        #    2) content\n        debug_print('delete_via_sql: ContentID: ', ContentID, 'ContentType: ', ContentType)\n        with closing(self.device_database_connection()) as connection:\n            cursor = connection.cursor()\n            t = (ContentID,)\n            cursor.execute('select ImageID from content where ContentID = ?', t)\n            ImageID = None\n            for row in cursor:\n                # First get the ImageID to delete the images\n                ImageID = row[0]\n            cursor.close()\n            cursor = connection.cursor()\n            if ContentType == 6 and self.dbversion < 8:\n                # Delete the shortcover_pages first\n                cursor.execute('delete from shortcover_page where shortcoverid in (select ContentID from content where BookID = ?)', t)\n            # Delete the volume_shortcovers second\n            cursor.execute('delete from volume_shortcovers where volumeid = ?', t)\n            # Delete the rows from content_keys\n            if self.dbversion >= 8:\n                cursor.execute('delete from content_keys where volumeid = ?', t)\n            # Delete the chapters associated with the book next\n            t = (ContentID,)\n            # Kobo does not delete the Book row (ie the row where the BookID is Null)\n            # The next server sync should remove the row\n            cursor.execute('delete from content where BookID = ?', t)\n            if ContentType == 6:\n                try:\n                    cursor.execute('update content set ReadStatus=0, FirstTimeReading = \\'true\\', ___PercentRead=0, ___ExpirationStatus=3 '\n                        'where BookID is Null and ContentID =?',t)\n                except Exception as e:\n                    if 'no such column' not in unicode_type(e):\n                        raise\n                    try:\n                        cursor.execute('update content set ReadStatus=0, FirstTimeReading = \\'true\\', ___PercentRead=0 '\n                            'where BookID is Null and ContentID =?',t)\n                    except Exception as e:\n                        if 'no such column' not in unicode_type(e):\n                            raise\n                        cursor.execute('update content set ReadStatus=0, FirstTimeReading = \\'true\\' '\n                            'where BookID is Null and ContentID =?',t)\n            else:\n                cursor.execute('delete from content where BookID is Null and ContentID =?',t)\n            cursor.close()\n            if ImageID is None:\n                print(\"Error condition ImageID was not found\")\n                print(\"You likely tried to delete a book that the kobo has not yet added to the database\")\n        # If all this succeeds we need to delete the images files via the ImageID\n        return ImageID\n", "docstring": "Delete Order:"}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def get_content_type_from_path(self, path):\n        # Strictly speaking the ContentType could be 6 or 10\n        # however newspapers have the same storage format\n        ContentType = 901\n        if path.find('kepub') >= 0:\n            ContentType = 6\n        return ContentType\n", "docstring": "Strictly speaking the ContentType could be 6 or 10"}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def book_from_path(cls, prefix, lpath, title, authors, mime, date, ContentType, ImageID):\n        # debug_print(\"KOBO:book_from_path - title=%s\"%title)\n        from calibre.ebooks.metadata import MetaInformation\n        if cls.read_metadata or cls.MUST_READ_METADATA:\n            mi = cls.metadata_from_path(cls.normalize_path(os.path.join(prefix, lpath)))\n        else:\n            from calibre.ebooks.metadata.meta import metadata_from_filename\n            mi = metadata_from_filename(cls.normalize_path(os.path.basename(lpath)),\n                                        cls.build_template_regexp())\n        if mi is None:\n            mi = MetaInformation(os.path.splitext(os.path.basename(lpath))[0],\n                    [_('Unknown')])\n        size = os.stat(cls.normalize_path(os.path.join(prefix, lpath))).st_size\n        book =  cls.book_class(prefix, lpath, title, authors, mime, date, ContentType, ImageID, size=size, other=mi)\n        return book\n", "docstring": "debug_print(\"KOBO:book_from_path - title=%s\"%title)"}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def reset_favouritesindex(self, connection, oncard):\n        # Reset FavouritesIndex list in the database\n        if oncard == 'carda':\n            query= 'update content set FavouritesIndex=-1 where BookID is Null and ContentID like \\'file:///mnt/sd/%\\''\n        elif oncard != 'carda' and oncard != 'cardb':\n            query= 'update content set FavouritesIndex=-1 where BookID is Null and ContentID not like \\'file:///mnt/sd/%\\''\n        cursor = connection.cursor()\n        try:\n            cursor.execute(query)\n        except Exception as e:\n            debug_print('    Database Exception:  Unable to reset Shortlist list')\n            if 'no such column' not in unicode_type(e):\n                raise\n        finally:\n            cursor.close()\n", "docstring": "Reset FavouritesIndex list in the database"}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def config_widget(self):\n        # TODO: Cleanup the following\n        self.current_friendly_name = self.gui_name\n        from calibre.gui2.device_drivers.tabbed_device_config import TabbedDeviceConfig\n        return TabbedDeviceConfig(self.settings(), self.FORMATS, self.SUPPORTS_SUB_DIRS,\n                    self.MUST_READ_METADATA, self.SUPPORTS_USE_AUTHOR_SORT,\n                    self.EXTRA_CUSTOMIZATION_MESSAGE, self,\n                    extra_customization_choices=self.EXTRA_CUSTOMIZATION_CHOICES)\n", "docstring": "TODO: Cleanup the following"}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def create_annotations_path(self, mdata, device_path=None):\n        if device_path:\n            return device_path\n        return USBMS.create_annotations_path(self, mdata)\n", "docstring": "if device_path:"}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def open_osx(self):\n        # Just dump some info to the logs.\n        super(KOBOTOUCH, self).open_osx()\n        # Wrap some debugging output in a try/except so that it is unlikely to break things completely.\n        try:\n            if DEBUG:\n                from calibre_extensions.usbobserver import get_mounted_filesystems\n                mount_map = get_mounted_filesystems()\n                debug_print('KoboTouch::open_osx - mount_map=', mount_map)\n                debug_print('KoboTouch::open_osx - self._main_prefix=', self._main_prefix)\n                debug_print('KoboTouch::open_osx - self._card_a_prefix=', self._card_a_prefix)\n                debug_print('KoboTouch::open_osx - self._card_b_prefix=', self._card_b_prefix)\n        except:\n            pass\n        self.swap_drives_if_needed()\n", "docstring": "Just dump some info to the logs."}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "        def get_bookshelvesforbook(connection, ContentID):\n            #            debug_print(\"KoboTouch:get_bookshelvesforbook - \" + ContentID)\n            bookshelves = []\n            if not self.supports_bookshelves:\n                return bookshelves\n            cursor = connection.cursor()\n            query = \"select ShelfName \"         \\\n                    \"from ShelfContent \"        \\\n                    \"where ContentId = ? \"      \\\n                    \"and _IsDeleted = 'false' \" \\\n                    \"and ShelfName is not null\"         # This should never be nulll, but it is protection against an error cause by a sync to the Kobo server\n            values = (ContentID, )\n            cursor.execute(query, values)\n            for i, row in enumerate(cursor):\n                bookshelves.append(row['ShelfName'])\n            cursor.close()\n", "docstring": "debug_print(\"KoboTouch:get_bookshelvesforbook - \" + ContentID)"}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def create_container(self, book_file, metadata, container=None):\n        # create new container if not received, else pass through\n        if not container:\n            commit_container = True\n            try:\n                from calibre.ebooks.oeb.polish.container import get_container\n                debug_print(\"KoboTouch:create_container: try to create new container\")\n                container = get_container(book_file)\n                container.css_preprocessor = DummyCSSPreProcessor()\n            except Exception as e:\n                debug_print(\"KoboTouch:create_container: exception from get_container {0} - {1}\".format(metadata.author_sort, metadata.title))\n                debug_print(\"KoboTouch:create_container: exception is: {0}\".format(e))\n        else:\n            commit_container = False\n            debug_print(\"KoboTouch:create_container: received container\")\n        return container, commit_container\n", "docstring": "create new container if not received, else pass through"}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def _calculate_kobo_cover_size(self, library_size, kobo_size, expand, keep_cover_aspect, letterbox):\n        # Remember the canvas size\n        canvas_size = kobo_size\n        # NOTE: Loosely based on Qt's QSize::scaled implementation\n        if keep_cover_aspect:\n            # NOTE: Unlike Qt, we round to avoid accumulating errors,\n            #       as ImageOps will then floor via fit_image\n            aspect_ratio = library_size[0] / library_size[1]\n            rescaled_width = int(round(kobo_size[1] * aspect_ratio))\n            if expand:\n                use_height = (rescaled_width >= kobo_size[0])\n            else:\n                use_height = (rescaled_width <= kobo_size[0])\n            if use_height:\n                kobo_size = (rescaled_width, kobo_size[1])\n            else:\n                kobo_size = (kobo_size[0], int(round(kobo_size[0] / aspect_ratio)))\n            # Did we actually want to letterbox?\n            if not letterbox:\n                canvas_size = kobo_size\n        return (kobo_size, canvas_size)\n", "docstring": "Remember the canvas size"}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def config_widget(cls):\n        # TODO: Cleanup the following\n        cls.current_friendly_name = cls.gui_name\n        from calibre.devices.kobo.kobotouch_config import KOBOTOUCHConfig\n        return KOBOTOUCHConfig(cls.settings(), cls.FORMATS,\n                               cls.SUPPORTS_SUB_DIRS, cls.MUST_READ_METADATA,\n                               cls.SUPPORTS_USE_AUTHOR_SORT, cls.EXTRA_CUSTOMIZATION_MESSAGE,\n                               cls, extra_customization_choices=cls.EXTRA_CUSTOMIZATION_CHOICES\n                               )\n", "docstring": "TODO: Cleanup the following"}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def get_pref(cls, key):\n        ''' Get the setting named key. First looks for a device specific setting.\n        If that is not found looks for a device default and if that is not\n        found uses the global default.'''\n", "docstring": "Get the setting named key. First looks for a device specific setting."}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def ignore_collections_names(self):\n        # Cache the collection from the options string.\n        if not hasattr(self.opts, '_ignore_collections_names'):\n            icn = self.get_pref('ignore_collections_names')\n            self.opts._ignore_collections_names = [x.strip() for x in icn.split(',')] if icn else []\n        return self.opts._ignore_collections_names\n", "docstring": "Cache the collection from the options string."}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def create_bookshelves(self):\n        # Only for backwards compatabilty\n        return self.manage_collections\n", "docstring": "Only for backwards compatabilty"}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def delete_empty_shelves(self):\n        # Only for backwards compatabilty\n        return self.delete_empty_collections\n", "docstring": "Only for backwards compatabilty"}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def update_subtitle(self):\n        # Subtitle was added to the database at the same time as the series support.\n        return self.update_device_metadata and self.supports_series() and self.get_pref('update_subtitle')\n", "docstring": "Subtitle was added to the database at the same time as the series support."}
{"repo": "calibre-master/src/calibre/devices/kobo/driver.py", "original_string": "    def is_supported_fwversion(self):\n        # Starting with firmware version 3.19.x, the last number appears to be is a\n        # build number. It can be safely ignored when testing the firmware version.\n        debug_print(\"KoboTouch::is_supported_fwversion - self.fwversion[:2]\", self.fwversion[:2])\n        return self.fwversion[:2] > self.max_supported_fwversion\n", "docstring": "Starting with firmware version 3.19.x, the last number appears to be is a"}
{"repo": "calibre-master/src/calibre/devices/smart_device_app/driver.py", "original_string": "def synchronous(tlockname):\n    \"\"\"A decorator to place an instance based lock around a method \"\"\"\n    def _synched(func):\n        @wraps(func)\n        def _synchronizer(self, *args, **kwargs):\n            with self.__getattribute__(tlockname):\n                return func(self, *args, **kwargs)\n        return _synchronizer\n    return _synched\n", "docstring": "A decorator to place an instance based lock around a method \n"}
{"repo": "calibre-master/src/calibre/devices/smart_device_app/driver.py", "original_string": "    def _debug(self, *args):\n        # manual synchronization so we don't lose the calling method name\n        import inspect\n        with self.sync_lock:\n            if not DEBUG:\n                return\n            total_elapsed = time.time() - self.debug_start_time\n            elapsed = time.time() - self.debug_time\n            print('SMART_DEV (%7.2f:%7.3f) %s'%(total_elapsed, elapsed,\n                                                   inspect.stack()[1][3]), end='')\n            for a in args:\n                try:\n                    if isinstance(a, dict):\n                        printable = {}\n                        for k,v in iteritems(a):\n                            if isinstance(v, (bytes, unicode_type)) and len(v) > 50:\n                                printable[k] = 'too long'\n                            else:\n                                printable[k] = v\n                        prints('', printable, end='')\n                    else:\n                        prints('', a, end='')\n                except:\n                    prints('', 'value too long', end='')\n            print()\n            self.debug_time = time.time()\n", "docstring": "manual synchronization so we don't lose the calling method name"}
{"repo": "calibre-master/src/calibre/devices/smart_device_app/driver.py", "original_string": "    def _shutdown(self):\n        # Force close any socket open by a device. This will cause any IO on the\n        # socket to fail, eventually releasing the transaction lock.\n        self._close_device_socket()\n        # Now lockup so we can shutdown the control socket and unpublish mDNS\n        with self.sync_lock:\n            if getattr(self, 'listen_socket', None) is not None:\n                self.connection_listener.stop()\n                try:\n                    unpublish_zeroconf('calibre smart device client',\n                                       '_calibresmartdeviceapp._tcp', self.port, {})\n                except:\n                    self._debug('deregistration with bonjour failed')\n                    traceback.print_exc()\n                self._close_listen_socket()\n", "docstring": "Force close any socket open by a device. This will cause any IO on the"}
{"repo": "calibre-master/src/calibre/devices/mtp/test.py", "original_string": "    def test_folder_operations(self):\n        ''' Test the creation of folders, duplicate folders and sub folders '''\n        self.check_setup()\n        # Create a folder\n        name = 'zzz-test-folder'\n        folder = self.dev.create_folder(self.storage, name)\n        self.cleanup.append(folder)\n        self.assertTrue(folder.is_folder)\n        self.assertEqual(folder.parent_id, self.storage.object_id)\n        self.assertEqual(folder.storage_id, self.storage.object_id)\n        self.assertEqual(lower(name), lower(folder.name))\n        # Create a sub-folder\n        name = 'sub-folder'\n        subfolder = self.dev.create_folder(folder, name)\n        self.assertTrue(subfolder.is_folder)\n        self.assertEqual(subfolder.parent_id, folder.object_id)\n        self.assertEqual(subfolder.storage_id, self.storage.object_id)\n        self.assertEqual(lower(name), lower(subfolder.name))\n        self.cleanup.append(subfolder)\n        # Check that creating an existing folder returns that folder (case\n        # insensitively)\n        self.assertIs(subfolder, self.dev.create_folder(folder,\n            'SUB-FOLDER'),\n            msg='Creating an existing folder did not return the existing folder')\n        # Check that creating folders as children of files is not allowed\n        root_file = [f for f in self.dev.filesystem_cache.entries[0].files if\n                not f.is_folder]\n        if root_file:\n            with self.assertRaises(ValueError):\n                self.dev.create_folder(root_file[0], 'sub-folder')\n", "docstring": "Test the creation of folders, duplicate folders and sub folders '''"}
{"repo": "calibre-master/src/calibre/devices/mtp/test.py", "original_string": "    def test_memory_leaks(self):\n        ''' Test for memory leaks in the C module '''\n        self.check_setup()\n        # Test device scanning\n        used_by_one = self.measure_memory_usage(1,\n                self.dev.detect_managed_devices, self.scanner.devices,\n                force_refresh=True)\n        used_by_many = self.measure_memory_usage(100,\n                self.dev.detect_managed_devices, self.scanner.devices,\n                force_refresh=True)\n        self.check_memory(used_by_one, used_by_many,\n                'Memory consumption during device scan')\n        # Test file transfer\n        size = 1024*100\n        raw = io.BytesIO(b'a'*size)\n        raw.seek(0)\n        name = 'zzz-test-file.txt'\n        def send_file(storage, name, raw, size):\n            raw.seek(0)\n            pc = ProgressCallback()\n            f = self.dev.put_file(storage, name, raw, size, callback=pc)\n            self.cleanup.append(f)\n            del pc\n        used_once = self.measure_memory_usage(1, send_file, self.storage, name,\n                raw, size)\n        used_many = self.measure_memory_usage(20, send_file, self.storage, name,\n                raw, size)\n        self.check_memory(used_once, used_many,\n                'Memory consumption during put_file:')\n        def get_file(f):\n            raw = io.BytesIO()\n            pc = ProgressCallback()\n            self.dev.get_mtp_file(f, raw, callback=pc)\n            raw.truncate(0)\n            del raw\n            del pc\n        f = self.storage.file_named(name)\n        used_once = self.measure_memory_usage(1, get_file, f)\n        used_many = self.measure_memory_usage(20, get_file, f)\n        self.check_memory(used_once, used_many,\n                'Memory consumption during get_file:')\n        # Test get_filesystem\n        used_by_one = self.measure_memory_usage(1,\n                self.dev.dev.get_filesystem, self.storage.object_id,\n                                                lambda x, l:True)\n        used_by_many = self.measure_memory_usage(5,\n                self.dev.dev.get_filesystem, self.storage.object_id,\n                                                 lambda x, l: True)\n        self.check_memory(used_by_one, used_by_many,\n                'Memory consumption during get_filesystem')\n", "docstring": "Test for memory leaks in the C module '''"}
{"repo": "calibre-master/src/calibre/devices/mtp/driver.py", "original_string": "    def get_pref(self, key):\n        ''' Get the setting named key. First looks for a device specific setting.\n        If that is not found looks for a device default and if that is not\n        found uses the global default.'''\n        dd = self.current_device_defaults if self.is_mtp_device_connected else {}\n        dev_settings = self.prefs.get('device-%s'%self.current_serial_num, {})\n        default_value = dd.get(key, self.prefs[key])\n        return dev_settings.get(key, default_value)\n", "docstring": "Get the setting named key. First looks for a device specific setting."}
{"repo": "calibre-master/src/calibre/devices/prst1/driver.py", "original_string": "    def post_open_callback(self):\n        # Set the thumbnail width to the theoretical max if the user has asked\n        # that we do not preserve aspect ratio\n        ec = self.settings().extra_customization\n        if not ec[self.OPT_PRESERVE_ASPECT_RATIO]:\n            self.THUMBNAIL_WIDTH = 108\n        self.WANTS_UPDATED_THUMBNAILS = ec[self.OPT_REFRESH_COVERS]\n        # Make sure the date offset is set to none, we'll calculate it in books.\n        self.device_offset = None\n", "docstring": "Set the thumbnail width to the theoretical max if the user has asked"}
{"repo": "calibre-master/src/calibre/devices/prst1/driver.py", "original_string": "    def get_lastrowid(self, cursor):\n        # SQLite3 + Python has a fun issue on 32-bit systems with integer overflows.\n        # Issue a SQL query instead, getting the value as a string, and then converting to a long python int manually.\n        query = 'SELECT last_insert_rowid()'\n        cursor.execute(query)\n        row = cursor.fetchone()\n        return long_type(row[0])\n", "docstring": "SQLite3 + Python has a fun issue on 32-bit systems with integer overflows."}
{"repo": "calibre-master/src/calibre/devices/kindle/driver.py", "original_string": "        def get_my_clippings(storage, bookmarked_books):\n            # add an entry for 'My Clippings.txt'\n            for vol in storage:\n                mc_path = os.path.join(vol,'My Clippings.txt')\n                if os.path.exists(mc_path):\n                    return mc_path\n            return None\n", "docstring": "add an entry for 'My Clippings.txt'"}
{"repo": "calibre-master/src/calibre/devices/kindle/driver.py", "original_string": "    def amazon_cover_bug_cache_dir(self):\n        # see https://www.mobileread.com/forums/showthread.php?t=329945\n        return os.path.join(self._main_prefix, 'amazon-cover-bug')\n", "docstring": "see https://www.mobileread.com/forums/showthread.php?t=329945"}
{"repo": "calibre-master/src/calibre/devices/usbms/device.py", "original_string": "    def open_windows(self):\n        from calibre.devices.scanner import drive_is_ok\n        from calibre.devices.winusb import get_drive_letters_for_device\n        usbdev = self.device_being_opened\n        debug = DEBUG or getattr(self, 'do_device_debug', False)\n        try:\n            dlmap = get_drive_letters_for_device(usbdev, debug=debug)\n        except Exception:\n            dlmap = {}\n        if not dlmap.get('drive_letters'):\n            time.sleep(7)\n            dlmap = get_drive_letters_for_device(usbdev, debug=debug)\n        if debug:\n            from pprint import pformat\n            prints('Drive letters for {}'.format(usbdev))\n            prints(pformat(dlmap))\n        filtered = set()\n        for dl in dlmap['drive_letters']:\n            pnp_id = dlmap['pnp_id_map'][dl].upper()\n            if dl in dlmap['readonly_drives']:\n                filtered.add(dl)\n                if debug:\n                    prints('Ignoring the drive %s as it is readonly' % dl)\n            elif self.windows_filter_pnp_id(pnp_id):\n                filtered.add(dl)\n                if debug:\n                    prints('Ignoring the drive %s because of a PNP filter on %s' % (dl, pnp_id))\n            elif not drive_is_ok(dl, debug=debug):\n                filtered.add(dl)\n                if debug:\n                    prints('Ignoring the drive %s because failed to get free space for it' % dl)\n        dlmap['drive_letters'] = [dl for dl in dlmap['drive_letters'] if dl not in filtered]\n        if not dlmap['drive_letters']:\n            raise DeviceError(_('Unable to detect any disk drives for the device: %s. Try rebooting') % self.get_gui_name())\n        drives = {}\n        for drive_letter, which in zip(dlmap['drive_letters'], 'main carda cardb'.split()):\n            drives[which] = drive_letter + ':\\\\'\n        drives = self.windows_sort_drives(drives)\n        self._main_prefix = drives.get('main')\n        self._card_a_prefix = drives.get('carda', None)\n        self._card_b_prefix = drives.get('cardb', None)\n", "docstring": "from calibre.devices.scanner import drive_is_ok"}
{"repo": "calibre-master/src/calibre/devices/usbms/device.py", "original_string": "    def open_freebsd(self):\n        # There should be some way to access the -v arg...\n        verbose = False\n        # this gives us access to the S/N, etc. of the reader that the scanner has found\n        # and the match routines for some of that data, like s/n, vendor ID, etc.\n        d=self.detected_device\n        if not d.serial:\n            raise DeviceError(\"Device has no S/N.  Can't continue\")\n        from .hal import get_hal\n        hal = get_hal()\n        vols = hal.get_volumes(d)\n        if verbose:\n            print(\"FBSD:\t\", vols)\n        ok, mv = hal.mount_volumes(vols)\n        if not ok:\n            raise DeviceError(_('Unable to mount the device'))\n        for k, v in mv.items():\n            setattr(self, k, v)\n", "docstring": "There should be some way to access the -v arg..."}
{"repo": "calibre-master/src/calibre/devices/usbms/books.py", "original_string": "    def db_id(self):\n        '''The database id in the application database that this file corresponds to'''\n        match = re.search(r'_(\\d+)$', self.lpath.rpartition('.')[0])\n        if match:\n            return int(match.group(1))\n        return None\n", "docstring": "The database id in the application database that this file corresponds to'''"}
{"repo": "calibre-master/src/calibre/devices/usbms/books.py", "original_string": "    def title_sorter(self):\n        '''String to sort the title. If absent, title is returned'''\n        return title_sort(self.title)\n", "docstring": "String to sort the title. If absent, title is returned'''"}
{"repo": "calibre-master/src/calibre/devices/usbms/driver.py", "original_string": "    def delete_single_book(self, path):\n        os.unlink(path)\n", "docstring": "os.unlink(path)"}
{"repo": "calibre-master/src/calibre/gui2/search_box.py", "original_string": "    def normalize_state(self):\n        # need this because line_edit will call it in some cases such as paste\n        pass\n", "docstring": "need this because line_edit will call it in some cases such as paste"}
{"repo": "calibre-master/src/calibre/gui2/update.py", "original_string": "    def plugin_update_found(self, number_of_updates):\n        # Change the plugin icon to indicate there are updates available\n        plugin = self.iactions.get('Plugin Updater', None)\n        if not plugin:\n            return\n        if number_of_updates:\n            plugin.qaction.setText(_('Plugin updates')+'*')\n            plugin.qaction.setIcon(QIcon(I('plugins/plugin_updater_updates.png')))\n            plugin.qaction.setToolTip(\n                ngettext('A plugin update is available',\n                         'There are {} plugin updates available', number_of_updates).format(number_of_updates))\n        else:\n            plugin.qaction.setText(_('Plugin updates'))\n            plugin.qaction.setIcon(QIcon(I('plugins/plugin_updater.png')))\n            plugin.qaction.setToolTip(_('Install and configure user plugins'))\n", "docstring": "Change the plugin icon to indicate there are updates available"}
{"repo": "calibre-master/src/calibre/gui2/device.py", "original_string": "    def get_device_information(self, done, add_as_step_to_job=None):\n        '''Get device information and free space on device'''\n        return self.create_job_step(self._get_device_information, done,\n                    description=_('Get device information'), to_job=add_as_step_to_job)\n", "docstring": "Get device information and free space on device'''"}
{"repo": "calibre-master/src/calibre/gui2/device.py", "original_string": "    def books(self, done, add_as_step_to_job=None):\n        '''Return callable that returns the list of books on device as two booklists'''\n        return self.create_job_step(self._books, done,\n                description=_('Get list of books on device'), to_job=add_as_step_to_job)\n", "docstring": "Return callable that returns the list of books on device as two booklists'''"}
{"repo": "calibre-master/src/calibre/gui2/device.py", "original_string": "    def annotations(self, done, path_map, add_as_step_to_job=None):\n        '''Return mapping of ids to annotations. Each annotation is of the\n        form (type, location_info, content). path_map is a mapping of\n        ids to paths on the device.'''\n        return self.create_job_step(self._annotations, done, args=[path_map],\n                description=_('Get annotations from device'), to_job=add_as_step_to_job)\n", "docstring": "Return mapping of ids to annotations. Each annotation is of the"}
{"repo": "calibre-master/src/calibre/gui2/device.py", "original_string": "    def _upload_books(self, files, names, on_card=None, metadata=None, plugboards=None):\n        '''Upload books to device: '''\n        from calibre.ebooks.metadata.meta import set_metadata\n        if hasattr(self.connected_device, 'set_plugboards') and \\\n                callable(self.connected_device.set_plugboards):\n            self.connected_device.set_plugboards(plugboards, find_plugboard)\n        if metadata and files and len(metadata) == len(files):\n            for f, mi in zip(files, metadata):\n                if isinstance(f, unicode_type):\n                    ext = f.rpartition('.')[-1].lower()\n                    cpb = find_plugboard(\n                            device_name_for_plugboards(self.connected_device),\n                            ext, plugboards)\n                    if ext:\n                        try:\n                            if DEBUG:\n                                prints('Setting metadata in:', mi.title, 'at:',\n                                        f, file=sys.__stdout__)\n                            with lopen(f, 'r+b') as stream:\n                                if cpb:\n                                    newmi = mi.deepcopy_metadata()\n                                    newmi.template_to_attribute(mi, cpb)\n                                else:\n                                    newmi = mi\n                                nuke_comments = getattr(self.connected_device,\n                                        'NUKE_COMMENTS', None)\n                                if nuke_comments is not None:\n                                    mi.comments = nuke_comments\n                                set_metadata(stream, newmi, stream_type=ext)\n                        except:\n                            if DEBUG:\n                                prints(traceback.format_exc(), file=sys.__stdout__)\n        try:\n            return self.device.upload_books(files, names, on_card,\n                    metadata=metadata, end_session=False)\n        finally:\n            if metadata:\n                for mi in metadata:\n                    try:\n                        if mi.cover:\n                            os.remove(mi.cover)\n                    except:\n                        pass\n", "docstring": "Upload books to device: '''"}
{"repo": "calibre-master/src/calibre/gui2/device.py", "original_string": "    def _save_books(self, paths, target):\n        '''Copy books from device to disk'''\n        for path in paths:\n            name = sanitize_file_name(os.path.basename(path))\n            dest = os.path.join(target, name)\n            if os.path.abspath(dest) != os.path.abspath(path):\n                with lopen(dest, 'wb') as f:\n                    self.device.get_file(path, f)\n", "docstring": "Copy books from device to disk'''"}
{"repo": "calibre-master/src/calibre/gui2/device.py", "original_string": "    def set_device_menu_items_state(self, connected):\n        self.iactions['Connect Share'].set_state(connected,\n                self.device_manager.device)\n        if connected:\n            self._sync_menu.disconnect_mounted_device_action.setEnabled(True)\n            self._sync_menu.enable_device_actions(True,\n                    self.device_manager.device.card_prefix(),\n                    self.device_manager.device)\n            self.eject_action.setEnabled(True)\n        else:\n            self._sync_menu.disconnect_mounted_device_action.setEnabled(False)\n            self._sync_menu.enable_device_actions(False)\n            self.eject_action.setEnabled(False)\n", "docstring": "self.iactions['Connect Share'].set_state(connected,"}
{"repo": "calibre-master/src/calibre/gui2/device.py", "original_string": "    def remove_paths(self, paths):\n        return self.device_manager.delete_books(\n                FunctionDispatcher(self.books_deleted), paths)\n", "docstring": "return self.device_manager.delete_books("}
{"repo": "calibre-master/src/calibre/gui2/device.py", "original_string": "    def _upload_collections(self, job):\n        if job.failed:\n            self.device_job_exception(job)\n", "docstring": "if job.failed:"}
{"repo": "calibre-master/src/calibre/gui2/device.py", "original_string": "    def update_metadata_on_device(self):\n        self.set_books_in_library(self.booklists(), reset=True, force_send=True)\n        self.refresh_ondevice()\n", "docstring": "self.set_books_in_library(self.booklists(), reset=True, force_send=True)"}
{"repo": "calibre-master/src/calibre/gui2/widgets2.py", "original_string": "    def setBuddy(self, widget_for_height):\n        ''' See __init__. This is repurposed to support Qt Designer .ui files. '''\n        self.widget_for_height = widget_for_height\n", "docstring": "See __init__. This is repurposed to support Qt Designer .ui files. '''"}
{"repo": "calibre-master/src/calibre/gui2/widgets2.py", "original_string": "    def paintEvent(self, ev):\n        painter = QPainter(self)\n        # Purely subjective: shorten the line a bit to look 'better'\n        r = ev.rect()\n        r.setTop(r.top() + 3)\n        r.setBottom(r.bottom() - 3)\n        painter.fillRect(r, self.brush)\n        painter.end()\n", "docstring": "Purely subjective: shorten the line a bit to look 'better'"}
{"repo": "calibre-master/src/calibre/gui2/widgets2.py", "original_string": "def to_plain_text(self):\n    # QPlainTextEdit's toPlainText implementation replaces nbsp with normal\n    # space, so we re-implement it using QTextCursor, which does not do\n    # that\n    c = self.textCursor()\n    c.clearSelection()\n    c.movePosition(QTextCursor.MoveOperation.Start)\n    c.movePosition(QTextCursor.MoveOperation.End, QTextCursor.MoveMode.KeepAnchor)\n    ans = c.selectedText().replace(PARAGRAPH_SEPARATOR, '\\n')\n    # QTextCursor pads the return value of selectedText with null bytes if\n    # non BMP characters such as 0x1f431 are present.\n    return ans.rstrip('\\0')\n", "docstring": "QPlainTextEdit's toPlainText implementation replaces nbsp with normal"}
{"repo": "calibre-master/src/calibre/gui2/css_transform_rules.py", "original_string": "    def __init__(self, *args, **kw):\n        # This has to be loaded on instantiation as it can be shared by\n        # multiple processes\n        self.PREFS_OBJECT = JSONConfig('style-transform-rules')\n        RulesDialogBase.__init__(self, *args, **kw)\n", "docstring": "This has to be loaded on instantiation as it can be shared by"}
{"repo": "calibre-master/src/calibre/gui2/custom_column_widgets.py", "original_string": "    def set_to_undefined(self):\n        # Only called if bools are tristate\n        self.main_widget.setCurrentIndex(2)\n", "docstring": "Only called if bools are tristate"}
{"repo": "calibre-master/src/calibre/gui2/dnd.py", "original_string": "def dnd_has_image(md):\n    # Chromium puts image data into application/octet-stream\n    return md.hasImage() or md.hasFormat('application/octet-stream') and what(None, bytes(md.data('application/octet-stream'))) in image_extensions()\n", "docstring": "Chromium puts image data into application/octet-stream"}
{"repo": "calibre-master/src/calibre/gui2/dnd.py", "original_string": "    def is_ok(path):\n        ext = extension(path)\n        if allow_all_extensions and ext and ext not in filter_exts:\n            return True\n        return ext in exts and ext not in filter_exts\n", "docstring": "ext = extension(path)"}
{"repo": "calibre-master/src/calibre/gui2/keyboard.py", "original_string": "    def __init__(self, parent=None, config_name='shortcuts/main'):\n        QObject.__init__(self, parent)\n        self.config = JSONConfig(config_name)\n        self.shortcuts = OrderedDict()\n        self.keys_map = {}\n        self.groups = {}\n", "docstring": "QObject.__init__(self, parent)"}
{"repo": "calibre-master/src/calibre/gui2/keyboard.py", "original_string": "    def __init__(self, group_map, shortcut_map, name=None, shortcut=None):\n        self.data = name if name is not None else shortcut\n        self.is_shortcut = shortcut is not None\n        self.children = []\n        if name is not None:\n            self.children = [Node(None, None, shortcut=shortcut_map[uname])\n                    for uname in group_map[name]]\n", "docstring": "self.data = name if name is not None else shortcut"}
{"repo": "calibre-master/src/calibre/gui2/__init__.py", "original_string": "def gui_prefs():\n    return _gui_prefs\n", "docstring": "return _gui_prefs"}
{"repo": "calibre-master/src/calibre/gui2/__init__.py", "original_string": "def setup_hidpi():\n    # This requires Qt >= 5.6\n    has_env_setting = False\n    env_vars = ('QT_AUTO_SCREEN_SCALE_FACTOR', 'QT_SCALE_FACTOR', 'QT_SCREEN_SCALE_FACTORS', 'QT_DEVICE_PIXEL_RATIO')\n    for v in env_vars:\n        if os.environ.get(v):\n            has_env_setting = True\n            break\n    hidpi = gprefs['hidpi']\n    if hidpi == 'on' or (hidpi == 'auto' and not has_env_setting):\n        if DEBUG:\n            prints('Turning on automatic hidpi scaling')\n        QApplication.setAttribute(Qt.ApplicationAttribute.AA_EnableHighDpiScaling, True)\n    elif hidpi == 'off':\n        if DEBUG:\n            prints('Turning off automatic hidpi scaling')\n        QApplication.setAttribute(Qt.ApplicationAttribute.AA_EnableHighDpiScaling, False)\n        for p in env_vars:\n            os.environ.pop(p, None)\n    elif DEBUG:\n        prints('Not controlling automatic hidpi scaling')\n", "docstring": "This requires Qt >= 5.6"}
{"repo": "calibre-master/src/calibre/gui2/__init__.py", "original_string": "    def fix_combobox_text_color(self):\n        # Workaround for https://bugreports.qt.io/browse/QTBUG-75321\n        # Buttontext is set to black for some reason\n        pal = QPalette(self.palette())\n        pal.setColor(QPalette.ColorRole.ButtonText, pal.color(QPalette.ColorRole.WindowText))\n        self.ignore_palette_changes = True\n        self.setPalette(pal, 'QComboBox')\n        self.ignore_palette_changes = False\n", "docstring": "Workaround for https://bugreports.qt.io/browse/QTBUG-75321"}
{"repo": "calibre-master/src/calibre/gui2/__init__.py", "original_string": "    def save_custom_colors(self):\n        # Qt 5 regression, it no longer saves custom colors\n        colors = self.current_custom_colors\n        if colors != self.color_prefs.get('custom_colors_for_color_dialog', None):\n            self.color_prefs.set('custom_colors_for_color_dialog', colors)\n", "docstring": "Qt 5 regression, it no longer saves custom colors"}
{"repo": "calibre-master/src/calibre/gui2/__init__.py", "original_string": "def sanitize_env_vars():\n    '''Unset various environment variables that calibre uses. This\n    is needed to prevent library conflicts when launching external utilities.'''\n    if islinux and isfrozen:\n        env_vars = {'LD_LIBRARY_PATH':'/lib'}\n    elif iswindows:\n        env_vars = {}\n    elif ismacos:\n        env_vars = {k:None for k in (\n                    'FONTCONFIG_FILE FONTCONFIG_PATH SSL_CERT_FILE').split()}\n    else:\n        env_vars = {}\n    originals = {x:os.environ.get(x, '') for x in env_vars}\n    changed = {x:False for x in env_vars}\n    for var, suffix in iteritems(env_vars):\n        paths = [x for x in originals[var].split(os.pathsep) if x]\n        npaths = [] if suffix is None else [x for x in paths if x != (sys.frozen_path + suffix)]\n        if len(npaths) < len(paths):\n            if npaths:\n                os.environ[var] = os.pathsep.join(npaths)\n            else:\n                del os.environ[var]\n            changed[var] = True\n    try:\n        yield\n    finally:\n        for var, orig in iteritems(originals):\n            if changed[var]:\n                if orig:\n                    os.environ[var] = orig\n                elif var in os.environ:\n                    del os.environ[var]\n", "docstring": "Unset various environment variables that calibre uses. This"}
{"repo": "calibre-master/src/calibre/gui2/__init__.py", "original_string": "def open_url(qurl):\n    # Qt 5 requires QApplication to be constructed before trying to use\n    # QDesktopServices::openUrl()\n    ensure_app()\n    if isinstance(qurl, string_or_bytes):\n        qurl = QUrl(qurl)\n    with sanitize_env_vars():\n        QDesktopServices.openUrl(qurl)\n", "docstring": "Qt 5 requires QApplication to be constructed before trying to use"}
{"repo": "calibre-master/src/calibre/gui2/__init__.py", "original_string": "def ensure_app(headless=True):\n    global _store_app\n    with _ea_lock:\n        if _store_app is None and QApplication.instance() is None:\n            args = sys.argv[:1]\n            has_headless = ismacos or islinux or isbsd\n            if headless and has_headless:\n                args += ['-platformpluginpath', plugins_loc, '-platform', 'headless']\n                if ismacos:\n                    os.environ['QT_MAC_DISABLE_FOREGROUND_APPLICATION_TRANSFORM'] = '1'\n            if headless and iswindows:\n                QApplication.setAttribute(Qt.ApplicationAttribute.AA_UseSoftwareOpenGL, True)\n            _store_app = QApplication(args)\n            if headless and has_headless:\n                _store_app.headless = True\n            import traceback\n            # This is needed because as of PyQt 5.4 if sys.execpthook ==\n            # sys.__excepthook__ PyQt will abort the application on an\n            # unhandled python exception in a slot or virtual method. Since ensure_app()\n            # is used in worker processes for background work like rendering html\n            # or running a headless browser, we circumvent this as I really\n            # dont feel like going through all the code and making sure no\n            # unhandled exceptions ever occur. All the actual GUI apps already\n            # override sys.except_hook with a proper error handler.\n            def eh(t, v, tb):\n                try:\n                    traceback.print_exception(t, v, tb, file=sys.stderr)\n                except:\n                    pass\n            sys.excepthook = eh\n    return _store_app\n", "docstring": "global _store_app"}
{"repo": "calibre-master/src/calibre/gui2/widgets.py", "original_string": "    def event(self, ev):\n        # See https://bugreports.qt.io/browse/QTBUG-46911\n        if ev.type() == QEvent.Type.ShortcutOverride and (\n                hasattr(ev, 'key') and ev.key() in (Qt.Key.Key_Left, Qt.Key.Key_Right) and (\n                    ev.modifiers() & ~Qt.KeyboardModifier.KeypadModifier) == Qt.KeyboardModifier.ControlModifier):\n            ev.accept()\n        return QLineEdit.event(self, ev)\n", "docstring": "See https://bugreports.qt.io/browse/QTBUG-46911"}
{"repo": "calibre-master/src/calibre/gui2/listener.py", "original_string": "def send_message_via_worker(msg, address=None, timeout=5, wait_till_sent=False):\n    # On Windows sending a message in a process that also is listening on the\n    # same named pipe in a different thread deadlocks, so we do the actual sending in\n    # a simple worker process\n    import json\n    import subprocess\n    from calibre.startup import get_debug_executable\n    cmd = get_debug_executable() + [\n        '-c', 'from calibre.gui2.listener import *; import sys, json;'\n        'send_message_implementation(sys.stdin.buffer.read(), address=json.loads(sys.argv[-2]), timeout=int(sys.argv[-1]))',\n        json.dumps(address), str(timeout)]\n    p = subprocess.Popen(cmd, stdin=subprocess.PIPE)\n    if isinstance(msg, str):\n        msg = msg.encode('utf-8')\n    with closing(p.stdin):\n        p.stdin.write(msg)\n    if wait_till_sent:\n        return p.wait(timeout=timeout) == 0\n", "docstring": "On Windows sending a message in a process that also is listening on the"}
{"repo": "calibre-master/src/calibre/gui2/complete2.py", "original_string": "    def event(self, ev):\n        # See https://bugreports.qt.io/browse/QTBUG-46911\n        try:\n            if ev.type() == QEvent.Type.ShortcutOverride and (\n                    ev.key() in (Qt.Key.Key_Left, Qt.Key.Key_Right) and (\n                        ev.modifiers() & ~Qt.KeyboardModifier.KeypadModifier) == Qt.KeyboardModifier.ControlModifier):\n                ev.accept()\n        except AttributeError:\n            pass\n        return QLineEdit.event(self, ev)\n", "docstring": "See https://bugreports.qt.io/browse/QTBUG-46911"}
{"repo": "calibre-master/src/calibre/gui2/ui.py", "original_string": "    def current_view(self):\n        '''Convenience method that returns the currently visible view '''\n        idx = self.stack.currentIndex()\n        if idx == 0:\n            return self.library_view\n        if idx == 1:\n            return self.memory_view\n        if idx == 2:\n            return self.card_a_view\n        if idx == 3:\n            return self.card_b_view\n", "docstring": "Convenience method that returns the currently visible view '''"}
{"repo": "calibre-master/src/calibre/gui2/init.py", "original_string": "    def read_layout_settings(self):\n        # View states are restored automatically when set_database is called\n        for x in ('cb', 'tb', 'bd'):\n            getattr(self, x+'_splitter').restore_state()\n        self.grid_view_button.restore_state()\n        self.search_bar_button.restore_state()\n        # Can't do quickview here because the gui isn't totally set up. Do it in ui\n", "docstring": "View states are restored automatically when set_database is called"}
{"repo": "calibre-master/src/calibre/gui2/jobs.py", "original_string": "    def _update(self):\n        # Update running time\n        for i, j in enumerate(self.jobs):\n            if j.run_state == j.RUNNING:\n                idx = self.index(i, 3)\n                self.dataChanged.emit(idx, idx)\n        # Update parallel jobs\n        jobs = set()\n        while True:\n            try:\n                jobs.add(self.server.changed_jobs_queue.get_nowait())\n            except Empty:\n                break\n        # Update device jobs\n        while True:\n            try:\n                jobs.add(self.changed_queue.get_nowait())\n            except Empty:\n                break\n        # Update threaded jobs\n        while True:\n            try:\n                jobs.add(self.threaded_server.changed_jobs.get_nowait())\n            except Empty:\n                break\n        if jobs:\n            needs_reset = False\n            for job in jobs:\n                orig_state = job.run_state\n                job.update()\n                if orig_state != job.run_state:\n                    needs_reset = True\n                    if job.is_finished:\n                        self.job_done.emit(len(self.unfinished_jobs()))\n            if needs_reset:\n                self.modelAboutToBeReset.emit()\n                self.jobs.sort()\n                self.modelReset.emit()\n            else:\n                for job in jobs:\n                    idx = self.jobs.index(job)\n                    self.dataChanged.emit(\n                        self.index(idx, 0), self.index(idx, 3))\n        # Kill parallel jobs that have gone on too long\n        try:\n            wmax_time = gprefs['worker_max_time'] * 60\n        except:\n            wmax_time = 0\n        if wmax_time > 0:\n            for job in self.jobs:\n                if isinstance(job, ParallelJob):\n                    rtime = job.running_time\n                    if (rtime is not None and rtime > wmax_time and\n                            job.duration is None):\n                        job.timed_out = True\n                        self.server.kill_job(job)\n", "docstring": "Update running time"}
{"repo": "calibre-master/src/calibre/gui2/device_drivers/tabbed_device_config.py", "original_string": "    def device(self):\n        return self._device()\n", "docstring": "return self._device()"}
{"repo": "calibre-master/src/calibre/gui2/device_drivers/tabbed_device_config.py", "original_string": "    def opt_save_template(self):\n        # Really shouldn't be accessing the template this way\n        return self.template.t\n", "docstring": "Really shouldn't be accessing the template this way"}
{"repo": "calibre-master/src/calibre/gui2/actions/edit_metadata.py", "original_string": "    def refresh_books_after_metadata_edit(self, book_ids, previous=None):\n        m = self.gui.library_view.model()\n        m.refresh_ids(list(book_ids))\n        current = self.gui.library_view.currentIndex()\n        self.gui.refresh_cover_browser()\n        m.current_changed(current, previous or current)\n        self.gui.tags_view.recount_with_position_based_index()\n        qv = get_quickview_action_plugin()\n        if qv:\n            qv.refresh_quickview(current)\n", "docstring": "m = self.gui.library_view.model()"}
{"repo": "calibre-master/src/calibre/gui2/actions/edit_metadata.py", "original_string": "    def do_edit_bulk_metadata(self, rows, book_ids):\n        # Prevent the TagView from updating due to signals from the database\n        self.gui.tags_view.blockSignals(True)\n        changed = False\n        refresh_books = set(book_ids)\n        try:\n            current_tab = 0\n            while True:\n                dialog = MetadataBulkDialog(self.gui, rows,\n                                self.gui.library_view.model(), current_tab, refresh_books)\n                if dialog.changed:\n                    changed = True\n                if not dialog.do_again:\n                    break\n                current_tab = dialog.central_widget.currentIndex()\n        finally:\n            self.gui.tags_view.blockSignals(False)\n        if changed:\n            refresh_books |= dialog.refresh_books\n            m = self.gui.library_view.model()\n            if gprefs['refresh_book_list_on_bulk_edit']:\n                m.refresh(reset=False)\n                m.research()\n            else:\n                m.refresh_ids(refresh_books)\n            self.gui.tags_view.recount()\n            self.gui.refresh_cover_browser()\n            self.gui.library_view.select_rows(book_ids)\n", "docstring": "Prevent the TagView from updating due to signals from the database"}
{"repo": "calibre-master/src/calibre/gui2/actions/edit_metadata.py", "original_string": "    def formats_for_ids(self, ids):\n        m = self.gui.library_view.model()\n        ans = []\n        for id_ in ids:\n            dbfmts = m.db.formats(id_, index_is_id=True)\n            if dbfmts:\n                for fmt in dbfmts.split(','):\n                    try:\n                        path = m.db.format(id_, fmt, index_is_id=True,\n                                as_path=True)\n                        ans.append(path)\n                    except NoSuchFormat:\n                        continue\n        return ans\n", "docstring": "m = self.gui.library_view.model()"}
{"repo": "calibre-master/src/calibre/gui2/actions/show_quickview.py", "original_string": "    def focus_booklist(self):\n        self.gui.activateWindow()\n        self.gui.library_view.setFocus()\n", "docstring": "self.gui.activateWindow()"}
{"repo": "calibre-master/src/calibre/gui2/actions/add.py", "original_string": "    def add_recursive_question(self):\n        single =  question_dialog(self.gui, _('Multi-file books?'), _(\n            'Assume all e-book files in a single folder are the same book in different formats?'))\n        self.add_recursive(single)\n", "docstring": "single =  question_dialog(self.gui, _('Multi-file books?'), _("}
{"repo": "calibre-master/src/calibre/gui2/actions/next_match.py", "original_string": "    def move_forward(self):\n        if self.can_move is None:\n            self.can_move = self.gui.current_view() is self.gui.library_view\n        if self.can_move:\n            self.gui.current_view().move_highlighted_row(forward=True)\n", "docstring": "if self.can_move is None:"}
{"repo": "calibre-master/src/calibre/gui2/actions/__init__.py", "original_string": "    def accept_drag_move_event(self, event, mime_data):\n        ''' This method should return True iff this interface action is capable\n        of handling the drag event. Do not call accept/ignore on the event,\n        that will be taken care of by the calibre UI.'''\n        return False\n", "docstring": "This method should return True iff this interface action is capable"}
{"repo": "calibre-master/src/calibre/gui2/preferences/columns.py", "original_string": "    def init_columns(self, defaults=False):\n        # Set up columns\n        self.opt_columns.blockSignals(True)\n        self.model = model = self.gui.library_view.model()\n        colmap = list(model.column_map)\n        state = self.columns_state(defaults)\n        self.hidden_cols = state['hidden_columns']\n        positions = state['column_positions']\n        colmap.sort(key=lambda x: positions[x])\n        self.opt_columns.clear()\n        db = model.db\n        self.field_metadata = db.field_metadata\n        self.opt_columns.setColumnCount(4)\n        item = QTableWidgetItem(_('Column header'))\n        self.opt_columns.setHorizontalHeaderItem(0, item)\n        item = QTableWidgetItem(_('Lookup name'))\n        self.opt_columns.setHorizontalHeaderItem(1, item)\n        item = QTableWidgetItem(_('Type'))\n        self.opt_columns.setHorizontalHeaderItem(2, item)\n        item = QTableWidgetItem(_('Description'))\n        self.opt_columns.setHorizontalHeaderItem(3, item)\n        self.opt_columns.setRowCount(len(colmap))\n        self.column_desc = dict(map(lambda x:(CreateCustomColumn.column_types[x]['datatype'],\n                                         CreateCustomColumn.column_types[x]['text']),\n                                  CreateCustomColumn.column_types))\n        for row, col in enumerate(colmap):\n            self.setup_row(self.field_metadata, row, col)\n        self.restore_geometry()\n        self.opt_columns.cellDoubleClicked.connect(self.row_double_clicked)\n        self.opt_columns.blockSignals(False)\n", "docstring": "Set up columns"}
{"repo": "calibre-master/src/calibre/gui2/preferences/adding.py", "original_string": "    def refresh_gui(self, gui):\n        # Ensure worker process reads updated settings\n        gui.spare_pool().shutdown()\n        # Update rules used int he auto adder\n        gui.auto_adder.read_rules()\n", "docstring": "Ensure worker process reads updated settings"}
{"repo": "calibre-master/src/calibre/gui2/preferences/__init__.py", "original_string": "    def __init__(self, name, config_obj, widget, gui_name=None,\n            empty_string_is_None=True, choices=None, restart_required=False):\n        self.name, self.gui_name = name, gui_name\n        self.empty_string_is_None = empty_string_is_None\n        self.restart_required = restart_required\n        self.choices = choices\n        if gui_name is None:\n            self.gui_name = 'opt_'+name\n        self.config_obj = config_obj\n        self.gui_obj = getattr(widget, self.gui_name)\n        self.widget = widget\n        if isinstance(self.gui_obj, QCheckBox):\n            self.datatype = 'bool'\n            self.gui_obj.stateChanged.connect(self.changed)\n        elif isinstance(self.gui_obj, QAbstractSpinBox):\n            self.datatype = 'number'\n            self.gui_obj.valueChanged.connect(self.changed)\n        elif isinstance(self.gui_obj, (QLineEdit, HistoryLineEdit)):\n            self.datatype = 'string'\n            self.gui_obj.textChanged.connect(self.changed)\n            if isinstance(self.gui_obj, HistoryLineEdit):\n                self.gui_obj.initialize('preferences_setting_' + self.name)\n        elif isinstance(self.gui_obj, QComboBox):\n            self.datatype = 'choice'\n            self.gui_obj.editTextChanged.connect(self.changed)\n            self.gui_obj.currentIndexChanged.connect(self.changed)\n        else:\n            raise ValueError('Unknown data type %s' % self.gui_obj.__class__)\n        if isinstance(self.config_obj, ConfigProxy) and \\\n                not unicode_type(self.gui_obj.toolTip()):\n            h = self.config_obj.help(self.name)\n            if h:\n                self.gui_obj.setToolTip(h)\n        tt = unicode_type(self.gui_obj.toolTip())\n        if tt:\n            if not unicode_type(self.gui_obj.whatsThis()):\n                self.gui_obj.setWhatsThis(tt)\n            if not unicode_type(self.gui_obj.statusTip()):\n                self.gui_obj.setStatusTip(tt)\n            tt = '\\n'.join(textwrap.wrap(tt, 70))\n            self.gui_obj.setToolTip(tt)\n", "docstring": "empty_string_is_None=True, choices=None, restart_required=False):"}
{"repo": "calibre-master/src/calibre/gui2/dialogs/template_dialog_code_widget.py", "original_string": "    def line_area_doubleclick_event(self, event):\n        # remember that the result of the divide will be zero-based\n        line = event.y()//self.fontMetrics().height() + 1 + self.firstVisibleBlock().blockNumber()\n        if line in self.clicked_line_numbers:\n            self.clicked_line_numbers.discard(line)\n        else:\n            self.clicked_line_numbers.add(line)\n        self.update(self.line_number_area.geometry())\n", "docstring": "remember that the result of the divide will be zero-based"}
{"repo": "calibre-master/src/calibre/gui2/dialogs/message_box.py", "original_string": "    def do_close(self, result):\n        # Ensure this notification is garbage collected\n        self.setParent(None)\n        self.finished.disconnect()\n        self.vlb.clicked.disconnect()\n        _proceed_memory.remove(self)\n", "docstring": "Ensure this notification is garbage collected"}
{"repo": "calibre-master/src/calibre/gui2/dialogs/opml.py", "original_string": "def uniq(vals, kmap=lambda x:x):\n    ''' Remove all duplicates from vals, while preserving order. kmap must be a\n    callable that returns a hashable value for every item in vals '''\n    vals = vals or ()\n    lvals = (kmap(x) for x in vals)\n    seen = set()\n    seen_add = seen.add\n    return tuple(x for x, k in zip(vals, lvals) if k not in seen and not seen_add(k))\n", "docstring": "Remove all duplicates from vals, while preserving order. kmap must be a"}
{"repo": "calibre-master/src/calibre/gui2/dialogs/catalog.py", "original_string": "    def apply(self, *args):\n        # Store current values without building catalog\n        self.save_catalog_settings()\n        if self.tabs.count() > 1:\n            self.options_widget.options()\n", "docstring": "Store current values without building catalog"}
{"repo": "calibre-master/src/calibre/gui2/dialogs/plugin_updater.py", "original_string": "def filter_not_installed_plugins(display_plugin):\n    return not display_plugin.is_installed()\n", "docstring": "return not display_plugin.is_installed()"}
{"repo": "calibre-master/src/calibre/gui2/dialogs/template_dialog.py", "original_string": "    def load_last_template_text(self):\n        from calibre.customize.ui import find_plugin\n        tt = find_plugin('Template Tester')\n        if tt and tt.actual_plugin_:\n            self.textbox.setPlainText(tt.actual_plugin_.last_template_text())\n        else:\n            # I don't think we can get here, but just in case ...\n            self.textbox.setPlainText(_('No Template tester text is available'))\n", "docstring": "from calibre.customize.ui import find_plugin"}
{"repo": "calibre-master/src/calibre/gui2/dialogs/choose_format_device.py", "original_string": "    def format(self):\n        return self._format\n", "docstring": "return self._format"}
{"repo": "calibre-master/src/calibre/gui2/dialogs/quickview.py", "original_string": "    def set_search_text(self, txt):\n        self.last_search = txt\n", "docstring": "self.last_search = txt"}
{"repo": "calibre-master/src/calibre/gui2/dialogs/quickview.py", "original_string": "    def indicate_no_items(self):\n        self.no_valid_items = True\n        self.items.clear()\n        self.add_columns_to_widget()\n        self.items.addItem(QListWidgetItem(_('**No items found**')))\n        self.books_label.setText(_('Click in a column  in the library view '\n                                   'to see the information for that book'))\n", "docstring": "self.no_valid_items = True"}
{"repo": "calibre-master/src/calibre/gui2/dialogs/quickview.py", "original_string": "    def set_focus(self):\n        self.activateWindow()\n        self.books_table.setFocus()\n", "docstring": "self.activateWindow()"}
{"repo": "calibre-master/src/calibre/gui2/dialogs/quickview.py", "original_string": "    def save_state(self):\n        if self.is_closed:\n            return\n        self.books_table_column_widths = []\n        for c in range(0, self.books_table.columnCount()):\n            self.books_table_column_widths.append(self.books_table.columnWidth(c))\n        gprefs['quickview_dialog_books_table_widths'] = self.books_table_column_widths\n        if not self.is_pane:\n            gprefs['quickview_dialog_geometry'] = bytearray(self.saveGeometry())\n", "docstring": "if self.is_closed:"}
{"repo": "calibre-master/src/calibre/gui2/toc/main.py", "original_string": "def main(path=None, title=None):\n    # Ensure we can continue to function if GUI is closed\n    os.environ.pop('CALIBRE_WORKER_TEMP_DIR', None)\n    reset_base_dir()\n    if iswindows:\n        # Ensure that all instances are grouped together in the task bar. This\n        # prevents them from being grouped with viewer/editor process when\n        # launched from within calibre, as both use calibre-parallel.exe\n        set_app_uid(TOC_DIALOG_APP_UID)\n    with open(path + '.started', 'w'):\n        pass\n    override = 'calibre-gui' if islinux else None\n    app = Application([], override_program_name=override)\n    d = TOCEditor(path, title=title, write_result_to=path + '.result')\n    d.start()\n    ret = 1\n    if d.exec_() == QDialog.DialogCode.Accepted:\n        ret = 0\n    del d\n    del app\n    raise SystemExit(ret)\n", "docstring": "Ensure we can continue to function if GUI is closed"}
{"repo": "calibre-master/src/calibre/gui2/library/models.py", "original_string": "    def row_indices(self, index):\n        ''' Return list indices of all cells in index.row()'''\n        return [self.index(index.row(), c) for c in range(self.columnCount(None))]\n", "docstring": "Return list indices of all cells in index.row()'''"}
{"repo": "calibre-master/src/calibre/gui2/library/models.py", "original_string": "    def search(self, text, reset=True):\n        # This should not be here, but since the DeviceBooksModel does not\n        # implement count_changed and I am too lazy to fix that, this kludge\n        # will have to do\n        self.resize_rows.emit()\n        if not text or not text.strip():\n            self.map = list(range(len(self.db)))\n        else:\n            try:\n                matches = self.search_engine.parse(text)\n            except ParseException:\n                self.searched.emit(False)\n                return\n            self.map = []\n            for i in range(len(self.db)):\n                if i in matches:\n                    self.map.append(i)\n        self.resort(reset=False)\n        if reset:\n            self.beginResetModel(), self.endResetModel()\n        self.last_search = text\n        if self.last_search:\n            self.searched.emit(True)\n        self.count_changed()\n", "docstring": "This should not be here, but since the DeviceBooksModel does not"}
{"repo": "calibre-master/src/calibre/gui2/library/delegates.py", "original_string": "    def createEditor(self, parent, option, index):\n        if self.auto_complete_function:\n            editor = EditWithComplete(parent)\n            editor.set_separator(None)\n            editor.set_clear_button_enabled(False)\n            complete_items = [i[1] for i in self.auto_complete_function()]\n            editor.update_items_cache(complete_items)\n        else:\n            editor = EnLineEdit(parent)\n        return editor\n", "docstring": "if self.auto_complete_function:"}
{"repo": "calibre-master/src/calibre/gui2/library/delegates.py", "original_string": "    def get_required_width(self, editor, style, fm):\n        srect = style.itemTextRect(fm, editor.geometry(), Qt.AlignmentFlag.AlignLeft, False,\n                                   self.longest_text + 'M')\n        return srect.width() + editor.iconSize().width()\n", "docstring": "srect = style.itemTextRect(fm, editor.geometry(), Qt.AlignmentFlag.AlignLeft, False,"}
{"repo": "calibre-master/src/calibre/gui2/library/alternate_views.py", "original_string": "def auto_height(widget):\n    # On some broken systems, availableGeometry() returns tiny values, we need\n    # a value of at least 1000 for 200 DPI systems.\n    return max(1000, QApplication.instance().desktop().availableGeometry(widget).height()) / 5.0\n", "docstring": "On some broken systems, availableGeometry() returns tiny values, we need"}
{"repo": "calibre-master/src/calibre/gui2/library/alternate_views.py", "original_string": "def sync(func):\n    @wraps(func)\n    def ans(self, *args, **kwargs):\n        if self.break_link or self.current_view is self.main_view:\n            return\n        with self:\n            return func(self, *args, **kwargs)\n    return ans\n", "docstring": "@wraps(func)"}
{"repo": "calibre-master/src/calibre/gui2/library/alternate_views.py", "original_string": "    def selectAll(self):\n        # We re-implement this to ensure that only indexes from column 0 are\n        # selected. The base class implementation selects all columns. This\n        # causes problems with selection syncing, see\n        # https://bugs.launchpad.net/bugs/1236348\n        m = self.model()\n        sm = self.selectionModel()\n        sel = QItemSelection(m.index(0, 0), m.index(m.rowCount(QModelIndex())-1, 0))\n        sm.select(sel, QItemSelectionModel.SelectionFlag.ClearAndSelect)\n", "docstring": "We re-implement this to ensure that only indexes from column 0 are"}
{"repo": "calibre-master/src/calibre/gui2/library/views.py", "original_string": "def restrict_column_width(self, col, old_size, new_size):\n    # arbitrary: scroll bar + header + some\n    sw = self.verticalScrollBar().width() if self.verticalScrollBar().isVisible() else 0\n    hw = self.verticalHeader().width() if self.verticalHeader().isVisible() else 0\n    max_width = max(200, self.width() - (sw + hw + 10))\n    if new_size > max_width:\n        self.column_header.blockSignals(True)\n        self.setColumnWidth(col, max_width)\n        self.column_header.blockSignals(False)\n", "docstring": "arbitrary: scroll bar + header + some"}
{"repo": "calibre-master/src/calibre/gui2/library/views.py", "original_string": "    def save_state(self):\n        # Only save if we have been initialized (set_database called)\n        if len(self.column_map) > 0 and self.was_restored:\n            state = self.get_state()\n            self.write_state(state)\n            if self.is_library_view:\n                self.pin_view.save_state()\n", "docstring": "Only save if we have been initialized (set_database called)"}
{"repo": "calibre-master/src/calibre/gui2/library/views.py", "original_string": "    def set_editable(self, editable, supports_backloading):\n        self._model.set_editable(editable)\n", "docstring": "self._model.set_editable(editable)"}
{"repo": "calibre-master/src/calibre/gui2/catalog/catalog_epub_mobi.py", "original_string": "    def exclude_genre_changed(self):\n        \"\"\" Dynamically compute excluded genres.\n        Run exclude_genre regex against selected genre_source_field to show excluded tags.\n        Inputs:\n            current regex\n            genre_source_field\n        Output:\n         self.exclude_genre_results (QLabel): updated to show tags to be excluded as genres\n        \"\"\"\n        def _truncated_results(excluded_tags, limit=180):\n            '''\n            Limit number of genres displayed to avoid dialog explosion\n            '''\n            start = []\n            end = []\n            lower = 0\n            upper = len(excluded_tags) -1\n            excluded_tags.sort()\n            while True:\n                if lower > upper:\n                    break\n                elif lower == upper:\n                    start.append(excluded_tags[lower])\n                    break\n                start.append(excluded_tags[lower])\n                end.insert(0,excluded_tags[upper])\n                if len(', '.join(start)) + len(', '.join(end)) > limit:\n                    break\n                lower += 1\n                upper -= 1\n            if excluded_tags == start + end:\n                return ', '.join(excluded_tags)\n            else:\n                return \"%s  ...  %s\" % (', '.join(start), ', '.join(end))\n        results = _('No genres will be excluded')\n        regex = unicode_type(getattr(self, 'exclude_genre').text()).strip()\n        if not regex:\n            self.exclude_genre_results.clear()\n            self.exclude_genre_results.setText(results)\n            return\n        # Populate all_genre_tags from currently source\n        if self.genre_source_field_name == _('Tags'):\n            all_genre_tags = self.db.all_tags()\n        else:\n            all_genre_tags = list(self.db.all_custom(self.db.field_metadata.key_to_label(self.genre_source_field_name)))\n        try:\n            pattern = re.compile(regex)\n        except:\n            results = _(\"regex error: %s\") % sys.exc_info()[1]\n        else:\n            excluded_tags = []\n            for tag in all_genre_tags:\n                hit = pattern.search(tag)\n                if hit:\n                    excluded_tags.append(hit.string)\n            if excluded_tags:\n                if set(excluded_tags) == set(all_genre_tags):\n                    results = _(\"All genres will be excluded\")\n                else:\n                    results = _truncated_results(excluded_tags)\n        finally:\n            if False and self.DEBUG:\n                print(\"exclude_genre_changed(): %s\" % results)\n            self.exclude_genre_results.clear()\n            self.exclude_genre_results.setText(results)\n", "docstring": "Dynamically compute excluded genres."}
{"repo": "calibre-master/src/calibre/gui2/catalog/catalog_epub_mobi.py", "original_string": "    def get_format_and_title(self):\n        current_format = None\n        current_title = None\n        parent = self.parent_ref()\n        if parent is not None:\n            current_title = parent.title.text().strip()\n            current_format = parent.format.currentText().strip()\n        return current_format, current_title\n", "docstring": "current_format = None"}
{"repo": "calibre-master/src/calibre/gui2/catalog/catalog_epub_mobi.py", "original_string": "    def __init__(self, checked=False, is_tristate=False):\n        QTableWidgetItem.__init__(self, '')\n        self.setFlags(Qt.ItemFlags(Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsUserCheckable | Qt.ItemFlag.ItemIsEnabled))\n        if is_tristate:\n            self.setFlags(self.flags() | Qt.ItemFlag.ItemIsTristate)\n        if checked:\n            self.setCheckState(Qt.CheckState.Checked)\n        else:\n            if is_tristate and checked is None:\n                self.setCheckState(Qt.CheckState.PartiallyChecked)\n            else:\n                self.setCheckState(Qt.CheckState.Unchecked)\n", "docstring": "QTableWidgetItem.__init__(self, '')"}
{"repo": "calibre-master/src/calibre/gui2/catalog/catalog_epub_mobi.py", "original_string": "    def wheelEvent(self, event):\n        # Disable the mouse wheel on top of the combo box changing selection as plays havoc in a grid\n        event.ignore()\n", "docstring": "Disable the mouse wheel on top of the combo box changing selection as plays havoc in a grid"}
{"repo": "calibre-master/src/calibre/gui2/catalog/catalog_epub_mobi.py", "original_string": "    def populate_table(self):\n        # Format of rules list is different if default values vs retrieved JSON\n        # Hack to normalize list style\n        rules = self.rules\n        if rules and type(rules[0]) is list:\n            rules = rules[0]\n        self.setFocus()\n        rules = sorted(rules, key=lambda k: k['ordinal'])\n        for row, rule in enumerate(rules):\n            self.insertRow(row)\n            self.select_and_scroll_to_row(row)\n            self.populate_table_row(row, rule)\n        self.selectRow(0)\n", "docstring": "Format of rules list is different if default values vs retrieved JSON"}
{"repo": "calibre-master/src/calibre/gui2/catalog/catalog_epub_mobi.py", "original_string": "    def source_index_changed(self, combo, row, pattern=''):\n        # Populate the Pattern field based upon the Source field\n        source_field = combo.currentText()\n        if source_field == '':\n            values = []\n        elif source_field == _('Tags'):\n            values = sorted(self.db.all_tags(), key=sort_key)\n        else:\n            if self.eligible_custom_fields[unicode_type(source_field)]['datatype'] in ['enumeration', 'text']:\n                values = self.db.all_custom(self.db.field_metadata.key_to_label(\n                                            self.eligible_custom_fields[unicode_type(source_field)]['field']))\n                values = sorted(values, key=sort_key)\n            elif self.eligible_custom_fields[unicode_type(source_field)]['datatype'] in ['bool']:\n                values = [_('True'),_('False'),_('unspecified')]\n            elif self.eligible_custom_fields[unicode_type(source_field)]['datatype'] in ['composite']:\n                values = [_('any value'),_('unspecified')]\n            elif self.eligible_custom_fields[unicode_type(source_field)]['datatype'] in ['datetime']:\n                values = [_('any date'),_('unspecified')]\n        values_combo = ComboBox(self, values, pattern)\n        values_combo.currentIndexChanged.connect(partial(self.values_index_changed, values_combo))\n        self.setCellWidget(row, self.COLUMNS['PATTERN']['ordinal'], values_combo)\n        self.select_and_scroll_to_row(row)\n        self.settings_changed(\"source_index_changed\")\n", "docstring": "Populate the Pattern field based upon the Source field"}
{"repo": "calibre-master/src/calibre/gui2/store/web_store.py", "original_string": "def main(args):\n    # Ensure we can continue to function if GUI is closed\n    os.environ.pop('CALIBRE_WORKER_TEMP_DIR', None)\n    reset_base_dir()\n    if iswindows:\n        # Ensure that all instances are grouped together in the task bar. This\n        # prevents them from being grouped with viewer/editor process when\n        # launched from within calibre, as both use calibre-parallel.exe\n        set_app_uid(STORE_DIALOG_APP_UID)\n    data = args[-1]\n    data = json.loads(from_base64_bytes(data))\n    override = 'calibre-gui' if islinux else None\n    app = Application(args, override_program_name=override)\n    m = Main(data)\n    m.show(), m.raise_()\n    app.exec_()\n    del m\n    del app\n", "docstring": "Ensure we can continue to function if GUI is closed"}
{"repo": "calibre-master/src/calibre/gui2/store/__init__.py", "original_string": "    def do_genesis(self):\n        self.genesis()\n", "docstring": "self.genesis()"}
{"repo": "calibre-master/src/calibre/gui2/store/search/search.py", "original_string": "    def do_config(self):\n        # Save values that need to be synced between the dialog and the\n        # search widget.\n        self.config['open_external'] = self.open_external.isChecked()\n        # Create the config dialog. It's going to put two config widgets\n        # into a QTabWidget for displaying all of the settings.\n        d = QDialog(self)\n        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Close)\n        v = QVBoxLayout(d)\n        button_box.accepted.connect(d.accept)\n        button_box.rejected.connect(d.reject)\n        d.setWindowTitle(_('Customize Get books search'))\n        tab_widget = QTabWidget(d)\n        v.addWidget(tab_widget)\n        v.addWidget(button_box)\n        chooser_config_widget = StoreChooserWidget()\n        search_config_widget = StoreConfigWidget(self.config)\n        tab_widget.addTab(chooser_config_widget, _('Choose s&tores'))\n        tab_widget.addTab(search_config_widget, _('Configure s&earch'))\n        # Restore dialog state.\n        geometry = self.config.get('config_dialog_geometry', None)\n        if geometry:\n            QApplication.instance().safe_restore_geometry(d, geometry)\n        else:\n            d.resize(800, 600)\n        tab_index = self.config.get('config_dialog_tab_index', 0)\n        tab_index = min(tab_index, tab_widget.count() - 1)\n        tab_widget.setCurrentIndex(tab_index)\n        d.exec_()\n        # Save dialog state.\n        self.config['config_dialog_geometry'] = bytearray(d.saveGeometry())\n        self.config['config_dialog_tab_index'] = tab_widget.currentIndex()\n        search_config_widget.save_settings()\n        self.config_changed()\n        self.gui.load_store_plugins()\n        self.setup_store_checks()\n", "docstring": "Save values that need to be synced between the dialog and the"}
{"repo": "calibre-master/src/calibre/gui2/store/search/search.py", "original_string": "    def get_results(self):\n        # We only want the search plugins to run\n        # a maximum set amount of time before giving up.\n        self.hang_check += 1\n        if self.hang_check >= self.hang_time:\n            self.search_pool.abort()\n            self.checker.stop()\n        else:\n            # Stop the checker if not threads are running.\n            if not self.search_pool.threads_running() and not self.search_pool.has_tasks():\n                self.checker.stop()\n        while self.search_pool.has_results():\n            res, store_plugin = self.search_pool.get_result()\n            if res:\n                self.results_view.model().add_result(res, store_plugin)\n        if not self.search_pool.threads_running() and not self.results_view.model().has_results():\n            info_dialog(self, _('No matches'), _('Couldn\\'t find any books matching your query.'), show=True, show_copy_button=False)\n", "docstring": "We only want the search plugins to run"}
{"repo": "calibre-master/src/calibre/gui2/store/search/models.py", "original_string": "def comparable_price(text):\n    # this keep thousand and fraction separators\n    match = re.search(r'(?:\\d|[,.](?=\\d))(?:\\d*(?:[,.\\' ](?=\\d))?)+', text)\n    if match:\n        # replace all separators with '.'\n        m = re.sub(r'[.,\\' ]', '.', match.group())\n        # remove all separators accept fraction,\n        # leave only 2 digits in fraction\n        m = re.sub(r'\\.(?!\\d*$)', r'', m)\n        text = '{0:0>8.0f}'.format(float(m) * 100.)\n    return text\n", "docstring": "this keep thousand and fraction separators"}
{"repo": "calibre-master/src/calibre/gui2/store/search/models.py", "original_string": "    def _filter_results(self):\n        # Only use the search filter's filtered results when there is a query\n        # and it is a filterable query. This allows for the stores best guess\n        # matches to come though.\n        if self.query and self.filterable_query:\n            self.matches = list(self.search_filter.parse(self.query))\n        else:\n            self.matches = list(self.search_filter.universal_set())\n        self.total_changed.emit(self.rowCount())\n        self.sort(self.sort_col, self.sort_order, False)\n", "docstring": "Only use the search filter's filtered results when there is a query"}
{"repo": "calibre-master/src/calibre/gui2/store/search/models.py", "original_string": "    def is_filterable_query(self, query):\n        # Remove control modifiers.\n        query = query.replace('\\\\', '')\n        query = query.replace('!', '')\n        query = query.replace('=', '')\n        query = query.replace('~', '')\n        query = query.replace('>', '')\n        query = query.replace('<', '')\n        # Store the query at this point for comparision later\n        mod_query = query\n        # Remove filter identifiers\n        # Remove the prefix.\n        for loc in ('all', 'author', 'author2', 'authors', 'title', 'title2'):\n            query = re.sub(r'%s:\"(?P<a>[^\\s\"]+)\"' % loc, r'\\g<a>', query)\n            query = query.replace('%s:' % loc, '')\n        # Remove the prefix and search text.\n        for loc in ('cover', 'download', 'downloads', 'drm', 'format', 'formats', 'price', 'store'):\n            query = re.sub(r'%s:\"[^\"]\"' % loc, '', query)\n            query = re.sub(r'%s:[^\\s]*' % loc, '', query)\n        # Remove whitespace\n        query = re.sub(r'\\s', '', query)\n        mod_query = re.sub(r'\\s', '', mod_query)\n        # If mod_query and query are the same then there were no filter modifiers\n        # so this isn't a filterable query.\n        if mod_query == query:\n            return False\n        return True\n", "docstring": "Remove control modifiers."}
{"repo": "calibre-master/src/calibre/gui2/store/search/download_thread.py", "original_string": "    def has_tasks(self):\n        return not self.tasks.empty()\n", "docstring": "return not self.tasks.empty()"}
{"repo": "calibre-master/src/calibre/gui2/store/stores/manybooks_plugin.py", "original_string": "    def search(self, query, max_results=10, timeout=60):\n        for r in search_manybooks(query, max_results=max_results, timeout=timeout, open_search_url=self.open_search_url):\n            yield r\n", "docstring": "for r in search_manybooks(query, max_results=max_results, timeout=timeout, open_search_url=self.open_search_url):"}
{"repo": "calibre-master/src/calibre/gui2/store/stores/litres_plugin.py", "original_string": "def _get_affiliate_id():\n    aff_id = u'3623565'\n    # Use Kovid's affiliate id 30% of the time.\n    if random.randint(1, 10) in (1, 2, 3):\n        aff_id = u'4084465'\n    return u'lfrom=' + aff_id\n", "docstring": "Use Kovid's affiliate id 30% of the time."}
{"repo": "calibre-master/src/calibre/gui2/store/stores/mobileread/cache_progress_dialog.py", "original_string": "    def set_details(self, msg):\n        self.details.setText(msg)\n", "docstring": "self.details.setText(msg)"}
{"repo": "calibre-master/src/calibre/gui2/viewer/toc.py", "original_string": "    def helpEvent(self, ev, view, option, index):\n        # Show a tooltip only if the item is truncated\n        if not ev or not view:\n            return False\n        if ev.type() == QEvent.Type.ToolTip:\n            rect = view.visualRect(index)\n            size = self.sizeHint(option, index)\n            if rect.width() < size.width():\n                tooltip = index.data(Qt.ItemDataRole.DisplayRole)\n                QToolTip.showText(ev.globalPos(), tooltip, view)\n                return True\n        return QStyledItemDelegate.helpEvent(self, ev, view, option, index)\n", "docstring": "Show a tooltip only if the item is truncated"}
{"repo": "calibre-master/src/calibre/gui2/viewer/overlay.py", "original_string": "    def hideEvent(self, ev):\n        # import time\n        # print(1111111, time.monotonic() - self.st)\n        self.pi.stop()\n", "docstring": "import time"}
{"repo": "calibre-master/src/calibre/gui2/convert/search_and_replace.py", "original_string": "    def __init__(self, parent, get_option, get_help, db=None, book_id=None):\n        # Dummy attributes to fool the Widget() option handler code. We handle\n        # everything in our *handler methods.\n        for i in range(1, 4):\n            x = 'sr%d_'%i\n            for y in ('search', 'replace'):\n                z = x + y\n                setattr(self, 'opt_'+z, z)\n        self.opt_search_replace = 'search_replace'\n        Widget.__init__(self, parent, OPTIONS['pipe']['search_and_replace'])\n        self.db, self.book_id = db, book_id\n        self.sr_search.set_msg(_('&Search regular expression:'))\n        self.sr_search.set_book_id(book_id)\n        self.sr_search.set_db(db)\n        self.sr_search.doc_update.connect(self.update_doc)\n        proto = QTableWidgetItem()\n        proto.setFlags(Qt.ItemFlags(Qt.ItemFlag.ItemIsSelectable + Qt.ItemFlag.ItemIsEnabled))\n        self.search_replace.setItemPrototype(proto)\n        self.search_replace.setColumnCount(2)\n        self.search_replace.setColumnWidth(0, 320)\n        self.search_replace.setColumnWidth(1, 320)\n        self.search_replace.setHorizontalHeaderLabels([\n            _('Search regular expression'), _('Replacement text')])\n        self.sr_add.clicked.connect(self.sr_add_clicked)\n        self.sr_change.clicked.connect(self.sr_change_clicked)\n        self.sr_remove.clicked.connect(self.sr_remove_clicked)\n        self.sr_load.clicked.connect(self.sr_load_clicked)\n        self.sr_save.clicked.connect(self.sr_save_clicked)\n        self.sr_up.clicked.connect(self.sr_up_clicked)\n        self.sr_down.clicked.connect(self.sr_down_clicked)\n        self.search_replace.currentCellChanged.connect(self.sr_currentCellChanged)\n        self.initialize_options(get_option, get_help, db, book_id)\n        try:\n            self.rh_label.setText(self.rh_label.text() % localize_user_manual_link(\n                'https://manual.calibre-ebook.com/regexp.html'))\n        except TypeError:\n            pass  # link already localized\n", "docstring": "Dummy attributes to fool the Widget() option handler code. We handle"}
{"repo": "calibre-master/src/calibre/gui2/tag_browser/model.py", "original_string": "    def handle_user_category_drop(self, on_node, ids, column):\n        categories = self.db.new_api.pref('user_categories', {})\n        cat_contents = categories.get(on_node.category_key[1:], None)\n        if cat_contents is None:\n            return\n        cat_contents = {(v, c) for v,c,ign in cat_contents}\n        fm_src = self.db.metadata_for_field(column)\n        label = fm_src['label']\n        for id in ids:\n            if not fm_src['is_custom']:\n                if label == 'authors':\n                    value = self.db.authors(id, index_is_id=True)\n                    value = [v.replace('|', ',') for v in value.split(',')]\n                elif label == 'publisher':\n                    value = self.db.publisher(id, index_is_id=True)\n                elif label == 'series':\n                    value = self.db.series(id, index_is_id=True)\n            else:\n                if fm_src['datatype'] != 'composite':\n                    value = self.db.get_custom(id, label=label, index_is_id=True)\n                else:\n                    value = self.db.get_property(id, loc=fm_src['rec_index'],\n                                                 index_is_id=True)\n            if value:\n                if not isinstance(value, list):\n                    value = [value]\n                cat_contents |= {(v, column) for v in value}\n        categories[on_node.category_key[1:]] = [[v, c, 0] for v,c in cat_contents]\n        self.db.new_api.set_pref('user_categories', categories)\n        self.refresh_required.emit()\n        self.user_category_added.emit()\n", "docstring": "categories = self.db.new_api.pref('user_categories', {})"}
{"repo": "calibre-master/src/calibre/gui2/tag_browser/model.py", "original_string": "    def get_categories_filter(self):\n        return self.filter_categories_by\n", "docstring": "return self.filter_categories_by"}
{"repo": "calibre-master/src/calibre/gui2/tag_browser/model.py", "original_string": "    def headerData(self, *args):\n        return None\n", "docstring": "return None"}
{"repo": "calibre-master/src/calibre/gui2/tag_browser/model.py", "original_string": "    def set_boxed(self, idx):\n        tag_item = self.get_node(idx)\n        tag_item.boxed = True\n        self.dataChanged.emit(idx, idx)\n", "docstring": "tag_item = self.get_node(idx)"}
{"repo": "calibre-master/src/calibre/gui2/tag_browser/view.py", "original_string": "    def expand_parent(self, idx):\n        # Needed otherwise Qt sometimes segfaults if the node is buried in a\n        # collapsed, off screen hierarchy. To be safe, we expand from the\n        # outermost in\n        p = self._model.parent(idx)\n        if p.isValid():\n            self.expand_parent(p)\n        self.expand(idx)\n", "docstring": "Needed otherwise Qt sometimes segfaults if the node is buried in a"}
{"repo": "calibre-master/src/calibre/gui2/tag_browser/ui.py", "original_string": "    def get_book_ids(self, use_virtual_library, db, category):\n        book_ids = None if not use_virtual_library else self.tags_view.model().get_book_ids_to_use()\n        data = db.new_api.get_categories(book_ids=book_ids)\n        if category in data:\n            result = [(t.id, t.original_name, t.count) for t in data[category] if t.count > 0]\n        else:\n            result = None\n        return result\n", "docstring": "book_ids = None if not use_virtual_library else self.tags_view.model().get_book_ids_to_use()"}
{"repo": "calibre-master/src/calibre/gui2/tag_browser/ui.py", "original_string": "    def do_tag_item_renamed(self):\n        # Clean up library view and search\n        # get information to redo the selection\n        rows = [r.row() for r in\n                self.library_view.selectionModel().selectedRows()]\n        m = self.library_view.model()\n        ids = [m.id(r) for r in rows]\n        m.refresh(reset=False)\n        m.research()\n        self.library_view.select_rows(ids)\n        # refreshing the tags view happens at the emit()/call() site\n", "docstring": "Clean up library view and search"}
{"repo": "calibre-master/src/calibre/gui2/metadata/single.py", "original_string": "    def break_cycles(self):\n        # Break any reference cycles that could prevent python\n        # from garbage collecting this dialog\n        self.set_current_callback = self.db = None\n        self.metadata_before_fetch = None\n        def disconnect(signal):\n            try:\n                signal.disconnect()\n            except:\n                pass  # Fails if view format was never connected\n        disconnect(self.view_format)\n        disconnect(self.edit_format)\n        for b in ('next_button', 'prev_button'):\n            x = getattr(self, b, None)\n            if x is not None:\n                disconnect(x.clicked)\n        for widget in self.basic_metadata_widgets:\n            bc = getattr(widget, 'break_cycles', None)\n            if bc is not None and callable(bc):\n                bc()\n        for widget in getattr(self, 'custom_metadata_widgets', []):\n            widget.break_cycles()\n", "docstring": "Break any reference cycles that could prevent python"}
{"repo": "calibre-master/src/calibre/gui2/metadata/single_download.py", "original_string": "    def clear_failed(self):\n        # Remove entries that are still waiting\n        good = []\n        pmap = {}\n        def keygen(x):\n            pmap = x[2]\n            if pmap is None:\n                return 1\n            return pmap.width()*pmap.height()\n        dcovers = sorted(self.covers[1:], key=keygen, reverse=True)\n        cmap = {i:self.plugin_for_index(i) for i in range(len(self.covers))}\n        for i, x in enumerate(self.covers[0:1] + dcovers):\n            if not x[-1]:\n                good.append(x)\n                plugin = cmap[i]\n                if plugin is not None:\n                    try:\n                        pmap[plugin].append(len(good) - 1)\n                    except KeyError:\n                        pmap[plugin] = [len(good)-1]\n        self.covers = good\n        self.plugin_map = pmap\n        self.beginResetModel(), self.endResetModel()\n", "docstring": "Remove entries that are still waiting"}
{"repo": "calibre-master/src/calibre/gui2/metadata/single_download.py", "original_string": "    def accept(self):\n        # Prevent the usual dialog accept mechanisms from working\n        gprefs['metadata_single_gui_geom'] = bytearray(self.saveGeometry())\n        self.identify_widget.save_state()\n        if DEBUG_DIALOG:\n            if self.stack.currentIndex() == 2:\n                return QDialog.accept(self)\n        else:\n            if self.stack.currentIndex() == 1:\n                return QDialog.accept(self)\n", "docstring": "Prevent the usual dialog accept mechanisms from working"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/plugin.py", "original_string": "def plugin_action_sid(plugin, tool, for_toolbar=True):\n    return plugin.name + tool.name + ('toolbar' if for_toolbar else 'menu')\n", "docstring": "return plugin.name + tool.name + ('toolbar' if for_toolbar else 'menu')"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/function_replace.py", "original_string": "def replace_uppercase(match, number, file_name, metadata, dictionaries, data, functions, *args, **kwargs):\n    '''Make matched text upper case. If the regular expression contains groups,\n    only the text in the groups will be changed, otherwise the entire text is\n    changed.'''\n    return apply_func_to_match_groups(match, upper)\n", "docstring": "Make matched text upper case. If the regular expression contains groups,"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/function_replace.py", "original_string": "def replace_lowercase(match, number, file_name, metadata, dictionaries, data, functions, *args, **kwargs):\n    '''Make matched text lower case. If the regular expression contains groups,\n    only the text in the groups will be changed, otherwise the entire text is\n    changed.'''\n    return apply_func_to_match_groups(match, lower)\n", "docstring": "Make matched text lower case. If the regular expression contains groups,"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/function_replace.py", "original_string": "def replace_capitalize(match, number, file_name, metadata, dictionaries, data, functions, *args, **kwargs):\n    '''Capitalize matched text. If the regular expression contains groups,\n    only the text in the groups will be changed, otherwise the entire text is\n    changed.'''\n    return apply_func_to_match_groups(match, capitalize)\n", "docstring": "Capitalize matched text. If the regular expression contains groups,"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/function_replace.py", "original_string": "def replace_titlecase(match, number, file_name, metadata, dictionaries, data, functions, *args, **kwargs):\n    '''Title-case matched text. If the regular expression contains groups,\n    only the text in the groups will be changed, otherwise the entire text is\n    changed.'''\n    return apply_func_to_match_groups(match, titlecase)\n", "docstring": "Title-case matched text. If the regular expression contains groups,"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/function_replace.py", "original_string": "def replace_swapcase(match, number, file_name, metadata, dictionaries, data, functions, *args, **kwargs):\n    '''Swap the case of the matched text. If the regular expression contains groups,\n    only the text in the groups will be changed, otherwise the entire text is\n    changed.'''\n    return apply_func_to_match_groups(match, swapcase)\n", "docstring": "Swap the case of the matched text. If the regular expression contains groups,"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/function_replace.py", "original_string": "def replace_uppercase_ignore_tags(match, number, file_name, metadata, dictionaries, data, functions, *args, **kwargs):\n    '''Make matched text upper case, ignoring the text inside tag definitions.'''\n    return apply_func_to_html_text(match, upper)\n", "docstring": "Make matched text upper case, ignoring the text inside tag definitions.'''"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/function_replace.py", "original_string": "def replace_lowercase_ignore_tags(match, number, file_name, metadata, dictionaries, data, functions, *args, **kwargs):\n    '''Make matched text lower case, ignoring the text inside tag definitions.'''\n    return apply_func_to_html_text(match, lower)\n", "docstring": "Make matched text lower case, ignoring the text inside tag definitions.'''"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/function_replace.py", "original_string": "def replace_capitalize_ignore_tags(match, number, file_name, metadata, dictionaries, data, functions, *args, **kwargs):\n    '''Capitalize matched text, ignoring the text inside tag definitions.'''\n    return apply_func_to_html_text(match, capitalize)\n", "docstring": "Capitalize matched text, ignoring the text inside tag definitions.'''"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/function_replace.py", "original_string": "def replace_titlecase_ignore_tags(match, number, file_name, metadata, dictionaries, data, functions, *args, **kwargs):\n    '''Title-case matched text, ignoring the text inside tag definitions.'''\n    return apply_func_to_html_text(match, titlecase)\n", "docstring": "Title-case matched text, ignoring the text inside tag definitions.'''"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/function_replace.py", "original_string": "def replace_swapcase_ignore_tags(match, number, file_name, metadata, dictionaries, data, functions, *args, **kwargs):\n    '''Swap the case of the matched text, ignoring the text inside tag definitions.'''\n    return apply_func_to_html_text(match, swapcase)\n", "docstring": "Swap the case of the matched text, ignoring the text inside tag definitions.'''"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/undo.py", "original_string": "    def rewind_savepoint(self):\n        ''' Revert back to the last save point, should only be used immediately\n        after a call to add_savepoint. If there are intervening calls to undo\n        or redo, behavior is undefined. This is intended to be used in the case\n        where you create savepoint, perform some operation, operation fails, so\n        revert to state before creating savepoint. '''\n        if self.pos > 0 and self.pos == len(self.states) - 1:\n            self.beginRemoveRows(ROOT, self.pos, self.pos)\n            self.pos -= 1\n            cleanup([self.states.pop().container])\n            self.endRemoveRows()\n            self.dataChanged.emit(self.index(self.pos), self.index(self.pos))\n            ans = self.current_container\n            self.states[self.pos].message = self.states[self.pos].rewind_message\n            return ans\n", "docstring": "Revert back to the last save point, should only be used immediately"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/spell.py", "original_string": "    def replace_word(self, w, new_word):\n        # Hack to deal with replacement words that are actually multiple words,\n        # ignore all words except the first\n        try:\n            new_word = split_into_words(new_word)[0]\n        except IndexError:\n            new_word = ''\n        for location in self.words[w]:\n            location.replace(new_word)\n        if w[0] == new_word:\n            return w\n        new_key = (new_word, w[1])\n        if new_key in self.words:\n            self.words[new_key] = merge_locations(self.words[new_key], self.words[w])\n            row = self.row_for_word(w)\n            self.dataChanged.emit(self.index(row, 1), self.index(row, 1))\n        else:\n            self.words[new_key] = self.words[w]\n            self.spell_map[new_key] = dictionaries.recognized(*new_key)\n            self.update_word(new_key)\n            self.update_counts()\n        row = self.row_for_word(w)\n        if row > -1:\n            self.beginRemoveRows(QModelIndex(), row, row)\n            del self.items[row]\n            self.endRemoveRows()\n        self.words.pop(w, None)\n        return new_key\n", "docstring": "Hack to deal with replacement words that are actually multiple words,"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/preview.py", "original_string": "def uniq(vals):\n    ''' Remove all duplicates from vals, while preserving order.  '''\n    vals = vals or ()\n    seen = set()\n    seen_add = seen.add\n    return tuple(x for x in vals if x not in seen and not seen_add(x))\n", "docstring": "Remove all duplicates from vals, while preserving order.  '''"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/boss.py", "original_string": "    def compare_book(self):\n        if not self.ensure_book():\n            return\n        self.commit_all_editors_to_container()\n        c = current_container()\n        path = choose_files(self.gui, 'select-book-for-comparison', _('Choose book'), filters=[\n            (_('%s books') % c.book_type.upper(), (c.book_type,))], select_only_single_file=True, all_files=False)\n        if path and path[0]:\n            with TemporaryDirectory('_compare') as tdir:\n                other = _gc(path[0], tdir=tdir, tweak_mode=True)\n                d = self.create_diff_dialog(revert_msg=None)\n                d.container_diff(other, c,\n                                 names=(_('Other book'), _('Current book')))\n", "docstring": "if not self.ensure_book():"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/boss.py", "original_string": "    def search(self, action, overrides=None):\n        # Run a search/replace\n        sp = self.gui.central.search_panel\n        # Ensure the search panel is visible\n        sp.setVisible(True)\n        ed = self.gui.central.current_editor\n        name = editor_name(ed)\n        state = sp.state\n        if overrides:\n            state.update(overrides)\n        searchable_names = self.gui.file_list.searchable_names\n        if not validate_search_request(name, searchable_names, getattr(ed, 'has_marked_text', False), state, self.gui):\n            return\n        ret = run_search(state, action, ed, name, searchable_names,\n                   self.gui, self.show_editor, self.edit_file, self.show_current_diff, self.add_savepoint, self.rewind_savepoint, self.set_modified)\n        ed = ret is True and self.gui.central.current_editor\n        if getattr(ed, 'has_line_numbers', False):\n            ed.editor.setFocus(Qt.FocusReason.OtherFocusReason)\n        else:\n            self.gui.saved_searches.setFocus(Qt.FocusReason.OtherFocusReason)\n", "docstring": "Run a search/replace"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/boss.py", "original_string": "    def next_spell_error(self):\n        # Go to the next spelling error\n        ed = self.gui.central.current_editor\n        name = editor_name(ed)\n        find_next_error(ed, name, self.gui, self.show_editor, self.edit_file)\n", "docstring": "Go to the next spelling error"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/boss.py", "original_string": "    def commit_all_editors_to_container(self):\n        ''' Commit any changes that the user has made to files open in editors to\n        the container. You should call this method before performing any\n        actions on the current container '''\n        changed = False\n        with BusyCursor():\n            for name, ed in iteritems(editors):\n                if not ed.is_synced_to_container:\n                    self.commit_editor_to_container(name)\n                    ed.is_synced_to_container = True\n                    changed = True\n        return changed\n", "docstring": "Commit any changes that the user has made to files open in editors to"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/boss.py", "original_string": "    def edit_file(self, name, syntax=None, use_template=None):\n        ''' Open the file specified by name in an editor\n        :param syntax: The media type of the file, for example, ``'text/html'``. If not specified it is guessed from the file extension.\n        :param use_template: A template to initialize the opened editor with\n        '''\n        editor = editors.get(name, None)\n        if editor is None:\n            syntax = syntax or syntax_from_mime(name, guess_type(name))\n            if use_template is None:\n                data = current_container().raw_data(name)\n                if isbytestring(data) and syntax in {'html', 'css', 'text', 'xml', 'javascript'}:\n                    try:\n                        data = data.decode('utf-8')\n                    except UnicodeDecodeError:\n                        return error_dialog(self.gui, _('Cannot decode'), _(\n                            'Cannot edit %s as it appears to be in an unknown character encoding') % name, show=True)\n            else:\n                data = use_template\n            editor = editors[name] = editor_from_syntax(syntax, self.gui.editor_tabs)\n            self.init_editor(name, editor, data, use_template=bool(use_template))\n            if tprefs['pretty_print_on_open']:\n                editor.pretty_print(name)\n        self.show_editor(name)\n        return editor\n", "docstring": "Open the file specified by name in an editor"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/editor/text.py", "original_string": "    def is_modified(self):\n        ''' True if the document has been modified since it was loaded or since\n        the last time is_modified was set to False. '''\n        return self.document().isModified()\n", "docstring": "True if the document has been modified since it was loaded or since"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/editor/text.py", "original_string": "    def override_shortcut(self, ev):\n        # Let the global cut/copy/paste/undo/redo shortcuts work, this avoids the nbsp\n        # problem as well, since they use the overridden createMimeDataFromSelection() method\n        # instead of the one from Qt (which makes copy() work), and allows proper customization\n        # of the shortcuts\n        if ev in (\n            QKeySequence.StandardKey.Copy, QKeySequence.StandardKey.Cut, QKeySequence.StandardKey.Paste,\n            QKeySequence.StandardKey.Undo, QKeySequence.StandardKey.Redo\n        ):\n            ev.ignore()\n            return True\n        # This is used to convert typed hex codes into unicode\n        # characters\n        if ev.key() == Qt.Key.Key_X and ev.modifiers() == Qt.KeyboardModifier.AltModifier:\n            ev.accept()\n            return True\n        return PlainTextEdit.override_shortcut(self, ev)\n", "docstring": "Let the global cut/copy/paste/undo/redo shortcuts work, this avoids the nbsp"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/editor/smarts/html.py", "original_string": "def find_closest_containing_tag(block, offset, max_tags=sys.maxsize):\n    ''' Find the closest containing tag. To find it, we search for the first\n    opening tag that does not have a matching closing tag before the specified\n    position. Search through at most max_tags. '''\n    prev_tag_boundary = lambda b, o: next_tag_boundary(b, o, forward=False)\n    block, boundary = prev_tag_boundary(block, offset)\n    if block is None:\n        return None\n    if boundary.is_start:\n        # We are inside a tag already\n        if boundary.closing:\n            return find_closest_containing_tag(block, boundary.offset)\n        eblock, eboundary = next_tag_boundary(block, boundary.offset)\n        if eblock is None or eboundary is None or eboundary.is_start:\n            return None\n        if eboundary.self_closing:\n            return Tag(block, boundary, eblock, eboundary, self_closing=True)\n        return find_closest_containing_tag(eblock, eboundary.offset + 1)\n    stack = []\n    block, tag_end = block, boundary\n    while block is not None and max_tags > 0:\n        sblock, tag_start = prev_tag_boundary(block, tag_end.offset)\n        if sblock is None or not tag_start.is_start:\n            break\n        if tag_start.closing:  # A closing tag of the form </a>\n            stack.append((tag_start.prefix, tag_start.name))\n        elif tag_end.self_closing:  # A self closing tag of the form <a/>\n            pass  # Ignore it\n        else:  # An opening tag, hurray\n            try:\n                prefix, name = stack.pop()\n            except IndexError:\n                prefix = name = None\n            if (prefix, name) != (tag_start.prefix, tag_start.name):\n                # Either we have an unbalanced opening tag or a syntax error, in\n                # either case terminate\n                return Tag(sblock, tag_start, block, tag_end)\n        block, tag_end = prev_tag_boundary(sblock, tag_start.offset)\n        max_tags -= 1\n    return None  # Could not find a containing tag\n", "docstring": "Find the closest containing tag. To find it, we search for the first"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/editor/smarts/html.py", "original_string": "    def verify_for_spellcheck(self, cursor, highlighter):\n        # Return True iff the cursor is in a location where spelling is\n        # checked (inside a tag or inside a checked attribute)\n        highlighter.join()\n        block = cursor.block()\n        start_pos = cursor.anchor() - block.position()\n        end_pos = cursor.position() - block.position()\n        start_tag, closing = find_tag_definition(block, start_pos)\n        if closing:\n            return False\n        end_tag, closing = find_tag_definition(block, end_pos)\n        if closing:\n            return False\n        if start_tag is None and end_tag is None:\n            # We are in normal text, check that the containing tag is\n            # allowed for spell checking.\n            tag = find_closest_containing_tag(block, start_pos)\n            if tag is not None and highlighter.tag_ok_for_spell(tag.name.split(':')[-1]):\n                return True\n        if start_tag != end_tag:\n            return False\n        # Now we check if we are in an allowed attribute\n        sa = find_containing_attribute(block, start_pos)\n        ea = find_containing_attribute(block, end_pos)\n        if sa == ea and sa in highlighter.spell_attributes:\n            return True\n        return False\n", "docstring": "Return True iff the cursor is in a location where spelling is"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/editor/smarts/html.py", "original_string": "    def goto_sourceline(self, editor, sourceline, tags, attribute=None):\n        ''' Move the cursor to the tag identified by sourceline and tags (a\n        list of tags names on the specified line). If attribute is specified\n        the cursor will be placed at the start of the attribute value. '''\n        found_tag = False\n        if sourceline is None:\n            return found_tag\n        block = editor.document().findBlockByNumber(sourceline - 1)  # blockNumber() is zero based\n        if not block.isValid():\n            return found_tag\n        editor.highlighter.join()\n        c = editor.textCursor()\n        ud = block.userData()\n        all_tags = [] if ud is None else [t for t in ud.tags if (t.is_start and not t.closing)]\n        tag_names = [t.name for t in all_tags]\n        if all_tags and tag_names[:len(tags)] == tags:\n            c.setPosition(block.position() + all_tags[len(tags)-1].offset)\n            found_tag = True\n        else:\n            c.setPosition(block.position())\n        if found_tag and attribute is not None:\n            start_offset = c.position() - block.position()\n            nblock, offset = find_attribute_in_tag(block, start_offset, attribute)\n            if nblock is not None:\n                c.setPosition(nblock.position() + offset)\n        editor.setTextCursor(c)\n        return found_tag\n", "docstring": "Move the cursor to the tag identified by sourceline and tags (a"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/editor/smarts/html.py", "original_string": "    def set_text_alignment(self, editor, value):\n        ''' Set the text-align property on the current block tag(s) '''\n        editor.highlighter.join()\n        block_tag_names = BLOCK_TAG_NAMES - {'body'}  # ignore body since setting text-align globally on body is almost never what is wanted\n        tags = []\n        c = editor.textCursor()\n        if c.hasSelection():\n            start, end = min(c.anchor(), c.position()), max(c.anchor(), c.position())\n            c.setPosition(start)\n            block = c.block()\n            while block.isValid() and block.position() < end:\n                ud = block.userData()\n                if ud is not None:\n                    for tb in ud.tags:\n                        if tb.is_start and not tb.closing and tb.name.lower() in block_tag_names:\n                            nblock, boundary = next_tag_boundary(block, tb.offset)\n                            if boundary is not None and not boundary.is_start and not boundary.self_closing:\n                                tags.append(Tag(block, tb, nblock, boundary))\n                block = block.next()\n        if not tags:\n            c = editor.textCursor()\n            block, offset = c.block(), c.positionInBlock()\n            tag = find_closest_containing_block_tag(block, offset, block_tag_names)\n            if tag is None:\n                return error_dialog(editor, _('Not in a block tag'), _(\n                    'Cannot change text alignment as the cursor is not inside a block level tag, such as a &lt;p&gt; or &lt;div&gt; tag.'), show=True)\n            tags = [tag]\n        for tag in reversed(tags):\n            set_style_property(tag, 'text-align', value, editor)\n", "docstring": "Set the text-align property on the current block tag(s) '''"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/editor/syntax/base.py", "original_string": "    def join(self):\n        ''' Blocks until all pending highlighting requests are handled '''\n        doc = self.doc\n        if doc is None:\n            self.requests.clear()\n            return\n        self.ignore_requests = True\n        try:\n            while self.requests:\n                start_cursor, end_cursor = self.requests.popleft()\n                block = start_cursor.block()\n                last_block = end_cursor.block()\n                if not last_block.isValid():\n                    last_block = doc.lastBlock()\n                end_pos = last_block.position() + last_block.length()\n                force_next_highlight = False\n                while block.isValid() and (force_next_highlight or block.position() < end_pos):\n                    formats, force_next_highlight = self.parse_single_block(block)\n                    self.apply_format_changes(block, formats)\n                    doc.markContentsDirty(block.position(), block.length())\n                    block = block.next()\n        finally:\n            self.ignore_requests = False\n", "docstring": "Blocks until all pending highlighting requests are handled '''"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/editor/syntax/pygments_highlighter.py", "original_string": "    def __init__(self):\n        self.parse = NORMAL\n        self.pygments_stack = None\n", "docstring": "self.parse = NORMAL"}
{"repo": "calibre-master/src/calibre/gui2/tweak_book/diff/view.py", "original_string": "    def trim_identical_leading_lines(self, alo, ahi, blo, bhi):\n        ''' The patience diff algorithm sometimes results in a block of replace\n        lines with identical leading lines. Remove these. This can cause extra\n        lines of context, but that is better than having extra lines of diff\n        with no actual changes. '''\n        a, b = self.left_lines, self.right_lines\n        leading = 0\n        while alo < ahi and blo < bhi and a[alo] == b[blo]:\n            leading += 1\n            alo += 1\n            blo += 1\n        if leading > 0:\n            self.equal(alo - leading, alo, blo - leading, blo)\n        return alo, ahi, blo, bhi\n", "docstring": "The patience diff algorithm sometimes results in a block of replace"}
{"repo": "calibre-master/src/calibre/utils/unicode_names.py", "original_string": "def points_for_word(w):\n    \"\"\"Returns the set of all codepoints that contain ``word`` in their names\"\"\"\n    w = w.lower()\n    ans = points_for_word.cache.get(w)\n    if ans is None:\n        from calibre_extensions.unicode_names import codepoints_for_word\n        ans = codepoints_for_word(w) | html_entities().get(w, set())\n        points_for_word.cache[w] = ans\n    return ans\n", "docstring": "Returns the set of all codepoints that contain ``word`` in their names\n"}
{"repo": "calibre-master/src/calibre/utils/formatter.py", "original_string": "    def float_deal_with_none(self, v):\n        # Undefined values and the string 'None' are assumed to be zero.\n        # The reason for string 'None': raw_field returns it for undefined values\n        return float(v if v and v != 'None' else 0)\n", "docstring": "Undefined values and the string 'None' are assumed to be zero."}
{"repo": "calibre-master/src/calibre/utils/smtp.py", "original_string": "def safe_localhost():\n    # RFC 2821 says we should use the fqdn in the EHLO/HELO verb, and\n    # if that can't be calculated, that we should use a domain literal\n    # instead (essentially an encoded IP address like [A.B.C.D]).\n    try:\n        fqdn = decode_fqdn(socket.getfqdn())\n    except UnicodeDecodeError:\n        if not iswindows:\n            raise\n        from calibre_extensions.winutil import get_computer_name\n        fqdn = get_computer_name()\n    if '.' in fqdn and fqdn != '.':\n        # Some mail servers have problems with non-ascii local hostnames, see\n        # https://bugs.launchpad.net/bugs/1256549\n        try:\n            local_hostname = as_unicode(idna.ToASCII(fqdn))\n        except Exception:\n            local_hostname = 'localhost.localdomain'\n    else:\n        # We can't find an fqdn hostname, so use a domain literal\n        addr = '127.0.0.1'\n        try:\n            addr = socket.gethostbyname(socket.gethostname())\n        except socket.gaierror:\n            pass\n        local_hostname = '[%s]' % addr\n    return local_hostname\n", "docstring": "RFC 2821 says we should use the fqdn in the EHLO/HELO verb, and"}
{"repo": "calibre-master/src/calibre/utils/filenames.py", "original_string": "def windows_get_fileid(path):\n    ''' The fileid uniquely identifies actual file contents (it is the same for\n    all hardlinks to a file). Similar to inode number on linux. '''\n    from calibre_extensions.winutil import get_file_id\n    if isbytestring(path):\n        path = path.decode(filesystem_encoding)\n    with suppress(OSError):\n        return get_file_id(path)\n", "docstring": "The fileid uniquely identifies actual file contents (it is the same for"}
{"repo": "calibre-master/src/calibre/utils/filenames.py", "original_string": "def windows_hardlink(src, dest):\n    from calibre_extensions import winutil\n    winutil.create_hard_link(dest, src)\n    src_size = os.path.getsize(src)\n    # We open and close dest, to ensure its directory entry is updated\n    # see http://blogs.msdn.com/b/oldnewthing/archive/2011/12/26/10251026.aspx\n    for i in range(10):\n        # If we are on a network filesystem, we have to wait for some indeterminate time, since\n        # network file systems are the best thing since sliced bread\n        try:\n            if windows_get_size(dest) == src_size:\n                return\n        except EnvironmentError:\n            pass\n        time.sleep(0.3)\n    sz = windows_get_size(dest)\n    if sz != src_size:\n        msg = 'Creating hardlink from %s to %s failed: %%s' % (src, dest)\n        raise OSError(msg % ('hardlink size: %d not the same as source size' % sz))\n", "docstring": "from calibre_extensions import winutil"}
{"repo": "calibre-master/src/calibre/utils/filenames.py", "original_string": "def atomic_rename(oldpath, newpath):\n    '''Replace the file newpath with the file oldpath. Can fail if the files\n    are on different volumes. If succeeds, guaranteed to be atomic. newpath may\n    or may not exist. If it exists, it is replaced. '''\n    if iswindows:\n        retry_on_fail(rename_file, oldpath, newpath)\n    else:\n        os.rename(oldpath, newpath)\n", "docstring": "Replace the file newpath with the file oldpath. Can fail if the files"}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "def quoteaddr(addr):\n    \"\"\"Quote a subset of the email addresses defined by RFC 821.\n    Should be able to handle anything rfc822.parseaddr can handle.\n    \"\"\"\n    m = (None, None)\n    try:\n        m = email.utils.parseaddr(addr)[1]\n    except AttributeError:\n        pass\n    if m == (None, None):  # Indicates parse failure or AttributeError\n        # something weird here.. punt -ddm\n        return \"<%s>\" % addr\n    elif m is None:\n        # the sender wants an empty return address\n        return \"<>\"\n    else:\n        return \"<%s>\" % m\n", "docstring": "Quote a subset of the email addresses defined by RFC 821."}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "def quotedata(data):\n    \"\"\"Quote data for email.\n    Double leading '.', and change Unix newline '\\\\n', or Mac '\\\\r' into\n    Internet CRLF end-of-line.\n    \"\"\"\n    return re.sub(r'(?m)^\\.', '..',\n        re.sub(r'(?:\\r\\n|\\n|\\r(?!\\n))', CRLF, data))\n", "docstring": "Quote data for email."}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "    def _get_socket(self, host, port, timeout):\n        # This makes it simpler for SMTP_SSL to use the SMTP connect code\n        # and just alter the socket connection bit.\n        if self.debuglevel > 0:\n            self.debug('connect:', (host, port))\n        return socket.create_connection((host, port), timeout)\n", "docstring": "This makes it simpler for SMTP_SSL to use the SMTP connect code"}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "    def send(self, str):\n        \"\"\"Send `str' to the server.\"\"\"\n        if self.debuglevel > 0:\n            raw = repr(str)\n            self.debug('send:', raw)\n        if hasattr(self, 'sock') and self.sock:\n            try:\n                self.sock.sendall(str)\n            except socket.error:\n                self.close()\n                raise SMTPServerDisconnected('Server not connected')\n        else:\n            raise SMTPServerDisconnected('please run connect() first')\n", "docstring": "Send `str' to the server.\n"}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "    def getreply(self):\n        \"\"\"Get a reply from the server.\n        Returns a tuple consisting of:\n          - server response code (e.g. '250', or such, if all goes well)\n            Note: returns -1 if it can't read response code.\n          - server response string corresponding to response code (multiline\n            responses are converted to a single, multiline string).\n        Raises SMTPServerDisconnected if end-of-file is reached.\n        \"\"\"\n        resp = []\n        if self.file is None:\n            self.file = self.sock.makefile('rb')\n        while True:\n            try:\n                line = self.file.readline(_MAXLINE + 1)\n            except socket.error as e:\n                self.close()\n                raise SMTPServerDisconnected(\"Connection unexpectedly closed: \" + str(e))\n            if line == '':\n                self.close()\n                raise SMTPServerDisconnected(\"Connection unexpectedly closed\")\n            if self.debuglevel > 0:\n                self.debug('reply:', repr(line))\n            if len(line) > _MAXLINE:\n                raise SMTPResponseException(500, \"Line too long.\")\n            resp.append(line[4:].strip())\n            code = line[:3]\n            # Check that the error code is syntactically correct.\n            # Don't attempt to read a continuation line if it is broken.\n            try:\n                errcode = int(code)\n            except ValueError:\n                errcode = -1\n                break\n            # Check if multiline response.\n            if line[3:4] != \"-\":\n                break\n        errmsg = \"\\n\".join(resp)\n        if self.debuglevel > 0:\n            self.debug('reply: retcode (%s); Msg: %s' % (errcode,errmsg))\n        return errcode, errmsg\n", "docstring": "Get a reply from the server."}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "    def helo(self, name=''):\n        \"\"\"SMTP 'helo' command.\n        Hostname to send for this command defaults to the FQDN of the local\n        host.\n        \"\"\"\n        self.putcmd(\"helo\", name or self.local_hostname)\n        (code, msg) = self.getreply()\n        self.helo_resp = msg\n        return (code, msg)\n", "docstring": "SMTP 'helo' command."}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "    def has_extn(self, opt):\n        \"\"\"Does the server support a given SMTP service extension?\"\"\"\n        return opt.lower() in self.esmtp_features\n", "docstring": "Does the server support a given SMTP service extension?\n"}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "    def rset(self):\n        \"\"\"SMTP 'rset' command -- resets session.\"\"\"\n        return self.docmd(\"rset\")\n", "docstring": "SMTP 'rset' command -- resets session.\n"}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "    def mail(self, sender, options=[]):\n        \"\"\"SMTP 'mail' command -- begins mail xfer session.\"\"\"\n        optionlist = ''\n        if options and self.does_esmtp:\n            optionlist = ' ' + ' '.join(options)\n        self.putcmd(\"mail\", \"FROM:%s%s\" % (quoteaddr(sender), optionlist))\n        return self.getreply()\n", "docstring": "SMTP 'mail' command -- begins mail xfer session.\n"}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "    def data(self, msg):\n        \"\"\"SMTP 'DATA' command -- sends message data to server.\n        Automatically quotes lines beginning with a period per rfc821.\n        Raises SMTPDataError if there is an unexpected reply to the\n        DATA command; the return value from this method is the final\n        response code received when the all data is sent.\n        \"\"\"\n        self.putcmd(\"data\")\n        (code, repl) = self.getreply()\n        if self.debuglevel > 0:\n            self.debug(\"data:\", (code, repl))\n        if code != 354:\n            raise SMTPDataError(code, repl)\n        else:\n            q = quotedata(msg)\n            if q[-2:] != CRLF:\n                q = q + CRLF\n            q = q + \".\" + CRLF\n            self.send(q)\n            (code, msg) = self.getreply()\n            if self.debuglevel > 0 :\n                self.debug(\"data:\", (code, msg))\n            return (code, msg)\n", "docstring": "SMTP 'DATA' command -- sends message data to server."}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "    def expn(self, address):\n        \"\"\"SMTP 'expn' command -- expands a mailing list.\"\"\"\n        self.putcmd(\"expn\", _addr_only(address))\n        return self.getreply()\n", "docstring": "SMTP 'expn' command -- expands a mailing list.\n"}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "    def ehlo_or_helo_if_needed(self):\n        \"\"\"Call self.ehlo() and/or self.helo() if needed.\n        If there has been no previous EHLO or HELO command this session, this\n        method tries ESMTP EHLO first.\n        This method may raise the following exceptions:\n         SMTPHeloError            The server didn't reply properly to\n                                  the helo greeting.\n        \"\"\"\n        if self.helo_resp is None and self.ehlo_resp is None:\n            if not (200 <= self.ehlo()[0] <= 299):\n                (code, resp) = self.helo()\n                if not (200 <= code <= 299):\n                    raise SMTPHeloError(code, resp)\n", "docstring": "Call self.ehlo() and/or self.helo() if needed."}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "    def starttls(self, context=None):\n        \"\"\"Puts the connection to the SMTP server into TLS mode.\n        If there has been no previous EHLO or HELO command this session, this\n        method tries ESMTP EHLO first.\n        If the server supports TLS, this will encrypt the rest of the SMTP\n        session. If you provide the keyfile and certfile parameters,\n        the identity of the SMTP server and client can be checked. This,\n        however, depends on whether the socket module really checks the\n        certificates.\n        This method may raise the following exceptions:\n         SMTPHeloError            The server didn't reply properly to\n                                  the helo greeting.\n        \"\"\"\n        self.ehlo_or_helo_if_needed()\n        if not self.has_extn(\"starttls\"):\n            raise SMTPException(\"STARTTLS extension not supported by server.\")\n        (resp, reply) = self.docmd(\"STARTTLS\")\n        if resp == 220:\n            if not _have_ssl:\n                raise RuntimeError(\"No SSL support included in this Python\")\n            if context is None:\n                self.sock = ssl.wrap_socket(self.sock)\n            else:\n                self.sock = context.wrap_socket(self.sock, server_hostname=self._host)\n            self.file = SSLFakeFile(self.sock)\n            # RFC 3207:\n            # The client MUST discard any knowledge obtained from\n            # the server, such as the list of SMTP service extensions,\n            # which was not obtained from the TLS negotiation itself.\n            self.helo_resp = None\n            self.ehlo_resp = None\n            self.esmtp_features = {}\n            self.does_esmtp = 0\n        else:\n            # RFC 3207:\n            # 501 Syntax error (no parameters allowed)\n            # 454 TLS not available due to temporary reason\n            raise SMTPResponseException(resp, reply)\n        return (resp, reply)\n", "docstring": "Puts the connection to the SMTP server into TLS mode."}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "    def close(self):\n        \"\"\"Close the connection to the SMTP server.\"\"\"\n        try:\n            file = self.file\n            self.file = None\n            if file:\n                file.close()\n        finally:\n            sock = self.sock\n            self.sock = None\n            if sock:\n                sock.close()\n", "docstring": "Close the connection to the SMTP server.\n"}
{"repo": "calibre-master/src/calibre/utils/smtplib.py", "original_string": "    def __init__(self, host='', port=LMTP_PORT, local_hostname=None):\n        \"\"\"Initialize a new instance.\"\"\"\n        SMTP.__init__(self, host, port, local_hostname)\n", "docstring": "Initialize a new instance.\n"}
{"repo": "calibre-master/src/calibre/utils/ip_routing.py", "original_string": "    def get_default_route_src_address_external():\n        # Use -6 for IPv6 addresses\n        raw = subprocess.check_output('route -4 print 0.0.0.0'.split(), creationflags=subprocess.DETACHED_PROCESS).decode('utf-8', 'replace')\n        in_table = False\n        default_gateway = get_address_of_default_gateway()\n        for line in raw.splitlines():\n            parts = line.strip().split()\n            if in_table:\n                if len(parts) == 6:\n                    network, destination, netmask, gateway, interface, metric = parts\n                elif len(parts) == 5:\n                    destination, netmask, gateway, interface, metric = parts\n                if gateway == default_gateway:\n                    return interface\n            else:\n                if parts == 'Network Destination Netmask Gateway Interface Metric'.split():\n                    in_table = True\n", "docstring": "Use -6 for IPv6 addresses"}
{"repo": "calibre-master/src/calibre/utils/ip_routing.py", "original_string": "    def get_default_route_src_address():\n        # Use -inet6 for IPv6\n        raw = subprocess.check_output('route -n get -inet default'.split()).decode('utf-8')\n        m = re.search(r'^\\s*interface:\\s*(\\S+)\\s*$', raw, flags=re.MULTILINE)\n        if m is not None:\n            interface = m.group(1)\n            for addr in get_addresses_for_interface(interface):\n                return addr\n", "docstring": "Use -inet6 for IPv6"}
{"repo": "calibre-master/src/calibre/utils/ip_routing.py", "original_string": "    def get_default_route_src_address():\n        # Use /proc/net/ipv6_route for IPv6 addresses\n        with open('/proc/net/route', 'rb') as f:\n            raw = f.read().decode('utf-8')\n        for line in raw.splitlines():\n            parts = line.split()\n            if len(parts) > 1 and parts[1] == '00000000':\n                for addr in get_addresses_for_interface(parts[0]):\n                    return addr\n", "docstring": "Use /proc/net/ipv6_route for IPv6 addresses"}
{"repo": "calibre-master/src/calibre/utils/recycle_bin.py", "original_string": "    def recycle(path):\n        # We have to run the delete to recycle bin in a separate process as the\n        # morons who wrote SHFileOperation designed it to spin the event loop\n        # even when no UI is created. And there is no other way to send files\n        # to the recycle bin on windows. Le Sigh. So we do it in a worker\n        # process. Unfortunately, if the worker process exits immediately after\n        # deleting to recycle bin, winblows does not update the recycle bin\n        # icon. Le Double Sigh. So we use a long lived worker process, that is\n        # started on first recycle, and sticks around to handle subsequent\n        # recycles.\n        if isinstance(path, bytes):\n            path = path.decode(filesystem_encoding)\n        path = os.path.abspath(path)  # Windows does not like recycling relative paths\n        return delegate_recycle(path)\n", "docstring": "We have to run the delete to recycle bin in a separate process as the"}
{"repo": "calibre-master/src/calibre/utils/mem.py", "original_string": "def gc_histogram():\n    \"\"\"Returns per-class counts of existing objects.\"\"\"\n    result = {}\n    for o in gc.get_objects():\n        t = type(o)\n        count = result.get(t, 0)\n        result[t] = count + 1\n    return result\n", "docstring": "Returns per-class counts of existing objects.\n"}
{"repo": "calibre-master/src/calibre/utils/img.py", "original_string": "def save_cover_data_to(\n    data, path=None,\n    bgcolor='#ffffff',\n    resize_to=None,\n    compression_quality=90,\n    minify_to=None,\n    grayscale=False,\n    eink=False,\n    letterbox=False,\n    letterbox_color='#000000',\n    data_fmt='jpeg'\n", "docstring": "data, path=None,"}
{"repo": "calibre-master/src/calibre/utils/img.py", "original_string": "def clone_image(img):\n    ''' Returns a shallow copy of the image. However, the underlying data buffer\n    will be automatically copied-on-write '''\n    return QImage(img)\n", "docstring": "Returns a shallow copy of the image. However, the underlying data buffer"}
{"repo": "calibre-master/src/calibre/utils/img.py", "original_string": "def grayscale_image(img):\n    return imageops.grayscale(image_from_data(img))\n", "docstring": "return imageops.grayscale(image_from_data(img))"}
{"repo": "calibre-master/src/calibre/utils/img.py", "original_string": "def quantize_image(img, max_colors=256, dither=True, palette=''):\n    ''' Quantize the image to contain a maximum of `max_colors` colors. By\n    default a palette is chosen automatically, if you want to use a fixed\n    palette, then pass in a list of color names in the `palette` variable. If\n    you, specify a palette `max_colors` is ignored. Note that it is possible\n    for the actual number of colors used to be less than max_colors.\n    :param max_colors: Max. number of colors in the auto-generated palette. Must be between 2 and 256.\n    :param dither: Whether to use dithering or not. dithering is almost always a good thing.\n    :param palette: Use a manually specified palette instead. For example: palette='red green blue #eee'\n    '''\n    img = image_from_data(img)\n    if img.hasAlphaChannel():\n        img = blend_image(img)\n    if palette and isinstance(palette, string_or_bytes):\n        palette = palette.split()\n    return imageops.quantize(img, max_colors, dither, [QColor(x).rgb() for x in palette])\n", "docstring": "Quantize the image to contain a maximum of `max_colors` colors. By"}
{"repo": "calibre-master/src/calibre/utils/config.py", "original_string": "    def option_by_dest(self, dest):\n        for opt in self.options_iter():\n            if opt.dest == dest:\n                return opt\n", "docstring": "for opt in self.options_iter():"}
{"repo": "calibre-master/src/calibre/utils/short_uuid.py", "original_string": "    def __init__(self, alphabet=None):\n        # We do not include zero and one in the default alphabet as they can be\n        # confused with the letters O and I in some fonts. And removing them\n        # does not change the uuid_pad_len.\n        self.alphabet = tuple(sorted(unicode_type(alphabet or (string.digits + string.ascii_letters)[2:])))\n        self.alphabet_len = len(self.alphabet)\n        self.alphabet_map = {c:i for i, c in enumerate(self.alphabet)}\n        self.uuid_pad_len = int(math.ceil(math.log(1 << 128, self.alphabet_len)))\n", "docstring": "We do not include zero and one in the default alphabet as they can be"}
{"repo": "calibre-master/src/calibre/utils/https.py", "original_string": "    def _dnsname_match(dn, hostname, max_wildcards=1):\n        \"\"\"Matching according to RFC 6125, section 6.4.3\n        http://tools.ietf.org/html/rfc6125#section-6.4.3\n        \"\"\"\n        pats = []\n        if not dn:\n            return False\n        parts = dn.split(r'.')\n        leftmost, remainder = parts[0], parts[1:]\n        wildcards = leftmost.count('*')\n        if wildcards > max_wildcards:\n            # Issue #17980: avoid denials of service by refusing more\n            # than one wildcard per fragment.  A survery of established\n            # policy among SSL implementations showed it to be a\n            # reasonable choice.\n            raise CertificateError(\n                \"too many wildcards in certificate DNS name: \" + repr(dn))\n        # speed up common case w/o wildcards\n        if not wildcards:\n            return dn.lower() == hostname.lower()\n        # RFC 6125, section 6.4.3, subitem 1.\n        # The client SHOULD NOT attempt to match a presented identifier in which\n        # the wildcard character comprises a label other than the left-most label.\n        if leftmost == '*':\n            # When '*' is a fragment by itself, it matches a non-empty dotless\n            # fragment.\n            pats.append('[^.]+')\n        elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n            # RFC 6125, section 6.4.3, subitem 3.\n            # The client SHOULD NOT attempt to match a presented identifier\n            # where the wildcard character is embedded within an A-label or\n            # U-label of an internationalized domain name.\n            pats.append(re.escape(leftmost))\n        else:\n            # Otherwise, '*' matches any dotless string, e.g. www*\n            pats.append(re.escape(leftmost).replace(r'\\*', '[^.]*'))\n        # add the remaining fragments, ignore any wildcards\n        for frag in remainder:\n            pats.append(re.escape(frag))\n        pat = re.compile(r'\\A' + r'\\.'.join(pats) + r'\\Z', re.IGNORECASE)\n        return pat.match(hostname)\n", "docstring": "Matching according to RFC 6125, section 6.4.3"}
{"repo": "calibre-master/src/calibre/utils/search_query_parser.py", "original_string": "    def get_queried_fields(self, query):\n        # empty the list of searches used for recursion testing\n        self.recurse_level = 0\n        self.searches_seen = set()\n        tree = self._get_tree(query)\n        yield from self._walk_expr(tree)\n", "docstring": "empty the list of searches used for recursion testing"}
{"repo": "calibre-master/src/calibre/utils/search_query_parser.py", "original_string": "    def parse(self, query, candidates=None):\n        # empty the list of searches used for recursion testing\n        self.recurse_level = 0\n        self.searches_seen = set()\n        candidates = self.universal_set()\n        return self._parse(query, candidates=candidates)\n", "docstring": "empty the list of searches used for recursion testing"}
{"repo": "calibre-master/src/calibre/utils/search_query_parser.py", "original_string": "    def evaluate_or(self, argument, candidates):\n        # RHS checks only those elements not matched by LHS\n        # returns LHS union RHS: LHmatches(c) + RHmatches(c-LHmatches(c))\n        #  return self.evaluate(argument[0]).union(self.evaluate(argument[1]))\n        l = self.evaluate(argument[0], candidates)\n        return l.union(self.evaluate(argument[1], candidates.difference(l)))\n", "docstring": "RHS checks only those elements not matched by LHS"}
{"repo": "calibre-master/src/calibre/utils/socket_inheritance.py", "original_string": "def test():\n    import socket\n    s = socket.socket()\n    orig = get_socket_inherit(s)\n    set_socket_inherit(s, orig ^ True)\n    if orig == get_socket_inherit(s):\n        raise RuntimeError('Failed to change socket inheritance status')\n    print('OK!')\n", "docstring": "import socket"}
{"repo": "calibre-master/src/calibre/utils/linux_trash.py", "original_string": "def check_create(dir):\n    # use 0700 for paths [3]\n    if not op.exists(dir):\n        os.makedirs(dir, 0o700)\n", "docstring": "use 0700 for paths [3]"}
{"repo": "calibre-master/src/calibre/utils/linux_trash.py", "original_string": "def find_mount_point(path):\n    # Even if something's wrong, \"/\" is a mount point, so the loop will exit.\n    # Use realpath in case it's a symlink\n    path = op.realpath(path)  # Required to avoid infinite loop\n    while not op.ismount(path):\n        path = op.split(path)[0]\n    return path\n", "docstring": "Even if something's wrong, \"/\" is a mount point, so the loop will exit."}
{"repo": "calibre-master/src/calibre/utils/linux_trash.py", "original_string": "def find_ext_volume_fallback_trash(volume_root):\n    # from [2] Trash directories (1) create a .Trash-$uid dir.\n    trash_dir = op.join(volume_root, TOPDIR_FALLBACK)\n    # Try to make the directory, if we can't the OSError exception will escape\n    # be thrown out of send2trash.\n    check_create(trash_dir)\n    return trash_dir\n", "docstring": "from [2] Trash directories (1) create a .Trash-$uid dir."}
{"repo": "calibre-master/src/calibre/utils/serialize.py", "original_string": "def msgpack_loads(dump, use_list=True):\n    # use_list controls whether msgpack arrays are unpacked as lists or tuples\n    import msgpack\n    return msgpack.unpackb(dump, ext_hook=msgpack_decoder, raw=False, use_list=use_list, strict_map_key=False)\n", "docstring": "use_list controls whether msgpack arrays are unpacked as lists or tuples"}
{"repo": "calibre-master/src/calibre/utils/imghdr.py", "original_string": "def jpeg(h):\n    \"\"\"JPEG data in JFIF format (Changed by Kovid to mimic the file utility,\n    the original code was failing with some jpegs that included ICC_PROFILE\n    data, for example: http://nationalpostnews.files.wordpress.com/2013/03/budget.jpeg?w=300&h=1571)\"\"\"\n    if h[6:10] in (b'JFIF', b'Exif'):\n        return 'jpeg'\n    if h[:2] == b'\\xff\\xd8':\n        q = h[:32].tobytes()\n        if b'JFIF' in q or b'8BIM' in q:\n            return 'jpeg'\n", "docstring": "JPEG data in JFIF format (Changed by Kovid to mimic the file utility,"}
{"repo": "calibre-master/src/calibre/utils/imghdr.py", "original_string": "def gif(h):\n    \"\"\"GIF ('87 and '89 variants)\"\"\"\n    if h[:6] in (b'GIF87a', b'GIF89a'):\n        return 'gif'\n", "docstring": "GIF ('87 and '89 variants)\n"}
{"repo": "calibre-master/src/calibre/utils/imghdr.py", "original_string": "def tiff(h):\n    \"\"\"TIFF (can be in Motorola or Intel byte order)\"\"\"\n    if h[:2] in (b'MM', b'II'):\n        if h[2:4] == b'\\xbc\\x01':\n            return 'jxr'\n        return 'tiff'\n", "docstring": "TIFF (can be in Motorola or Intel byte order)\n"}
{"repo": "calibre-master/src/calibre/utils/imghdr.py", "original_string": "def rgb(h):\n    \"\"\"SGI image library\"\"\"\n    if h[:2] == b'\\001\\332':\n        return 'rgb'\n", "docstring": "SGI image library\n"}
{"repo": "calibre-master/src/calibre/utils/imghdr.py", "original_string": "def pbm(h):\n    \"\"\"PBM (portable bitmap)\"\"\"\n    if len(h) >= 3 and \\\n        h[0] == b'P' and h[1] in b'14' and h[2] in b' \\t\\n\\r':\n        return 'pbm'\n", "docstring": "PBM (portable bitmap)\n"}
{"repo": "calibre-master/src/calibre/utils/imghdr.py", "original_string": "def pgm(h):\n    \"\"\"PGM (portable graymap)\"\"\"\n    if len(h) >= 3 and \\\n        h[0] == b'P' and h[1] in b'25' and h[2] in b' \\t\\n\\r':\n        return 'pgm'\n", "docstring": "PGM (portable graymap)\n"}
{"repo": "calibre-master/src/calibre/utils/imghdr.py", "original_string": "def ppm(h):\n    \"\"\"PPM (portable pixmap)\"\"\"\n    if len(h) >= 3 and \\\n        h[0] == b'P' and h[1] in b'36' and h[2] in b' \\t\\n\\r':\n        return 'ppm'\n", "docstring": "PPM (portable pixmap)\n"}
{"repo": "calibre-master/src/calibre/utils/imghdr.py", "original_string": "def rast(h):\n    \"\"\"Sun raster file\"\"\"\n    if h[:4] == b'\\x59\\xA6\\x6A\\x95':\n        return 'rast'\n", "docstring": "Sun raster file\n"}
{"repo": "calibre-master/src/calibre/utils/imghdr.py", "original_string": "def xbm(h):\n    \"\"\"X bitmap (X10 or X11)\"\"\"\n    s = b'#define '\n    if h[:len(s)] == s:\n        return 'xbm'\n", "docstring": "X bitmap (X10 or X11)\n"}
{"repo": "calibre-master/src/calibre/utils/bibtex.py", "original_string": "    def resolveUnicode(self, text):\n        # UTF-8 text as entry\n        text = self.rep_utf8.mreplace(text)\n        return text.replace('$}{$', '')\n", "docstring": "UTF-8 text as entry"}
{"repo": "calibre-master/src/calibre/utils/localization.py", "original_string": "def get_udc():\n    global _udc\n    if _udc is None:\n        from calibre.ebooks.unihandecode import Unihandecoder\n        _udc = Unihandecoder(lang=get_lang())\n    return _udc\n", "docstring": "global _udc"}
{"repo": "calibre-master/src/calibre/utils/formatter_functions.py", "original_string": "    def evaluate(self, formatter, kwargs, mi, locals, *args):\n        # The arguments function is implemented in-line in the formatter\n        raise NotImplementedError()\n", "docstring": "The arguments function is implemented in-line in the formatter"}
{"repo": "calibre-master/src/calibre/utils/formatter_functions.py", "original_string": "    def evaluate(self, formatter, kwargs, mi, locals, *args):\n        # The globals function is implemented in-line in the formatter\n        raise NotImplementedError()\n", "docstring": "The globals function is implemented in-line in the formatter"}
{"repo": "calibre-master/src/calibre/utils/formatter_functions.py", "original_string": "    def evaluate(self, formatter, kwargs, mi, locals, *args):\n        # The globals function is implemented in-line in the formatter\n        raise NotImplementedError()\n", "docstring": "The globals function is implemented in-line in the formatter"}
{"repo": "calibre-master/src/calibre/utils/formatter_functions.py", "original_string": "    def evaluate(self, formatter, kwargs, mi, locals, character_name):\n        # The globals function is implemented in-line in the formatter\n        raise NotImplementedError()\n", "docstring": "The globals function is implemented in-line in the formatter"}
{"repo": "calibre-master/src/calibre/utils/mdns.py", "original_string": "    def get_all_ips(self):\n        ''' Return a mapping of interface names to the configuration of the\n        interface, which includes the ip address, netmask and broadcast addresses\n        '''\n        import netifaces\n        all_ips = defaultdict(list)\n        if hasattr(netifaces, 'AF_INET'):\n            for x in netifaces.interfaces():\n                try:\n                    for c in netifaces.ifaddresses(x).get(netifaces.AF_INET, []):\n                        all_ips[x].append(c)\n                except ValueError:\n                    from calibre import prints\n                    prints('Failed to get IP addresses for interface', x)\n                    import traceback\n                    traceback.print_exc()\n        return dict(all_ips)\n", "docstring": "Return a mapping of interface names to the configuration of the"}
{"repo": "calibre-master/src/calibre/utils/shared_file.py", "original_string": "    def raise_winerror(x):\n        reraise(NotImplementedError, None, sys.exc_info()[2])\n", "docstring": "reraise(NotImplementedError, None, sys.exc_info()[2])"}
{"repo": "calibre-master/src/calibre/utils/iso8601.py", "original_string": "    def _isdst(self, dt):\n        # This method in tzlocal raises ValueError if dt is out of range (in\n        # older versions of dateutil)\n        # In such cases, just assume that dt is not DST.\n        try:\n            return super(SafeLocalTimeZone, self)._isdst(dt)\n        except Exception:\n            pass\n        return False\n", "docstring": "This method in tzlocal raises ValueError if dt is out of range (in"}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "def is_zipfile(filename):\n    \"\"\"Quickly see if a file is a ZIP file by checking the magic number.\n    The filename argument may be a file or file-like object too.\n    \"\"\"\n    result = False\n    try:\n        if hasattr(filename, \"read\"):\n            result = _check_zipfile(filename)\n        else:\n            with open(filename, \"rb\") as fp:\n                result = _check_zipfile(fp)\n    except IOError:\n        pass\n    return result\n", "docstring": "Quickly see if a file is a ZIP file by checking the magic number."}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "def _EndRecData(fpin):\n    \"\"\"Return data from the \"End of Central Directory\" record, or None.\n    The data is a list of the nine items in the ZIP \"End of central dir\"\n    record followed by a tenth item, the file seek offset of this record.\"\"\"\n    # Determine file size\n    fpin.seek(0, 2)\n    filesize = fpin.tell()\n    # Check to see if this is ZIP file with no archive comment (the\n    # \"end of central directory\" structure should be the last item in the\n    # file if this is the case).\n    try:\n        fpin.seek(-sizeEndCentDir, 2)\n    except IOError:\n        return None\n    data = fpin.read()\n    if data[0:4] == stringEndArchive and data[-2:] == b\"\\000\\000\":\n        # the signature is correct and there's no comment, unpack structure\n        endrec = struct.unpack(structEndArchive, data)\n        endrec=list(endrec)\n        # Append a blank comment and record start offset\n        endrec.append(b\"\")\n        endrec.append(filesize - sizeEndCentDir)\n        # Try to read the \"Zip64 end of central directory\" structure\n        return _EndRecData64(fpin, -sizeEndCentDir, endrec)\n    # Either this is not a ZIP file, or it is a ZIP file with an archive\n    # comment.  Search the end of the file for the \"end of central directory\"\n    # record signature. The comment is the last item in the ZIP file and may be\n    # up to 64K long.  It is assumed that the \"end of central directory\" magic\n    # number does not appear in the comment.\n    maxCommentStart = max(filesize - (1 << 16) - sizeEndCentDir, 0)\n    fpin.seek(maxCommentStart, 0)\n    data = fpin.read()\n    start = data.rfind(stringEndArchive)\n    if start >= 0:\n        # found the magic number; attempt to unpack and interpret\n        recData = data[start:start+sizeEndCentDir]\n        endrec = list(struct.unpack(structEndArchive, recData))\n        comment = data[start+sizeEndCentDir:]\n        # check that comment length is correct\n        # Kovid: Added == 0 check as some zip files apparently dont set this\n        if endrec[_ECD_COMMENT_SIZE] == 0 or endrec[_ECD_COMMENT_SIZE] == len(comment):\n            # Append the archive comment and start offset\n            endrec.append(comment)\n            endrec.append(maxCommentStart + start)\n            # Try to read the \"Zip64 end of central directory\" structure\n            return _EndRecData64(fpin, maxCommentStart + start - filesize,\n                                 endrec)\n    # Unable to find a valid end of central directory structure\n    return\n", "docstring": "Return data from the \"End of Central Directory\" record, or None."}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "    def _GenerateCRCTable():\n        \"\"\"Generate a CRC-32 table.\n        ZIP encryption uses the CRC32 one-byte primitive for scrambling some\n        internal keys. We noticed that a direct implementation is faster than\n        relying on binascii.crc32().\n        \"\"\"\n        poly = 0xedb88320\n        table = [0] * 256\n        for i in range(256):\n            crc = i\n            for j in range(8):\n                if crc & 1:\n                    crc = ((crc >> 1) & 0x7FFFFFFF) ^ poly\n                else:\n                    crc = ((crc >> 1) & 0x7FFFFFFF)\n            table[i] = crc\n        return table\n", "docstring": "Generate a CRC-32 table."}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "    def _crc32(self, ch, crc):\n        \"\"\"Compute the CRC32 primitive on one byte.\"\"\"\n        return ((crc >> 8) & 0xffffff) ^ self.crctable[(crc ^ ch) & 0xff]\n", "docstring": "Compute the CRC32 primitive on one byte.\n"}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "    def peek(self, n=1):\n        \"\"\"Returns buffered bytes without advancing the position.\"\"\"\n        if n > len(self._readbuffer) - self._offset:\n            chunk = self.read(n)\n            self._offset -= len(chunk)\n        # Return up to 512 bytes to reduce allocation overhead for tight loops.\n        return self._readbuffer[self._offset: self._offset + 512]\n", "docstring": "Returns buffered bytes without advancing the position.\n"}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "    def read(self, n=-1):\n        \"\"\"Read and return up to n bytes.\n        If the argument is omitted, None, or negative, data is read and returned until EOF is reached..\n        \"\"\"\n        buf = b''\n        if n is None:\n            n = -1\n        while True:\n            if n < 0:\n                data = self.read1(n)\n            elif n > len(buf):\n                data = self.read1(n - len(buf))\n            else:\n                return buf\n            if len(data) == 0:\n                return buf\n            buf += data\n", "docstring": "Read and return up to n bytes."}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "    def read1(self, n):\n        \"\"\"Read up to n bytes with at most one read() system call.\"\"\"\n        # Simplify algorithm (branching) by transforming negative n to large n.\n        if n < 0 or n is None:\n            n = self.MAX_N\n        # Bytes available in read buffer.\n        len_readbuffer = len(self._readbuffer) - self._offset\n        # Read from file.\n        if self._compress_left > 0 and n > len_readbuffer + len(self._unconsumed):\n            nbytes = n - len_readbuffer - len(self._unconsumed)\n            nbytes = max(nbytes, self.MIN_READ_SIZE)\n            nbytes = min(nbytes, self._compress_left)\n            data = self._fileobj.read(nbytes)\n            self._compress_left -= len(data)\n            if data and self._decrypter is not None:\n                data = b''.join(bytes(bytearray(map(self._decrypter, bytearray(data)))))\n            if self._compress_type == ZIP_STORED:\n                self._update_crc(data, eof=(self._compress_left==0))\n                self._readbuffer = self._readbuffer[self._offset:] + data\n                self._offset = 0\n            else:\n                # Prepare deflated bytes for decompression.\n                self._unconsumed += data\n        # Handle unconsumed data.\n        if (len(self._unconsumed) > 0 and n > len_readbuffer and\n            self._compress_type == ZIP_DEFLATED):\n            data = self._decompressor.decompress(\n                self._unconsumed,\n                max(n - len_readbuffer, self.MIN_READ_SIZE)\n            )\n            self._unconsumed = self._decompressor.unconsumed_tail\n            eof = len(self._unconsumed) == 0 and self._compress_left == 0\n            if eof:\n                data += self._decompressor.flush()\n            self._update_crc(data, eof=eof)\n            self._readbuffer = self._readbuffer[self._offset:] + data\n            self._offset = 0\n        # Read from buffer.\n        data = self._readbuffer[self._offset: self._offset + n]\n        self._offset += len(data)\n        return data\n", "docstring": "Read up to n bytes with at most one read() system call.\n"}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "    def __init__(self, file, mode=\"r\", compression=ZIP_DEFLATED, allowZip64=True):\n        \"\"\"Open the ZIP file with mode read \"r\", write \"w\" or append \"a\".\"\"\"\n        if mode not in (\"r\", \"w\", \"a\"):\n            raise RuntimeError('ZipFile() requires mode \"r\", \"w\", or \"a\" not %s'%mode)\n        if compression == ZIP_STORED:\n            pass\n        elif compression == ZIP_DEFLATED:\n            if not zlib:\n                raise RuntimeError(\n                      \"Compression requires the (missing) zlib module\")\n        else:\n            raise RuntimeError(\"The compression method %s is not supported\" % compression)\n        self._allowZip64 = allowZip64\n        self._didModify = False\n        self.debug = 0  # Level of printing: 0 through 3\n        self.NameToInfo = {}    # Find file info given name\n        self.filelist = []      # List of ZipInfo instances for archive\n        self.compression = compression  # Method of compression\n        self.mode = key = mode.replace('b', '')[0]\n        self.pwd = None\n        self.comment = b''\n        # Check if we were passed a file-like object\n        if isinstance(file, string_or_bytes):\n            self._filePassed = 0\n            self.filename = file\n            modeDict = {'r' : 'rb', 'w': 'wb', 'a' : 'r+b'}\n            try:\n                self.fp = open(file, modeDict[mode])\n            except IOError:\n                if mode == 'a':\n                    mode = key = 'w'\n                    self.fp = open(file, modeDict[mode])\n                else:\n                    raise\n        else:\n            self._filePassed = 1\n            self.fp = file\n            self.filename = getattr(file, 'name', None)\n        if key == 'r':\n            self._GetContents()\n        elif key == 'w':\n            # set the modified flag so central directory gets written\n            # even if no files are added to the archive\n            self._didModify = True\n        elif key == 'a':\n            try:\n                # See if file is a zip file\n                self._RealGetContents()\n                self._calculate_file_offsets()\n                # seek to start of directory and overwrite\n                self.fp.seek(self.start_dir, 0)\n            except BadZipfile:\n                # file is not a zip file, just append\n                self.fp.seek(0, 2)\n                # set the modified flag so central directory gets written\n                # even if no files are added to the archive\n                self._didModify = True\n        else:\n            if not self._filePassed:\n                self.fp.close()\n                self.fp = None\n            raise RuntimeError('Mode must be \"r\", \"w\" or \"a\"')\n", "docstring": "Open the ZIP file with mode read \"r\", write \"w\" or append \"a\".\n"}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "    def replace(self, filename, arcname=None, compress_type=None):\n        \"\"\"Delete arcname, and put the bytes from filename into the\n        archive under the name arcname.\"\"\"\n        deleteName = arcname\n        if deleteName is None:\n            deleteName = filename\n        self.delete(deleteName)\n        self.write(filename, arcname, compress_type)\n", "docstring": "Delete arcname, and put the bytes from filename into the"}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "    def delete(self, name):\n        \"\"\"Delete the file from the archive. If it appears multiple\n        times only the first instance will be deleted.\"\"\"\n        for i in range(0, len(self.filelist)):\n            if self.filelist[i].filename == name:\n                if self.debug:\n                    print(\"Removing\", name)\n                deleted_offset = self.filelist[i].header_offset\n                deleted_size   = (self.filelist[i].file_offset - self.filelist[i].header_offset) + self.filelist[i].compress_size\n                zinfo_size = struct.calcsize(structCentralDir) + len(self.filelist[i].filename) + len(self.filelist[i].extra)\n                # Remove the file's data from the archive.\n                current_offset = self.fp.tell()\n                self.fp.seek(0, 2)\n                archive_size = self.fp.tell()\n                self.fp.seek(deleted_offset + deleted_size)\n                buf = self.fp.read()\n                self.fp.seek(deleted_offset)\n                self.fp.write(buf)\n                self.fp.truncate(archive_size - deleted_size - zinfo_size)\n                if current_offset > deleted_offset + deleted_size:\n                    current_offset -= deleted_size\n                elif current_offset > deleted_offset:\n                    current_offset = deleted_offset\n                self.fp.seek(current_offset, 0)\n                # Remove file from central directory.\n                del self.filelist[i]\n                # Adjust the remaining offsets in the central directory.\n                for j in range(i, len(self.filelist)):\n                    if self.filelist[j].header_offset > deleted_offset:\n                        self.filelist[j].header_offset -= deleted_size\n                    if self.filelist[j].file_offset > deleted_offset:\n                        self.filelist[j].file_offset -= deleted_size\n                self._didModify = True\n                return\n        if self.debug:\n            print(name, \"not in archive\")\n", "docstring": "Delete the file from the archive. If it appears multiple"}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "    def infolist(self):\n        \"\"\"Return a list of class ZipInfo instances for files in the\n        archive.\"\"\"\n        return self.filelist\n", "docstring": "Return a list of class ZipInfo instances for files in the"}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "    def testzip(self):\n        \"\"\"Read all the files and check the CRC.\"\"\"\n        chunk_size = 2 ** 20\n        for zinfo in self.filelist:\n            try:\n                # Read by chunks, to avoid an OverflowError or a\n                # MemoryError with very large embedded files.\n                f = self.open(zinfo.filename, \"r\")\n                while f.read(chunk_size):     # Check CRC-32\n                    pass\n            except BadZipfile:\n                return zinfo.filename\n", "docstring": "Read all the files and check the CRC.\n"}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "    def setpassword(self, pwd):\n        \"\"\"Set default password for encrypted files.\"\"\"\n        self.pwd = pwd\n", "docstring": "Set default password for encrypted files.\n"}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "    def read_raw(self, name, mode=\"r\", pwd=None):\n        \"\"\"Return the raw bytes in the zipfile corresponding to name.\"\"\"\n        zef = self.open(name, mode=mode, pwd=pwd)\n        return zef.read_raw()\n", "docstring": "Return the raw bytes in the zipfile corresponding to name.\n"}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "    def extract(self, member, path=None, pwd=None):\n        \"\"\"Extract a member from the archive to the current working directory,\n           using its full name. Its file information is extracted as accurately\n           as possible. `member' may be a filename or a ZipInfo object. You can\n           specify a different directory using `path'.\n        \"\"\"\n        if not isinstance(member, ZipInfo):\n            member = self.getinfo(member)\n        if path is None:\n            path = getcwd()\n        return self._extract_member(member, path, pwd)\n", "docstring": "Extract a member from the archive to the current working directory,"}
{"repo": "calibre-master/src/calibre/utils/zipfile.py", "original_string": "    def rbytes(name):\n        r = replacements[name]\n        if not isinstance(r, bytes):\n            r = r.read()\n        return r\n", "docstring": "r = replacements[name]"}
{"repo": "calibre-master/src/calibre/utils/__init__.py", "original_string": "def join_with_timeout(q, timeout=2):\n    ''' Join the queue q with a specified timeout. Blocks until all tasks on\n    the queue are done or times out with a runtime error. '''\n    q.all_tasks_done.acquire()\n    try:\n        endtime = time() + timeout\n        while q.unfinished_tasks:\n            remaining = endtime - time()\n            if remaining <= 0.0:\n                raise RuntimeError('Waiting for queue to clear timed out')\n            q.all_tasks_done.wait(remaining)\n    finally:\n        q.all_tasks_done.release()\n", "docstring": "Join the queue q with a specified timeout. Blocks until all tasks on"}
{"repo": "calibre-master/src/calibre/utils/icu.py", "original_string": "def normalize(text, mode='NFC'):\n    # This is very slightly slower than using unicodedata.normalize, so stick with\n    # that unless you have very good reasons not too. Also, it's speed\n    # decreases on wide python builds, where conversion to/from ICU's string\n    # representation is slower.\n    return _icu.normalize(_nmodes[mode], unicode_type(text))\n", "docstring": "This is very slightly slower than using unicodedata.normalize, so stick with"}
{"repo": "calibre-master/src/calibre/utils/icu.py", "original_string": "def partition_by_first_letter(items, reverse=False, key=lambda x:x):\n    # Build a list of 'equal' first letters by noticing changes\n    # in ICU's 'ordinal' for the first letter.\n    from collections import OrderedDict\n    items = sorted(items, key=lambda x:sort_key(key(x)), reverse=reverse)\n    ans = OrderedDict()\n    last_c, last_ordnum = ' ', 0\n    for item in items:\n        c = icu_upper(key(item) or ' ')\n        ordnum, ordlen = collation_order(c)\n        if last_ordnum != ordnum:\n            last_c = c[0:1]\n            last_ordnum = ordnum\n        try:\n            ans[last_c].append(item)\n        except KeyError:\n            ans[last_c] = [item]\n    return ans\n", "docstring": "Build a list of 'equal' first letters by noticing changes"}
{"repo": "calibre-master/src/calibre/utils/threadpool.py", "original_string": "    def __init__(self, requestsQueue, resultsQueue, **kwds):\n        \"\"\"Set up thread in daemonic mode and start it immediatedly.\n        requestsQueue and resultQueue are instances of queue.Queue passed\n        by the ThreadPool class when it creates a new worker thread.\n        \"\"\"\n        threading.Thread.__init__(self, **kwds)\n        self.setDaemon(1)\n        self.workRequestQueue = requestsQueue\n        self.resultQueue = resultsQueue\n        self._dismissed = threading.Event()\n        self.start()\n", "docstring": "Set up thread in daemonic mode and start it immediatedly."}
{"repo": "calibre-master/src/calibre/utils/threadpool.py", "original_string": "    def dismiss(self):\n        \"\"\"Sets a flag to tell the thread to exit when done with current job.\n        \"\"\"\n        self._dismissed.set()\n", "docstring": "Sets a flag to tell the thread to exit when done with current job."}
{"repo": "calibre-master/src/calibre/utils/threadpool.py", "original_string": "    def __init__(self, num_workers, q_size=0):\n        \"\"\"Set up the thread pool and start num_workers worker threads.\n        num_workers is the number of worker threads to start initialy.\n        If q_size > 0 the size of the work request queue is limited and\n        the thread pool blocks when the queue is full and it tries to put\n        more work requests in it (see putRequest method).\n        \"\"\"\n        self.requestsQueue = queue.Queue(q_size)\n        self.resultsQueue = queue.Queue()\n        self.workers = []\n        self.workRequests = {}\n        self.createWorkers(num_workers)\n", "docstring": "Set up the thread pool and start num_workers worker threads."}
{"repo": "calibre-master/src/calibre/utils/threadpool.py", "original_string": "    def dismissWorkers(self, num_workers):\n        \"\"\"Tell num_workers worker threads to quit after their current task.\n        \"\"\"\n        for i in range(min(num_workers, len(self.workers))):\n            worker = self.workers.pop()\n            worker.dismiss()\n", "docstring": "Tell num_workers worker threads to quit after their current task."}
{"repo": "calibre-master/src/calibre/utils/threadpool.py", "original_string": "    def poll(self, block=False):\n        \"\"\"Process any new results in the queue.\"\"\"\n        while True:\n            # still results pending?\n            if not self.workRequests:\n                raise NoResultsPending\n            # are there still workers to process remaining requests?\n            elif block and not self.workers:\n                raise NoWorkersAvailable\n            try:\n                # get back next results\n                request, result = self.resultsQueue.get(block=block)\n                # has an exception occured?\n                if request.exception and request.exc_callback:\n                    request.exc_callback(request, result)\n                # hand results to callback, if any\n                if request.callback and not \\\n                  (request.exception and request.exc_callback):\n                    request.callback(request, result)\n                del self.workRequests[request.requestID]\n            except queue.Empty:\n                break\n", "docstring": "Process any new results in the queue.\n"}
{"repo": "calibre-master/src/calibre/utils/threadpool.py", "original_string": "def makeRequests(callable, args_list, callback=None, exc_callback=None):\n    \"\"\"Create several work requests for same callable with different arguments.\n    Convenience function for creating several work requests for the same\n    callable where each invocation of the callable receives different values\n    for its arguments.\n    args_list contains the parameters for each invocation of callable.\n    Each item in 'args_list' should be either a 2-item tuple of the list of\n    positional arguments and a dictionary of keyword arguments or a single,\n    non-tuple argument.\n    See docstring for WorkRequest for info on callback and exc_callback.\n    \"\"\"\n    requests = []\n    for item in args_list:\n        if isinstance(item, tuple):\n            requests.append(\n              WorkRequest(callable, item[0], item[1], callback=callback,\n                exc_callback=exc_callback)\n            )\n        else:\n            requests.append(\n              WorkRequest(callable, [item], None, callback=callback,\n                exc_callback=exc_callback)\n            )\n    return requests\n", "docstring": "Create several work requests for same callable with different arguments."}
{"repo": "calibre-master/src/calibre/utils/wordcount.py", "original_string": "def is_asian(char):\n    \"\"\"Is the character Asian?\"\"\"\n    # 0x3000 is ideographic space (i.e. double-byte space)\n    # Anything over is an Asian character\n    return ord(char) > IDEOGRAPHIC_SPACE\n", "docstring": "Is the character Asian?\n"}
{"repo": "calibre-master/src/calibre/utils/wordcount.py", "original_string": "def nonj_len(word):\n    \"\"\"Returns number of non-Asian words in {word}\n    - 日本語AアジアンB -> 2\n    - hello -> 1\n    @param word: A word, possibly containing Asian characters\n    \"\"\"\n    # Here are the steps:\n    # 本spam日eggs\n    # -> [' ', 's', 'p', 'a', 'm', ' ', 'e', 'g', 'g', 's']\n    # -> ' spam eggs'\n    # -> ['spam', 'eggs']\n    # The length of which is 2!\n    chars = [filter_jchars(c) for c in word]\n    return len(''.join(chars).split())\n", "docstring": "Returns number of non-Asian words in {word}"}
{"repo": "calibre-master/src/calibre/utils/wordcount.py", "original_string": "def dict2obj(dictionary):\n    \"\"\"Transform a dictionary into an object\"\"\"\n    class Obj(object):\n        def __init__(self, dictionary):\n            self.__dict__.update(dictionary)\n    return Obj(dictionary)\n", "docstring": "Transform a dictionary into an object\n"}
{"repo": "calibre-master/src/calibre/utils/iphlpapi.py", "original_string": "def adapters():\n    ''' A list of adapters on this machine '''\n    ans = []\n    smap = {1:'up', 2:'down', 3:'testing', 4:'unknown', 5:'dormant', 6:'not-present', 7:'lower-layer-down'}\n    with _get_adapters() as p_adapters_list:\n        adapter = p_adapters_list\n        while adapter:\n            adapter = adapter.contents\n            if not adapter:\n                break\n            ans.append(Adapter(\n                name=adapter.AdapterName.decode(),\n                if_index=adapter.Union1.Struct1.IfIndex,\n                if_index6=adapter.Ipv6IfIndex,\n                friendly_name=adapter.FriendlyName,\n                status=smap.get(adapter.OperStatus, 'unknown'),\n                transmit_speed=adapter.TransmitLinkSpeed,\n                receive_speed=adapter.ReceiveLinkSpeed\n            ))\n            adapter = ctypes.cast(adapter.Next, ctypes.POINTER(IP_ADAPTER_ADDRESSES))\n    return ans\n", "docstring": "A list of adapters on this machine '''"}
{"repo": "calibre-master/src/calibre/utils/iphlpapi.py", "original_string": "def routes():\n    ''' A list of routes on this machine '''\n    ans = []\n    adapter_map = {a.if_index:a.name for a in adapters()}\n    with _get_forward_table() as p_forward_table:\n        if p_forward_table is None:\n            return ans\n        forward_table = p_forward_table.contents\n        table = ctypes.cast(\n            ctypes.addressof(forward_table.table),\n            ctypes.POINTER(Win32_MIB_IPFORWARDROW * forward_table.dwNumEntries)\n        ).contents\n        for row in table:\n            destination = Ws2_32.inet_ntoa(row.dwForwardDest).decode()\n            netmask = Ws2_32.inet_ntoa(row.dwForwardMask).decode()\n            gateway = Ws2_32.inet_ntoa(row.dwForwardNextHop).decode()\n            ans.append(Route(\n                destination=destination,\n                gateway=gateway,\n                netmask=netmask,\n                interface=adapter_map.get(row.dwForwardIfIndex),\n                metric=row.dwForwardMetric1,\n                flags=row.dwForwardProto\n            ))\n    return ans\n", "docstring": "A list of routes on this machine '''"}
{"repo": "calibre-master/src/calibre/utils/inotify.py", "original_string": "def load_inotify():  # {{{\n    ''' Initialize the inotify ctypes wrapper '''\n    global _inotify\n    if _inotify is None:\n        if hasattr(sys, 'getwindowsversion'):\n            # On windows abort before loading the C library. Windows has\n            # multiple, incompatible C runtimes, and we have no way of knowing\n            # if the one chosen by ctypes is compatible with the currently\n            # loaded one.\n            raise INotifyError('INotify not available on windows')\n        if sys.platform == 'darwin':\n            raise INotifyError('INotify not available on OS X')\n        import ctypes\n        if not hasattr(ctypes, 'c_ssize_t'):\n            raise INotifyError('You need python >= 2.7 to use inotify')\n        libc = ctypes.CDLL(None, use_errno=True)\n        for function in (\"inotify_add_watch\", \"inotify_init1\", \"inotify_rm_watch\"):\n            if not hasattr(libc, function):\n                raise INotifyError('libc is too old')\n        # inotify_init1()\n        prototype = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, use_errno=True)\n        init1 = prototype(('inotify_init1', libc), ((1, \"flags\", 0),))\n        # inotify_add_watch()\n        prototype = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_char_p, ctypes.c_uint32, use_errno=True)\n        add_watch = prototype(('inotify_add_watch', libc), (\n            (1, \"fd\"), (1, \"pathname\"), (1, \"mask\")), use_errno=True)\n        # inotify_rm_watch()\n        prototype = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_int, use_errno=True)\n        rm_watch = prototype(('inotify_rm_watch', libc), (\n            (1, \"fd\"), (1, \"wd\")), use_errno=True)\n        # read()\n        prototype = ctypes.CFUNCTYPE(ctypes.c_ssize_t, ctypes.c_int, ctypes.c_void_p, ctypes.c_size_t, use_errno=True)\n        read = prototype(('read', libc), (\n            (1, \"fd\"), (1, \"buf\"), (1, \"count\")), use_errno=True)\n        _inotify = (init1, add_watch, rm_watch, read)\n    return _inotify\n", "docstring": "Initialize the inotify ctypes wrapper '''"}
{"repo": "calibre-master/src/calibre/utils/inotify.py", "original_string": "    def __del__(self):\n        # This method can be called during interpreter shutdown, which means we\n        # must do the absolute minimum here. Note that there could be running\n        # daemon threads that are trying to call other methods on this object.\n        try:\n            self.os.close(self._inotify_fd)\n        except (AttributeError, TypeError):\n            pass\n", "docstring": "This method can be called during interpreter shutdown, which means we"}
{"repo": "calibre-master/src/calibre/utils/inotify.py", "original_string": "    def add_watches(self, base, top_level=True):\n        ''' Add watches for this directory and all its descendant directories,\n        recursively. '''\n        base = realpath(base)\n        # There may exist a link which leads to an endless\n        # add_watches loop or to maximum recursion depth exceeded\n        if not top_level and base in self.watched_dirs:\n            return\n        try:\n            is_dir = self.add_watch(base)\n        except OSError as e:\n            if e.errno == errno.ENOENT:\n                # The entry could have been deleted between listdir() and\n                # add_watch().\n                if top_level:\n                    raise NoSuchDir('The dir {0} does not exist'.format(base))\n                return\n            if e.errno == errno.EACCES:\n                # We silently ignore entries for which we dont have permission,\n                # unless they are the top level dir\n                if top_level:\n                    raise NoSuchDir('You do not have permission to monitor {0}'.format(base))\n                return\n            raise\n        else:\n            if is_dir:\n                try:\n                    files = os.listdir(base)\n                except OSError as e:\n                    if e.errno in (errno.ENOTDIR, errno.ENOENT):\n                        # The dir was deleted/replaced between the add_watch()\n                        # and listdir()\n                        if top_level:\n                            raise NoSuchDir('The dir {0} does not exist'.format(base))\n                        return\n                    raise\n                for x in files:\n                    self.add_watches(os.path.join(base, x), top_level=False)\n            elif top_level:\n                # The top level dir is a file, not good.\n                raise NoSuchDir('The dir {0} does not exist'.format(base))\n", "docstring": "Add watches for this directory and all its descendant directories,"}
{"repo": "calibre-master/src/calibre/utils/ipc/server.py", "original_string": "    def __enter__(self):\n        return self\n", "docstring": "return self"}
{"repo": "calibre-master/src/calibre/utils/ipc/pool.py", "original_string": "    def shutdown(self, wait_time=0.1):\n        ''' Shutdown this pool, terminating all worker process. The pool cannot\n        be used after a shutdown. '''\n        self.shutting_down = True\n        self.events.put(None)\n        self.shutdown_workers(wait_time=wait_time)\n", "docstring": "Shutdown this pool, terminating all worker process. The pool cannot"}
{"repo": "calibre-master/src/calibre/utils/fonts/utils.py", "original_string": "def get_font_names(raw, raw_is_table=False):\n    records = _get_font_names(raw, raw_is_table)\n    family_name = decode_name_record(records[1])\n    subfamily_name = decode_name_record(records[2])\n    full_name = decode_name_record(records[4])\n    return family_name, subfamily_name, full_name\n", "docstring": "records = _get_font_names(raw, raw_is_table)"}
{"repo": "calibre-master/src/calibre/utils/fonts/utils.py", "original_string": "def is_font_embeddable(raw):\n    # https://www.microsoft.com/typography/otspec/os2.htm#fst\n    ok, sig = is_truetype_font(raw)\n    if not ok:\n        raise UnsupportedFont('Not a supported font, sfnt_version: %r'%sig)\n    table, table_index, table_offset = get_table(raw, 'os/2')[:3]\n    if table is None:\n        raise UnsupportedFont('Not a supported font, has no OS/2 table')\n    fs_type_offset = struct.calcsize(b'>HhHH')\n    fs_type = struct.unpack_from(b'>H', table, fs_type_offset)[0]\n    if fs_type == 0 or fs_type & 0x8:\n        return True, fs_type\n    if fs_type & 1:\n        return False, fs_type\n    if fs_type & 0x200:\n        return False, fs_type\n    return True, fs_type\n", "docstring": "https://www.microsoft.com/typography/otspec/os2.htm#fst"}
{"repo": "calibre-master/src/calibre/utils/fonts/scanner.py", "original_string": "def build_families(cached_fonts, folders, family_attr='font-family'):\n    families = defaultdict(list)\n    for f in itervalues(cached_fonts):\n        if not f:\n            continue\n        lf = icu_lower(f.get(family_attr) or '')\n        if lf:\n            families[lf].append(f)\n    for fonts in itervalues(families):\n        # Look for duplicate font files and choose the copy that is from a\n        # more significant font directory (prefer user directories over\n        # system directories).\n        fmap = {}\n        remove = []\n        for f in fonts:\n            fingerprint = (icu_lower(f['font-family']), f['font-weight'],\n                    f['font-stretch'], f['font-style'])\n            if fingerprint in fmap:\n                opath = fmap[fingerprint]['path']\n                npath = f['path']\n                if path_significance(npath, folders) >= path_significance(opath, folders):\n                    remove.append(fmap[fingerprint])\n                    fmap[fingerprint] = f\n                else:\n                    remove.append(f)\n            else:\n                fmap[fingerprint] = f\n        for font in remove:\n            fonts.remove(font)\n        fonts.sort(key=font_priority)\n    font_family_map = dict.copy(families)\n    font_families = tuple(sorted((f[0]['font-family'] for f in\n            itervalues(font_family_map)), key=sort_key))\n    return font_family_map, font_families\n", "docstring": "families = defaultdict(list)"}
{"repo": "calibre-master/src/calibre/utils/fonts/scanner.py", "original_string": "    def find_font_for_text(self, text, allowed_families={'serif', 'sans-serif'},\n            preferred_families=('serif', 'sans-serif', 'monospace', 'cursive', 'fantasy')):\n        '''\n        Find a font on the system capable of rendering the given text.\n        Returns a font family (as given by fonts_for_family()) that has a\n        \"normal\" font and that can render the supplied text. If no such font\n        exists, returns None.\n        :return: (family name, faces) or None, None\n        '''\n        from calibre.utils.fonts.utils import (supports_text,\n                panose_to_css_generic_family, get_printable_characters)\n        if not isinstance(text, unicode_type):\n            raise TypeError(u'%r is not unicode'%text)\n        text = get_printable_characters(text)\n        found = {}\n        def filter_faces(font):\n            try:\n                raw = self.get_font_data(font)\n                return supports_text(raw, text)\n            except:\n                pass\n            return False\n        for family in self.find_font_families():\n            faces = list(filter(filter_faces, self.fonts_for_family(family)))\n            if not faces:\n                continue\n            generic_family = panose_to_css_generic_family(faces[0]['panose'])\n            if generic_family in allowed_families or generic_family == preferred_families[0]:\n                return (family, faces)\n            elif generic_family not in found:\n                found[generic_family] = (family, faces)\n        for f in preferred_families:\n            if f in found:\n                return found[f]\n        return None, None\n", "docstring": "preferred_families=('serif', 'sans-serif', 'monospace', 'cursive', 'fantasy')):"}
{"repo": "calibre-master/src/calibre/utils/fonts/scanner.py", "original_string": "    def reload_cache(self):\n        if not hasattr(self, 'cache'):\n            from calibre.utils.config import JSONConfig\n            self.cache = JSONConfig('fonts/scanner_cache')\n        else:\n            self.cache.refresh()\n        if self.cache.get('version', None) != self.CACHE_VERSION:\n            self.cache.clear()\n        self.cached_fonts = self.cache.get('fonts', {})\n", "docstring": "if not hasattr(self, 'cache'):"}
{"repo": "calibre-master/src/calibre/utils/fonts/free_type.py", "original_string": "    def glyph_ids(self, text):\n        if not isinstance(text, unicode_type):\n            raise TypeError('%r is not a unicode object'%text)\n        for char in text:\n            yield self.face.glyph_id(ord(char))\n", "docstring": "if not isinstance(text, unicode_type):"}
{"repo": "calibre-master/src/calibre/utils/fonts/win_fonts.py", "original_string": "def load_winfonts():\n    from calibre_extensions import winfonts\n    return WinFonts(winfonts)\n", "docstring": "from calibre_extensions import winfonts"}
{"repo": "calibre-master/src/calibre/utils/fonts/sfnt/metrics.py", "original_string": "    def width(self, string, pixel_size=12.0, stretch=1.0):\n        'The width of the string at the specified pixel size and stretch, in pixels'\n        return sum(self.advance_widths(string, pixel_size, stretch))\n", "docstring": "'The width of the string at the specified pixel size and stretch, in pixels'"}
{"repo": "calibre-master/src/calibre/utils/fonts/sfnt/cmap.py", "original_string": "def split_range(start_code, end_code, cmap):  # {{{\n    # Try to split a range of character codes into subranges with consecutive\n    # glyph IDs in such a way that the cmap4 subtable can be stored \"most\"\n    # efficiently.\n    if start_code == end_code:\n        return [], [end_code]\n    last_id = cmap[start_code]\n    last_code = start_code\n    in_order = None\n    ordered_begin = None\n    sub_ranges = []\n    # Gather subranges in which the glyph IDs are consecutive.\n    for code in range(start_code + 1, end_code + 1):\n        glyph_id = cmap[code]\n        if glyph_id - 1 == last_id:\n            if in_order is None or not in_order:\n                in_order = 1\n                ordered_begin = last_code\n        else:\n            if in_order:\n                in_order = 0\n                sub_ranges.append((ordered_begin, last_code))\n                ordered_begin = None\n        last_id = glyph_id\n        last_code = code\n    if in_order:\n        sub_ranges.append((ordered_begin, last_code))\n    assert last_code == end_code\n    # Now filter out those new subranges that would only make the data bigger.\n    # A new segment cost 8 bytes, not using a new segment costs 2 bytes per\n    # character.\n    new_ranges = []\n    for b, e in sub_ranges:\n        if b == start_code and e == end_code:\n            break  # the whole range, we're fine\n        if b == start_code or e == end_code:\n            threshold = 4  # split costs one more segment\n        else:\n            threshold = 8  # split costs two more segments\n        if (e - b + 1) > threshold:\n            new_ranges.append((b, e))\n    sub_ranges = new_ranges\n    if not sub_ranges:\n        return [], [end_code]\n    if sub_ranges[0][0] != start_code:\n        sub_ranges.insert(0, (start_code, sub_ranges[0][0] - 1))\n    if sub_ranges[-1][1] != end_code:\n        sub_ranges.append((sub_ranges[-1][1] + 1, end_code))\n    # Fill the \"holes\" in the segments list -- those are the segments in which\n    # the glyph IDs are _not_ consecutive.\n    i = 1\n    while i < len(sub_ranges):\n        if sub_ranges[i-1][1] + 1 != sub_ranges[i][0]:\n            sub_ranges.insert(i, (sub_ranges[i-1][1] + 1, sub_ranges[i][0] - 1))\n            i = i + 1\n        i = i + 1\n    # Transform the ranges into start_code/end_code lists.\n    start = []\n    end = []\n    for b, e in sub_ranges:\n        start.append(b)\n        end.append(e)\n    start.pop(0)\n    assert len(start) + 1 == len(end)\n    return start, end\n", "docstring": "Try to split a range of character codes into subranges with consecutive"}
{"repo": "calibre-master/src/calibre/utils/fonts/sfnt/cmap.py", "original_string": "def set_id_delta(id_delta):  # {{{\n    # The lowest gid in glyphIndexArray, after subtracting id_delta, must be 1.\n    # id_delta is a short, and must be between -32K and 32K\n    # startCode can be between 0 and 64K-1, and the first glyph index can be between 1 and 64K-1\n    # This means that we have a problem because we can need to assign to\n    # id_delta values\n    # between -(64K-2) and 64K -1.\n    # Since the final gi is reconstructed from the glyphArray GID by:\n    #    (short)finalGID = (gid +  id_delta) % 0x10000),\n    # we can get from a startCode of 0 to a final GID of 64 -1K by subtracting 1, and casting the\n    # negative number to an unsigned short.\n    # Similarly , we can get from a startCode of 64K-1 to a final GID of 1 by adding 2, because of\n    # the modulo arithmetic.\n    if id_delta > 0x7FFF:\n        id_delta = id_delta - 0x10000\n    elif id_delta <  -0x7FFF:\n        id_delta = id_delta + 0x10000\n    return id_delta\n", "docstring": "The lowest gid in glyphIndexArray, after subtracting id_delta, must be 1."}
{"repo": "calibre-master/src/calibre/utils/fonts/sfnt/container.py", "original_string": "    def __iter__(self):\n        '''Iterate over the table tags in order.'''\n        for x in sorted(self.tables):\n            yield x\n        # Although the optimal order is not alphabetical, the OTF spec says\n        # they should be alphabetical, so we stick with that. See\n        # http://partners.adobe.com/public/developer/opentype/index_recs.html\n        # for optimal order.\n        # keys = list(self.tables)\n        # order = {x:i for i, x in enumerate((b'head', b'hhea', b'maxp', b'OS/2',\n        #     b'hmtx', b'LTSH', b'VDMX', b'hdmx', b'cmap', b'fpgm', b'prep',\n        #     b'cvt ', b'loca', b'glyf', b'CFF ', b'kern', b'name', b'post',\n        #     b'gasp', b'PCLT', b'DSIG'))}\n        # keys.sort(key=lambda x:order.get(x, 1000))\n        # for x in keys:\n        #     yield x\n", "docstring": "Iterate over the table tags in order.'''"}
{"repo": "calibre-master/src/calibre/utils/fonts/sfnt/gsub.py", "original_string": "    def all_substitutions(self, glyph_ids):\n        # This table only defined substitution in terms of other tables\n        return set()\n", "docstring": "This table only defined substitution in terms of other tables"}
{"repo": "calibre-master/src/calibre/utils/fonts/sfnt/gsub.py", "original_string": "    def all_substitutions(self, glyph_ids):\n        # This table only defined substitution in terms of other tables\n        return set()\n", "docstring": "This table only defined substitution in terms of other tables"}
{"repo": "calibre-master/src/calibre/utils/fonts/sfnt/__init__.py", "original_string": "    def __init__(self, raw):\n        self.raw = raw\n", "docstring": "self.raw = raw"}
{"repo": "calibre-master/src/calibre/utils/winreg/default_programs.py", "original_string": "    def __exit__(self, *args):\n        # Give the thread some time to finish in case the user quit the\n        # application very quickly\n        self.join(4.0)\n", "docstring": "Give the thread some time to finish in case the user quit the"}
{"repo": "calibre-master/src/calibre/utils/winreg/lib.py", "original_string": "    def set(self, name=None, value=None, sub_key=None, has_expansions=False):\n        ''' Set a value for this key (with optional sub-key). If name is None,\n        the Default value is set. value can be an integer, a string, bytes or a list\n        of strings. If you want to use expansions, set has_expansions=True. '''\n        value, dtype, size = convert_to_registry_data(value, has_expansions=has_expansions)\n        RegSetKeyValue(self.hkey, sub_key, name, dtype, value, size)\n", "docstring": "Set a value for this key (with optional sub-key). If name is None,"}
{"repo": "calibre-master/src/calibre/db/legacy.py", "original_string": "    def add_format_with_hooks(self, index, fmt, fpath, index_is_id=False, path=None, notify=True, replace=True):\n        ''' path is ignored by the new API '''\n        book_id = index if index_is_id else self.id(index)\n        ret = self.new_api.add_format(book_id, fmt, fpath, replace=replace, run_hooks=True, dbapi=self)\n        self.notify('metadata', [book_id])\n        return ret\n", "docstring": "path is ignored by the new API '''"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def safe_read_lock(self):\n        ''' A safe read lock is a lock that does nothing if the thread already\n        has a write lock, otherwise it acquires a read lock. This is necessary\n        to prevent DowngradeLockErrors, which can happen when updating the\n        search cache in the presence of composite columns. Updating the search\n        cache holds an exclusive lock, but searching a composite column\n        involves reading field values via ProxyMetadata which tries to get a\n        shared lock. There may be other scenarios that trigger this as well.\n        This property returns a new lock object on every access. This lock\n        object is not recursive (for performance) and must only be used in a\n        with statement as ``with cache.safe_read_lock:`` otherwise bad things\n        will happen.'''\n        return SafeReadLock(self.read_lock)\n", "docstring": "A safe read lock is a lock that does nothing if the thread already"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def fast_field_for(self, field_obj, book_id, default_value=None):\n        ' Same as field_for, except that it avoids the extra lookup to get the field object '\n        if field_obj.is_composite:\n            return field_obj.get_value_with_cache(book_id, self._get_proxy_metadata)\n        if field_obj.is_multiple:\n            default_value = field_obj.default_value\n        try:\n            return field_obj.for_book(book_id, default_value=default_value)\n        except (KeyError, IndexError):\n            return default_value\n", "docstring": "' Same as field_for, except that it avoids the extra lookup to get the field object '"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def all_field_names(self, field):\n        ''' Frozen set of all fields names (should only be used for many-one and many-many fields) '''\n        if field == 'formats':\n            return frozenset(self.fields[field].table.col_book_map)\n        try:\n            return frozenset(self.fields[field].table.id_map.values())\n        except AttributeError:\n            raise ValueError('%s is not a many-one or many-many field' % field)\n", "docstring": "Frozen set of all fields names (should only be used for many-one and many-many fields) '''"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def get_usage_count_by_id(self, field):\n        ''' Return a mapping of id to usage count for all values of the specified\n        field, which must be a many-one or many-many field. '''\n        try:\n            return {k:len(v) for k, v in iteritems(self.fields[field].table.col_book_map)}\n        except AttributeError:\n            raise ValueError('%s is not a many-one or many-many field' % field)\n", "docstring": "Return a mapping of id to usage count for all values of the specified"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def get_id_map(self, field):\n        ''' Return a mapping of id numbers to values for the specified field.\n        The field must be a many-one or many-many field, otherwise a ValueError\n        is raised. '''\n        try:\n            return self.fields[field].table.id_map.copy()\n        except AttributeError:\n            if field == 'title':\n                return self.fields[field].table.book_col_map.copy()\n            raise ValueError('%s is not a many-one or many-many field' % field)\n", "docstring": "Return a mapping of id numbers to values for the specified field."}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def get_item_name(self, field, item_id):\n        ''' Return the item name for the item specified by item_id in the\n        specified field. See also :meth:`get_id_map`.'''\n        return self.fields[field].table.id_map[item_id]\n", "docstring": "Return the item name for the item specified by item_id in the"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def get_item_id(self, field, item_name):\n        ' Return the item id for item_name (case-insensitive) '\n        rmap = {icu_lower(v) if isinstance(v, unicode_type) else v:k for k, v in iteritems(self.fields[field].table.id_map)}\n        return rmap.get(icu_lower(item_name) if isinstance(item_name, unicode_type) else item_name, None)\n", "docstring": "' Return the item id for item_name (case-insensitive) '"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def format_hash(self, book_id, fmt):\n        ''' Return the hash of the specified format for the specified book. The\n        kind of hash is backend dependent, but is usually SHA-256. '''\n        try:\n            name = self.fields['formats'].format_fname(book_id, fmt)\n            path = self._field_for('path', book_id).replace('/', os.sep)\n        except:\n            raise NoSuchFormat('Record %d has no fmt: %s'%(book_id, fmt))\n        return self.backend.format_hash(book_id, fmt, name, path)\n", "docstring": "Return the hash of the specified format for the specified book. The"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def format_files(self, book_id):\n        field = self.fields['formats']\n        fmts = field.table.book_col_map.get(book_id, ())\n        return {fmt:field.format_fname(book_id, fmt) for fmt in fmts}\n", "docstring": "field = self.fields['formats']"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def get_proxy_metadata(self, book_id):\n        ''' Like :meth:`get_metadata` except that it returns a ProxyMetadata\n        object that only reads values from the database on demand. This is much\n        faster than get_metadata when only a small number of fields need to be\n        accessed from the returned metadata object. '''\n        return ProxyMetadata(self, book_id)\n", "docstring": "Like :meth:`get_metadata` except that it returns a ProxyMetadata"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def has_format(self, book_id, fmt):\n        'Return True iff the format exists on disk'\n        fmt = (fmt or '').upper()\n        try:\n            name = self.fields['formats'].format_fname(book_id, fmt)\n            path = self._field_for('path', book_id).replace('/', os.sep)\n        except:\n            return False\n        return self.backend.has_format(book_id, fmt, name, path)\n", "docstring": "'Return True iff the format exists on disk'"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def restore_original_format(self, book_id, original_fmt):\n        ''' Restore the specified format from the previously saved\n        ORIGINAL_FORMAT, if any. Return True on success. The ORIGINAL_FORMAT is\n        deleted after a successful restore. '''\n        original_fmt = original_fmt.upper()\n        fmt = original_fmt.partition('_')[2]\n        try:\n            ofmt_name = self.fields['formats'].format_fname(book_id, original_fmt)\n            path = self._field_for('path', book_id).replace('/', os.sep)\n        except Exception:\n            return False\n        if self.backend.is_format_accessible(book_id, original_fmt, ofmt_name, path):\n            self.add_format(book_id, fmt, BytesIO(), run_hooks=False)\n            fmt_name = self.fields['formats'].format_fname(book_id, fmt)\n            file_size = self.backend.rename_format_file(book_id, ofmt_name, original_fmt, fmt_name, fmt, path)\n            self.fields['formats'].table.update_fmt(book_id, fmt, fmt_name, file_size, self.backend)\n            self._remove_formats({book_id:(original_fmt,)})\n            return True\n        return False\n", "docstring": "Restore the specified format from the previously saved"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def books_in_virtual_library(self, vl, search_restriction=None, virtual_fields=None):\n        ' Return the set of books in the specified virtual library '\n        vl = self._pref('virtual_libraries', {}).get(vl) if vl else None\n        if not vl and not search_restriction:\n            return self.all_book_ids()\n        # We utilize the search restriction cache to speed this up\n        srch = partial(self._search, virtual_fields=virtual_fields)\n        if vl:\n            if search_restriction:\n                return frozenset(srch('', vl) & srch('', search_restriction))\n            return frozenset(srch('', vl))\n        return frozenset(srch('', search_restriction))\n", "docstring": "' Return the set of books in the specified virtual library '"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def update_path(self, book_ids, mark_as_dirtied=True):\n        for book_id in book_ids:\n            title = self._field_for('title', book_id, default_value=_('Unknown'))\n            try:\n                author = self._field_for('authors', book_id, default_value=(_('Unknown'),))[0]\n            except IndexError:\n                author = _('Unknown')\n            self.backend.update_path(book_id, title, author, self.fields['path'], self.fields['formats'])\n            self.format_metadata_cache.pop(book_id, None)\n            if mark_as_dirtied:\n                self._mark_as_dirty(book_ids)\n", "docstring": "for book_id in book_ids:"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def clear_dirtied(self, book_id, sequence):\n        # Clear the dirtied indicator for the books. This is used when fetching\n        # metadata, creating an OPF, and writing a file are separated into steps.\n        # The last step is clearing the indicator\n        dc_sequence = self.dirtied_cache.get(book_id, None)\n        if dc_sequence is None or sequence is None or dc_sequence == sequence:\n            self.backend.mark_book_as_clean(book_id)\n            self.dirtied_cache.pop(book_id, None)\n", "docstring": "Clear the dirtied indicator for the books. This is used when fetching"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def read_backup(self, book_id):\n        ''' Return the OPF metadata backup for the book as a bytestring or None\n        if no such backup exists.  '''\n        try:\n            path = self._field_for('path', book_id).replace('/', os.sep)\n        except:\n            return\n        try:\n            return self.backend.read_backup(path)\n        except EnvironmentError:\n            return None\n", "docstring": "Return the OPF metadata backup for the book as a bytestring or None"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def set_cover(self, book_id_data_map):\n        ''' Set the cover for this book.  data can be either a QImage,\n        QPixmap, file object or bytestring. It can also be None, in which\n        case any existing cover is removed. '''\n        for book_id, data in iteritems(book_id_data_map):\n            try:\n                path = self._field_for('path', book_id).replace('/', os.sep)\n            except AttributeError:\n                self._update_path((book_id,))\n                path = self._field_for('path', book_id).replace('/', os.sep)\n            self.backend.set_cover(book_id, path, data)\n        for cc in self.cover_caches:\n            cc.invalidate(book_id_data_map)\n        return self._set_field('cover', {\n            book_id:(0 if data is None else 1) for book_id, data in iteritems(book_id_data_map)})\n", "docstring": "Set the cover for this book.  data can be either a QImage,"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def author_sort_from_authors(self, authors, key_func=icu_lower):\n        '''Given a list of authors, return the author_sort string for the authors,\n        preferring the author sort associated with the author over the computed\n        string. '''\n        table = self.fields['authors'].table\n        result = []\n        rmap = {key_func(v):k for k, v in iteritems(table.id_map)}\n        for aut in authors:\n            aid = rmap.get(key_func(aut), None)\n            result.append(author_to_author_sort(aut) if aid is None else table.asort_map[aid])\n        return ' & '.join(_f for _f in result if _f)\n", "docstring": "Given a list of authors, return the author_sort string for the authors,"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def data_for_has_book(self):\n        ''' Return data suitable for use in :meth:`has_book`. This can be used for an\n        implementation of :meth:`has_book` in a worker process without access to the\n        db. '''\n        try:\n            return {icu_lower(title) for title in itervalues(self.fields['title'].table.book_col_map)}\n        except TypeError:\n            # Some non-unicode titles in the db\n            return {icu_lower(as_unicode(title)) for title in itervalues(self.fields['title'].table.book_col_map)}\n", "docstring": "Return data suitable for use in :meth:`has_book`. This can be used for an"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def has_book(self, mi):\n        ''' Return True iff the database contains an entry with the same title\n        as the passed in Metadata object. The comparison is case-insensitive.\n        See also :meth:`data_for_has_book`.  '''\n        title = mi.title\n        if title:\n            if isbytestring(title):\n                title = title.decode(preferred_encoding, 'replace')\n            q = icu_lower(title).strip()\n            for title in itervalues(self.fields['title'].table.book_col_map):\n                if q == icu_lower(title):\n                    return True\n        return False\n", "docstring": "Return True iff the database contains an entry with the same title"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def has_id(self, book_id):\n        ' Return True iff the specified book_id exists in the db '''\n        return book_id in self.fields['title'].table.book_col_map\n", "docstring": "' Return True iff the specified book_id exists in the db '''"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def remove_books(self, book_ids, permanent=False):\n        ''' Remove the books specified by the book_ids from the database and delete\n        their format files. If ``permanent`` is False, then the format files\n        are placed in the recycle bin. '''\n        path_map = {}\n        for book_id in book_ids:\n            try:\n                path = self._field_for('path', book_id).replace('/', os.sep)\n            except:\n                path = None\n            path_map[book_id] = path\n        if iswindows:\n            paths = (x.replace(os.sep, '/') for x in itervalues(path_map) if x)\n            self.backend.windows_check_if_files_in_use(paths)\n        self.backend.remove_books(path_map, permanent=permanent)\n        for field in itervalues(self.fields):\n            try:\n                table = field.table\n            except AttributeError:\n                continue  # Some fields like ondevice do not have tables\n            else:\n                table.remove_books(book_ids, self.backend)\n        self._search_api.discard_books(book_ids)\n        self._clear_caches(book_ids=book_ids, template_cache=False, search_cache=False)\n        for cc in self.cover_caches:\n            cc.invalidate(book_ids)\n", "docstring": "Remove the books specified by the book_ids from the database and delete"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def author_sort_strings_for_books(self, book_ids):\n        val_map = {}\n        for book_id in book_ids:\n            authors = self._field_ids_for('authors', book_id)\n            adata = self._author_data(authors)\n            val_map[book_id] = tuple(adata[aid]['sort'] for aid in authors)\n        return val_map\n", "docstring": "val_map = {}"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def remove_items(self, field, item_ids, restrict_to_book_ids=None):\n        ''' Delete all items in the specified field with the specified ids.\n        Returns the set of affected book ids. ``restrict_to_book_ids`` is an\n        optional set of books ids. If specified the items will only be removed\n        from those books. '''\n        field = self.fields[field]\n        if restrict_to_book_ids is not None and not isinstance(restrict_to_book_ids, (MutableSet, Set)):\n            restrict_to_book_ids = frozenset(restrict_to_book_ids)\n        affected_books = field.table.remove_items(item_ids, self.backend,\n                                                  restrict_to_book_ids=restrict_to_book_ids)\n        if affected_books:\n            if hasattr(field, 'index_field'):\n                self._set_field(field.index_field.name, {bid:1.0 for bid in affected_books})\n            else:\n                self._mark_as_dirty(affected_books)\n        return affected_books\n", "docstring": "Delete all items in the specified field with the specified ids."}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def add_custom_book_data(self, name, val_map, delete_first=False):\n        ''' Add data for name where val_map is a map of book_ids to values. If\n        delete_first is True, all previously stored data for name will be\n        removed. '''\n        missing = frozenset(val_map) - self._all_book_ids()\n        if missing:\n            raise ValueError('add_custom_book_data: no such book_ids: %d'%missing)\n        self.backend.add_custom_data(name, val_map, delete_first)\n", "docstring": "Add data for name where val_map is a map of book_ids to values. If"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def get_custom_book_data(self, name, book_ids=(), default=None):\n        ''' Get data for name. By default returns data for all book_ids, pass\n        in a list of book ids if you only want some data. Returns a map of\n        book_id to values. If a particular value could not be decoded, uses\n        default for it. '''\n        return self.backend.get_custom_book_data(name, book_ids, default)\n", "docstring": "Get data for name. By default returns data for all book_ids, pass"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def delete_custom_book_data(self, name, book_ids=()):\n        ''' Delete data for name. By default deletes all data, if you only want\n        to delete data for some book ids, pass in a list of book ids. '''\n        self.backend.delete_custom_book_data(name, book_ids)\n", "docstring": "Delete data for name. By default deletes all data, if you only want"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def get_ids_for_custom_book_data(self, name):\n        ''' Return the set of book ids for which name has data. '''\n        return self.backend.get_ids_for_custom_book_data(name)\n", "docstring": "Return the set of book ids for which name has data. '''"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def conversion_options(self, book_id, fmt='PIPE'):\n        return self.backend.conversion_options(book_id, fmt)\n", "docstring": "return self.backend.conversion_options(book_id, fmt)"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def set_conversion_options(self, options, fmt='PIPE'):\n        ''' options must be a map of the form {book_id:conversion_options} '''\n        return self.backend.set_conversion_options(options, fmt)\n", "docstring": "options must be a map of the form {book_id:conversion_options} '''"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def set_sort_for_authors(self, author_id_to_sort_map, update_books=True):\n        sort_map = self.fields['authors'].table.set_sort_names(author_id_to_sort_map, self.backend)\n        changed_books = set()\n        if update_books:\n            val_map = {}\n            for author_id in sort_map:\n                books = self._books_for_field('authors', author_id)\n                changed_books |= books\n                for book_id in books:\n                    authors = self._field_ids_for('authors', book_id)\n                    adata = self._author_data(authors)\n                    sorts = [adata[x]['sort'] for x in authors]\n                    val_map[book_id] = ' & '.join(sorts)\n            if val_map:\n                self._set_field('author_sort', val_map)\n        if changed_books:\n            self._mark_as_dirty(changed_books)\n        return changed_books\n", "docstring": "sort_map = self.fields['authors'].table.set_sort_names(author_id_to_sort_map, self.backend)"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def data_for_find_identical_books(self):\n        ''' Return data that can be used to implement\n        :meth:`find_identical_books` in a worker process without access to the\n        db. See db.utils for an implementation. '''\n        at = self.fields['authors'].table\n        author_map = defaultdict(set)\n        for aid, author in iteritems(at.id_map):\n            author_map[icu_lower(author)].add(aid)\n        return (author_map, at.col_book_map.copy(), self.fields['title'].table.book_col_map.copy(), self.fields['languages'].book_value_map.copy())\n", "docstring": "Return data that can be used to implement"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def find_identical_books(self, mi, search_restriction='', book_ids=None):\n        ''' Finds books that have a superset of the authors in mi and the same\n        title (title is fuzzy matched). See also :meth:`data_for_find_identical_books`. '''\n        from calibre.db.utils import fuzzy_title\n        identical_book_ids = set()\n        langq = tuple(x for x in map(canonicalize_lang, mi.languages or ()) if x and x != 'und')\n        if mi.authors:\n            try:\n                quathors = mi.authors[:20]  # Too many authors causes parsing of the search expression to fail\n                query = ' and '.join('authors:\"=%s\"'%(a.replace('\"', '')) for a in quathors)\n                qauthors = mi.authors[20:]\n            except ValueError:\n                return identical_book_ids\n            try:\n                book_ids = self._search(query, restriction=search_restriction, book_ids=book_ids)\n            except:\n                traceback.print_exc()\n                return identical_book_ids\n            if qauthors and book_ids:\n                matches = set()\n                qauthors = {icu_lower(x) for x in qauthors}\n                for book_id in book_ids:\n                    aut = self._field_for('authors', book_id)\n                    if aut:\n                        aut = {icu_lower(x) for x in aut}\n                        if aut.issuperset(qauthors):\n                            matches.add(book_id)\n                book_ids = matches\n            for book_id in book_ids:\n                fbook_title = self._field_for('title', book_id)\n                fbook_title = fuzzy_title(fbook_title)\n                mbook_title = fuzzy_title(mi.title)\n                if fbook_title == mbook_title:\n                    bl = self._field_for('languages', book_id)\n                    if not langq or not bl or bl == langq:\n                        identical_book_ids.add(book_id)\n        return identical_book_ids\n", "docstring": "Finds books that have a superset of the authors in mi and the same"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def restore_book(self, book_id, mi, last_modified, path, formats, annotations=()):\n        ''' Restore the book entry in the database for a book that already exists on the filesystem '''\n        cover = mi.cover\n        mi.cover = None\n        self._create_book_entry(mi, add_duplicates=True,\n                force_id=book_id, apply_import_tags=False, preserve_uuid=True)\n        self._update_last_modified((book_id,), last_modified)\n        if cover and os.path.exists(cover):\n            self._set_field('cover', {book_id:1})\n        self.backend.restore_book(book_id, path, formats)\n        if annotations:\n            self._restore_annotations(book_id, annotations)\n", "docstring": "Restore the book entry in the database for a book that already exists on the filesystem '''"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def virtual_libraries_for_books(self, book_ids, virtual_fields=None):\n        # use a primitive lock to ensure that only one thread is updating\n        # the cache and that recursive calls don't do the update. This\n        # method can recurse via self._search()\n        with try_lock(self.vls_cache_lock) as got_lock:\n            # Using a list is slightly faster than a set.\n            c = defaultdict(list)\n            if not got_lock:\n                # We get here if resolving the books in a VL triggers another VL\n                # calculation. This can be 'real' recursion, in which case the\n                # eventual answer will be wrong. It can also be a  search using\n                # a location of 'all' that causes evaluation of a composite that\n                # references virtual_libraries(). If the composite isn't used in a\n                # VL then the eventual answer will be correct because get_metadata\n                # will clear the caches.\n                return c\n            if self.vls_for_books_cache is None:\n                self.vls_for_books_cache_is_loading = True\n                libraries = self._pref('virtual_libraries', {})\n                for lib, expr in libraries.items():\n                    book = None\n                    try:\n                        for book in self._search(expr, virtual_fields=virtual_fields):\n                            c[book].append(lib)\n                    except Exception as e:\n                        if book:\n                            c[book].append(_('[Error in Virtual library {0}: {1}]').format(lib, str(e)))\n                self.vls_for_books_cache = {b:tuple(sorted(libs, key=sort_key)) for b, libs in c.items()}\n        if not book_ids:\n            book_ids = self._all_book_ids()\n        # book_ids is usually 1 long. The loop will be faster than a comprehension\n        r = {}\n        default = ()\n        for b in book_ids:\n            r[b] = self.vls_for_books_cache.get(b, default)\n        return r\n", "docstring": "use a primitive lock to ensure that only one thread is updating"}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def user_categories_for_books(self, book_ids, proxy_metadata_map=None):\n        ''' Return the user categories for the specified books.\n        proxy_metadata_map is optional and is useful for a performance boost,\n        in contexts where a ProxyMetadata object for the books already exists.\n        It should be a mapping of book_ids to their corresponding ProxyMetadata\n        objects.\n        '''\n        user_cats = self._pref('user_categories', {})\n        pmm = proxy_metadata_map or {}\n        ans = {}\n        for book_id in book_ids:\n            proxy_metadata = pmm.get(book_id) or self._get_proxy_metadata(book_id)\n            user_cat_vals = ans[book_id] = {}\n            for ucat, categories in iteritems(user_cats):\n                user_cat_vals[ucat] = res = []\n                for name, cat, ign in categories:\n                    try:\n                        field_obj = self.fields[cat]\n                    except KeyError:\n                        continue\n                    if field_obj.is_composite:\n                        v = field_obj.get_value_with_cache(book_id, lambda x:proxy_metadata)\n                    else:\n                        v = self._fast_field_for(field_obj, book_id)\n                    if isinstance(v, (list, tuple)):\n                        if name in v:\n                            res.append([name, cat])\n                    elif name == v:\n                        res.append([name, cat])\n        return ans\n", "docstring": "Return the user categories for the specified books."}
{"repo": "calibre-master/src/calibre/db/cache.py", "original_string": "    def embed_metadata(self, book_ids, only_fmts=None, report_error=None, report_progress=None):\n        ''' Update metadata in all formats of the specified book_ids to current metadata in the database. '''\n        field = self.fields['formats']\n        from calibre.customize.ui import apply_null_metadata\n        from calibre.ebooks.metadata.meta import set_metadata\n        from calibre.ebooks.metadata.opf2 import pretty_print\n        if only_fmts:\n            only_fmts = {f.lower() for f in only_fmts}\n        def doit(fmt, mi, stream):\n            with apply_null_metadata, pretty_print:\n                set_metadata(stream, mi, stream_type=fmt, report_error=report_error)\n            stream.seek(0, os.SEEK_END)\n            return stream.tell()\n        for i, book_id in enumerate(book_ids):\n            fmts = field.table.book_col_map.get(book_id, ())\n            if not fmts:\n                continue\n            mi = self.get_metadata(book_id, get_cover=True, cover_as_data=True)\n            try:\n                path = self._field_for('path', book_id).replace('/', os.sep)\n            except:\n                continue\n            for fmt in fmts:\n                if only_fmts is not None and fmt.lower() not in only_fmts:\n                    continue\n                try:\n                    name = self.fields['formats'].format_fname(book_id, fmt)\n                except:\n                    continue\n                if name and path:\n                    new_size = self.backend.apply_to_format(book_id, path, name, fmt, partial(doit, fmt, mi))\n                    if new_size is not None:\n                        self.format_metadata_cache[book_id].get(fmt, {})['size'] = new_size\n                        max_size = self.fields['formats'].table.update_fmt(book_id, fmt, name, new_size, self.backend)\n                        self.fields['size'].table.update_sizes({book_id: max_size})\n            if report_progress is not None:\n                report_progress(i+1, len(book_ids), mi)\n", "docstring": "Update metadata in all formats of the specified book_ids to current metadata in the database. '''"}
{"repo": "calibre-master/src/calibre/db/utils.py", "original_string": "def atof(string):\n    # Python 2.x does not handle unicode number separators correctly, so we\n    # have to implement our own\n    global number_separators\n    if number_separators is None:\n        if iswindows:\n            number_separators = get_windows_number_formats()\n        else:\n            lc = localeconv()\n            t, d = lc['thousands_sep'], lc['decimal_point']\n            if isinstance(t, bytes):\n                t = t.decode('utf-8', 'ignore') or ','\n            if isinstance(d, bytes):\n                d = d.decode('utf-8', 'ignore') or '.'\n            number_separators = t, d\n    return float(string.replace(number_separators[1], '.').replace(number_separators[0], ''))\n", "docstring": "Python 2.x does not handle unicode number separators correctly, so we"}
{"repo": "calibre-master/src/calibre/db/fields.py", "original_string": "    def for_book(self, book_id, default_value=None):\n        return self.table.book_col_map.get(book_id, default_value)\n", "docstring": "return self.table.book_col_map.get(book_id, default_value)"}
{"repo": "calibre-master/src/calibre/db/fields.py", "original_string": "    def _render_composite_with_cache(self, book_id, mi, formatter, template_cache):\n        ''' INTERNAL USE ONLY. DO NOT USE METHOD DIRECTLY. INSTEAD USE\n         db.composite_for() OR mi.get(). Those methods make sure there is no\n         risk of infinite recursion when evaluating templates that refer to\n         themselves. '''\n        with self._lock:\n            ans = self._render_cache.get(book_id, None)\n        if ans is None:\n            return self.__render_composite(book_id, mi, formatter, template_cache)\n        return ans\n", "docstring": "INTERNAL USE ONLY. DO NOT USE METHOD DIRECTLY. INSTEAD USE"}
{"repo": "calibre-master/src/calibre/db/lazy.py", "original_string": "    def __init__(self, db, book_id, formatter=None):\n        sa(self, 'template_cache', db.formatter_template_cache)\n        sa(self, 'formatter', SafeFormat() if formatter is None else formatter)\n        sa(self, '_db', weakref.ref(db))\n        sa(self, '_book_id', book_id)\n        sa(self, '_cache', {'cover_data':(None,None), 'device_collections':[]})\n        sa(self, '_user_metadata', db.field_metadata)\n", "docstring": "sa(self, 'template_cache', db.formatter_template_cache)"}
{"repo": "calibre-master/src/calibre/db/write.py", "original_string": "def uniq(vals, kmap=lambda x:x):\n    ''' Remove all duplicates from vals, while preserving order. kmap must be a\n    callable that returns a hashable value for every item in vals '''\n    vals = vals or ()\n    lvals = (kmap(x) for x in vals)\n    seen = set()\n    seen_add = seen.add\n    return tuple(x for x, k in zip(vals, lvals) if k not in seen and not seen_add(k))\n", "docstring": "Remove all duplicates from vals, while preserving order. kmap must be a"}
{"repo": "calibre-master/src/calibre/db/annotations.py", "original_string": "def merge_annotations(annots, annots_map, merge_last_read=True):\n    # If you make changes to this algorithm also update the\n    # implementation in read_book.annotations\n    if isinstance(annots, dict):\n        amap = annots\n    else:\n        amap = defaultdict(list)\n        for annot in annots:\n            amap[annot['type']].append(annot)\n    if merge_last_read:\n        lr = amap.get('last-read')\n        if lr:\n            existing = annots_map.get('last-read')\n            if existing:\n                lr = existing + lr\n            if lr:\n                lr.sort(key=safe_timestamp_sort_key, reverse=True)\n                annots_map['last-read'] = [lr[0]]\n    for annot_type, field in merge_field_map.items():\n        a = annots_map.get(annot_type)\n        b = amap.get(annot_type)\n        if not b:\n            continue\n        changed, annots_map[annot_type] = merge_annots_with_identical_field(a or [], b, field=field)\n", "docstring": "If you make changes to this algorithm also update the"}
{"repo": "calibre-master/src/calibre/db/locking.py", "original_string": "    def __init__(self):\n        self._lock = Lock()\n        #  When a shared lock is held, is_shared will give the cumulative\n        #  number of locks and _shared_owners maps each owning thread to\n        #  the number of locks is holds.\n        self.is_shared = 0\n        self._shared_owners = {}\n        #  When an exclusive lock is held, is_exclusive will give the number\n        #  of locks held and _exclusive_owner will give the owning thread\n        self.is_exclusive = 0\n        self._exclusive_owner = None\n        #  When someone is forced to wait for a lock, they add themselves\n        #  to one of these queues along with a \"waiter\" condition that\n        #  is used to wake them up.\n        self._shared_queue = []\n        self._exclusive_queue = []\n        #  This is for recycling waiter objects.\n        self._free_waiters = []\n", "docstring": "When a shared lock is held, is_shared will give the cumulative"}
{"repo": "calibre-master/src/calibre/db/adding.py", "original_string": "def metadata_extensions():\n    # Set of all known book extensions + OPF (the OPF is used to read metadata,\n    # but not actually added)\n    global _metadata_extensions\n    if _metadata_extensions is None:\n        _metadata_extensions =  frozenset(it_map(unicode_type, BOOK_EXTENSIONS)) | {'opf'}\n    return _metadata_extensions\n", "docstring": "Set of all known book extensions + OPF (the OPF is used to read metadata,"}
{"repo": "calibre-master/src/calibre/db/view.py", "original_string": "    def refresh(self, field=None, ascending=True, clear_caches=True, do_search=True):\n        self._map = tuple(sorted(self.cache.all_book_ids()))\n        self._map_filtered = tuple(self._map)\n        self.full_map_is_sorted = True\n        self.sort_history = [('id', True)]\n        if clear_caches:\n            self.cache.clear_caches()\n        if field is not None:\n            self.sort(field, ascending)\n        if do_search and (self.search_restriction or self.base_restriction):\n            self.search('', return_matches=False)\n", "docstring": "self._map = tuple(sorted(self.cache.all_book_ids()))"}
{"repo": "calibre-master/src/calibre/db/backend.py", "original_string": "def Concatenate(sep=','):\n    '''String concatenation aggregator for sqlite'''\n    def step(ctxt, value):\n        if value is not None:\n            ctxt.append(value)\n    def finalize(ctxt):\n        try:\n            if not ctxt:\n                return None\n            return sep.join(ctxt)\n        except Exception:\n            import traceback\n            traceback.print_exc()\n            raise\n    return ([], step, finalize)\n", "docstring": "String concatenation aggregator for sqlite'''"}
{"repo": "calibre-master/src/calibre/db/backend.py", "original_string": "def IdentifiersConcat():\n    '''String concatenation aggregator for the identifiers map'''\n    def step(ctxt, key, val):\n        ctxt.append(u'%s:%s'%(key, val))\n    def finalize(ctxt):\n        try:\n            return ','.join(ctxt)\n        except Exception:\n            import traceback\n            traceback.print_exc()\n            raise\n    return ([], step, finalize)\n", "docstring": "String concatenation aggregator for the identifiers map'''"}
{"repo": "calibre-master/src/calibre/db/backend.py", "original_string": "    def user_version(self):\n        '''The user version of this database'''\n        return self.conn.get('pragma user_version;', all=False)\n", "docstring": "The user version of this database'''"}
{"repo": "calibre-master/src/calibre/db/backend.py", "original_string": "    def custom_table_names(self, num):\n        return 'custom_column_%d'%num, 'books_custom_column_%d_link'%num\n", "docstring": "return 'custom_column_%d'%num, 'books_custom_column_%d_link'%num"}
{"repo": "calibre-master/src/calibre/db/backend.py", "original_string": "    def library_id(self):\n        '''The UUID for this library. As long as the user only operates  on libraries with calibre, it will be unique'''\n        if getattr(self, '_library_id_', None) is None:\n            ans = self.conn.get('SELECT uuid FROM library_id', all=False)\n            if ans is None:\n                ans = unicode_type(uuid.uuid4())\n                self.library_id = ans\n            else:\n                self._library_id_ = ans\n        return self._library_id_\n", "docstring": "The UUID for this library. As long as the user only operates  on libraries with calibre, it will be unique'''"}
{"repo": "calibre-master/src/calibre/db/backend.py", "original_string": "    def cover_abspath(self, book_id, path):\n        path = os.path.join(self.library_path, path)\n        fmt_path = os.path.join(path, 'cover.jpg')\n        if os.path.exists(fmt_path):\n            return fmt_path\n", "docstring": "path = os.path.join(self.library_path, path)"}
{"repo": "calibre-master/src/calibre/db/schema_upgrades.py", "original_string": "    def upgrade_version_2(self):\n        ''' Fix Foreign key constraints for deleting from link tables. '''\n        script = '''\\\n        DROP TRIGGER IF EXISTS fkc_delete_books_%(ltable)s_link;\n        CREATE TRIGGER fkc_delete_on_%(table)s\n        BEFORE DELETE ON %(table)s\n        BEGIN\n            SELECT CASE\n                WHEN (SELECT COUNT(id) FROM books_%(ltable)s_link WHERE %(ltable_col)s=OLD.id) > 0\n                THEN RAISE(ABORT, 'Foreign key violation: %(table)s is still referenced')\n            END;\n        END;\n        DELETE FROM %(table)s WHERE (SELECT COUNT(id) FROM books_%(ltable)s_link WHERE %(ltable_col)s=%(table)s.id) < 1;\n        '''\n        self.db.execute(script%dict(ltable='authors', table='authors', ltable_col='author'))\n        self.db.execute(script%dict(ltable='publishers', table='publishers', ltable_col='publisher'))\n        self.db.execute(script%dict(ltable='tags', table='tags', ltable_col='tag'))\n        self.db.execute(script%dict(ltable='series', table='series', ltable_col='series'))\n", "docstring": "Fix Foreign key constraints for deleting from link tables. '''"}
{"repo": "calibre-master/src/calibre/db/schema_upgrades.py", "original_string": "    def upgrade_version_22(self):\n        ''' Create the last_read_positions table '''\n        self.db.execute('''\n", "docstring": "Create the last_read_positions table '''"}
{"repo": "calibre-master/src/calibre/db/schema_upgrades.py", "original_string": "    def upgrade_version_23(self):\n        ''' Create the annotations table '''\n        self.db.execute('''\n", "docstring": "Create the annotations table '''"}
{"repo": "calibre-master/src/calibre/db/cli/cmd_catalog.py", "original_string": "    def add_plugin_parser_options(fmt, parser):\n        # Fetch the extension-specific CLI options from the plugin\n        # library.catalogs.<format>.py\n        plugin = plugin_for_catalog_format(fmt)\n        p = parser.add_option_group(_('{} OPTIONS').format(fmt.upper()))\n        for option in plugin.cli_options:\n            if option.action:\n                p.add_option(\n                    option.option,\n                    default=option.default,\n                    dest=option.dest,\n                    action=option.action,\n                    help=option.help\n                )\n            else:\n                p.add_option(\n                    option.option,\n                    default=option.default,\n                    dest=option.dest,\n                    help=option.help\n                )\n", "docstring": "Fetch the extension-specific CLI options from the plugin"}
{"repo": "calibre-master/src/calibre/db/tests/locking.py", "original_string": "def wait_for(period):\n    # time.sleep() is not useful for very small values on windows because the\n    # default timer has a resolutions of about 16ms see\n    # https://stackoverflow.com/questions/40594587/why-time-sleep-is-so-slow-in-windows\n    deadline = time.perf_counter() + period\n    while time.perf_counter() < deadline:\n        pass\n", "docstring": "time.sleep() is not useful for very small values on windows because the"}
{"repo": "calibre-master/src/calibre/ebooks/css_transform_rules.py", "original_string": "    def set_property(self, name, value, priority='', replace=True):\n        # Note that this does not handle shorthand properties, so you must\n        # call remove_property() yourself in that case\n        self.changed = True\n        if replace:\n            self.css_declaration.removeProperty(name)\n        self.css_declaration.setProperty(Property(name, value, priority, parent=self.css_declaration))\n", "docstring": "Note that this does not handle shorthand properties, so you must"}
{"repo": "calibre-master/src/calibre/ebooks/hyphenate.py", "original_string": "    def hyphenate_word(self, word):\n        \"\"\" Given a word, returns a list of pieces, broken at the possible\n            hyphenation points.\n        \"\"\"\n        # Short words aren't hyphenated.\n        if len(word) <= 4:\n            return [word]\n        # If the word is an exception, get the stored points.\n        if word.lower() in self.exceptions:\n            points = self.exceptions[word.lower()]\n        else:\n            work = '.' + word.lower() + '.'\n            points = [0] * (len(work)+1)\n            for i in range(len(work)):\n                t = self.tree\n                for c in work[i:]:\n                    if c in t:\n                        t = t[c]\n                        if None in t:\n                            p = t[None]\n                            for j in range(len(p)):\n                                points[i+j] = max(points[i+j], p[j])\n                    else:\n                        break\n            # No hyphens in the first two chars or the last two.\n            points[1] = points[2] = points[-2] = points[-3] = 0\n        # Examine the points to build the pieces list.\n        pieces = ['']\n        for c, p in zip(word, points[2:]):\n            pieces[-1] += c\n            if p % 2:\n                pieces.append('')\n        return pieces\n", "docstring": "Given a word, returns a list of pieces, broken at the possible"}
{"repo": "calibre-master/src/calibre/ebooks/compression/tcr.py", "original_string": "    def _reset(self):\n        # List of indexes in the codes list that are empty and can hold new codes\n        self.unused_codes = set()\n        self.coded_txt = b''\n        # Generate initial codes from text.\n        # The index of the list will be the code that represents the characters at that location\n        # in the list\n        self.codes = []\n", "docstring": "List of indexes in the codes list that are empty and can hold new codes"}
{"repo": "calibre-master/src/calibre/ebooks/compression/tcr.py", "original_string": "    def compress(self, txt):\n        self._reset()\n        self.codes = list(set(re.findall(b'(?ms).', txt)))\n        # Replace the text with their corresponding code\n        # FIXME: python3 is native bytearray, but all we want are bytes\n        for c in bytearray(txt):\n            self.coded_txt += int_to_byte(self.codes.index(int_to_byte(c)))\n        # Zero the unused codes and record which are unused.\n        for i in range(len(self.codes), 256):\n            self.codes.append(b'')\n            self.unused_codes.add(i)\n        self._combine_codes()\n        possible_codes = self._new_codes()\n        while possible_codes and self.unused_codes:\n            while possible_codes and self.unused_codes:\n                unused_code = self.unused_codes.pop()\n                # Take the last possible codes and split it into individual\n                # codes. The last possible code is the most often occurring.\n                code = possible_codes.pop()\n                self.codes[unused_code] = b'%s%s' % (self.codes[ord(code[0:1])], self.codes[ord(code[1:2])])\n                self.coded_txt = self.coded_txt.replace(code, int_to_byte(unused_code))\n            self._combine_codes()\n            self._free_unused_codes()\n            possible_codes = self._new_codes()\n        self._free_unused_codes()\n        # Generate the code dictionary.\n        code_dict = []\n        for i in range(0, 256):\n            if i in self.unused_codes:\n                code_dict.append(b'\\0')\n            else:\n                code_dict.append(int_to_byte(len(self.codes[i])) + self.codes[i])\n        # Join the identifier with the dictionary and coded text.\n        return b'!!8-Bit!!'+b''.join(code_dict)+self.coded_txt\n", "docstring": "self._reset()"}
{"repo": "calibre-master/src/calibre/ebooks/snb/snbml.py", "original_string": "def ProcessFileName(fileName):\n    # Flat the path\n    fileName = fileName.replace(\"/\", \"_\").replace(os.sep, \"_\")\n    # Handle bookmark for HTML file\n    fileName = fileName.replace(\"#\", \"_\")\n    # Make it lower case\n    fileName = fileName.lower()\n    # Change all images to jpg\n    root, ext = os.path.splitext(fileName)\n    if ext in ['.jpeg', '.jpg', '.gif', '.svg', '.png']:\n        fileName = root + '.jpg'\n    return fileName\n", "docstring": "Flat the path"}
{"repo": "calibre-master/src/calibre/ebooks/snb/snbfile.py", "original_string": "    def Parse(self, snbFile, metaOnly=False):\n        # Read header\n        vmbr = snbFile.read(44)\n        (self.magic, self.rev80, self.revA3, self.revZ1,\n         self.fileCount, self.vfatSize, self.vfatCompressed,\n         self.binStreamSize, self.plainStreamSizeUncompressed,\n         self.revZ2) = struct.unpack('>8siiiiiiiii', vmbr)\n        # Read FAT\n        self.vfat = zlib.decompress(snbFile.read(self.vfatCompressed))\n        self.ParseFile(self.vfat, self.fileCount)\n        # Read tail\n        snbFile.seek(-16, os.SEEK_END)\n        # plainStreamEnd = snbFile.tell()\n        tailblock = snbFile.read(16)\n        (self.tailSize, self.tailOffset, self.tailMagic) = struct.unpack('>ii8s', tailblock)\n        snbFile.seek(self.tailOffset)\n        self.vTailUncompressed = zlib.decompress(snbFile.read(self.tailSize))\n        self.tailSizeUncompressed = len(self.vTailUncompressed)\n        self.ParseTail(self.vTailUncompressed, self.fileCount)\n        # Uncompress file data\n        # Read files\n        binPos = 0\n        plainPos = 0\n        uncompressedData = None\n        for f in self.files:\n            if f.attr & 0x41000000 == 0x41000000:\n                # Compressed Files\n                if uncompressedData is None:\n                    uncompressedData = b\"\"\n                    for i in range(self.plainBlock):\n                        bzdc = bz2.BZ2Decompressor()\n                        if (i < self.plainBlock - 1):\n                            bSize = self.blocks[self.binBlock + i + 1].Offset - self.blocks[self.binBlock + i].Offset\n                        else:\n                            bSize = self.tailOffset - self.blocks[self.binBlock + i].Offset\n                        snbFile.seek(self.blocks[self.binBlock + i].Offset)\n                        try:\n                            data = snbFile.read(bSize)\n                            if len(data) < 32768:\n                                uncompressedData += bzdc.decompress(data)\n                            else:\n                                uncompressedData += data\n                        except Exception:\n                            import traceback\n                            print(traceback.print_exc())\n                if len(uncompressedData) != self.plainStreamSizeUncompressed:\n                    raise Exception()\n                f.fileBody = uncompressedData[plainPos:plainPos+f.fileSize]\n                plainPos += f.fileSize\n            elif f.attr & 0x01000000 == 0x01000000:\n                # Binary Files\n                snbFile.seek(44 + self.vfatCompressed + binPos)\n                f.fileBody = snbFile.read(f.fileSize)\n                binPos += f.fileSize\n            else:\n                raise ValueError(\"Invalid file: {} {}\".format(f.attr, f.fileName))\n", "docstring": "Read header"}
{"repo": "calibre-master/src/calibre/ebooks/textile/functions.py", "original_string": "    def __init__(self, restricted=False, lite=False, noimage=False):\n        \"\"\"docstring for __init__\"\"\"\n        self.restricted = restricted\n        self.lite = lite\n        self.noimage = noimage\n        self.get_sizes = False\n        self.fn = {}\n        self.urlrefs = {}\n        self.shelf = {}\n        self.rel = ''\n        self.html_type = 'xhtml'\n", "docstring": "docstring for __init__\n"}
{"repo": "calibre-master/src/calibre/ebooks/textile/functions.py", "original_string": "    def lT(self, input):\n        if re.search(r'^#+', input):\n            return 'o'\n        else:\n            return 'u'\n", "docstring": "if re.search(r'^#+', input):"}
{"repo": "calibre-master/src/calibre/ebooks/textile/functions.py", "original_string": "    def footnoteID(self, match):\n        id, t = match.groups()\n        if id not in self.fn:\n            self.fn[id] = unicode_type(uuid.uuid4())\n        fnid = self.fn[id]\n        if not t:\n            t = ''\n        return '<sup class=\"footnote\"><a href=\"#fn%s\">%s</a></sup>%s' % (fnid, id, t)\n", "docstring": "id, t = match.groups()"}
{"repo": "calibre-master/src/calibre/ebooks/textile/functions.py", "original_string": "    def macros_only(self, text):\n        # fix: hackish\n        text = re.sub(r'\"\\Z', '\\\" ', text)\n        result = []\n        for line in re.compile(r'(<.*?>)', re.U).split(text):\n            if not re.search(r'<.*>', line):\n                rules = []\n                if re.search(r'{.+?}', line):\n                    rules = self.macro_defaults\n                for s, r in rules:\n                    line = s.sub(r, line)\n            result.append(line)\n        return ''.join(result)\n", "docstring": "fix: hackish"}
{"repo": "calibre-master/src/calibre/ebooks/textile/functions.py", "original_string": "    def shelve(self, text):\n        id = unicode_type(uuid.uuid4()) + 'c'\n        self.shelf[id] = text\n        return id\n", "docstring": "id = unicode_type(uuid.uuid4()) + 'c'"}
{"repo": "calibre-master/src/calibre/ebooks/textile/functions.py", "original_string": "    def code(self, text):\n        text = self.doSpecial(text, '<code>', '</code>', self.fCode)\n        text = self.doSpecial(text, '@', '@', self.fCode)\n        text = self.doSpecial(text, '<pre>', '</pre>', self.fPre)\n        return text\n", "docstring": "text = self.doSpecial(text, '<code>', '</code>', self.fCode)"}
{"repo": "calibre-master/src/calibre/ebooks/textile/functions.py", "original_string": "    def fTextile(self, match):\n        before, notextile, after = match.groups()\n        if after is None:\n            after = ''\n        return ''.join([before, self.shelve(notextile), after])\n", "docstring": "before, notextile, after = match.groups()"}
{"repo": "calibre-master/src/calibre/ebooks/lit/mssha1.py", "original_string": "def _long2bytesBigEndian(n, blocksize=0):\n    \"\"\"Convert a long integer to a byte string.\n    If optional blocksize is given and greater than zero, pad the front\n    of the byte string with binary zeros so that the length is a multiple\n    of blocksize.\n    \"\"\"\n    # After much testing, this algorithm was deemed to be the fastest.\n    s = b''\n    pack = struct.pack\n    while n > 0:\n        s = pack('>I', n & 0xffffffff) + s\n        n = n >> 32\n    # Strip off leading zeros.\n    s = s.lstrip(b'\\0')\n    # Add back some pad bytes. This could be done more efficiently\n    # w.r.t. the de-padding being done above, but sigh...\n    if blocksize > 0 and len(s) % blocksize:\n        s = (blocksize - len(s) % blocksize) * b'\\000' + s\n    return s\n", "docstring": "Convert a long integer to a byte string."}
{"repo": "calibre-master/src/calibre/ebooks/lit/mssha1.py", "original_string": "    def update(self, inBuf):\n        \"\"\"Add to the current message.\n        Update the mssha1 object with the string arg. Repeated calls\n        are equivalent to a single call with the concatenation of all\n        the arguments, i.e. s.update(a); s.update(b) is equivalent\n        to s.update(a+b).\n        The hash is immediately calculated for all full blocks. The final\n        calculation is made in digest(). It will calculate 1-2 blocks,\n        depending on how much padding we have to add. This allows us to\n        keep an intermediate value for the hash, so that we only need to\n        make minimal recalculation if we call update() to add more data\n        to the hashed string.\n        \"\"\"\n        inBuf = bytearray(inBuf)\n        leninBuf = long_type(len(inBuf))\n        # Compute number of bytes mod 64.\n        index = (self.count[1] >> 3) & 0x3F\n        # Update number of bits.\n        self.count[1] = self.count[1] + (leninBuf << 3)\n        if self.count[1] < (leninBuf << 3):\n            self.count[0] = self.count[0] + 1\n        self.count[0] = self.count[0] + (leninBuf >> 29)\n        partLen = 64 - index\n        if leninBuf >= partLen:\n            self.input[index:] = inBuf[:partLen]\n            self._transform(_bytelist2longBigEndian(self.input))\n            i = partLen\n            while i + 63 < leninBuf:\n                self._transform(_bytelist2longBigEndian(inBuf[i:i+64]))\n                i = i + 64\n            else:\n                self.input = inBuf[i:leninBuf]\n        else:\n            i = 0\n            self.input = self.input + inBuf\n", "docstring": "Add to the current message."}
{"repo": "calibre-master/src/calibre/ebooks/lit/mssha1.py", "original_string": "    def hexdigest(self):\n        \"\"\"Terminate and return digest in HEX form.\n        Like digest() except the digest is returned as a string of\n        length 32, containing only hexadecimal digits. This may be\n        used to exchange the value safely in email or other non-\n        binary environments.\n        \"\"\"\n        return ''.join(['%02x' % c for c in bytearray(self.digest())])\n", "docstring": "Terminate and return digest in HEX form."}
{"repo": "calibre-master/src/calibre/ebooks/lit/mssha1.py", "original_string": "def new(arg=None):\n    \"\"\"Return a new mssha1 crypto object.\n    If arg is present, the method call update(arg) is made.\n    \"\"\"\n    crypto = mssha1()\n    if arg:\n        crypto.update(arg)\n    return crypto\n", "docstring": "Return a new mssha1 crypto object."}
{"repo": "calibre-master/src/calibre/ebooks/pdf/pdftohtml.py", "original_string": "        def process_node(node, toc):\n            for child in node.iterchildren('*'):\n                if child.tag == 'outline':\n                    parent = toc.children[-1] if toc.children else toc\n                    process_node(child, parent)\n                else:\n                    if child.text:\n                        page = child.get('page', '1')\n                        toc.add(child.text, 'index.html', 'p' + page)\n                        count[0] += 1\n", "docstring": "for child in node.iterchildren('*'):"}
{"repo": "calibre-master/src/calibre/ebooks/pdf/html_writer.py", "original_string": "def merge_font_files(fonts, log):\n    # As of Qt 5.15.1 Chromium has switched to harfbuzz and dropped sfntly. It\n    # now produces font descriptors whose W arrays dont match the glyph width\n    # information from the hhea table, in contravention of the PDF spec. So\n    # we can no longer merge font descriptors, all we can do is merge the\n    # actual sfnt data streams into a single stream and subset it to contain\n    # only the glyphs from all W arrays.\n    # choose the largest font as the base font\n    fonts.sort(key=lambda f: len(f['Data'] or b''), reverse=True)\n    descendant_fonts = [f for f in fonts if f['Subtype'] != 'Type0']\n    total_size = sum(len(f['Data']) for f in descendant_fonts)\n    merged_sfnt = merge_truetype_fonts_for_pdf(tuple(f['sfnt'] for f in descendant_fonts), log)\n    w_arrays = tuple(filter(None, (f['W'] for f in descendant_fonts)))\n    glyph_ids = all_glyph_ids_in_w_arrays(w_arrays, as_set=True)\n    h_arrays = tuple(filter(None, (f['W2'] for f in descendant_fonts)))\n    glyph_ids |= all_glyph_ids_in_w_arrays(h_arrays, as_set=True)\n    try:\n        pdf_subset(merged_sfnt, glyph_ids)\n    except NoGlyphs:\n        log.warn(f'Subsetting of {fonts[0][\"BaseFont\"]} failed with no glyphs found, ignoring')\n    font_data = merged_sfnt()[0]\n    log(f'Merged {len(fonts)} instances of {fonts[0][\"BaseFont\"]} reducing size from {human_readable(total_size)} to {human_readable(len(font_data))}')\n    return font_data, tuple(f['Reference'] for f in descendant_fonts)\n", "docstring": "As of Qt 5.15.1 Chromium has switched to harfbuzz and dropped sfntly. It"}
{"repo": "calibre-master/src/calibre/ebooks/pdf/reflow.py", "original_string": "    def contains(self, columns):\n        # TODO: handle unbalanced columns\n        if not self.columns:\n            return True\n        if len(columns) != len(self.columns):\n            return False\n        for i in range(len(columns)):\n            c1, c2 = self.columns[i], columns[i]\n            x1 = Interval(c1.left, c1.right)\n            x2 = Interval(c2.left, c2.right)\n            intersection = x1.intersection(x2)\n            base = min(x1.width, x2.width)\n            if intersection.width/base < 0.6:\n                return False\n        return True\n", "docstring": "TODO: handle unbalanced columns"}
{"repo": "calibre-master/src/calibre/ebooks/pdf/reflow.py", "original_string": "    def coalesce_regions(self):\n        # find contiguous sets of small regions\n        # absorb into a neighboring region (prefer the one with number of cols\n        # closer to the avg number of cols in the set, if equal use larger\n        # region)\n        found = True\n        absorbed = set()\n        processed = set()\n        while found:\n            found = False\n            for i, region in enumerate(self.regions):\n                if region in absorbed:\n                    continue\n                if region.is_small and region not in processed:\n                    found = True\n                    processed.add(region)\n                    regions = [region]\n                    end = i+1\n                    for j in range(i+1, len(self.regions)):\n                        end = j\n                        if self.regions[j].is_small:\n                            regions.append(self.regions[j])\n                        else:\n                            break\n                    prev_region = None if i == 0 else i-1\n                    next_region = end if end < len(self.regions) and self.regions[end] not in regions else None\n                    absorb_at = 'bottom'\n                    if prev_region is None and next_region is not None:\n                        absorb_into = next_region\n                        absorb_at = 'top'\n                    elif next_region is None and prev_region is not None:\n                        absorb_into = prev_region\n                    elif prev_region is None and next_region is None:\n                        if len(regions) > 1:\n                            absorb_into = i\n                            regions = regions[1:]\n                        else:\n                            absorb_into = None\n                    else:\n                        absorb_into = prev_region\n                        if self.regions[next_region].line_count >= \\\n                                self.regions[prev_region].line_count:\n                            avg_column_count = sum([len(r.columns) for r in\n                                regions])/float(len(regions))\n                            if self.regions[next_region].line_count > \\\n                                    self.regions[prev_region].line_count \\\n                               or abs(avg_column_count -\n                                       len(self.regions[prev_region].columns)) \\\n                               > abs(avg_column_count -\n                                       len(self.regions[next_region].columns)):\n                                absorb_into = next_region\n                                absorb_at = 'top'\n                    if absorb_into is not None:\n                        self.regions[absorb_into].absorb_regions(regions, absorb_at)\n                        absorbed.update(regions)\n        for region in absorbed:\n            self.regions.remove(region)\n", "docstring": "find contiguous sets of small regions"}
{"repo": "calibre-master/src/calibre/ebooks/pdf/render/graphics.py", "original_string": "    def __call__(self, pdf_system, painter):\n        # Apply the currently pending state to the PDF\n        if self.pending_state is None:\n            return\n        pdf_state = self.current_state\n        ps = self.pending_state\n        pdf = self.pdf\n        if ps.transform != pdf_state.transform or ps.clip_updated:\n            pdf.restore_stack()\n            pdf.save_stack()\n            pdf_state = self.base_state\n        if (pdf_state.transform != ps.transform):\n            pdf.transform(ps.transform)\n        if (pdf_state.opacity != ps.opacity or pdf_state.stroke != ps.stroke):\n            self.apply_stroke(ps, pdf_system, painter)\n        if (pdf_state.opacity != ps.opacity or pdf_state.fill != ps.fill or\n            pdf_state.brush_origin != ps.brush_origin):\n            self.apply_fill(ps, pdf_system, painter)\n        if ps.clip_updated:\n            ps.clip_updated = False\n            path = painter.clipPath()\n            if not path.isEmpty():\n                p = convert_path(path)\n                fill_rule = {Qt.FillRule.OddEvenFill:'evenodd',\n                            Qt.FillRule.WindingFill:'winding'}[path.fillRule()]\n                pdf.add_clip(p, fill_rule=fill_rule)\n        self.current_state = self.pending_state\n        self.pending_state = None\n", "docstring": "Apply the currently pending state to the PDF"}
{"repo": "calibre-master/src/calibre/ebooks/pdf/render/graphics.py", "original_string": "    def apply_stroke(self, state, pdf_system, painter):\n        # TODO: Support miter limit by using QPainterPathStroker\n        pen = state.stroke\n        self.pending_state.do_stroke = True\n        pdf = self.pdf\n        # Width\n        w = pen.widthF()\n        if pen.isCosmetic():\n            t = painter.transform()\n            try:\n                w /= sqrt(t.m11()**2 + t.m22()**2)\n            except ZeroDivisionError:\n                pass\n        pdf.serialize(w)\n        pdf.current_page.write(' w ')\n        # Line cap\n        cap = {Qt.PenCapStyle.FlatCap:0, Qt.PenCapStyle.RoundCap:1, Qt.PenCapStyle.SquareCap:\n               2}.get(pen.capStyle(), 0)\n        pdf.current_page.write('%d J '%cap)\n        # Line join\n        join = {Qt.PenJoinStyle.MiterJoin:0, Qt.PenJoinStyle.RoundJoin:1,\n                Qt.PenJoinStyle.BevelJoin:2}.get(pen.joinStyle(), 0)\n        pdf.current_page.write('%d j '%join)\n        # Dash pattern\n        if pen.style() == Qt.PenStyle.CustomDashLine:\n            pdf.serialize(Array(pen.dashPattern()))\n            pdf.current_page.write(' %d d ' % pen.dashOffset())\n        else:\n            ps = {Qt.PenStyle.DashLine:[3], Qt.PenStyle.DotLine:[1,2], Qt.PenStyle.DashDotLine:[3,2,1,2],\n                  Qt.PenStyle.DashDotDotLine:[3, 2, 1, 2, 1, 2]}.get(pen.style(), [])\n            pdf.serialize(Array(ps))\n            pdf.current_page.write(' 0 d ')\n        # Stroke fill\n        color, opacity, pattern, self.pending_state.do_stroke = self.convert_brush(\n            pen.brush(), state.brush_origin, state.opacity, pdf_system,\n            painter.transform())\n        self.pdf.apply_stroke(color, pattern, opacity)\n        if pen.style() == Qt.PenStyle.NoPen:\n            self.pending_state.do_stroke = False\n", "docstring": "TODO: Support miter limit by using QPainterPathStroker"}
{"repo": "calibre-master/src/calibre/ebooks/txt/processor.py", "original_string": "def create_markdown_object(extensions):\n    # Need to load markdown extensions without relying on pkg_resources\n    import importlib\n    from calibre.ebooks.markdown import Markdown\n    from markdown import Extension\n    class NotBrainDeadMarkdown(Markdown):\n        def build_extension(self, ext_name, configs):\n            if '.' in ext_name or ':' in ext_name:\n                return Markdown.build_extension(self, ext_name, configs)\n            ext_name = 'markdown.extensions.' + ext_name\n            module = importlib.import_module(ext_name)\n            if hasattr(module, 'makeExtension'):\n                return module.makeExtension(**configs)\n            for name, x in vars(module).items():\n                if type(x) is type and issubclass(x, Extension) and x is not Extension:\n                    return x(**configs)\n            raise ImportError('No extension class in {}'.format(ext_name))\n    from calibre.ebooks.conversion.plugins.txt_input import MD_EXTENSIONS\n    extensions = [x.lower() for x in extensions]\n    extensions = [x for x in extensions if x in MD_EXTENSIONS]\n    md = NotBrainDeadMarkdown(extensions=extensions)\n    return md\n", "docstring": "Need to load markdown extensions without relying on pkg_resources"}
{"repo": "calibre-master/src/calibre/ebooks/txt/processor.py", "original_string": "def convert_markdown_with_metadata(txt, title='', extensions=DEFAULT_MD_EXTENSIONS):\n    from calibre.ebooks.metadata.book.base import Metadata\n    from calibre.utils.date import parse_only_date\n    from calibre.db.write import get_series_values\n    if 'meta' not in extensions:\n        extensions.append('meta')\n    md = create_markdown_object(extensions)\n    html = md.convert(txt)\n    mi = Metadata(title or _('Unknown'))\n    m = md.Meta\n    for k, v in iteritems({'date':'pubdate', 'summary':'comments'}):\n        if v not in m and k in m:\n            m[v] = m.pop(k)\n    for k in 'title authors series tags pubdate comments publisher rating'.split():\n        val = m.get(k)\n        if val:\n            mf = mi.metadata_for_field(k)\n            if not mf.get('is_multiple'):\n                val = val[0]\n            if k == 'series':\n                val, si = get_series_values(val)\n                mi.series_index = 1 if si is None else si\n            if k == 'rating':\n                try:\n                    val = max(0, min(int(float(val)), 10))\n                except Exception:\n                    continue\n            if mf.get('datatype') == 'datetime':\n                try:\n                    val = parse_only_date(val, assume_utc=False)\n                except Exception:\n                    continue\n            setattr(mi, k, val)\n    return mi, HTML_TEMPLATE % (mi.title, html)\n", "docstring": "from calibre.ebooks.metadata.book.base import Metadata"}
{"repo": "calibre-master/src/calibre/ebooks/txt/markdownml.py", "original_string": "    def tidy_up(self, text):\n        # Remove blank space form beginning of paragraph.\n        text = re.sub('(?msu)^[ ]{1,3}', '', text)\n        # pre has 4 spaces. We trimmed 3 so anything with a space left is a pre.\n        text = re.sub('(?msu)^[ ]', '    ', text)\n        # Remove tabs that aren't at the beinning of a line\n        new_text = []\n        for l in text.splitlines():\n            start = re.match('\\t+', l)\n            if start:\n                start = start.group()\n            else:\n                start = ''\n            l = re.sub('\\t', '', l)\n            new_text.append(start + l)\n        text = '\\n'.join(new_text)\n        # Remove spaces from blank lines.\n        text = re.sub('(?msu)^[ ]+$', '', text)\n        # Reduce blank lines\n        text = re.sub('(?msu)\\n{7,}', '\\n' * 6, text)\n        # Remove blank lines at beginning and end of document.\n        text = re.sub(r'^\\s*', '', text)\n        text = re.sub(r'\\s*$', '\\n\\n', text)\n        return text\n", "docstring": "Remove blank space form beginning of paragraph."}
{"repo": "calibre-master/src/calibre/ebooks/conversion/preprocess.py", "original_string": "    def __init__(self, verbose=0, log=None):\n        self.log = log\n        self.verbose = verbose\n        # Add common suffixes to the regex below to increase the likelihood of a match -\n        # don't add suffixes which are also complete words, such as 'able' or 'sex'\n        # only remove if it's not already the point of hyphenation\n        self.suffix_string = (\n            \"((ed)?ly|'?e?s||a?(t|s)?ion(s|al(ly)?)?|ings?|er|(i)?ous|\"\n            \"(i|a)ty|(it)?ies|ive|gence|istic(ally)?|(e|a)nce|m?ents?|ism|ated|\"\n            \"(e|u)ct(ed)?|ed|(i|ed)?ness|(e|a)ncy|ble|ier|al|ex|ian)$\")\n        self.suffixes = re.compile(r\"^%s\" % self.suffix_string, re.IGNORECASE)\n        self.removesuffixes = re.compile(r\"%s\" % self.suffix_string, re.IGNORECASE)\n        # remove prefixes if the prefix was not already the point of hyphenation\n        self.prefix_string = '^(dis|re|un|in|ex)'\n        self.prefixes = re.compile(r'%s$' % self.prefix_string, re.IGNORECASE)\n        self.removeprefix = re.compile(r'%s' % self.prefix_string, re.IGNORECASE)\n", "docstring": "self.log = log"}
{"repo": "calibre-master/src/calibre/ebooks/conversion/plumber.py", "original_string": "    def get_option_by_name(self, name):\n        for group in (self.input_options, self.pipeline_options,\n                      self.output_options, self.all_format_options):\n            for rec in group:\n                if rec.option == name:\n                    return rec\n", "docstring": "for group in (self.input_options, self.pipeline_options,"}
{"repo": "calibre-master/src/calibre/ebooks/conversion/plumber.py", "original_string": "        def set_profile(profiles, which):\n            attr = which + '_profile'\n            sval = getattr(self.opts, attr)\n            for x in profiles():\n                if x.short_name == sval:\n                    setattr(self.opts, attr, x)\n                    return\n            self.log.warn(\n                'Profile (%s) %r is no longer available, using default'%(which, sval))\n            for x in profiles():\n                if x.short_name == 'default':\n                    setattr(self.opts, attr, x)\n                    break\n", "docstring": "attr = which + '_profile'"}
{"repo": "calibre-master/src/calibre/ebooks/conversion/utils.py", "original_string": "    def markup_italicis(self, html):\n        # self.log.debug(\"\\n\\n\\nitalicize debugging \\n\\n\\n\")\n        ITALICIZE_WORDS = [\n            'Etc.', 'etc.', 'viz.', 'ie.', 'i.e.', 'Ie.', 'I.e.', 'eg.',\n            'e.g.', 'Eg.', 'E.g.', 'et al.', 'et cetera', 'n.b.', 'N.b.',\n            'nota bene', 'Nota bene', 'Ste.', 'Mme.', 'Mdme.',\n            'Mlle.', 'Mons.', 'PS.', 'PPS.',\n        ]\n        ITALICIZE_STYLE_PATS = [\n            unicode_type(r'(?msu)(?<=[\\s>\"“\\'‘])_\\*/(?P<words>[^\\*_]+)/\\*_'),\n            unicode_type(r'(?msu)(?<=[\\s>\"“\\'‘])~~(?P<words>[^~]+)~~'),\n            unicode_type(r'(?msu)(?<=[\\s>\"“\\'‘])_/(?P<words>[^/_]+)/_'),\n            unicode_type(r'(?msu)(?<=[\\s>\"“\\'‘])_\\*(?P<words>[^\\*_]+)\\*_'),\n            unicode_type(r'(?msu)(?<=[\\s>\"“\\'‘])\\*/(?P<words>[^/\\*]+)/\\*'),\n            unicode_type(r'(?msu)(?<=[\\s>\"“\\'‘])/:(?P<words>[^:/]+):/'),\n            unicode_type(r'(?msu)(?<=[\\s>\"“\\'‘])\\|:(?P<words>[^:\\|]+):\\|'),\n            unicode_type(r'(?msu)(?<=[\\s>\"“\\'‘])\\*(?P<words>[^\\*]+)\\*'),\n            unicode_type(r'(?msu)(?<=[\\s>\"“\\'‘])~(?P<words>[^~]+)~'),\n            unicode_type(r'(?msu)(?<=[\\s>\"“\\'‘])/(?P<words>[^/\\*><]+)/'),\n            unicode_type(r'(?msu)(?<=[\\s>\"“\\'‘])_(?P<words>[^_]+)_'),\n        ]\n        for word in ITALICIZE_WORDS:\n            html = re.sub(r'(?<=\\s|>)' + re.escape(word) + r'(?=\\s|<)', '<i>%s</i>' % word, html)\n        search_text = re.sub(r'(?s)<head[^>]*>.*?</head>', '', html)\n        search_text = re.sub(r'<[^>]*>', '', search_text)\n        for pat in ITALICIZE_STYLE_PATS:\n            for match in re.finditer(pat, search_text):\n                ital_string = unicode_type(match.group('words'))\n                # self.log.debug(\"italicising \"+unicode_type(match.group(0))+\"    with <i>\"+ital_string+\"</i>\")\n                try:\n                    html = re.sub(re.escape(unicode_type(match.group(0))), '<i>%s</i>' % ital_string, html)\n                except OverflowError:\n                    # match.group(0) was too large to be compiled into a regex\n                    continue\n                except re.error:\n                    # the match was not a valid regular expression\n                    continue\n        return html\n", "docstring": "self.log.debug(\"\\n\\n\\nitalicize debugging \\n\\n\\n\")"}
{"repo": "calibre-master/src/calibre/ebooks/conversion/utils.py", "original_string": "    def markup_pre(self, html):\n        pre = re.compile(r'<pre>', re.IGNORECASE)\n        if len(pre.findall(html)) >= 1:\n            self.log.debug(\"Running Text Processing\")\n            outerhtml = re.compile(r'.*?(?<=<pre>)(?P<text>.*?)</pre>', re.IGNORECASE|re.DOTALL)\n            html = outerhtml.sub(self.txt_process, html)\n            from calibre.ebooks.conversion.preprocess import convert_entities\n            html = re.sub(r'&(\\S+?);', convert_entities, html)\n        else:\n            # Add markup naively\n            # TODO - find out if there are cases where there are more than one <pre> tag or\n            # other types of unmarked html and handle them in some better fashion\n            add_markup = re.compile('(?<!>)(\\n)')\n            html = add_markup.sub('</p>\\n<p>', html)\n        return html\n", "docstring": "pre = re.compile(r'<pre>', re.IGNORECASE)"}
{"repo": "calibre-master/src/calibre/ebooks/conversion/utils.py", "original_string": "    def cleanup_required(self):\n        for option in ['unwrap_lines', 'markup_chapter_headings', 'format_scene_breaks', 'delete_blank_paragraphs']:\n            if getattr(self.extra_opts, option, False):\n                return True\n        return False\n", "docstring": "for option in ['unwrap_lines', 'markup_chapter_headings', 'format_scene_breaks', 'delete_blank_paragraphs']:"}
{"repo": "calibre-master/src/calibre/ebooks/conversion/config.py", "original_string": "def get_sorted_output_formats(preferred_fmt=None):\n    preferred_output_format = (preferred_fmt or prefs['output_format']).upper()\n    fmts = get_output_formats(preferred_output_format)\n    try:\n        fmts.remove(preferred_output_format)\n    except Exception:\n        pass\n    fmts.insert(0, preferred_output_format)\n    return fmts\n", "docstring": "preferred_output_format = (preferred_fmt or prefs['output_format']).upper()"}
{"repo": "calibre-master/src/calibre/ebooks/conversion/__init__.py", "original_string": "    def __init__(self, title, msg, level='info', det_msg=''):\n        ''' Show a simple message to the user\n        :param title: The title (very short description)\n        :param msg: The message to show the user\n        :param level: Must be one of 'info', 'warn' or 'error'\n        :param det_msg: Optional detailed message to show the user\n        '''\n        import json\n        Exception.__init__(self, json.dumps({'msg':msg, 'level':level,\n            'det_msg':det_msg, 'title':title}))\n        self.title, self.msg, self.det_msg = title, msg, det_msg\n        self.level = level\n", "docstring": "Show a simple message to the user"}
{"repo": "calibre-master/src/calibre/ebooks/conversion/plugins/epub_input.py", "original_string": "    def rationalize_cover3(self, opf, log):\n        ''' If there is a reference to the cover/titlepage via manifest properties, convert to\n        entries in the <guide> so that the rest of the pipeline picks it up. '''\n        from calibre.ebooks.metadata.opf3 import items_with_property\n        removed = guide_titlepage_href = guide_titlepage_id = None\n        # Look for titlepages incorrectly marked in the <guide> as covers\n        guide_cover, guide_elem = None, None\n        for guide_elem in opf.iterguide():\n            if guide_elem.get('type', '').lower() == 'cover':\n                guide_cover = guide_elem.get('href', '').partition('#')[0]\n                break\n        if guide_cover:\n            spine = list(opf.iterspine())\n            if spine:\n                idref = spine[0].get('idref', '')\n                for x in opf.itermanifest():\n                    if x.get('id') == idref and x.get('href') == guide_cover:\n                        guide_titlepage_href = guide_cover\n                        guide_titlepage_id = idref\n                        break\n        raster_cover_href = opf.epub3_raster_cover or opf.raster_cover\n        if raster_cover_href:\n            self.set_guide_type(opf, 'cover', raster_cover_href, 'Cover Image')\n        titlepage_id = titlepage_href = None\n        for item in items_with_property(opf.root, 'calibre:title-page'):\n            tid, href = item.get('id'), item.get('href')\n            if href and tid:\n                titlepage_id, titlepage_href = tid, href.partition('#')[0]\n                break\n        if titlepage_href is None:\n            titlepage_href, titlepage_id = guide_titlepage_href, guide_titlepage_id\n        if titlepage_href is not None:\n            self.set_guide_type(opf, 'titlepage', titlepage_href, 'Title page')\n            spine = list(opf.iterspine())\n            if len(spine) > 1:\n                for item in spine:\n                    if item.get('idref') == titlepage_id:\n                        log('Found HTML cover', titlepage_href)\n                        if self.for_viewer:\n                            item.attrib.pop('linear', None)\n                        else:\n                            item.getparent().remove(item)\n                            removed = titlepage_href\n                        return removed\n", "docstring": "If there is a reference to the cover/titlepage via manifest properties, convert to"}
{"repo": "calibre-master/src/calibre/ebooks/conversion/plugins/pdf_output.py", "original_string": "    def specialize_options(self, log, opts, input_fmt):\n        # Ensure Qt is setup to be used with WebEngine\n        # specialize_options is called early enough in the pipeline\n        # that hopefully no Qt application has been constructed as yet\n        from qt.webengine import QWebEngineUrlScheme\n        from qt.webengine import QWebEnginePage  # noqa\n        from calibre.gui2 import must_use_qt\n        from calibre.constants import FAKE_PROTOCOL\n        scheme = QWebEngineUrlScheme(FAKE_PROTOCOL.encode('ascii'))\n        scheme.setSyntax(QWebEngineUrlScheme.Syntax.Host)\n        scheme.setFlags(QWebEngineUrlScheme.Flag.SecureScheme)\n        QWebEngineUrlScheme.registerScheme(scheme)\n        must_use_qt()\n        self.input_fmt = input_fmt\n        if opts.pdf_use_document_margins:\n            # Prevent the conversion pipeline from overwriting document margins\n            opts.margin_left = opts.margin_right = opts.margin_top = opts.margin_bottom = -1\n", "docstring": "Ensure Qt is setup to be used with WebEngine"}
{"repo": "calibre-master/src/calibre/ebooks/conversion/plugins/pdf_output.py", "original_string": "    def process_fonts(self):\n        ''' Make sure all fonts are embeddable '''\n        from calibre.ebooks.oeb.base import urlnormalize\n        from calibre.utils.fonts.utils import remove_embed_restriction\n        processed = set()\n        for item in list(self.oeb.manifest):\n            if not hasattr(item.data, 'cssRules'):\n                continue\n            for i, rule in enumerate(item.data.cssRules):\n                if rule.type == rule.FONT_FACE_RULE:\n                    try:\n                        s = rule.style\n                        src = s.getProperty('src').propertyValue[0].uri\n                    except:\n                        continue\n                    path = item.abshref(src)\n                    ff = self.oeb.manifest.hrefs.get(urlnormalize(path), None)\n                    if ff is None:\n                        continue\n                    raw = nraw = ff.data\n                    if path not in processed:\n                        processed.add(path)\n                        try:\n                            nraw = remove_embed_restriction(raw)\n                        except:\n                            continue\n                        if nraw != raw:\n                            ff.data = nraw\n                            self.oeb.container.write(path, nraw)\n", "docstring": "Make sure all fonts are embeddable '''"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/utils.py", "original_string": "def count_set_bits(num):\n    if num < 0:\n        num = -num\n    ans = 0\n    while num > 0:\n        ans += (num & 0b1)\n        num >>= 1\n    return ans\n", "docstring": "if num < 0:"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/utils.py", "original_string": "    def __init__(self, strings=()):\n        self.strings = OrderedDict((s, 0) for s in strings)\n        self.records = []\n        offset = 0\n        buf = BytesIO()\n        RECORD_LIMIT = 0x10000 - 1024  # kindlegen appears to use 1024, PDB limit is 0x10000\n        for key in self.strings:\n            utf8 = utf8_text(key[:self.MAX_STRING_LENGTH])\n            l = len(utf8)\n            sz_bytes = encint(l)\n            raw = sz_bytes + utf8\n            if buf.tell() + len(raw) > RECORD_LIMIT:\n                self.records.append(align_block(buf.getvalue()))\n                buf.seek(0), buf.truncate(0)\n                offset = len(self.records) * 0x10000\n            buf.write(raw)\n            self.strings[key] = offset\n            offset += len(raw)\n        val = buf.getvalue()\n        if val:\n            self.records.append(align_block(val))\n", "docstring": "self.strings = OrderedDict((s, 0) for s in strings)"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/writer8/skeleton.py", "original_string": "    def set_internal_links(self, text, rebuilt_text):\n        ''' Update the internal link placeholders to point to the correct\n        location, based on the chunk table.'''\n        # A kindle:pos:fid:off link contains two base 32 numbers of the form\n        # XXXX:YYYYYYYYYY\n        # The first number is an index into the chunk table and the second is\n        # an offset from the start of the chunk to the start of the tag pointed\n        # to by the link.\n        aid_map = PolyglotDict()  # Map of aid to (fid, offset_from_start_of_chunk, offset_from_start_of_text)\n        for match in re.finditer(br'<[^>]+? [ac]id=[\\'\"]([cA-Z0-9]+)[\\'\"]', rebuilt_text):\n            offset = match.start()\n            pos_fid = None\n            for chunk in self.chunk_table:\n                if chunk.insert_pos <= offset < chunk.insert_pos + chunk.length:\n                    pos_fid = (chunk.sequence_number, offset-chunk.insert_pos,\n                            offset)\n                    break\n                if chunk.insert_pos > offset:\n                    # This aid is in the skeleton, not in a chunk, so we use\n                    # the chunk immediately after\n                    pos_fid = (chunk.sequence_number, 0, offset)\n                    break\n                if chunk is self.chunk_table[-1]:\n                    # This can happen for aids very close to the end of the\n                    # text (https://bugs.launchpad.net/bugs/1011330)\n                    pos_fid = (chunk.sequence_number, offset-chunk.insert_pos,\n                            offset)\n            if pos_fid is None:\n                raise ValueError('Could not find chunk for aid: %r'%\n                        match.group(1))\n            aid_map[match.group(1)] = pos_fid\n        self.aid_offset_map = aid_map\n        def to_placeholder(aid):\n            pos, fid, _ = aid_map[aid]\n            pos, fid = to_base(pos, min_num_digits=4), to_href(fid)\n            return ':off:'.join((pos, fid)).encode('utf-8')\n        placeholder_map = {as_bytes(k):to_placeholder(v) for k, v in\n                iteritems(self.placeholder_map)}\n        # Now update the links\n        def sub(match):\n            raw = match.group()\n            pl = match.group(1)\n            try:\n                return raw[:-19] + placeholder_map[pl]\n            except KeyError:\n                pass\n            return raw\n        return re.sub(br'<[^>]+(kindle:pos:fid:0000:off:[0-9A-Za-z]{10})', sub,\n                text)\n", "docstring": "Update the internal link placeholders to point to the correct"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/writer8/main.py", "original_string": "    def replace_resource_links(self):\n        ''' Replace links to resources (raster images/fonts) with pointers to\n        the MOBI record containing the resource. The pointers are of the form:\n        kindle:embed:XXXX?mime=image/* The ?mime= is apparently optional and\n        not used for fonts. '''\n        def pointer(item, oref):\n            ref = urlnormalize(item.abshref(oref))\n            idx = self.resources.item_map.get(ref, None)\n            if idx is not None:\n                is_image = self.resources.records[idx-1][:4] not in {b'FONT'}\n                idx = to_ref(idx)\n                if is_image:\n                    self.used_images.add(ref)\n                    return 'kindle:embed:%s?mime=%s'%(idx,\n                            self.resources.mime_map[ref])\n                else:\n                    return 'kindle:embed:%s'%idx\n            return oref\n        for item in self.oeb.manifest:\n            if item.media_type in XML_DOCS:\n                root = self.data(item)\n                for tag in XPath('//h:img|//svg:image')(root):\n                    for attr, ref in iteritems(tag.attrib):\n                        if attr.split('}')[-1].lower() in {'src', 'href'}:\n                            tag.attrib[attr] = pointer(item, ref)\n                for tag in XPath('//h:style')(root):\n                    if tag.text:\n                        sheet = css_parser.parseString(tag.text, validate=False)\n                        replacer = partial(pointer, item)\n                        css_parser.replaceUrls(sheet, replacer,\n                                ignoreImportRules=True)\n                        repl = sheet.cssText\n                        if isbytestring(repl):\n                            repl = repl.decode('utf-8')\n                        tag.text = '\\n'+ repl + '\\n'\n            elif item.media_type in OEB_STYLES:\n                sheet = self.data(item)\n                replacer = partial(pointer, item)\n                css_parser.replaceUrls(sheet, replacer, ignoreImportRules=True)\n", "docstring": "Replace links to resources (raster images/fonts) with pointers to"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/writer8/tbs.py", "original_string": "def encode_strands_as_sequences(strands, tbs_type=8):\n    ''' Encode the list of strands for a single text record into a list of\n    sequences, ready to be converted into TBS bytes.    '''\n    ans = []\n    last_index = None\n    max_length_offset = 0\n    first_entry = None\n    for strand in strands:\n        for entries in itervalues(strand):\n            for entry in entries:\n                if first_entry is None:\n                    first_entry = entry\n                if entry.length_offset > max_length_offset:\n                    max_length_offset = entry.length_offset\n    for strand in strands:\n        strand_seqs = []\n        for depth, entries in iteritems(strand):\n            extra = {}\n            if entries[-1].action == 'spans':\n                extra[0b1] = 0\n            elif False and (\n                    entries[-1].length_offset < entries[-1].text_record_length and\n                    entries[-1].action == 'completes' and\n                    entries[-1].length_offset != max_length_offset):\n                # I can't figure out exactly when kindlegen decides to insert\n                # this, so disable it for now.\n                extra[0b1] = entries[-1].length_offset\n            if entries[0] is first_entry:\n                extra[0b10] = tbs_type\n            if len(entries) > 1:\n                extra[0b100] = len(entries)\n            index = entries[0].index - (entries[0].parent or 0)\n            if ans and not strand_seqs:\n                # We are in the second or later strands, so we need to use a\n                # special flag and index value. The index value is the entry\n                # index - the index of the last entry in the previous strand.\n                index = last_index - entries[0].index\n                if index < 0:\n                    if tbs_type == 5:\n                        index = -index\n                    else:\n                        raise NegativeStrandIndex()\n                else:\n                    extra[0b1000] = True\n            last_index = entries[-1].index\n            strand_seqs.append((index, extra))\n        # Handle the case of consecutive action == 'spans' entries. In this\n        # case, the 0b1 = 0 flag should be present only in the last consecutive\n        # spans entry.\n        for i, seq in enumerate(strand_seqs):\n            if i + 1 < len(strand_seqs):\n                if 0b1 in seq[1] and 0b1 in strand_seqs[i+1][1]:\n                    del seq[1][0b1]\n        ans.extend(strand_seqs)\n    return ans\n", "docstring": "Encode the list of strands for a single text record into a list of"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/writer8/mobi.py", "original_string": "    def record0(self):\n        ''' We generate the EXTH header and record0 dynamically, to allow other\n        code to customize various values after build_records() has been\n        called'''\n        opts = self.opts\n        self.exth = build_exth(\n            self.metadata,\n            prefer_author_sort=opts.prefer_author_sort,\n            is_periodical=opts.mobi_periodical,\n            share_not_sync=opts.share_not_sync,\n            cover_offset=self.cover_offset,\n            thumbnail_offset=self.thumbnail_offset,\n            num_of_resources=self.num_of_resources,\n            kf8_unknown_count=self.kuc, be_kindlegen2=True,\n            start_offset=self.start_offset, mobi_doctype=self.book_type,\n            page_progression_direction=self.page_progression_direction,\n            primary_writing_mode=self.primary_writing_mode\n        )\n        kwargs = {field:getattr(self, field) for field in HEADER_FIELDS}\n        return MOBIHeader()(**kwargs)\n", "docstring": "We generate the EXTH header and record0 dynamically, to allow other"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/reader/headers.py", "original_string": "def uniq(vals):\n    ''' Remove all duplicates from vals, while preserving order.  '''\n    vals = vals or ()\n    seen = set()\n    seen_add = seen.add\n    return list(x for x in vals if x not in seen and not seen_add(x))\n", "docstring": "Remove all duplicates from vals, while preserving order.  '''"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/reader/mobi8.py", "original_string": "    def get_file_info(self, pos):\n        ''' Get information about the part (file) that exists at pos in\n        the raw markup '''\n        for part in self.partinfo:\n            if pos >= part.start and pos < part.end:\n                return part\n        return Part(*repeat(None, len(Part._fields)))\n", "docstring": "Get information about the part (file) that exists at pos in"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/reader/mobi8.py", "original_string": "    def get_id_tag(self, pos):\n        # Find the first tag with a named anchor (name or id attribute) before\n        # pos\n        fi = self.get_file_info(pos)\n        if fi.num is None and fi.start is None:\n            raise ValueError('No file contains pos: %d'%pos)\n        textblock = self.parts[fi.num]\n        npos = pos - fi.start\n        pgt = textblock.find(b'>', npos)\n        plt = textblock.find(b'<', npos)\n        # if npos inside a tag then search all text before the its end of tag marker\n        # else not in a tag need to search the preceding tag\n        if plt == npos or pgt < plt:\n            npos = pgt + 1\n        textblock = textblock[0:npos]\n        for tag in reverse_tag_iter(textblock):\n            m = self.id_re.match(tag) or self.name_re.match(tag)\n            if m is not None:\n                return m.group(1)\n            # For some files, kindlegen apparently creates links to tags\n            # without HTML anchors, using the AID instead. See\n            # See https://www.mobileread.com/forums/showthread.php?t=259557\n            m = self.aid_re.match(tag)\n            if m is not None:\n                self.linked_aids.add(m.group(1).decode('utf-8'))\n                return m.group(1) + b'-' + self.aid_anchor_suffix\n        # No tag found, link to start of file\n        return b''\n", "docstring": "Find the first tag with a named anchor (name or id attribute) before"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/reader/markup.py", "original_string": "def update_internal_links(mobi8_reader, log):\n    # need to update all links that are internal which\n    # are based on positions within the xhtml files **BEFORE**\n    # cutting and pasting any pieces into the xhtml text files\n    #   kindle:pos:fid:XXXX:off:YYYYYYYYYY  (used for internal link within xhtml)\n    #       XXXX is the offset in records into divtbl\n    #       YYYYYYYYYYYY is a base32 number you add to the divtbl insertpos to get final position\n    mr = mobi8_reader\n    # pos:fid pattern\n    posfid_pattern = re.compile(br'''(<a.*?href=.*?>)''', re.IGNORECASE)\n    posfid_index_pattern = re.compile(br'''['\"]kindle:pos:fid:([0-9|A-V]+):off:([0-9|A-V]+).*?[\"']''')\n    parts = []\n    for part in mr.parts:\n        srcpieces = posfid_pattern.split(part)\n        for j in range(1, len(srcpieces), 2):\n            tag = srcpieces[j]\n            if tag.startswith(b'<'):\n                for m in posfid_index_pattern.finditer(tag):\n                    posfid = m.group(1)\n                    offset = m.group(2)\n                    try:\n                        filename, idtag = mr.get_id_tag_by_pos_fid(\n                            int(posfid, 32), int(offset, 32))\n                    except ValueError:\n                        log.warn('Invalid link, points to nowhere, ignoring')\n                        replacement = b'#'\n                    else:\n                        suffix = (b'#' + idtag) if idtag else b''\n                        replacement = filename.split('/')[-1].encode(\n                                mr.header.codec) + suffix\n                        replacement = replacement.replace(b'\"', b'&quot;')\n                    tag = posfid_index_pattern.sub(b'\"' + replacement + b'\"', tag, 1)\n                srcpieces[j] = tag\n        raw = b''.join(srcpieces)\n        try:\n            parts.append(raw.decode(mr.header.codec))\n        except UnicodeDecodeError:\n            log.warn('Failed to decode text in KF8 part, replacing bad bytes')\n            parts.append(raw.decode(mr.header.codec, 'replace'))\n    # All parts are now unicode and have no internal links\n    return parts\n", "docstring": "need to update all links that are internal which"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/reader/markup.py", "original_string": "def insert_images_into_markup(parts, resource_map, log):\n    # Handle any embedded raster images links in the xhtml text\n    # kindle:embed:XXXX?mime=image/gif (png, jpeg, etc) (used for images)\n    img_pattern = re.compile(r'''(<[img\\s|image\\s][^>]*>)''', re.IGNORECASE)\n    img_index_pattern = re.compile(r'''[('\"]kindle:embed:([0-9|A-V]+)[^')\"]*[)'\"]''')\n    style_pattern = re.compile(r'''(<[a-zA-Z0-9]+\\s[^>]*style\\s*=\\s*[^>]*>)''',\n            re.IGNORECASE)\n    for i in range(len(parts)):\n        part = parts[i]\n        srcpieces = img_pattern.split(part)\n        for j in range(1, len(srcpieces), 2):\n            tag = srcpieces[j]\n            if tag.startswith('<im'):\n                for m in img_index_pattern.finditer(tag):\n                    num = int(m.group(1), 32)\n                    href = resource_map[num-1]\n                    if href:\n                        replacement = '\"%s\"'%('../' + href)\n                        tag = img_index_pattern.sub(replacement, tag, 1)\n                    else:\n                        log.warn('Referenced image %s was not recognized as '\n                                'a valid image in %s' % (num, tag))\n                srcpieces[j] = tag\n        part = \"\".join(srcpieces)\n        # store away modified version\n        parts[i] = part\n    # Replace urls used in style attributes\n    for i in range(len(parts)):\n        part = parts[i]\n        srcpieces = style_pattern.split(part)\n        for j in range(1, len(srcpieces), 2):\n            tag = srcpieces[j]\n            if 'kindle:embed' in tag:\n                for m in img_index_pattern.finditer(tag):\n                    num = int(m.group(1), 32)\n                    href = resource_map[num-1]\n                    osep = m.group()[0]\n                    csep = m.group()[-1]\n                    if href:\n                        replacement = '%s%s%s'%(osep, '../' + href, csep)\n                        tag = img_index_pattern.sub(replacement, tag, 1)\n                    else:\n                        log.warn('Referenced image %s was not recognized as '\n                                'a valid image in %s' % (num, tag))\n                srcpieces[j] = tag\n        part = \"\".join(srcpieces)\n        # store away modified version\n        parts[i] = part\n", "docstring": "Handle any embedded raster images links in the xhtml text"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/writer2/serializer.py", "original_string": "        def spine_item(tocitem):\n            href = urldefrag(tocitem.href)[0]\n            for item in self.oeb.spine:\n                if item.href == href:\n                    return item\n", "docstring": "href = urldefrag(tocitem.href)[0]"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/writer2/serializer.py", "original_string": "    def serialize_elem(self, elem, item, nsrmap=NSRMAP):\n        buf = self.buf\n        if not isinstance(elem.tag, string_or_bytes) \\\n            or namespace(elem.tag) not in nsrmap:\n            return\n        tag = prefixname(elem.tag, nsrmap)\n        # Previous layers take care of @name\n        id_ = elem.attrib.pop('id', None)\n        if id_:\n            href = '#'.join((item.href, id_))\n            offset = self.anchor_offset or buf.tell()\n            key = urlnormalize(href)\n            # Only set this id_offset if it wasn't previously seen\n            self.id_offsets[key] = self.id_offsets.get(key, offset)\n        if self.anchor_offset is not None and \\\n            tag == 'a' and not elem.attrib and \\\n            not len(elem) and not elem.text:\n            return\n        self.anchor_offset = buf.tell()\n        buf.write(b'<')\n        buf.write(tag.encode('utf-8'))\n        if elem.attrib:\n            for attr, val in elem.attrib.items():\n                if namespace(attr) not in nsrmap:\n                    continue\n                attr = prefixname(attr, nsrmap)\n                buf.write(b' ')\n                if attr == 'href':\n                    if self.serialize_href(val, item):\n                        continue\n                elif attr == 'src':\n                    href = urlnormalize(item.abshref(val))\n                    if href in self.images:\n                        index = self.images[href]\n                        self.used_images.add(href)\n                        buf.write(b'recindex=\"%05d\"' % index)\n                        continue\n                buf.write(attr.encode('utf-8'))\n                buf.write(b'=\"')\n                self.serialize_text(val, quot=True)\n                buf.write(b'\"')\n        buf.write(b'>')\n        if elem.text or len(elem) > 0:\n            if elem.text:\n                self.anchor_offset = None\n                self.serialize_text(elem.text)\n            for child in elem:\n                self.serialize_elem(child, item)\n                if child.tail:\n                    self.anchor_offset = None\n                    self.serialize_text(child.tail)\n        buf.write(('</%s>' % tag).encode('utf-8'))\n", "docstring": "buf = self.buf"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/writer2/resources.py", "original_string": "    def __bool__(self):\n        return bool(self.records)\n", "docstring": "return bool(self.records)"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/writer2/main.py", "original_string": "    def generate_images(self):\n        resources = self.resources\n        image_records = resources.records\n        self.image_map = resources.item_map\n        self.masthead_offset = resources.masthead_offset\n        self.cover_offset = resources.cover_offset\n        self.thumbnail_offset = resources.thumbnail_offset\n        if image_records and image_records[0] is None:\n            raise ValueError('Failed to find masthead image in manifest')\n", "docstring": "resources = self.resources"}
{"repo": "calibre-master/src/calibre/ebooks/mobi/writer2/indexer.py", "original_string": "    def __init__(self, offset, label_offset):\n        self.offset, self.label_offset = offset, label_offset\n        self.depth, self.class_offset = 0, None\n        self.control_byte_count = 1\n        self.length = 0\n        self.index = 0\n        self.parent_index = None\n        self.first_child_index = None\n        self.last_child_index = None\n        self.image_index = None\n        self.author_offset = None\n        self.desc_offset = None\n", "docstring": "self.offset, self.label_offset = offset, label_offset"}
{"repo": "calibre-master/src/calibre/ebooks/chm/reader.py", "original_string": "    def GetFile(self, path):\n        # have to have abs paths for ResolveObject, but Contents() deliberately\n        # makes them relative. So we don't have to worry, re-add the leading /.\n        # note this path refers to the internal CHM structure\n        if path[0] != '/':\n            path = '/' + path\n        res, ui = self.ResolveObject(path)\n        if res != chmlib.CHM_RESOLVE_SUCCESS:\n            raise CHMError(f\"Unable to locate {path!r} within CHM file {self.filename!r}\")\n        size, data = self.RetrieveObject(ui)\n        if size == 0:\n            raise CHMError(f\"{path!r} is zero bytes in length!\")\n        return data\n", "docstring": "have to have abs paths for ResolveObject, but Contents() deliberately"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/writer.py", "original_string": "    def config(cls, cfg):\n        \"\"\"Add any book-writing options to the :class:`Config` object\n        :param:`cfg`.\n        \"\"\"\n        oeb = cfg.add_group('oeb', _('OPF/NCX/etc. generation options.'))\n        versions = ['1.2', '2.0']\n        oeb('opf_version', ['--opf-version'], default='2.0', choices=versions,\n            help=_('OPF version to generate. Default is %default.'))\n        oeb('adobe_page_map', ['--adobe-page-map'], default=False,\n            help=_('Generate an Adobe \"page-map\" file if pagination '\n                   'information is available.'))\n        return cfg\n", "docstring": "Add any book-writing options to the :class:`Config` object"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/writer.py", "original_string": "    def generate(cls, opts):\n        \"\"\"Generate a Writer instance from command-line options.\"\"\"\n        version = opts.opf_version\n        page_map = opts.adobe_page_map\n        pretty_print = opts.pretty_print\n        return cls(version=version, page_map=page_map,\n                   pretty_print=pretty_print)\n", "docstring": "Generate a Writer instance from command-line options.\n"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "    def link_repl(href):\n        return urljoin(base_url, href)\n", "docstring": "return urljoin(base_url, href)"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "def urlquote(href):\n    \"\"\" Quote URL-unsafe characters, allowing IRI-safe characters.\n    That is, this function returns valid IRIs not valid URIs. In particular,\n    IRIs can contain non-ascii characters.  \"\"\"\n    result = []\n    isbytes = isinstance(href, bytes)\n    unsafe = URL_UNSAFE[int(isbytes)]\n    esc, join = \"%%%02x\", ''\n    if isbytes:\n        esc, join = esc.encode('ascii'), b''\n    for char in href:\n        if char in unsafe:\n            char = esc % ord(char)\n        result.append(char)\n    return join.join(result)\n", "docstring": "Quote URL-unsafe characters, allowing IRI-safe characters."}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "    def __init__(self):\n        logging.Handler.__init__(self, logging.WARNING)\n        self.setFormatter(logging.Formatter('%(message)s'))\n        self.log = None\n", "docstring": "logging.Handler.__init__(self, logging.WARNING)"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "        def data(self):\n            \"\"\"Provides MIME type sensitive access to the manifest\n            entry's associated content.\n            - XHTML, HTML, and variant content is parsed as necessary to\n              convert and return as an lxml.etree element in the XHTML\n              namespace.\n            - XML content is parsed and returned as an lxml.etree element.\n            - CSS and CSS-variant content is parsed and returned as a css_parser\n              CSS DOM stylesheet.\n            - All other content is returned as a :class:`str` or :class:`bytes`\n              object with no special parsing.\n            \"\"\"\n            data = self._data\n            if data is None:\n                if self._loader is None:\n                    return None\n                data = self._loader(getattr(self, 'html_input_href',\n                    self.href))\n            try:\n                mt = self.media_type.lower()\n            except Exception:\n                mt = 'application/octet-stream'\n            if not isinstance(data, string_or_bytes):\n                pass  # already parsed\n            elif mt in OEB_DOCS:\n                data = self._parse_xhtml(data)\n            elif mt[-4:] in ('+xml', '/xml'):\n                data = self._parse_xml(data)\n            elif mt in OEB_STYLES:\n                data = self._parse_css(data)\n            elif mt == 'text/plain':\n                self.oeb.log.warn('%s contains data in TXT format'%self.href,\n                        'converting to HTML')\n                data = self._parse_txt(data)\n                self.media_type = XHTML_MIME\n            self._data = data\n            return data\n", "docstring": "Provides MIME type sensitive access to the manifest"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "        def abshref(self, href):\n            \"\"\"Convert the URL provided in :param:`href` from a reference\n            relative to this manifest item to a book-absolute reference.\n            \"\"\"\n            try:\n                purl = urlparse(href)\n            except ValueError:\n                return href\n            scheme = purl.scheme\n            if scheme and scheme != 'file':\n                return href\n            purl = list(purl)\n            purl[0] = ''\n            href = urlunparse(purl)\n            path, frag = urldefrag(href)\n            if not path:\n                if frag:\n                    return '#'.join((self.href, frag))\n                else:\n                    return self.href\n            if '/' not in self.href:\n                return href\n            dirname = os.path.dirname(self.href)\n            href = os.path.join(dirname, href)\n            href = os.path.normpath(href).replace('\\\\', '/')\n            return href\n", "docstring": "Convert the URL provided in :param:`href` from a reference"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "    def add(self, id, href, media_type, fallback=None, loader=None, data=None):\n        \"\"\"Add a new item to the book manifest.\n        The item's :param:`id`, :param:`href`, and :param:`media_type` are all\n        required.  A :param:`fallback` item-id is required for any items with a\n        MIME type which is not one of the OPS core media types.  Either the\n        item's data itself may be provided with :param:`data`, or a loader\n        function for the data may be provided with :param:`loader`, or the\n        item's data may later be set manually via the :attr:`data` attribute.\n        \"\"\"\n        item = self.Item(\n            self.oeb, id, href, media_type, fallback, loader, data)\n        self.items.add(item)\n        self.ids[item.id] = item\n        self.hrefs[item.href] = item\n        return item\n", "docstring": "Add a new item to the book manifest."}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "    def add(self, item, linear=None):\n        \"\"\"Append :param:`item` to the end of the `Spine`.\"\"\"\n        item.linear = self._linear(linear)\n        item.spine_position = len(self.items)\n        self.items.append(item)\n        return item\n", "docstring": "Append :param:`item` to the end of the `Spine`.\n"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "    def remove(self, item):\n        \"\"\"Remove :param:`item` from the `Spine`.\"\"\"\n        index = item.spine_position\n        self.items.pop(index)\n        for i in range(index, len(self.items)):\n            self.items[i].spine_position = i\n        item.spine_position = None\n", "docstring": "Remove :param:`item` from the `Spine`.\n"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "        def item(self):\n            \"\"\"The manifest item associated with this reference.\"\"\"\n            path = urldefrag(self.href)[0]\n            hrefs = self.oeb.manifest.hrefs\n            return hrefs.get(path, None)\n", "docstring": "The manifest item associated with this reference.\n"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "    def add(self, type, title, href):\n        \"\"\"Add a new reference to the `Guide`.\"\"\"\n        if href:\n            href = unicode_type(href)\n        ref = self.Reference(self.oeb, type, title, href)\n        self.refs[type] = ref\n        return ref\n", "docstring": "Add a new reference to the `Guide`.\n"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "    def iterdescendants(self, breadth_first=False):\n        \"\"\"Iterate over all descendant nodes in depth-first order.\"\"\"\n        if breadth_first:\n            for child in self.nodes:\n                yield child\n            for child in self.nodes:\n                for node in child.iterdescendants(breadth_first=True):\n                    yield node\n        else:\n            for child in self.nodes:\n                for node in child.iter():\n                    yield node\n", "docstring": "Iterate over all descendant nodes in depth-first order.\n"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "    def depth(self):\n        \"\"\"The maximum depth of the navigation tree rooted at this node.\"\"\"\n        try:\n            return max(node.depth() for node in self.nodes) + 1\n        except ValueError:\n            return 1\n", "docstring": "The maximum depth of the navigation tree rooted at this node.\n"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "    def add(self, name, href, type='normal', klass=None, id=None):\n        \"\"\"Create a new page and add it to the `PageList`.\"\"\"\n        page = self.Page(name, href, type, klass, id)\n        self.pages.append(page)\n        return page\n", "docstring": "Create a new page and add it to the `PageList`.\n"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "    def generate(cls, opts):\n        \"\"\"Generate an OEBBook instance from command-line options.\"\"\"\n        encoding = opts.encoding\n        pretty_print = opts.pretty_print\n        return cls(encoding=encoding, pretty_print=pretty_print)\n", "docstring": "Generate an OEBBook instance from command-line options.\n"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "    def decode(self, data):\n        \"\"\"Automatically decode :param:`data` into a `unicode` object.\"\"\"\n        def fix_data(d):\n            return d.replace('\\r\\n', '\\n').replace('\\r', '\\n')\n        if isinstance(data, unicode_type):\n            return fix_data(data)\n        bom_enc = None\n        if data[:4] in (b'\\0\\0\\xfe\\xff', b'\\xff\\xfe\\0\\0'):\n            bom_enc = {b'\\0\\0\\xfe\\xff':'utf-32-be',\n                    b'\\xff\\xfe\\0\\0':'utf-32-le'}[data[:4]]\n            data = data[4:]\n        elif data[:2] in (b'\\xff\\xfe', b'\\xfe\\xff'):\n            bom_enc = {b'\\xff\\xfe':'utf-16-le', 'b\\xfe\\xff':'utf-16-be'}[data[:2]]\n            data = data[2:]\n        elif data[:3] == b'\\xef\\xbb\\xbf':\n            bom_enc = 'utf-8'\n            data = data[3:]\n        if bom_enc is not None:\n            try:\n                return fix_data(data.decode(bom_enc))\n            except UnicodeDecodeError:\n                pass\n        if self.input_encoding:\n            try:\n                return fix_data(data.decode(self.input_encoding, 'replace'))\n            except UnicodeDecodeError:\n                pass\n        try:\n            return fix_data(data.decode('utf-8'))\n        except UnicodeDecodeError:\n            pass\n        data, _ = xml_to_unicode(data)\n        return fix_data(data)\n", "docstring": "Automatically decode :param:`data` into a `unicode` object.\n"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/base.py", "original_string": "    def to_opf2(self, page_map=False):\n        \"\"\"Produce OPF 2.0 representing the book's metadata and structure.\n        Returns a dictionary in which the keys are MIME types and the values\n        are tuples of (default) filenames and lxml.etree element structures.\n        \"\"\"\n        results = {}\n        package = etree.Element(OPF('package'),\n            attrib={'version': '2.0', 'unique-identifier': self.uid.id},\n            nsmap={None: OPF2_NS})\n        self.metadata.to_opf2(package)\n        manifest = self.manifest.to_opf2(package)\n        spine = self.spine.to_opf2(package)\n        self.guide.to_opf2(package)\n        results[OPF_MIME] = ('content.opf', package)\n        id, href = self.manifest.generate('ncx', 'toc.ncx')\n        etree.SubElement(manifest, OPF('item'), id=id, href=href,\n                         attrib={'media-type': NCX_MIME})\n        spine.attrib['toc'] = id\n        results[NCX_MIME] = (href, self._to_ncx())\n        if page_map and len(self.pages) > 0:\n            id, href = self.manifest.generate('page-map', 'page-map.xml')\n            etree.SubElement(manifest, OPF('item'), id=id, href=href,\n                             attrib={'media-type': PAGE_MAP_MIME})\n            spine.attrib['page-map'] = id\n            results[PAGE_MAP_MIME] = (href, self.pages.to_page_map())\n        if self.spine.page_progression_direction in {'ltr', 'rtl'}:\n            spine.attrib['page-progression-direction'] = self.spine.page_progression_direction\n        return results\n", "docstring": "Produce OPF 2.0 representing the book's metadata and structure."}
{"repo": "calibre-master/src/calibre/ebooks/oeb/stylizer.py", "original_string": "    def fontSize(self):\n        def normalize_fontsize(value, base):\n            value = value.replace('\"', '').replace(\"'\", '')\n            result = None\n            factor = None\n            if value == 'inherit':\n                value = base\n            if value in FONT_SIZE_NAMES:\n                result = self._profile.fnames[value]\n            elif value == 'smaller':\n                factor = 1.0/1.2\n                for _, _, size in self._profile.fsizes:\n                    if base <= size:\n                        break\n                    factor = None\n                    result = size\n            elif value == 'larger':\n                factor = 1.2\n                for _, _, size in reversed(self._profile.fsizes):\n                    if base >= size:\n                        break\n                    factor = None\n                    result = size\n            else:\n                result = self._unit_convert(value, base=base, font=base)\n                if not isinstance(result, numbers.Number):\n                    return base\n                if result < 0:\n                    result = normalize_fontsize(\"smaller\", base)\n            if factor:\n                result = factor * base\n            return result\n        if self._fontSize is None:\n            result = None\n            parent = self._get_parent()\n            if parent is not None:\n                base = parent.fontSize\n            else:\n                base = self._profile.fbase\n            if 'font-size' in self._style:\n                size = self._style['font-size']\n                result = normalize_fontsize(size, base)\n            else:\n                result = base\n            self._fontSize = result\n        return self._fontSize\n", "docstring": "def normalize_fontsize(value, base):"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/stylizer.py", "original_string": "    def first_vertical_align(self):\n        ''' For docx output where tags are not nested, we cannot directly\n        simulate the HTML vertical-align rendering model. Instead use the\n        approximation of considering the first non-default vertical-align '''\n        val = self['vertical-align']\n        if val != 'baseline':\n            raw_val = self._get('vertical-align')\n            if '%' in raw_val:\n                val = self._unit_convert(raw_val, base=self['line-height'])\n            return val\n        parent = self._get_parent()\n        if parent is not None and 'inline' in parent['display']:\n            return parent.first_vertical_align\n", "docstring": "For docx output where tags are not nested, we cannot directly"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/stylizer.py", "original_string": "    def marginTop(self):\n        return self._unit_convert(\n            self._get('margin-top'), base=self.parent_width)\n", "docstring": "return self._unit_convert("}
{"repo": "calibre-master/src/calibre/ebooks/oeb/reader.py", "original_string": "    def config(cls, cfg):\n        \"\"\"Add any book-reading options to the :class:`Config` object\n        :param:`cfg`.\n        \"\"\"\n        return\n", "docstring": "Add any book-reading options to the :class:`Config` object"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/reader.py", "original_string": "    def generate(cls, opts):\n        \"\"\"Generate a Reader instance from command-line options.\"\"\"\n        return cls()\n", "docstring": "Generate a Reader instance from command-line options.\n"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/normalize_css.py", "original_string": "def normalize_font(cssvalue, font_family_as_list=False):\n    # See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n    composition = font_composition\n    val = css_text(cssvalue)\n    if val == 'inherit':\n        ans = {k:'inherit' for k in composition}\n    elif val in {'caption', 'icon', 'menu', 'message-box', 'small-caption', 'status-bar'}:\n        ans = {k:DEFAULTS[k] for k in composition}\n    else:\n        ans = {k:DEFAULTS[k] for k in composition}\n        ans.update(parse_font(val))\n    if font_family_as_list:\n        if isinstance(ans['font-family'], string_or_bytes):\n            ans['font-family'] = [x.strip() for x in ans['font-family'].split(',')]\n    else:\n        if not isinstance(ans['font-family'], string_or_bytes):\n            ans['font-family'] = serialize_font_family(ans['font-family'])\n    return ans\n", "docstring": "See https://developer.mozilla.org/en-US/docs/Web/CSS/font"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/iterator/spine.py", "original_string": "def character_count(html):\n    ''' Return the number of \"significant\" text characters in a HTML string. '''\n    count = 0\n    strip_space = re.compile(r'\\s+')\n    for match in re.finditer(r'>[^<]+<', html):\n        count += len(strip_space.sub(' ', match.group()))-2\n    return count\n", "docstring": "Return the number of \"significant\" text characters in a HTML string. '''"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/iterator/spine.py", "original_string": "def all_links(html):\n    ''' Return set of all links in the file '''\n    ans = set()\n    for match in re.finditer(\n            r'''<\\s*[Aa]\\s+.*?[hH][Rr][Ee][Ff]\\s*=\\s*(['\"])(.+?)\\1''', html, re.MULTILINE|re.DOTALL):\n        ans.add(replace_entities(match.group(2)))\n    return ans\n", "docstring": "Return set of all links in the file '''"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/transforms/structure.py", "original_string": "    def get_toc_parts_for_xpath(self, expr):\n        # if an attribute is selected by the xpath expr then truncate it\n        # from the path and instead return it as where to find the title text\n        title_attribute_regex = re.compile(r'/@([-\\w]+)$')\n        match = title_attribute_regex.search(expr)\n        if match is not None:\n            return expr[0:match.start()], match.group(1)\n        return expr, None\n", "docstring": "if an attribute is selected by the xpath expr then truncate it"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/transforms/split.py", "original_string": "    def __init__(self, item, page_breaks, page_break_ids, max_flow_size, oeb,\n            opts):\n        self.item           = item\n        self.oeb            = oeb\n        self.opts           = opts\n        self.log            = oeb.log\n        self.page_breaks    = page_breaks\n        self.page_break_ids = page_break_ids\n        self.max_flow_size  = max_flow_size\n        self.base           = item.href\n        self.csp_counter    = 0\n        base, ext = os.path.splitext(self.base)\n        self.base = base.replace('%', '%%')+'_split_%.3d'+ext\n        self.trees = [self.item.data.getroottree()]\n        self.splitting_on_page_breaks = True\n        if self.page_breaks:\n            self.split_on_page_breaks(self.trees[0])\n        self.splitting_on_page_breaks = False\n        if self.max_flow_size > 0:\n            lt_found = False\n            self.log('\\tLooking for large trees in %s...'%item.href)\n            trees = list(self.trees)\n            self.tree_map = {}\n            for i, tree in enumerate(trees):\n                size = len(tostring(tree.getroot()))\n                if size > self.max_flow_size:\n                    self.log('\\tFound large tree #%d'%i)\n                    lt_found = True\n                    self.split_trees = []\n                    self.split_to_size(tree)\n                    self.tree_map[tree] = self.split_trees\n            if not lt_found:\n                self.log('\\tNo large trees found')\n            self.trees = []\n            for x in trees:\n                self.trees.extend(self.tree_map.get(x, [x]))\n        self.was_split = len(self.trees) > 1\n        if self.was_split:\n            self.log('\\tSplit into %d parts'%len(self.trees))\n        self.commit()\n", "docstring": "opts):"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/transforms/subset.py", "original_string": "    def __call__(self, oeb, log, opts):\n        self.oeb, self.log, self.opts = oeb, log, opts\n        self.find_embedded_fonts()\n        if not self.embedded_fonts:\n            self.log.debug('No embedded fonts found')\n            return\n        self.find_style_rules()\n        self.find_font_usage()\n        totals = [0, 0]\n        def remove(font):\n            totals[1] += len(font['item'].data)\n            self.oeb.manifest.remove(font['item'])\n            font['rule'].parentStyleSheet.deleteRule(font['rule'])\n        fonts = {}\n        for font in self.embedded_fonts:\n            item, chars = font['item'], font['chars']\n            if item.href in fonts:\n                fonts[item.href]['chars'] |= chars\n            else:\n                fonts[item.href] = font\n        for font in itervalues(fonts):\n            if not font['chars']:\n                self.log('The font %s is unused. Removing it.'%font['src'])\n                remove(font)\n                continue\n            try:\n                raw, old_stats, new_stats = subset(font['item'].data, font['chars'])\n            except NoGlyphs:\n                self.log('The font %s has no used glyphs. Removing it.'%font['src'])\n                remove(font)\n                continue\n            except UnsupportedFont as e:\n                self.log.warn('The font %s is unsupported for subsetting. %s'%(\n                    font['src'], e))\n                sz = len(font['item'].data)\n                totals[0] += sz\n                totals[1] += sz\n            else:\n                font['item'].data = raw\n                nlen = sum(itervalues(new_stats))\n                olen = sum(itervalues(old_stats))\n                self.log('Decreased the font %s to %.1f%% of its original size'%\n                        (font['src'], nlen/olen *100))\n                totals[0] += nlen\n                totals[1] += olen\n            font['item'].unload_data_from_memory()\n        if totals[0]:\n            self.log('Reduced total font size to %.1f%% of original'%\n                    (totals[0]/totals[1] * 100))\n", "docstring": "self.oeb, self.log, self.opts = oeb, log, opts"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/transforms/jacket.py", "original_string": "def get_rating(rating, rchar, e_rchar):\n    ans = ''\n    try:\n        num = float(rating)/2\n    except:\n        return ans\n    num = max(0, num)\n    num = min(num, 5)\n    if num < 1:\n        return ans\n    ans = (\"%s%s\") % (rchar * int(num), e_rchar * (5 - int(num)))\n    return ans\n", "docstring": "ans = ''"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/transforms/embed_fonts.py", "original_string": "    def process_item(self, item, sheets):\n        ff_rules = []\n        self.current_item = item\n        self.page_sheet = None\n        for sheet in sheets:\n            if 'page_css' in sheet.id:\n                ff_rules.extend(find_font_face_rules(sheet, self.oeb))\n                self.page_sheet = sheet\n        base = {'font-family':['serif'], 'font-weight': '400',\n                'font-style':'normal', 'font-stretch':'normal'}\n        for body in item.data.xpath('//*[local-name()=\"body\"]'):\n            self.find_usage_in(body, base, ff_rules)\n", "docstring": "ff_rules = []"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/toc.py", "original_string": "    def depth(self):\n        \"\"\"The maximum depth of the navigation tree rooted at this node.\"\"\"\n        try:\n            return max(node.depth for node in self) + 1\n        except ValueError:\n            return 1\n", "docstring": "The maximum depth of the navigation tree rooted at this node.\n"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/toc.py", "original_string": "def find_text(node):\n    LIMIT = 200\n    pat = re.compile(r'\\s+')\n    for child in node:\n        if isinstance(child, etree._Element):\n            text = xml2text(child).strip()\n            text = pat.sub(' ', text)\n            if len(text) < 1:\n                continue\n            if len(text) > LIMIT:\n                # Look for less text in a child of this node, recursively\n                ntext = find_text(child)\n                return ntext or (text[:LIMIT] + '...')\n            else:\n                return text\n", "docstring": "LIMIT = 200"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/replace.py", "original_string": "def smarten_punctuation(container, report):\n    from calibre.ebooks.conversion.preprocess import smarten_punctuation\n    smartened = False\n    for path in container.spine_items:\n        name = container.abspath_to_name(path)\n        changed = False\n        with container.open(name, 'r+b') as f:\n            html = container.decode(f.read())\n            newhtml = smarten_punctuation(html, container.log)\n            if newhtml != html:\n                changed = True\n                report(_('Smartened punctuation in: %s')%name)\n                newhtml = strip_encoding_declarations(newhtml)\n                f.seek(0)\n                f.truncate()\n                f.write(codecs.BOM_UTF8 + newhtml.encode('utf-8'))\n        if changed:\n            # Add an encoding declaration (it will be added automatically when\n            # serialized)\n            root = container.parsed(name)\n            for m in root.xpath('descendant::*[local-name()=\"meta\" and @http-equiv]'):\n                m.getparent().remove(m)\n            container.dirty(name)\n            smartened = True\n    if not smartened:\n        report(_('No punctuation that could be smartened found'))\n    return smartened\n", "docstring": "from calibre.ebooks.conversion.preprocess import smarten_punctuation"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/replace.py", "original_string": "def get_recommended_folders(container, names):\n    ''' Return the folders that are recommended for the given filenames. The\n    recommendation is based on where the majority of files of the same type are\n    located in the container. If no files of a particular type are present, the\n    recommended folder is assumed to be the folder containing the OPF file. '''\n    from calibre.ebooks.oeb.polish.utils import guess_type\n    counts = defaultdict(Counter)\n    for name, mt in iteritems(container.mime_map):\n        folder = name.rpartition('/')[0] if '/' in name else ''\n        counts[mt_to_category(container, mt)][folder] += 1\n    try:\n        opf_folder = counts['opf'].most_common(1)[0][0]\n    except KeyError:\n        opf_folder = ''\n    recommendations = {category:counter.most_common(1)[0][0] for category, counter in iteritems(counts)}\n    return {n:recommendations.get(mt_to_category(container, guess_type(os.path.basename(n))), opf_folder) for n in names}\n", "docstring": "Return the folders that are recommended for the given filenames. The"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/cover.py", "original_string": "def is_raster_image(media_type):\n    return media_type and media_type.lower() in {\n        'image/png', 'image/jpeg', 'image/jpg', 'image/gif'}\n", "docstring": "return media_type and media_type.lower() in {"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/utils.py", "original_string": "def apply_func_to_match_groups(match, func=icu_upper, handle_entities=handle_entities):\n    '''Apply the specified function to individual groups in the match object (the result of re.search() or\n    the whole match if no groups were defined. Returns the replaced string.'''\n    found_groups = False\n    i = 0\n    parts, pos = [], match.start()\n    f = lambda text:handle_entities(text, func)\n    while True:\n        i += 1\n        try:\n            start, end = match.span(i)\n        except IndexError:\n            break\n        found_groups = True\n        if start > -1:\n            parts.append(match.string[pos:start])\n            parts.append(f(match.string[start:end]))\n            pos = end\n    if not found_groups:\n        return f(match.group())\n    parts.append(match.string[pos:match.end()])\n    return ''.join(parts)\n", "docstring": "Apply the specified function to individual groups in the match object (the result of re.search() or"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/split.py", "original_string": "    def nix_element(elem, top=True):\n        # Remove elem unless top is False in which case replace elem by its\n        # children\n        parent = elem.getparent()\n        if top:\n            parent.remove(elem)\n        else:\n            index = parent.index(elem)\n            parent[index:index+1] = list(elem.iterchildren())\n", "docstring": "Remove elem unless top is False in which case replace elem by its"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/split.py", "original_string": "    def __init__(self, base, anchor_map, master, container):\n        self.container, self.anchor_map = container, anchor_map\n        self.master = master\n        self.base = base\n        self.replaced = False\n", "docstring": "self.container, self.anchor_map = container, anchor_map"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/split.py", "original_string": "def remove_name_attributes(root):\n    # Remove all name attributes, replacing them with id attributes\n    for elem in root.xpath('//*[@id and @name]'):\n        del elem.attrib['name']\n    for elem in root.xpath('//*[@name]'):\n        elem.set('id', elem.attrib.pop('name'))\n", "docstring": "Remove all name attributes, replacing them with id attributes"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def parse_xhtml(self, data, fname='<string>', force_html5_parse=False):\n        if self.tweak_mode:\n            return parse_html_tweak(data, log=self.log, decoder=self.decode, force_html5_parse=force_html5_parse)\n        else:\n            try:\n                return parse_html(\n                    data, log=self.log, decoder=self.decode,\n                    preprocessor=self.html_preprocessor, filename=fname,\n                    non_html_file_tags={'ncx'})\n            except NotHTML:\n                return self.parse_xml(data)\n", "docstring": "if self.tweak_mode:"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def manifest_has_name(self, name):\n        ''' Return True if the manifest has an entry corresponding to name '''\n        all_names = {self.href_to_name(x.get('href'), self.opf_name) for x in self.opf_xpath('//opf:manifest/opf:item[@href]')}\n        return name in all_names\n", "docstring": "Return True if the manifest has an entry corresponding to name '''"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def add_file(self, name, data, media_type=None, spine_index=None, modify_name_if_needed=False, process_manifest_item=None):\n        ''' Add a file to this container. Entries for the file are\n        automatically created in the OPF manifest and spine\n        (if the file is a text document) '''\n        if '..' in name:\n            raise ValueError('Names are not allowed to have .. in them')\n        href = self.name_to_href(name, self.opf_name)\n        if self.has_name_case_insensitive(name) or self.manifest_has_name(name):\n            if not modify_name_if_needed:\n                raise ValueError(('A file with the name %s already exists' % name) if self.has_name_case_insensitive(name) else\n                                 ('An item with the href %s already exists in the manifest' % href))\n            name = self.make_name_unique(name)\n            href = self.name_to_href(name, self.opf_name)\n        path = self.name_to_abspath(name)\n        base = os.path.dirname(path)\n        if not os.path.exists(base):\n            os.makedirs(base)\n        with lopen(path, 'wb') as f:\n            if hasattr(data, 'read'):\n                shutil.copyfileobj(data, f)\n            else:\n                f.write(data)\n        mt = media_type or self.guess_type(name)\n        self.name_path_map[name] = path\n        self.mime_map[name] = mt\n        if self.ok_to_be_unmanifested(name):\n            return name\n        item_id = self.add_name_to_manifest(name, process_manifest_item=process_manifest_item)\n        if mt in OEB_DOCS:\n            manifest = self.opf_xpath('//opf:manifest')[0]\n            spine = self.opf_xpath('//opf:spine')[0]\n            si = manifest.makeelement(OPF('itemref'), idref=item_id)\n            self.insert_into_xml(spine, si, index=spine_index)\n        return name\n", "docstring": "Add a file to this container. Entries for the file are"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def replace_links(self, name, replace_func):\n        ''' Replace all links in name using replace_func, which must be a\n        callable that accepts a URL and returns the replaced URL. It must also\n        have a 'replaced' attribute that is set to True if any actual\n        replacement is done. Convenient ways of creating such callables are\n        using the :class:`LinkReplacer` and :class:`LinkRebaser` classes. '''\n        media_type = self.mime_map.get(name, guess_type(name))\n        if name == self.opf_name:\n            replace_func.file_type = 'opf'\n            for elem in self.opf_xpath('//*[@href]'):\n                elem.set('href', replace_func(elem.get('href')))\n        elif media_type.lower() in OEB_DOCS:\n            replace_func.file_type = 'text'\n            rewrite_links(self.parsed(name), replace_func)\n        elif media_type.lower() in OEB_STYLES:\n            replace_func.file_type = 'style'\n            replaceUrls(self.parsed(name), replace_func)\n        elif media_type.lower() == guess_type('toc.ncx'):\n            replace_func.file_type = 'ncx'\n            for elem in self.parsed(name).xpath('//*[@src]'):\n                elem.set('src', replace_func(elem.get('src')))\n        if replace_func.replaced:\n            self.dirty(name)\n        return replace_func.replaced\n", "docstring": "Replace all links in name using replace_func, which must be a"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def exists(self, name):\n        ''' True iff a file/folder corresponding to the canonical name exists. Note\n        that this function suffers from the limitations of the underlying OS\n        filesystem, in particular case (in)sensitivity. So on a case\n        insensitive filesystem this will return True even if the case of name\n        is different from the case of the underlying filesystem file. See also :meth:`has_name`'''\n        return os.path.exists(self.name_to_abspath(name))\n", "docstring": "True iff a file/folder corresponding to the canonical name exists. Note"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def name_to_href(self, name, base=None):\n        '''Convert a name to a href relative to base, which must be a name or\n        None in which case self.root is used as the base'''\n        return name_to_href(name, self.root, base=base)\n", "docstring": "Convert a name to a href relative to base, which must be a name or"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def has_name(self, name):\n        ''' Return True iff a file with the same canonical name as that specified exists. Unlike :meth:`exists` this method is always case-sensitive. '''\n        return name and name in self.name_path_map\n", "docstring": "Return True iff a file with the same canonical name as that specified exists. Unlike :meth:`exists` this method is always case-sensitive. '''"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def has_name_case_insensitive(self, name):\n        if not name:\n            return False\n        name = name.lower()\n        for q in self.name_path_map:\n            if q.lower() == name:\n                return True\n        return False\n", "docstring": "if not name:"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def opf(self):\n        ' The parsed OPF file '\n        return self.parsed(self.opf_name)\n", "docstring": "' The parsed OPF file '"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def mi(self):\n        ''' The metadata of this book as a Metadata object. Note that this\n        object is constructed on the fly every time this property is requested,\n        so use it sparingly. '''\n        from calibre.ebooks.metadata.opf2 import OPF as O\n        mi = self.serialize_item(self.opf_name)\n        return O(BytesIO(mi), basedir=self.opf_dir, unquote_urls=False,\n                populate_spine=False).to_book_metadata()\n", "docstring": "The metadata of this book as a Metadata object. Note that this"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def manifest_items_of_type(self, predicate):\n        ''' The names of all manifest items whose media-type matches predicate.\n        `predicate` can be a set, a list, a string or a function taking a single\n        argument, which will be called with the media-type. '''\n        if isinstance(predicate, unicode_type):\n            predicate = predicate.__eq__\n        elif hasattr(predicate, '__contains__'):\n            predicate = predicate.__contains__\n        for mt, names in iteritems(self.manifest_type_map):\n            if predicate(mt):\n                for name in names:\n                    yield name\n", "docstring": "The names of all manifest items whose media-type matches predicate."}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def add_properties(self, name, *properties):\n        ''' Add the specified properties to the manifest item identified by name. '''\n        properties = frozenset(properties)\n        if not properties:\n            return True\n        for p in properties:\n            if p.startswith('calibre:'):\n                ensure_prefix(self.opf, None, 'calibre', CALIBRE_PREFIX)\n                break\n        for item in self.opf_xpath('//opf:manifest/opf:item'):\n            iname = self.href_to_name(item.get('href'), self.opf_name)\n            if name == iname:\n                props = frozenset((item.get('properties') or '').split()) | properties\n                item.set('properties', ' '.join(props))\n                return True\n        return False\n", "docstring": "Add the specified properties to the manifest item identified by name. '''"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def spine_iter(self):\n        ''' An iterator that yields item, name is_linear for every item in the\n        books' spine. item is the lxml element, name is the canonical file name\n        and is_linear is True if the item is linear. See also: :attr:`spine_names` and :attr:`spine_items`. '''\n        manifest_id_map = self.manifest_id_map\n        non_linear = []\n        for item in self.opf_xpath('//opf:spine/opf:itemref[@idref]'):\n            idref = item.get('idref')\n            name = manifest_id_map.get(idref, None)\n            path = self.name_path_map.get(name, None)\n            if path:\n                if item.get('linear', 'yes') == 'yes':\n                    yield item, name, True\n                else:\n                    non_linear.append((item, name))\n        for item, name in non_linear:\n            yield item, name, False\n", "docstring": "An iterator that yields item, name is_linear for every item in the"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def spine_names(self):\n        ''' An iterator yielding name and is_linear for every item in the\n        books' spine. See also: :attr:`spine_iter` and :attr:`spine_items`. '''\n        for item, name, linear in self.spine_iter:\n            yield name, linear\n", "docstring": "An iterator yielding name and is_linear for every item in the"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def spine_items(self):\n        ''' An iterator yielding the path for every item in the\n        books' spine. See also: :attr:`spine_iter` and :attr:`spine_items`. '''\n        for name, linear in self.spine_names:\n            yield self.name_path_map[name]\n", "docstring": "An iterator yielding the path for every item in the"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def set_spine(self, spine_items):\n        ''' Set the spine to be spine_items where spine_items is an iterable of\n        the form (name, linear). Will raise an error if one of the names is not\n        present in the manifest. '''\n        imap = self.manifest_id_map\n        imap = {name:item_id for item_id, name in iteritems(imap)}\n        items = [item for item, name, linear in self.spine_iter]\n        tail, last_tail = (items[0].tail, items[-1].tail) if items else ('\\n    ', '\\n  ')\n        tuple(map(self.remove_from_xml, items))\n        spine = self.opf_xpath('//opf:spine')[0]\n        spine.text = tail\n        for name, linear in spine_items:\n            i = spine.makeelement('{%s}itemref' % OPF_NAMESPACES['opf'], nsmap={'opf':OPF_NAMESPACES['opf']})\n            i.tail = tail\n            i.set('idref', imap[name])\n            spine.append(i)\n            if not linear:\n                i.set('linear', 'no')\n        if len(spine) > 0:\n            spine[-1].tail = last_tail\n        self.dirty(self.opf_name)\n", "docstring": "Set the spine to be spine_items where spine_items is an iterable of"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def dirty(self, name):\n        ''' Mark the parsed object corresponding to name as dirty. See also: :meth:`parsed`. '''\n        self.dirtied.add(name)\n", "docstring": "Mark the parsed object corresponding to name as dirty. See also: :meth:`parsed`. '''"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def insert_into_xml(self, parent, item, index=None):\n        '''Insert item into parent (or append if index is None), fixing\n        indentation. Only works with self closing items.'''\n        if index is None:\n            parent.append(item)\n        else:\n            parent.insert(index, item)\n        idx = parent.index(item)\n        if idx == 0:\n            item.tail = parent.text\n            # If this is the only child of this parent element, we need a\n            # little extra work as we have gone from a self-closing <foo />\n            # element to <foo><item /></foo>\n            if len(parent) == 1:\n                sibling = parent.getprevious()\n                if sibling is None:\n                    # Give up!\n                    return\n                parent.text = sibling.text\n                item.tail = sibling.tail\n        else:\n            item.tail = parent[idx-1].tail\n            if idx == len(parent)-1:\n                parent[idx-1].tail = parent.text\n", "docstring": "Insert item into parent (or append if index is None), fixing"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def generate_item(self, name, id_prefix=None, media_type=None, unique_href=True):\n        '''Add an item to the manifest with href derived from the given\n        name. Ensures uniqueness of href and id automatically. Returns\n        generated item.'''\n        id_prefix = id_prefix or 'id'\n        media_type = media_type or guess_type(name)\n        if unique_href:\n            name = self.make_name_unique(name)\n        href = self.name_to_href(name, self.opf_name)\n        base, ext = href.rpartition('.')[0::2]\n        all_ids = {x.get('id') for x in self.opf_xpath('//*[@id]')}\n        c = 0\n        item_id = id_prefix\n        while item_id in all_ids:\n            c += 1\n            item_id = id_prefix + '%d'%c\n        manifest = self.opf_xpath('//opf:manifest')[0]\n        item = manifest.makeelement(OPF('item'),\n                                    id=item_id, href=href)\n        item.set('media-type', media_type)\n        self.insert_into_xml(manifest, item)\n        self.dirty(self.opf_name)\n        name = self.href_to_name(href, self.opf_name)\n        self.name_path_map[name] = path = self.name_to_abspath(name)\n        self.mime_map[name] = media_type\n        # Ensure that the file corresponding to the newly created item exists\n        # otherwise cloned containers will fail when they try to get the number\n        # of links to the file\n        base = os.path.dirname(path)\n        if not os.path.exists(base):\n            os.makedirs(base)\n        lopen(path, 'wb').close()\n        return item\n", "docstring": "Add an item to the manifest with href derived from the given"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def serialize_item(self, name):\n        ''' Convert a parsed object (identified by canonical name) into a bytestring. See :meth:`parsed`. '''\n        data = root = self.parsed(name)\n        if name == self.opf_name:\n            self.format_opf()\n        data = serialize(data, self.mime_map[name], pretty_print=name in\n                         self.pretty_print)\n        if name == self.opf_name and root.nsmap.get(None) == OPF2_NS:\n            # Needed as I can't get lxml to output opf:role and\n            # not output <opf:metadata> as well\n            data = re.sub(br'(<[/]{0,1})opf:', r'\\1', data)\n        return data\n", "docstring": "Convert a parsed object (identified by canonical name) into a bytestring. See :meth:`parsed`. '''"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def filesize(self, name):\n        ''' Return the size in bytes of the file represented by the specified\n        canonical name. Automatically handles dirtied parsed objects. See also:\n        :meth:`parsed` '''\n        if name in self.dirtied:\n            self.commit_item(name, keep_parsed=True)\n        path = self.name_to_abspath(name)\n        return os.path.getsize(path)\n", "docstring": "Return the size in bytes of the file represented by the specified"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "    def open(self, name, mode='rb'):\n        ''' Open the file pointed to by name for direct read/write. Note that\n        this will commit the file if it is dirtied and remove it from the parse\n        cache. You must finish with this file before accessing the parsed\n        version of it again, or bad things will happen. '''\n        return lopen(self.get_file_path_for_processing(name, mode not in {'r', 'rb'}), mode)\n", "docstring": "Open the file pointed to by name for direct read/write. Note that"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/container.py", "original_string": "        def _parse_css(self, data):\n            # The default CSS parser used by oeb.base inserts the h namespace\n            # and resolves all @import rules. We dont want that.\n            return container.parse_css(data)\n", "docstring": "The default CSS parser used by oeb.base inserts the h namespace"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/css.py", "original_string": "def filter_sheet(sheet, properties=()):\n    from css_parser.css import CSSRule\n    changed = False\n    remove = []\n    for rule in sheet.cssRules.rulesOfType(CSSRule.STYLE_RULE):\n        if filter_declaration(rule.style, properties):\n            changed = True\n            if rule.style.length == 0:\n                remove.append(rule)\n    for rule in remove:\n        sheet.cssRules.remove(rule)\n    return changed\n", "docstring": "from css_parser.css import CSSRule"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/css.py", "original_string": "def sort_sheet(container, sheet_or_text):\n    ''' Sort the rules in a stylesheet. Note that in the general case this can\n    change the effective styles, but for most common sheets, it should be safe.\n    '''\n    sheet = container.parse_css(sheet_or_text) if isinstance(sheet_or_text, unicode_type) else sheet_or_text\n    def text_sort_key(x):\n        return numeric_sort_key(unicode_type(x or ''))\n    def selector_sort_key(x):\n        return (x.specificity, text_sort_key(x.selectorText))\n    def rule_sort_key(rule):\n        primary = RULE_PRIORITIES.get(rule.type, len(RULE_PRIORITIES))\n        secondary = text_sort_key(getattr(rule, 'atkeyword', '') or '')\n        tertiary = None\n        if rule.type == CSSRule.STYLE_RULE:\n            primary += 1\n            selectors = sorted(rule.selectorList, key=selector_sort_key)\n            tertiary = selector_sort_key(selectors[0])\n            rule.selectorText = ', '.join(s.selectorText for s in selectors)\n        elif rule.type == CSSRule.FONT_FACE_RULE:\n            try:\n                tertiary = text_sort_key(rule.style.getPropertyValue('font-family'))\n            except Exception:\n                pass\n        return primary, secondary, tertiary\n    sheet.cssRules.sort(key=rule_sort_key)\n    return sheet\n", "docstring": "Sort the rules in a stylesheet. Note that in the general case this can"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/cascade.py", "original_string": "def iterrules(container, sheet_name, rules=None, media_rule_ok=media_allowed, rule_index_counter=None, rule_type=None, importing=None):\n    ''' Iterate over all style rules in the specified sheet. Import and Media rules are\n    automatically resolved. Yields (rule, sheet_name, rule_number).\n    :param rules: List of CSSRules or a CSSStyleSheet instance or None in which case it is read from container using sheet_name\n    :param sheet_name: The name of the sheet in the container (in case of inline style sheets, the name of the html file)\n    :param media_rule_ok: A function to test if a @media rule is allowed\n    :param rule_index_counter: A counter object, rule numbers will be calculated by incrementing the counter.\n    :param rule_type: Only yield rules of this type, where type is a string type name, see css_parser.css.CSSRule for the names (\n                    by default all rules are yielded)\n    :return: (CSSRule object, the name of the sheet from which it comes, rule index - a monotonically increasing number)\n    '''\n    rule_index_counter = rule_index_counter or count()\n    if importing is None:\n        importing = set()\n    importing.add(sheet_name)\n    riter = partial(iterrules, container, rule_index_counter=rule_index_counter, media_rule_ok=media_rule_ok, rule_type=rule_type, importing=importing)\n    if rules is None:\n        rules = container.parsed(sheet_name)\n    if rule_type is not None:\n        rule_type = getattr(CSSRule, rule_type)\n    for rule in rules:\n        if rule.type == CSSRule.IMPORT_RULE:\n            if media_rule_ok(rule.media):\n                name = container.href_to_name(rule.href, sheet_name)\n                if container.has_name(name):\n                    if name in importing:\n                        container.log.error('Recursive import of {} from {}, ignoring'.format(name, sheet_name))\n                    else:\n                        csheet = container.parsed(name)\n                        if isinstance(csheet, CSSStyleSheet):\n                            for cr in riter(name, rules=csheet):\n                                yield cr\n        elif rule.type == CSSRule.MEDIA_RULE:\n            if media_rule_ok(rule.media):\n                for cr in riter(sheet_name, rules=rule.cssRules):\n                    yield cr\n        elif rule_type is None or rule.type == rule_type:\n            num = next(rule_index_counter)\n            yield rule, sheet_name, num\n    importing.discard(sheet_name)\n", "docstring": "Iterate over all style rules in the specified sheet. Import and Media rules are"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/pretty.py", "original_string": "def pretty_opf(root):\n    # Put all dc: tags first starting with title and author. Preserve order for\n    # the rest.\n    def dckey(x):\n        return {'title':0, 'creator':1}.get(barename(x.tag), 2)\n    for metadata in root.xpath('//opf:metadata', namespaces=OPF_NAMESPACES):\n        dc_tags = metadata.xpath('./*[namespace-uri()=\"%s\"]' % OPF_NAMESPACES['dc'])\n        dc_tags.sort(key=dckey)\n        for x in reversed(dc_tags):\n            metadata.insert(0, x)\n    # Group items in the manifest\n    spine_ids = root.xpath('//opf:spine/opf:itemref/@idref', namespaces=OPF_NAMESPACES)\n    spine_ids = {x:i for i, x in enumerate(spine_ids)}\n    def manifest_key(x):\n        mt = x.get('media-type', '')\n        href = x.get('href', '')\n        ext = href.rpartition('.')[-1].lower()\n        cat = 1000\n        if mt in OEB_DOCS:\n            cat = 0\n        elif mt == guess_type('a.ncx'):\n            cat = 1\n        elif mt in OEB_STYLES:\n            cat = 2\n        elif mt.startswith('image/'):\n            cat = 3\n        elif ext in {'otf', 'ttf', 'woff'}:\n            cat = 4\n        elif mt.startswith('audio/'):\n            cat = 5\n        elif mt.startswith('video/'):\n            cat = 6\n        if cat == 0:\n            i = spine_ids.get(x.get('id', None), 1000000000)\n        else:\n            i = sort_key(href)\n        return (cat, i)\n    for manifest in root.xpath('//opf:manifest', namespaces=OPF_NAMESPACES):\n        try:\n            children = sorted(manifest, key=manifest_key)\n        except AttributeError:\n            continue  # There are comments so dont sort since that would mess up the comments\n        for x in reversed(children):\n            manifest.insert(0, x)\n", "docstring": "Put all dc: tags first starting with title and author. Preserve order for"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/pretty.py", "original_string": "def pretty_block(parent, level=1, indent='  '):\n    ''' Surround block tags with blank lines and recurse into child block tags\n    that contain only other block tags '''\n    if not parent.text or isspace(parent.text):\n        parent.text = ''\n    nn = '\\n' if hasattr(parent.tag, 'strip') and barename(parent.tag) in {'tr', 'td', 'th'} else '\\n\\n'\n    parent.text = parent.text + nn + (indent * level)\n    for i, child in enumerate(parent):\n        if isblock(child) and has_only_blocks(child):\n            pretty_block(child, level=level+1, indent=indent)\n        elif child.tag == SVG_TAG:\n            pretty_xml_tree(child, level=level, indent=indent)\n        l = level\n        if i == len(parent) - 1:\n            l -= 1\n        if not child.tail or isspace(child.tail):\n            child.tail = ''\n        child.tail = child.tail + nn + (indent * l)\n", "docstring": "Surround block tags with blank lines and recurse into child block tags"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/check/parsing.py", "original_string": "    def __init__(self, name):\n        # may be disabled during setting of known valid items\n        self.name = name\n        self.errors = []\n", "docstring": "may be disabled during setting of known valid items"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/tests/structure.py", "original_string": "    def test_epub2_covers(self):\n        # cover image\n        ce = partial(self.create_epub, ver=2)\n        c = ce([cmi('c.jpg')])\n        self.assertIsNone(find_cover_image(c))\n        c = ce([cmi('c.jpg')], meta_cover='c.jpg')\n        self.assertEqual('c.jpg', find_cover_image(c))\n        c = ce([cmi('c.jpg'), cmi('d.jpg')], guide=[('c.jpg', 'cover', '')])\n        self.assertEqual('c.jpg', find_cover_image(c))\n        mark_as_cover(c, 'd.jpg')\n        self.assertEqual('d.jpg', find_cover_image(c))\n        self.assertEqual({'cover':'d.jpg'}, c.guide_type_map)\n        # title page\n        c = ce([cmi('c.html'), cmi('a.html')])\n        self.assertIsNone(find_cover_page(c))\n        mark_as_titlepage(c, 'a.html', move_to_start=False)\n        self.assertEqual('a.html', find_cover_page(c))\n        self.assertEqual('c.html', next(c.spine_names)[0])\n        mark_as_titlepage(c, 'a.html', move_to_start=True)\n        self.assertEqual('a.html', find_cover_page(c))\n        self.assertEqual('a.html', next(c.spine_names)[0])\n", "docstring": "cover image"}
{"repo": "calibre-master/src/calibre/ebooks/oeb/polish/tests/parsing.py", "original_string": "def nonvoid_cdata_elements(test, parse_function):\n    ''' If self closed version of non-void cdata elements like <title/> are\n    present, the HTML5 parsing algorithm treats all following data as CDATA '''\n    markup = '''\n    <html> <head><{0}/></head> <body id=\"test\"> </html>\n    '''\n    for tag in cdataElements | rcdataElements:\n        for x in (tag, tag.upper(), '\\n' + tag, tag + ' id=\"xxx\" '):\n            root = parse_function(markup.format(x))\n            test.assertEqual(\n                len(XPath('//h:body[@id=\"test\"]')(root)), 1,\n                'Incorrect parsing for <%s/>, parsed markup:\\n' % x + etree.tostring(root, encoding='unicode'))\n", "docstring": "If self closed version of non-void cdata elements like <title/> are"}
{"repo": "calibre-master/src/calibre/ebooks/docx/index.py", "original_string": "def merge_blocks(prev_block, next_block, pind, nind, next_path, ldict):\n    # First elements match. Any more in next?\n    if len(next_path) == (nind + 1):\n        nextent = next_block[nind]\n        add_link(prev_block[pind], nextent, ldict)\n        return\n    nind = nind + 1\n    nextent = next_block[nind]\n    prevent = find_match(prev_block, pind, nextent, ldict)\n    if prevent > 0:\n        merge_blocks(prev_block, next_block, prevent, nind, next_path, ldict)\n        return\n    # Want to insert elements into previous block\n    while nind < len(next_block):\n        # insert takes it out of old\n        pind = pind + 1\n        prev_block.insert(pind, next_block[nind])\n    next_block.getparent().remove(next_block)\n", "docstring": "First elements match. Any more in next?"}
{"repo": "calibre-master/src/calibre/ebooks/docx/fields.py", "original_string": "    def parse_xe(self, field, parse_func, log):\n        # Parse XE fields\n        if None in (field.start, field.end):\n            return\n        xe = parse_func(field.instructions, log)\n        if xe:\n            # We insert a synthetic bookmark around this index item so that we\n            # can link to it later\n            def WORD(x):\n                return self.namespace.expand('w:' + x)\n            self.index_bookmark_counter += 1\n            bmark = xe['anchor'] = '%s%d' % (self.index_bookmark_prefix, self.index_bookmark_counter)\n            p = field.start.getparent()\n            bm = p.makeelement(WORD('bookmarkStart'))\n            bm.set(WORD('id'), bmark), bm.set(WORD('name'), bmark)\n            p.insert(p.index(field.start), bm)\n            p = field.end.getparent()\n            bm = p.makeelement(WORD('bookmarkEnd'))\n            bm.set(WORD('id'), bmark)\n            p.insert(p.index(field.end) + 1, bm)\n            xe['start_elem'] = field.start\n            self.xe_fields.append(xe)\n", "docstring": "Parse XE fields"}
{"repo": "calibre-master/src/calibre/ebooks/docx/styles.py", "original_string": "    def resolve_numbering(self, numbering):\n        # When a numPr element appears inside a paragraph style, the lvl info\n        # must be discarded and pStyle used instead.\n        self.numbering = numbering\n        for style in self:\n            ps = style.paragraph_style\n            if ps is not None and ps.numbering_id is not inherit:\n                lvl = numbering.get_pstyle(ps.numbering_id, style.style_id)\n                if lvl is None:\n                    ps.numbering_id = ps.numbering_level = inherit\n                else:\n                    ps.numbering_level = lvl\n", "docstring": "When a numPr element appears inside a paragraph style, the lvl info"}
{"repo": "calibre-master/src/calibre/ebooks/docx/cleanup.py", "original_string": "def liftable(css):\n    # A <span> is liftable if all its styling would work just as well if it is\n    # specified on the parent element.\n    prefixes = {x.partition('-')[0] for x in css}\n    return not (prefixes - {'text', 'font', 'letter', 'color', 'background'})\n", "docstring": "A <span> is liftable if all its styling would work just as well if it is"}
{"repo": "calibre-master/src/calibre/ebooks/docx/cleanup.py", "original_string": "def lift(span):\n    # Replace an element by its content (text, children and tail)\n    parent = span.getparent()\n    idx = parent.index(span)\n    try:\n        last_child = span[-1]\n    except IndexError:\n        last_child = None\n    if span.text:\n        if idx == 0:\n            add_text(parent, 'text', span.text)\n        else:\n            add_text(parent[idx - 1], 'tail', span.text)\n    for child in reversed(span):\n        parent.insert(idx, child)\n    parent.remove(span)\n    if span.tail:\n        if last_child is None:\n            if idx == 0:\n                add_text(parent, 'text', span.tail)\n            else:\n                add_text(parent[idx - 1], 'tail', span.tail)\n        else:\n            add_text(last_child, 'tail', span.tail)\n", "docstring": "Replace an element by its content (text, children and tail)"}
{"repo": "calibre-master/src/calibre/ebooks/docx/to_html.py", "original_string": "        def p_parent(x):\n            # Ensure that nested <w:p> tags are handled. These can occur if a\n            # textbox is present inside a paragraph.\n            while True:\n                x = x.getparent()\n                try:\n                    if x.tag.endswith('}p'):\n                        return x\n                except AttributeError:\n                    break\n", "docstring": "Ensure that nested <w:p> tags are handled. These can occur if a"}
{"repo": "calibre-master/src/calibre/ebooks/docx/writer/links.py", "original_string": "def sanitize_bookmark_name(base):\n    # Max length allowed by Word appears to be 40, we use 32 to leave some\n    # space for making the name unique\n    return re.sub(r'[^0-9a-zA-Z]', '_', ascii_text(base))[:32].rstrip('_')\n", "docstring": "Max length allowed by Word appears to be 40, we use 32 to leave some"}
{"repo": "calibre-master/src/calibre/ebooks/docx/writer/tables.py", "original_string": "    def expand_spanned_cells(self):\n        # Expand horizontally\n        for row in self.rows:\n            for cell in tuple(row.cells):\n                idx = row.cells.index(cell)\n                if cell.col_span > 1 and (cell is row.cells[-1] or not isinstance(row.cells[idx+1], SpannedCell)):\n                    row.cells[idx:idx+1] = [cell] + [SpannedCell(cell, horizontal=True) for i in range(1, cell.col_span)]\n        # Expand vertically\n        for r, row in enumerate(self.rows):\n            for idx, cell in enumerate(row.cells):\n                if cell.row_span > 1:\n                    for nrow in self.rows[r+1:]:\n                        sc = SpannedCell(cell, horizontal=False)\n                        try:\n                            tcell = nrow.cells[idx]\n                        except Exception:\n                            tcell = None\n                        if tcell is None:\n                            nrow.cells.extend([SpannedCell(nrow.cells[-1], horizontal=True) for i in range(idx - len(nrow.cells))])\n                            nrow.cells.append(sc)\n                        else:\n                            if isinstance(tcell, SpannedCell):\n                                # Conflict between rowspan and colspan\n                                break\n                            else:\n                                nrow.cells.insert(idx, sc)\n", "docstring": "Expand horizontally"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/combine_borders.py", "original_string": "    def __default_func(self, line):\n        # cw<bd<bor-t-r-vi\n        if self.__first_five == 'cw<bd':\n            self.found_bd(line)\n            return ''\n        return line\n", "docstring": "cw<bd<bor-t-r-vi"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/combine_borders.py", "original_string": "    def add_to_border_desc(self, line):\n        # cw<bt<bdr-hair__<nu<true\n        # cw<bt<bdr-linew<nu<0.50\n        # tx<__________<some text\n        border_desc = line[6:16]\n        num = line[20:-1]\n        if num == 'true':\n            num = ''\n        else:\n            num = ':' + num\n        self.__bord_att.append(border_desc + num)\n", "docstring": "cw<bt<bdr-hair__<nu<true"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/hex_2_utf8.py", "original_string": "    def __found_body_func(self, line):\n        self.__state = 'body'\n        self.__write_obj.write(line)\n", "docstring": "self.__state = 'body'"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/hex_2_utf8.py", "original_string": "    def __convert_body(self):\n        self.__state = 'body'\n        with open_for_read(self.__file) as read_obj:\n            with open_for_write(self.__write_to) as self.__write_obj:\n                for line in read_obj:\n                    self.__token_info = line[:16]\n                    action = self.__body_state_dict.get(self.__state)\n                    if action is None:\n                        sys.stderr.write('error no state found in hex_2_utf8',\n                        self.__state\n                        )\n                    action(line)\n        copy_obj = copy.Copy(bug_handler=self.__bug_handler)\n        if self.__copy:\n            copy_obj.copy_file(self.__write_to, \"body_utf_convert.data\")\n        copy_obj.rename(self.__write_to, self.__file)\n        os.remove(self.__write_to)\n", "docstring": "self.__state = 'body'"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/border_parse.py", "original_string": "    def __init__(self):\n        # cw<bd<bor-t-r-hi<nu<true\n        self.__border_dict = {\n        'bor-t-r-hi'    : 'border-table-row-horizontal-inside',\n        'bor-t-r-vi'    : 'border-table-row-vertical-inside',\n        'bor-t-r-to'    : 'border-table-row-top',\n        'bor-t-r-le'    : 'border-table-row-left',\n        'bor-t-r-bo'    : 'border-table-row-bottom',\n        'bor-t-r-ri'    : 'border-table-row-right',\n        'bor-cel-bo'    : 'border-cell-bottom',\n        'bor-cel-to'    : 'border-cell-top',\n        'bor-cel-le'    : 'border-cell-left',\n        'bor-cel-ri'    : 'border-cell-right',\n        'bor-par-bo'    : 'border-paragraph-bottom',\n        'bor-par-to'    : 'border-paragraph-top',\n        'bor-par-le'    : 'border-paragraph-left',\n        'bor-par-ri'    : 'border-paragraph-right',\n        'bor-par-bx'    : 'border-paragraph-box',\n        'bor-for-ev'    : 'border-for-every-paragraph',\n        'bor-outsid'    : 'border-outside',\n        'bor-none__'    : 'border',\n        # border type => bt\n        'bdr-li-wid'    : 'line-width',\n        'bdr-sp-wid'    :       'padding',\n        'bdr-color_'    :       'color',\n        }\n        self.__border_style_dict = {\n        'bdr-single'    : 'single',\n        'bdr-doubtb'    : 'double-thickness-border',\n        'bdr-shadow'    : 'shadowed-border',\n        'bdr-double'    : 'double-border',\n        'bdr-dotted'    : 'dotted-border',\n        'bdr-dashed'    : 'dashed',\n        'bdr-hair__'    : 'hairline',\n        'bdr-inset_'    : 'inset',\n        'bdr-das-sm'    : 'dash-small',\n        'bdr-dot-sm'    : 'dot-dash',\n        'bdr-dot-do'    : 'dot-dot-dash',\n        'bdr-outset'    : 'outset',\n        'bdr-trippl'    : 'tripple',\n        'bdr-thsm__'    : 'thick-thin-small',\n        'bdr-htsm__'    : 'thin-thick-small',\n        'bdr-hthsm_'    : 'thin-thick-thin-small',\n        'bdr-thm___'     : 'thick-thin-medium',\n        'bdr-htm___'     : 'thin-thick-medium',\n        'bdr-hthm__'     : 'thin-thick-thin-medium',\n        'bdr-thl___'     : 'thick-thin-large',\n        'bdr-hthl__'     : 'thin-thick-thin-large',\n        'bdr-wavy__'     : 'wavy',\n        'bdr-d-wav_'     : 'double-wavy',\n        'bdr-strip_'     : 'striped',\n        'bdr-embos_'     : 'emboss',\n        'bdr-engra_'     : 'engrave',\n        'bdr-frame_'     : 'frame',\n        }\n", "docstring": "cw<bd<bor-t-r-hi<nu<true"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/colors.py", "original_string": "    def __figure_num(self, num):\n        if num == 0:\n            hex_num = 'false'\n        else:\n            hex_num = self.__color_dict.get(num)\n        if hex_num is None:\n            hex_num = '0'\n            if self.__run_level > 3:\n                msg = 'no value in self.__color_dict' \\\n                'for key %s at line %d\\n' % (num, self.__line)\n                raise self.__bug_handler(msg)\n        return hex_num\n", "docstring": "if num == 0:"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/make_lists.py", "original_string": "    def __write_start_item(self):\n        self.__write_obj.write('mi<mk<item_start\\n')\n        self.__write_obj.write('mi<tg<open______<item\\n')\n        self.__write_obj.write('mi<mk<itemstart_\\n')\n", "docstring": "self.__write_obj.write('mi<mk<item_start\\n')"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/make_lists.py", "original_string": "    def __get_indent(self, line):\n        if self.__token_info == 'mi<mk<left_inden':\n            self.__left_indent = float(line[17:-1])\n", "docstring": "if self.__token_info == 'mi<mk<left_inden':"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/copy.py", "original_string": "    def remove_files(self):\n        \"\"\"Remove files from directory\"\"\"\n        self.__remove_the_files(Copy.__dir)\n", "docstring": "Remove files from directory\n"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/delete_info.py", "original_string": "    def __default_func(self,line):\n        \"\"\"Handle lines when in no special state. Look for an asterisk to\n        begin a special state. Otherwise, print out line.\"\"\"\n        # cw<ml<asterisk__<nu<true\n        if self.__token_info == 'cw<ml<asterisk__':\n            self.__state = 'after_asterisk'\n            self.__delete_count = self.__ob_count\n        elif self.__token_info == 'ob<nu<open-brack':\n            # write previous bracket, if exists\n            if self.__ob:\n                self.__write_obj.write(self.__ob)\n            self.__ob = line\n            return False\n        else:\n            # write previous bracket, since didn't find asterisk\n            if self.__ob:\n                self.__write_obj.write(self.__ob)\n                self.__ob = 0\n            return True\n", "docstring": "Handle lines when in no special state. Look for an asterisk to"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/options_trem.py", "original_string": "    def parse_options(self):\n        self.__system_string = self.__sub_short_with_long()\n        # # print 'subbed list is  %s' % self.__system_string\n        self.__system_string = self.__pair_arg_with_option()\n        # # print 'list with pairing is %s' % self.__system_string\n        options, arguments  = self.__get_just_options()\n        # # print 'options are %s ' % options\n        # # print 'arguments are %s ' % arguments\n        self.__is_legal_option_func()\n        if self.__options_okay:\n            options_dict = self.__make_options_dict(options)\n            # # print options_dict\n            return options_dict, arguments\n        else:\n            return 0,0\n", "docstring": "# print 'subbed list is  %s' % self.__system_string"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/ParseRtf.py", "original_string": "def Handle_Main():\n    # Handles options and creates a parse object\n    parse_obj =ParseRtf.ParseRtf(\n            in_file = 'in.rtf',\n            # All values from here on are optional\n            # determine the output file\n            out_file = 'out.xml',\n            # determine the run level. The default is 1.\n            run_level = 3,\n            # The name of a debug directory, if you are running at\n            # run level 3 or higer.\n            debug = 'debug_dir',\n            # Convert RTF caps to real caps.\n            # Default is 1.\n            convert_caps = 1,\n            # Indent resulting XML.\n            # Default is 0 (no indent).\n            indent = 1,\n            # Form lists from RTF. Default is 1.\n            form_lists = 1,\n            # Convert headings to sections. Default is 0.\n            headings_to_sections = 1,\n            # Group paragraphs with the same style name. Default is 1.\n            group_styles = 1,\n            # Group borders. Default is 1.\n            group_borders = 1,\n            # Write or do not write paragraphs. Default is 0.\n            empty_paragraphs = 0,\n            # Allow to use a custom default encoding as fallback\n            default_encoding = 'cp1252',\n    )\n    try:\n        parse_obj.parse_rtf()\n    except ParseRtf.InvalidRtfException, msg:\n        sys.stderr.write(msg)\n    except ParseRtf.RtfInvalidCodeException, msg:\n        sys.stderr.write(msg)\n", "docstring": "Handles options and creates a parse object"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/ParseRtf.py", "original_string": "    def __check_dir(self, the_dir):\n        \"\"\"Check to see if directory exists\"\"\"\n        if not the_dir :\n            return\n        dir_exists = os.path.isdir(the_dir)\n        if not dir_exists:\n            msg = \"\\n%s is not a directory\" % the_dir\n            raise RtfInvalidCodeException(msg)\n        return 1\n", "docstring": "Check to see if directory exists\n"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/styles.py", "original_string": "    def __found_end_ind_style_func(self, line):\n        name = self.__text_string[:-1]  # get rid of semicolon\n        # add 2005-04-29\n        # get rid of space before or after\n        name = name.strip()\n        self.__enter_dict_entry('name', name)\n        self.__text_string = ''\n", "docstring": "add 2005-04-29"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/group_styles.py", "original_string": "    def __close_pard_(self, line):\n        self.__write_obj.write(self.__list_chunk)\n        self.__write_obj.write('mi<tg<close_____<paragraph-definition\\n')\n        self.__write_end_wrap()\n        self.__list_chunk = ''\n        self.__state = 'default'\n", "docstring": "self.__write_obj.write(self.__list_chunk)"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/preamble_div.py", "original_string": "    def __rtf_head_func(self, line):\n        if self.__ob_count == '0002':\n            self.__rtf_final = (\n            'mi<mk<rtfhed-beg\\n' +\n            self.__rtf_final +\n            'mi<mk<rtfhed-end\\n'\n            )\n            self.__state = 'preamble'\n        elif self.__token_info == 'tx<nu<__________' or \\\n            self.__token_info == 'cw<pf<par-def___':\n            self.__state = 'body'\n            self.__rtf_final = (\n            'mi<mk<rtfhed-beg\\n' +\n            self.__rtf_final +\n            'mi<mk<rtfhed-end\\n'\n            )\n            self.__make_default_font_table()\n            self.__write_preamble()\n            self.__write_obj.write(line)\n        else:\n            self.__rtf_final = self.__rtf_final + line\n", "docstring": "if self.__ob_count == '0002':"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/preamble_div.py", "original_string": "    def __found_font_table_func(self, line):\n        if self.__found_font_table:\n            self.__state = 'ignore'\n        else:\n            self.__state = 'font_table'\n            self.__font_table_final = ''\n        self.__close_group_count = self.__ob_count\n        self.__cb_count = 0\n        self.__found_font_table = 1\n", "docstring": "if self.__found_font_table:"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/preamble_div.py", "original_string": "    def __color_table_func(self, line):\n        if int(self.__cb_count) == int(self.__close_group_count):\n            self.__state = 'preamble'\n            self.__color_table_final = 'mi<tg<open______<color-table\\n' + \\\n            'mi<mk<clrtbl-beg\\n' + self.__color_table_final\n            self.__color_table_final += \\\n            'mi<mk<clrtbl-end\\n' + 'mi<tg<close_____<color-table\\n'\n        else:\n            self.__color_table_final += line\n", "docstring": "if int(self.__cb_count) == int(self.__close_group_count):"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/preamble_div.py", "original_string": "    def __list_table_func(self, line):\n        if self.__cb_count == self.__close_group_count:\n            self.__state = 'preamble'\n            self.__list_table_final, self.__all_lists =\\\n                self.__list_table_obj.parse_list_table(\n                self.__list_table_final)\n            # sys.stderr.write(repr(all_lists))\n        elif self.__token_info == '':\n            pass\n        else:\n            self.__list_table_final += line\n            pass\n", "docstring": "if self.__cb_count == self.__close_group_count:"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/preamble_div.py", "original_string": "    def __body_func(self, line):\n        self.__write_obj.write(line)\n", "docstring": "self.__write_obj.write(line)"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/preamble_div.py", "original_string": "    def __para_def_func(self, line):\n        # if self.__ob_group == 1\n        # this tells dept of group\n        if self.__cb_count == '0002':\n            self.__state = 'body'\n            self.__write_preamble()\n        self.__write_obj.write(line)\n", "docstring": "if self.__ob_group == 1"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/preamble_div.py", "original_string": "    def __row_def_func(self, line):\n        # if self.__ob_group == 1\n        # this tells dept of group\n        if self.__cb_count == '0002':\n            self.__state = 'body'\n            self.__write_preamble()\n        self.__write_obj.write(line)\n", "docstring": "if self.__ob_group == 1"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/pict.py", "original_string": "    def __text_func(self, line):\n        # tx<nu<__________<true text\n        return line[17:]\n", "docstring": "tx<nu<__________<true text"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/pict.py", "original_string": "    def __create_pict_file(self):\n        \"\"\"Create a file for all the pict data to be written to.\n        \"\"\"\n        self.__pict_file = os.path.join(self.__dir_name, 'picts.rtf')\n        self.__write_pic_obj = open_for_write(self.__pict_file, append=True)\n", "docstring": "Create a file for all the pict data to be written to."}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/pict.py", "original_string": "    def __default(self, line, write_obj):\n        \"\"\"Determine if each token marks the beginning of pict data.\n        If it does, create a new file to write data to (if that file\n        has not already been created.) Set the self.__in_pict flag to true.\n        If the line does not contain pict data, return 1\n        \"\"\"\n        \"\"\"\n        $pict_count++;\n        $pict_count =  sprintf(\"%03d\", $pict_count);\n        print OUTPUT \"dv<xx<em<nu<pict<at<num>$pict_count\\n\";\n        \"\"\"\n        if self.__token_info == 'cw<gr<picture___':\n            self.__pict_count += 1\n            # write_obj.write(\"mi<tg<em<at<pict<num>%03d\\n\" % self.__pict_count)\n            write_obj.write('mi<mk<pict-start\\n')\n            write_obj.write('mi<tg<empty-att_<pict<num>%03d\\n' % self.__pict_count)\n            write_obj.write('mi<mk<pict-end__\\n')\n            if not self.__already_found_pict:\n                self.__create_pict_file()\n                self.__already_found_pict=True\n                self.__print_rtf_header()\n            self.__in_pict = 1\n            self.__pict_br_count = self.__ob_count\n            self.__cb_count = 0\n            self.__write_pic_obj.write(\"{\\\\pict\\n\")\n            return False\n        return True\n", "docstring": "Determine if each token marks the beginning of pict data."}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/process_tokens.py", "original_string": "    def convert_to_hex(self,number):\n        \"\"\"Convert a string to uppercase hexidecimal\"\"\"\n        num = int(number)\n        try:\n            hex_num = \"%X\" % num\n            return hex_num\n        except:\n            raise self.__bug_handler\n", "docstring": "Convert a string to uppercase hexidecimal\n"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/group_borders.py", "original_string": "    def __close_pard_(self, line):\n        self.__write_obj.write(self.__list_chunk)\n        self.__write_obj.write('mi<tg<close_____<paragraph-definition\\n')\n        self.__write_end_wrap()\n        self.__list_chunk = ''\n        self.__state = 'default'\n", "docstring": "self.__write_obj.write(self.__list_chunk)"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/group_borders.py", "original_string": "    def __write_end_border_tag(self):\n        self.__write_obj.write('mi<mk<end-brdg__\\n')\n        self.__write_obj.write('mi<tg<close_____<border-group\\n')\n", "docstring": "self.__write_obj.write('mi<mk<end-brdg__\\n')"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/info.py", "original_string": "    def __single_field_func(self, line, tag):\n        value = line[20:-1]\n        self.__write_obj.write(\n        'mi<tg<empty-att_<%s<%s>%s\\n' % (tag, tag, value)\n        )\n", "docstring": "value = line[20:-1]"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/headings_to_sections.py", "original_string": "    def __write_start_section(self, current_level, name):\n        section_num = ''\n        for the_num in self.__section_num:\n            section_num += '%s.' % the_num\n        section_num = section_num[:-1]\n        num_in_level = len(self.__all_sections)\n        num_in_level = self.__section_num[num_in_level]\n        level = len(self.__all_sections)\n        self.__write_obj.write(\n            'mi<mk<sect-start\\n'\n                )\n        self.__write_obj.write(\n                'mi<tg<open-att__<section<num>%s<num-in-level>%s<level>%s'\n                '<type>%s\\n'\n                % (section_num, num_in_level, level, name)\n                )\n", "docstring": "section_num = ''"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/headings_to_sections.py", "original_string": "    def __in_table_func(self, line):\n        if self.__token_info == 'mi<mk<table-end_':\n            self.__state = 'default'\n        self.__write_obj.write(line)\n", "docstring": "if self.__token_info == 'mi<mk<table-end_':"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/footnote.py", "original_string": "    def __in_footnote_func(self, line):\n        \"\"\"Handle all tokens that are part of footnote\"\"\"\n        if self.__first_line:\n            self.__first_line_func(line)\n        if self.__token_info == 'cw<ci<footnot-mk':\n            num = unicode_type(self.__footnote_count)\n            self.__write_to_foot_obj.write(line)\n            self.__write_to_foot_obj.write(\n                'tx<nu<__________<%s\\n' % num\n            )\n        if self.__cb_count == self.__footnote_bracket_count:\n            self.__in_footnote = 0\n            self.__write_obj.write(line)\n            self.__write_to_foot_obj.write(\n            'mi<mk<foot___clo\\n')\n            self.__write_to_foot_obj.write(\n            'mi<tg<close_____<footnote\\n')\n            self.__write_to_foot_obj.write(\n            'mi<mk<footnt-clo\\n')\n        else:\n            self.__write_to_foot_obj.write(line)\n", "docstring": "Handle all tokens that are part of footnote\n"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/footnote.py", "original_string": "    def __default_sep(self, line):\n        \"\"\"Handle all tokens that are not footnote tokens\"\"\"\n        if self.__token_info == 'cw<nt<footnote__':\n            self.__found_footnote(line)\n        self.__write_obj.write(line)\n        if self.__token_info == 'cw<ci<footnot-mk':\n            num = unicode_type(self.__footnote_count + 1)\n            self.__write_obj.write(\n                'tx<nu<__________<%s\\n' % num\n            )\n", "docstring": "Handle all tokens that are not footnote tokens\n"}
{"repo": "calibre-master/src/calibre/ebooks/rtf2xml/tokenize.py", "original_string": "    def tokenize(self):\n        \"\"\"Main class for handling other methods. Reads the file \\\n        , uses method self.sub_reg to make basic substitutions,\\\n        and process tokens by itself\"\"\"\n        # read\n        with open_for_read(self.__file) as read_obj:\n            input_file = read_obj.read()\n        # process simple replacements and split giving us a correct list\n        # remove '' and \\n in the process\n        tokens = self.__sub_reg_split(input_file)\n        # correct unicode\n        tokens = map(self.__unicode_process, tokens)\n        # remove empty items created by removing \\uc\n        tokens = list(filter(lambda x: len(x) > 0, tokens))\n        # write\n        with open_for_write(self.__write_to) as write_obj:\n            write_obj.write('\\n'.join(tokens))\n        # Move and copy\n        copy_obj = copy.Copy(bug_handler=self.__bug_handler)\n        if self.__copy:\n            copy_obj.copy_file(self.__write_to, \"tokenize.data\")\n        copy_obj.rename(self.__write_to, self.__file)\n        os.remove(self.__write_to)\n        # self.__special_tokens = [ '_', '~', \"'\", '{', '}' ]\n", "docstring": "Main class for handling other methods. Reads the file \\"}
{"repo": "calibre-master/src/calibre/ebooks/htmlz/oeb2html.py", "original_string": "    def mlize_spine(self, oeb_book):\n        output = []\n        for item in oeb_book.spine:\n            self.log.debug('Converting %s to HTML...' % item.href)\n            self.rewrite_ids(item.data, item)\n            rewrite_links(item.data, partial(self.rewrite_link, page=item))\n            stylizer = Stylizer(item.data, item.href, oeb_book, self.opts)\n            output += self.dump_text(item.data.find(XHTML('body')), stylizer, item)\n            output.append('\\n\\n')\n        if self.opts.htmlz_class_style == 'external':\n            css = '<link href=\"style.css\" rel=\"stylesheet\" type=\"text/css\" />'\n        else:\n            css =  '<style type=\"text/css\">' + self.get_css(oeb_book) + '</style>'\n        title = u'<title>%s</title>' % prepare_string_for_xml(self.book_title)\n        output = [u'<html><head><meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" />'] + \\\n            [css] + [title, u'</head><body>'] + output + [u'</body></html>']\n        return ''.join(output)\n", "docstring": "output = []"}
{"repo": "calibre-master/src/calibre/ebooks/rb/rbml.py", "original_string": "    def clean_text(self, text):\n        # Remove anchors that do not have links\n        anchors = set(re.findall(r'(?<=<A NAME=\").+?(?=\"></A>)', text))\n        links = set(re.findall(r'(?<=<A HREF=\"#).+?(?=\">)', text))\n        for unused in anchors.difference(links):\n            text = text.replace('<A NAME=\"%s\"></A>' % unused, '')\n        return text\n", "docstring": "Remove anchors that do not have links"}
{"repo": "calibre-master/src/calibre/ebooks/djvu/djvubzzdec.py", "original_string": "    def decode_sub_simple(self, mps, z):\n        # Test MPS/LPS\n        if z > self.code:\n            # LPS branch\n            z = 0x10000 - z\n            self.a += +z\n            self.code = self.code + z\n            # LPS renormalization\n            shift = self.ffz()\n            self.scount -= shift\n            self.a = self.a << shift\n            self.a &= 0xffff\n            self.code = (self.code << shift) | ((self.bufint >> self.scount) & ((1 << shift) - 1))\n            self.code &= 0xffff\n            if self.scount < 16:\n                self.preload()\n            # Adjust fence\n            self.fence = self.code\n            if self.code >= 0x8000:\n                self.fence = 0x7fff\n            result = mps ^ 1\n        else:\n            # MPS renormalization\n            self.scount -= 1\n            self.a = (z << 1) & 0xffff\n            self.code = ((self.code << 1) | ((self.bufint >> self.scount) & 1))\n            self.code &= 0xffff\n            if self.scount < 16:\n                self.preload()\n            # Adjust fence\n            self.fence = self.code\n            if self.code >= 0x8000:\n                self.fence = 0x7fff\n            result = mps\n        return result\n", "docstring": "Test MPS/LPS"}
{"repo": "calibre-master/src/calibre/ebooks/pml/pmlconverter.py", "original_string": "def footnote_sidebar_to_html(pre_id, id, pml):\n    id = id.strip('\\x01')\n    if id.strip():\n        html = '<br /><br style=\"page-break-after: always;\" /><div id=\"%s-%s\">%s<small><a href=\"#r%s-%s\">return</a></small></div>' % (\n            pre_id, id, pml_to_html(pml), pre_id, id)\n    else:\n        html = '<br /><br style=\"page-break-after: always;\" /><div>%s</div>' % pml_to_html(pml)\n    return html\n", "docstring": "id = id.strip('\\x01')"}
{"repo": "calibre-master/src/calibre/ebooks/pml/pmlml.py", "original_string": "    def clean_text(self, text):\n        # Remove excessive \\p tags\n        text = re.sub(r'\\\\p\\s*\\\\p', '', text)\n        # Remove anchors that do not have links\n        anchors = set(re.findall(r'(?<=\\\\Q=\").+?(?=\")', text))\n        links = set(re.findall(r'(?<=\\\\q=\"#).+?(?=\")', text))\n        for unused in anchors.difference(links):\n            text = text.replace(r'\\Q=\"%s\"' % unused, '')\n        # Remove \\Cn tags that are within \\x and \\Xn tags\n        text = re.sub(r'(?msu)(?P<t>\\\\(x|X[0-4]))(?P<a>.*?)(?P<c>\\\\C[0-4]\\s*=\\s*\"[^\"]*\")(?P<b>.*?)(?P=t)', r'\\g<t>\\g<a>\\g<b>\\g<t>', text)\n        # Replace bad characters.\n        text = text.replace('\\xc2', '')\n        text = text.replace('\\xa0', ' ')\n        # Turn all characters that cannot be represented by themself into their\n        # PML code equivelent\n        text = re.sub('[^\\x00-\\x7f]', lambda x: unipmlcode(x.group()), text)\n        # Remove excess spaces at beginning and end of lines\n        text = re.sub('(?m)^[ ]+', '', text)\n        text = re.sub('(?m)[ ]+$', '', text)\n        # Remove excessive spaces\n        text = re.sub('[ ]{2,}', ' ', text)\n        # Condense excessive \\c empty line sequences.\n        text = re.sub(r'(\\\\c\\s*\\\\c\\s*){2,}', r'\\\\c \\n\\\\c\\n', text)\n        # Remove excessive newlines.\n        text = re.sub('\\n[ ]+\\n', '\\n\\n', text)\n        if self.opts.remove_paragraph_spacing:\n            text = re.sub('\\n{2,}', '\\n', text)\n            # Only indent lines that don't have special formatting\n            text = re.sub('(?imu)^(?P<text>.+)$', lambda mo: mo.group('text')\n                          if re.search(r'\\\\[XxCmrctTp]', mo.group('text')) else '        %s' % mo.group('text'), text)\n        else:\n            text = re.sub('\\n{3,}', '\\n\\n', text)\n        return text\n", "docstring": "Remove excessive \\p tags"}
{"repo": "calibre-master/src/calibre/ebooks/epub/cfi/parse.py", "original_string": "    def __init__(self):\n        # All allowed unicode characters + escaped special characters\n        special_char = r'[\\[\\](),;=^]'\n        unescaped_char = '[[\\t\\n\\r -\\ud7ff\\ue000-\\ufffd\\U00010000-\\U0010ffff]--%s]' % special_char\n        escaped_char = r'\\^' + special_char\n        chars = r'(?:%s|(?:%s))+' % (unescaped_char, escaped_char)\n        chars_no_space = chars.replace('0020', '0021')\n        # No leading zeros allowed for integers\n        integer = r'(?:[1-9][0-9]*)|0'\n        # No leading zeros, except for numbers in (0, 1) and no trailing zeros for the fractional part\n        frac = r'\\.[0-9]*[1-9]'\n        number = r'(?:[1-9][0-9]*(?:{0})?)|(?:0{0})|(?:0)'.format(frac)\n        c = lambda x:regex.compile(x, flags=regex.VERSION1)\n        # A step of the form /integer\n        self.step_pat = c(r'/(%s)' % integer)\n        # An id assertion of the form [characters]\n        self.id_assertion_pat = c(r'\\[(%s)\\]' % chars)\n        # A text offset of the form :integer\n        self.text_offset_pat = c(r':(%s)' % integer)\n        # A temporal offset of the form ~number\n        self.temporal_offset_pat = c(r'~(%s)' % number)\n        # A spatial offset of the form @number:number\n        self.spatial_offset_pat = c(r'@({0}):({0})'.format(number))\n        # A spatio-temporal offset of the form ~number@number:number\n        self.st_offset_pat = c(r'~({0})@({0}):({0})'.format(number))\n        # Text assertion patterns\n        self.ta1_pat = c(r'({0})(?:,({0})){{0,1}}'.format(chars))\n        self.ta2_pat = c(r',(%s)' % chars)\n        self.parameters_pat = c(r'(?:;(%s)=((?:%s,?)+))+' % (chars_no_space, chars))\n        self.csv_pat = c(r'(?:(%s),?)+' % chars)\n        # Unescape characters\n        unescape_pat = c(r'%s(%s)' % (escaped_char[:2], escaped_char[2:]))\n        self.unescape = lambda x: unescape_pat.sub(r'\\1', x)\n", "docstring": "All allowed unicode characters + escaped special characters"}
{"repo": "calibre-master/src/calibre/ebooks/pdb/plucker/reader.py", "original_string": "    def __init__(self, section_header, raw):\n        # The uncompressed size of each paragraph.\n        self.sizes = []\n        # uncompressed offset of each paragraph starting\n        # at the beginning of the PHTML.\n        self.paragraph_offsets = []\n        # Paragraph attributes.\n        self.attributes = []\n        for i in range(section_header.paragraphs):\n            adv = 4*i\n            self.sizes.append(struct.unpack('>H', raw[adv:2+adv])[0])\n            self.attributes.append(struct.unpack('>H', raw[2+adv:4+adv])[0])\n        running_offset = 0\n        for size in self.sizes:\n            running_offset += size\n            self.paragraph_offsets.append(running_offset)\n", "docstring": "The uncompressed size of each paragraph."}
{"repo": "calibre-master/src/calibre/ebooks/pdb/ereader/reader202.py", "original_string": "    def create_opf(self, output_dir, images):\n        with CurrentDir(output_dir):\n            opf = OPFCreator(output_dir, self.mi)\n            manifest = [('index.html', None)]\n            for i in images:\n                manifest.append((os.path.join('images/', i), None))\n            opf.create_manifest(manifest)\n            opf.create_spine(['index.html'])\n            with open('metadata.opf', 'wb') as opffile:\n                opf.render(opffile)\n        return os.path.join(output_dir, 'metadata.opf')\n", "docstring": "with CurrentDir(output_dir):"}
{"repo": "calibre-master/src/calibre/ebooks/pdb/ereader/reader132.py", "original_string": "    def create_opf(self, output_dir, images, toc):\n        with CurrentDir(output_dir):\n            if 'cover.png' in images:\n                self.mi.cover = os.path.join('images', 'cover.png')\n            opf = OPFCreator(output_dir, self.mi)\n            manifest = [('index.html', None)]\n            for i in images:\n                manifest.append((os.path.join('images', i), None))\n            opf.create_manifest(manifest)\n            opf.create_spine(['index.html'])\n            opf.set_toc(toc)\n            with open('metadata.opf', 'wb') as opffile:\n                with open('toc.ncx', 'wb') as tocfile:\n                    opf.render(opffile, tocfile, 'toc.ncx')\n        return os.path.join(output_dir, 'metadata.opf')\n", "docstring": "with CurrentDir(output_dir):"}
{"repo": "calibre-master/src/calibre/ebooks/html/input.py", "original_string": "    def __hash__(self):\n        return hash(self.path)\n", "docstring": "return hash(self.path)"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/kfx.py", "original_string": "    def unpack_unsigned_int(self, length):\n        # unsigned big-endian (MSB first)\n        return struct.unpack_from(b'>Q', b'\\0' * (8 - length) + self.extract(length))[0]\n", "docstring": "unsigned big-endian (MSB first)"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/opf3.py", "original_string": "def uniq(vals):\n    ''' Remove all duplicates from vals, while preserving order.  '''\n    vals = vals or ()\n    seen = set()\n    seen_add = seen.add\n    return list(x for x in vals if x not in seen and not seen_add(x))\n", "docstring": "Remove all duplicates from vals, while preserving order.  '''"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/topaz.py", "original_string": "    def update(self, data_blocks):\n        # Rewrite the stream\n        stream = self._stream\n        base = self.start\n        stream.seek(base)\n        self._stream.truncate(base)\n        for block in data_blocks:\n            stream.write(block)\n", "docstring": "Rewrite the stream"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/topaz.py", "original_string": "    def dump_hex(self, src, length=16):\n        ''' Diagnostic '''\n        FILTER=''.join([(len(repr(codepoint_to_chr(x)))==3) and codepoint_to_chr(x) or '.' for x in range(256)])\n        N=0\n        result=''\n        while src:\n            s,src = src[:length],src[length:]\n            hexa = ' '.join([\"%02X\"%ord(x) for x in s])\n            s = s.translate(FILTER)\n            result += \"%04X   %-*s   %s\\n\" % (N, length*3, hexa, s)\n            N+=length\n        print(result)\n", "docstring": "Diagnostic '''"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/topaz.py", "original_string": "    def get_headers(self, offset):\n        # Build a dict of topaz_header records, list of order\n        topaz_headers = {}\n        th_seq = []\n        for x in range(self.header_records):\n            offset += 1\n            taglen, consumed = self.decode_vwi(self.data[offset:offset+4])\n            offset += consumed\n            tag = self.data[offset:offset+taglen]\n            offset += taglen\n            num_vals, consumed = self.decode_vwi(self.data[offset:offset+4])\n            offset += consumed\n            blocks = {}\n            for val in range(num_vals):\n                hdr_offset, consumed = self.decode_vwi(self.data[offset:offset+4])\n                offset += consumed\n                len_uncomp, consumed = self.decode_vwi(self.data[offset:offset+4])\n                offset += consumed\n                len_comp, consumed = self.decode_vwi(self.data[offset:offset+4])\n                offset += consumed\n                blocks[val] = dict(offset=hdr_offset,len_uncomp=len_uncomp,len_comp=len_comp)\n            topaz_headers[tag] = dict(blocks=blocks)\n            th_seq.append(tag)\n        self.eoth = self.data[offset]\n        offset += 1\n        self.base = offset\n        return topaz_headers, th_seq\n", "docstring": "Build a dict of topaz_header records, list of order"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/topaz.py", "original_string": "    def get_metadata(self):\n        ''' Return MetaInformation with title, author'''\n        self.get_original_metadata()\n        title = force_unicode(self.metadata['Title'], 'utf-8')\n        authors = force_unicode(self.metadata['Authors'], 'utf-8').split(';')\n        return MetaInformation(title, authors)\n", "docstring": "Return MetaInformation with title, author'''"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/opf3_test.py", "original_string": "    def test_against_opf2(self):  # {{{\n        # opf2 {{{\n        raw = '''<package xmlns=\"http://www.idpf.org/2007/opf\" unique-identifier=\"uuid_id\" version=\"2.0\">\n", "docstring": "opf2 {{{"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/archive.py", "original_string": "def parse_comic_comment(comment, series_index='volume'):\n    # See http://code.google.com/p/comicbookinfo/wiki/Example\n    from calibre.ebooks.metadata import MetaInformation\n    import json\n    mi = MetaInformation(None, None)\n    m = json.loads(comment)\n    if isinstance(m, dict):\n        for cat in m:\n            if cat.startswith('ComicBookInfo'):\n                get_comic_book_info(m[cat], mi, series_index=series_index)\n                break\n    return mi\n", "docstring": "See http://code.google.com/p/comicbookinfo/wiki/Example"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/rtf.py", "original_string": "def encode(unistr):\n    if not isinstance(unistr, unicode_type):\n        unistr = force_unicode(unistr)\n    return ''.join(c if ord(c) < 128 else '\\\\u{}?'.format(ord(c)) for c in unistr)\n", "docstring": "if not isinstance(unistr, unicode_type):"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/rtf.py", "original_string": "        def test_rtf_metadata(self):\n            stream = BytesIO(br'{\\rtf1\\ansi\\ansicpg1252}')\n            m = Metadata('Test ø̄title', ['Author One', 'Author БTwo'])\n            m.tags = 'tag1 見tag2'.split()\n            m.comments = '<p>some ⊹comments</p>'\n            m.publisher = 'publiSher'\n            set_metadata(stream, m)\n            stream.seek(0)\n            o = get_metadata(stream)\n            for attr in 'title authors publisher comments tags'.split():\n                self.assertEqual(getattr(m, attr), getattr(o, attr))\n", "docstring": "stream = BytesIO(br'{\\rtf1\\ansi\\ansicpg1252}')"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/pml.py", "original_string": "def get_metadata(stream, extract_cover=True):\n    \"\"\" Return metadata as a L{MetaInfo} object \"\"\"\n    mi = MetaInformation(_('Unknown'), [_('Unknown')])\n    stream.seek(0)\n    pml = b''\n    if stream.name.endswith('.pmlz'):\n        with TemporaryDirectory('_unpmlz') as tdir:\n            zf = ZipFile(stream)\n            zf.extractall(tdir)\n            pmls = glob.glob(os.path.join(tdir, '*.pml'))\n            for p in pmls:\n                with open(p, 'r+b') as p_stream:\n                    pml += p_stream.read()\n            if extract_cover:\n                mi.cover_data = get_cover(os.path.splitext(os.path.basename(stream.name))[0], tdir, True)\n    else:\n        pml = stream.read()\n        if extract_cover:\n            mi.cover_data = get_cover(os.path.splitext(os.path.basename(stream.name))[0], os.path.abspath(os.path.dirname(stream.name)))\n    for comment in re.findall(br'(?ms)\\\\v.*?\\\\v', pml):\n        m = re.search(br'TITLE=\"(.*?)\"', comment)\n        if m:\n            mi.title = re.sub('[\\x00-\\x1f]', '', prepare_string_for_xml(m.group(1).strip().decode('cp1252', 'replace')))\n        m = re.search(br'AUTHOR=\"(.*?)\"', comment)\n        if m:\n            if mi.authors == [_('Unknown')]:\n                mi.authors = []\n            mi.authors.append(re.sub('[\\x00-\\x1f]', '', prepare_string_for_xml(m.group(1).strip().decode('cp1252', 'replace'))))\n        m = re.search(br'PUBLISHER=\"(.*?)\"', comment)\n        if m:\n            mi.publisher = re.sub('[\\x00-\\x1f]', '', prepare_string_for_xml(m.group(1).strip().decode('cp1252', 'replace')))\n        m = re.search(br'COPYRIGHT=\"(.*?)\"', comment)\n        if m:\n            mi.rights = re.sub('[\\x00-\\x1f]', '', prepare_string_for_xml(m.group(1).strip().decode('cp1252', 'replace')))\n        m = re.search(br'ISBN=\"(.*?)\"', comment)\n        if m:\n            mi.isbn = re.sub('[\\x00-\\x1f]', '', prepare_string_for_xml(m.group(1).strip().decode('cp1252', 'replace')))\n    return mi\n", "docstring": "Return metadata as a L{MetaInfo} object \n"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/mobi.py", "original_string": "    def update(self, data_blocks):\n        # Rewrite the stream\n        stream = self._stream\n        base = self.start\n        stream.seek(base)\n        stream.truncate()\n        for block in data_blocks:\n            stream.write(block)\n", "docstring": "Rewrite the stream"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/mobi.py", "original_string": "    def hexdump(self, src, length=16):\n        # Diagnostic\n        FILTER=''.join([(len(repr(codepoint_to_chr(x)))==3) and codepoint_to_chr(x) or '.' for x in range(256)])\n        N=0\n        result=''\n        while src:\n            s,src = src[:length],src[length:]\n            hexa = ' '.join([\"%02X\"%ord(x) for x in s])\n            s = s.translate(FILTER)\n            result += \"%04X   %-*s   %s\\n\" % (N, length*3, hexa, s)\n            N+=length\n        print(result)\n", "docstring": "Diagnostic"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/extz.py", "original_string": "def get_first_opf_name(zf):\n    names = zf.namelist()\n    opfs = []\n    for n in names:\n        if n.endswith('.opf') and '/' not in n:\n            opfs.append(n)\n    if not opfs:\n        raise Exception('No OPF found')\n    opfs.sort()\n    return opfs[0]\n", "docstring": "names = zf.namelist()"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/xisbn.py", "original_string": "    def fetch_data(self, isbn):\n        # xisbn service has been de-comissioned see\n        # https://www.oclc.org/developer/news/2018/xid-decommission.en.html\n        return []\n        url = self.QUERY%isbn\n        data = browser().open_novisit(url).read()\n        data = json.loads(data)\n        if data.get('stat', None) != 'ok':\n            return []\n        data = data.get('list', [])\n        ans = []\n        for rec in data:\n            forms = rec.get('form', [])\n            # Only get books, not audio/video\n            forms = [x for x in forms if x in ('BA', 'BC', 'BB', 'DA')]\n            if forms:\n                ans.append(rec)\n        return ans\n", "docstring": "xisbn service has been de-comissioned see"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/__init__.py", "original_string": "def MetaInformation(title, authors=(_('Unknown'),)):\n    ''' Convenient encapsulation of book metadata, needed for compatibility\n        @param title: title or ``_('Unknown')`` or a MetaInformation object\n        @param authors: List of strings or []\n    '''\n    from calibre.ebooks.metadata.book.base import Metadata\n    mi = None\n    if hasattr(title, 'title') and hasattr(title, 'authors'):\n        mi = title\n        title = mi.title\n        authors = mi.authors\n    return Metadata(title, authors, other=mi)\n", "docstring": "Convenient encapsulation of book metadata, needed for compatibility"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/fb2.py", "original_string": "def _parse_book_title(root, ctx):\n    # <title-info> has a priority.   (actually <title-info>  is mandatory)\n    # other are backup solution (sequence is important. Other than in fb2-doc)\n    xp_ti = '//fb:title-info/fb:book-title/text()'\n    xp_pi = '//fb:publish-info/fb:book-title/text()'\n    xp_si = '//fb:src-title-info/fb:book-title/text()'\n    book_title = ctx.XPath('normalize-space(%s|%s|%s)' % (xp_ti, xp_pi, xp_si))(root)\n    return book_title\n", "docstring": "<title-info> has a priority.   (actually <title-info>  is mandatory)"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/fb2.py", "original_string": "def _parse_series(root, mi, ctx):\n    # calibre supports only 1 series: use the 1-st one\n    # pick up sequence but only from 1 section in preferred order\n    # except <src-title-info>\n    xp_ti = '//fb:title-info/fb:sequence[1]'\n    xp_pi = '//fb:publish-info/fb:sequence[1]'\n    elms_sequence = ctx.XPath('%s|%s' % (xp_ti, xp_pi))(root)\n    if elms_sequence:\n        mi.series = elms_sequence[0].get('name', None)\n        if mi.series:\n            try:\n                mi.series_index = float('.'.join(elms_sequence[0].get('number', None).split()[:2]))\n            except Exception:\n                pass\n", "docstring": "calibre supports only 1 series: use the 1-st one"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/fb2.py", "original_string": "def _parse_comments(root, mi, ctx):\n    # pick up annotation but only from 1 section <title-info>;  fallback: <src-title-info>\n    for annotation_sec in ['title-info', 'src-title-info']:\n        elms_annotation = ctx.XPath('//fb:%s/fb:annotation' % annotation_sec)(root)\n        if elms_annotation:\n            mi.comments = tostring(elms_annotation[0])\n            # TODO: tags i18n, xslt?\n            break\n", "docstring": "pick up annotation but only from 1 section <title-info>;  fallback: <src-title-info>"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/opf2.py", "original_string": "    def __init__(self):\n        ResourceCollection.__init__(self)\n        self.next_id = 1\n", "docstring": "ResourceCollection.__init__(self)"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/opf2.py", "original_string": "    def nonlinear_items(self):\n        for r in self:\n            if not r.is_linear:\n                yield r.path\n", "docstring": "for r in self:"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/opf2.py", "original_string": "    def title(self):\n        # TODO: Add support for EPUB 3 refinements\n        for elem in self.title_path(self.metadata):\n            title = self.get_text(elem)\n            if title and title.strip():\n                return re.sub(r'\\s+', ' ', title.strip())\n", "docstring": "TODO: Add support for EPUB 3 refinements"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/opf2.py", "original_string": "    def create_manifest_from_files_in(self, files_and_dirs,\n            exclude=lambda x:False):\n        entries = []\n        def dodir(dir):\n            for spec in os.walk(dir):\n                root, files = spec[0], spec[-1]\n                for name in files:\n                    path = os.path.join(root, name)\n                    if os.path.isfile(path) and not exclude(path):\n                        entries.append((path, None))\n        for i in files_and_dirs:\n            if os.path.isdir(i):\n                dodir(i)\n            else:\n                entries.append((i, None))\n        self.create_manifest(entries)\n", "docstring": "exclude=lambda x:False):"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/author_mapper.py", "original_string": "def uniq(vals, kmap=icu_lower):\n    ''' Remove all duplicates from vals, while preserving order. kmap must be a\n    callable that returns a hashable value for every item in vals '''\n    vals = vals or ()\n    lvals = (kmap(x) for x in vals)\n    seen = set()\n    seen_add = seen.add\n    return list(x for x, k in zip(vals, lvals) if k not in seen and not seen_add(k))\n", "docstring": "Remove all duplicates from vals, while preserving order. kmap must be a"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/xmp.py", "original_string": "def read_lang_alt(parent):\n    # A text value with possible alternate values in different languages\n    items = XPath('descendant::rdf:li[@xml:lang=\"x-default\"]')(parent)\n    if items:\n        return items[0]\n    items = XPath('descendant::rdf:li')(parent)\n    if items:\n        return items[0]\n", "docstring": "A text value with possible alternate values in different languages"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/xmp.py", "original_string": "def uniq(vals, kmap=lambda x:x):\n    ''' Remove all duplicates from vals, while preserving order. kmap must be a\n    callable that returns a hashable value for every item in vals '''\n    vals = vals or ()\n    lvals = (kmap(x) for x in vals)\n    seen = set()\n    seen_add = seen.add\n    return tuple(x for x, k in zip(vals, lvals) if k not in seen and not seen_add(k))\n", "docstring": "Remove all duplicates from vals, while preserving order. kmap must be a"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/xmp.py", "original_string": "def first_alt(expr, root):\n    # The first element matching expr, assumes that the element contains a\n    # language alternate array\n    for item in XPath(expr)(root):\n        q = read_simple_property(read_lang_alt(item))\n        if q:\n            return q\n", "docstring": "The first element matching expr, assumes that the element contains a"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/xmp.py", "original_string": "def first_sequence(expr, root):\n    # The first item in a sequence\n    for item in XPath(expr)(root):\n        for ans in read_sequence(item):\n            return ans\n", "docstring": "The first item in a sequence"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/xmp.py", "original_string": "def merge_xmp_packet(old, new):\n    ''' Merge metadata present in the old packet that is not present in the new\n    one into the new one. Assumes the new packet was generated by\n    metadata_to_xmp_packet() '''\n    old, new = parse_xmp_packet(old), parse_xmp_packet(new)\n    # As per the adobe spec all metadata items have to be present inside top-level rdf:Description containers\n    item_xpath = XPath('//rdf:RDF/rdf:Description/*')\n    # First remove all data fields that metadata_to_xmp_packet() knowns about,\n    # since either they will have been set or if not present, imply they have\n    # been cleared\n    defined_tags = {expand(prefix + ':' + scheme) for prefix in ('prism', 'pdfx') for scheme in KNOWN_ID_SCHEMES}\n    defined_tags |= {expand('dc:' + x) for x in ('identifier', 'title', 'creator', 'date', 'description', 'language', 'publisher', 'subject')}\n    defined_tags |= {expand('xmp:' + x) for x in ('MetadataDate', 'Identifier')}\n    # For redundancy also remove all fields explicitly set in the new packet\n    defined_tags |= {x.tag for x in item_xpath(new)}\n    calibrens = '{%s}' % NS_MAP['calibre']\n    for elem in item_xpath(old):\n        if elem.tag in defined_tags or (elem.tag and elem.tag.startswith(calibrens)):\n            elem.getparent().remove(elem)\n    # Group all items into groups based on their namespaces\n    groups = defaultdict(list)\n    for item in item_xpath(new):\n        ns = item.nsmap[item.prefix]\n        groups[ns].append(item)\n    for item in item_xpath(old):\n        ns = item.nsmap[item.prefix]\n        groups[ns].append(item)\n    A = ElementMaker(namespace=NS_MAP['x'], nsmap=nsmap('x'))\n    R = ElementMaker(namespace=NS_MAP['rdf'], nsmap=nsmap('rdf'))\n    root = A.xmpmeta(R.RDF)\n    rdf = root[0]\n    for namespace in sorted(groups, key=lambda x:{NS_MAP['dc']:'a', NS_MAP['xmp']:'b', NS_MAP['calibre']:'c'}.get(x, 'z'+x)):\n        items = groups[namespace]\n        desc = rdf.makeelement(expand('rdf:Description'), nsmap=find_nsmap(items))\n        desc.set(expand('rdf:about'), '')\n        rdf.append(desc)\n        for item in items:\n            clone_into(desc, item)\n    return serialize_xmp_packet(root)\n", "docstring": "Merge metadata present in the old packet that is not present in the new"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/book/json_codec.py", "original_string": "def object_to_unicode(obj, enc=preferred_encoding):\n    def dec(x):\n        return x.decode(enc, 'replace')\n    if isbytestring(obj):\n        return dec(obj)\n    if isinstance(obj, (list, tuple)):\n        return [dec(x) if isbytestring(x) else object_to_unicode(x) for x in obj]\n    if isinstance(obj, dict):\n        ans = {}\n        for k, v in obj.items():\n            k = object_to_unicode(k)\n            v = object_to_unicode(v)\n            ans[k] = v\n        return ans\n    return obj\n", "docstring": "def dec(x):"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/book/base.py", "original_string": "def human_readable(size, precision=2):\n    \"\"\" Convert a size in bytes into megabytes \"\"\"\n    ans = size/(1024*1024)\n    if ans < 0.1:\n        return '<0.1MB'\n    return ('%.'+unicode_type(precision)+'f'+ 'MB') % ans\n", "docstring": "Convert a size in bytes into megabytes \n"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/book/base.py", "original_string": "    def has_identifier(self, typ):\n        identifiers = object.__getattribute__(self,\n            '_data')['identifiers']\n        return typ in identifiers\n", "docstring": "identifiers = object.__getattribute__(self,"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/book/base.py", "original_string": "    def print_all_attributes(self):\n        for x in STANDARD_METADATA_FIELDS:\n            prints('%s:'%x, getattr(self, x, 'None'))\n        for x in self.custom_field_keys():\n            meta = self.get_user_metadata(x, make_copy=False)\n            if meta is not None:\n                prints(x, meta)\n        prints('--------------')\n", "docstring": "for x in STANDARD_METADATA_FIELDS:"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/book/base.py", "original_string": "    def __nonzero__(self):\n        return bool(self.title or self.author or self.comments or self.tags)\n", "docstring": "return bool(self.title or self.author or self.comments or self.tags)"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/sources/base.py", "original_string": "    def __init__(self, *args, **kwargs):\n        Plugin.__init__(self, *args, **kwargs)\n        self.running_a_test = False  # Set to True when using identify_test()\n        self._isbn_to_identifier_cache = {}\n        self._identifier_to_cover_url_cache = {}\n        self.cache_lock = threading.RLock()\n        self._config_obj = None\n        self._browser = None\n        self.prefs.defaults['ignore_fields'] = []\n        for opt in self.options:\n            self.prefs.defaults[opt.name] = opt.default\n", "docstring": "Plugin.__init__(self, *args, **kwargs)"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/sources/base.py", "original_string": "    def customization_help(self):\n        return 'This plugin can only be customized using the GUI'\n", "docstring": "return 'This plugin can only be customized using the GUI'"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/sources/base.py", "original_string": "    def user_agent(self):\n        # Pass in an index to random_user_agent() to test with a particular\n        # user agent\n        return random_user_agent()\n", "docstring": "Pass in an index to random_user_agent() to test with a particular"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/sources/base.py", "original_string": "    def split_jobs(self, jobs, num):\n        'Split a list of jobs into at most num groups, as evenly as possible'\n        groups = [[] for i in range(num)]\n        jobs = list(jobs)\n        while jobs:\n            for gr in groups:\n                try:\n                    job = jobs.pop()\n                except IndexError:\n                    break\n                gr.append(job)\n        return [g for g in groups if g]\n", "docstring": "'Split a list of jobs into at most num groups, as evenly as possible'"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/sources/base.py", "original_string": "        def keygen(mi):\n            return InternalMetadataCompareKeyGen(mi, self, title, authors,\n                identifiers)\n", "docstring": "return InternalMetadataCompareKeyGen(mi, self, title, authors,"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/sources/search_engines.py", "original_string": "def ddg_search(terms, site=None, br=None, log=prints, safe_search=False, dump_raw=None, timeout=60):\n    # https://duck.co/help/results/syntax\n    terms = [quote_term(ddg_term(t)) for t in terms]\n    if site is not None:\n        terms.append(quote_term(('site:' + site)))\n    q = '+'.join(terms)\n    url = 'https://duckduckgo.com/html/?q={q}&kp={kp}'.format(\n        q=q, kp=1 if safe_search else -1)\n    log('Making ddg query: ' + url)\n    br = br or browser()\n    root = query(br, url, 'ddg', dump_raw, timeout=timeout)\n    ans = []\n    for a in root.xpath('//*[@class=\"results\"]//*[@class=\"result__title\"]/a[@href and @class=\"result__a\"]'):\n        ans.append(Result(ddg_href(a.get('href')), tostring(a), None))\n    return ans, url\n", "docstring": "https://duck.co/help/results/syntax"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/sources/search_engines.py", "original_string": "def bing_search(terms, site=None, br=None, log=prints, safe_search=False, dump_raw=None, timeout=60):\n    # http://vlaurie.com/computers2/Articles/bing_advanced_search.htm\n    terms = [quote_term(bing_term(t)) for t in terms]\n    if site is not None:\n        terms.append(quote_term(('site:' + site)))\n    q = '+'.join(terms)\n    url = 'https://www.bing.com/search?q={q}'.format(q=q)\n    log('Making bing query: ' + url)\n    br = br or browser()\n    root = query(br, url, 'bing', dump_raw, timeout=timeout)\n    ans = []\n    for li in root.xpath('//*[@id=\"b_results\"]/li[@class=\"b_algo\"]'):\n        a = li.xpath('descendant::h2/a[@href]') or li.xpath('descendant::div[@class=\"b_algoheader\"]/a[@href]')\n        a = a[0]\n        title = tostring(a)\n        try:\n            div = li.xpath('descendant::div[@class=\"b_attribution\" and @u]')[0]\n        except IndexError:\n            log('Ignoring {!r} as it has no cached page'.format(title))\n            continue\n        d, w = div.get('u').split('|')[-2:]\n        cached_url = 'https://cc.bingj.com/cache.aspx?q={q}&d={d}&mkt=en-US&setlang=en-US&w={w}'.format(\n            q=q, d=d, w=w)\n        ans.append(Result(a.get('href'), title, cached_url))\n    if not ans:\n        title = ' '.join(root.xpath('//title/text()'))\n        log('Failed to find any results on results page, with title:', title)\n    return ans, url\n", "docstring": "http://vlaurie.com/computers2/Articles/bing_advanced_search.htm"}
{"repo": "calibre-master/src/calibre/ebooks/metadata/sources/edelweiss.py", "original_string": "    def user_agent(self):\n        # Pass in an index to random_user_agent() to test with a particular\n        # user agent\n        return random_user_agent(allow_ie=False)\n", "docstring": "Pass in an index to random_user_agent() to test with a particular"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/meta.py", "original_string": "    def __set__(self, obj, val):\n        obj.pack(val, start=self._start, fmt=self._fmt)\n", "docstring": "obj.pack(val, start=self._start, fmt=self._fmt)"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/meta.py", "original_string": "    def __set__(self, obj, val):\n        if not isinstance(val, string_or_bytes):\n            val = unicode_type(val)\n        if isinstance(val, unicode_type):\n            val = val.encode('utf-8')\n        if len(val) != self._length:\n            raise LRFException(\"Trying to set fixed_stringfield with a \" +\n                               \"string of  incorrect length\")\n        obj.pack(val, start=self._start, fmt=\"<\"+unicode_type(len(val))+\"s\")\n", "docstring": "if not isinstance(val, string_or_bytes):"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/meta.py", "original_string": "    def __set__(self, obj, val):\n        if not val:\n            val = ''\n        document = obj.info\n        def create_elem():\n            elem = document.createElement(self.tag_name)\n            parent = document.getElementsByTagName(self.parent)[0]\n            parent.appendChild(elem)\n            return elem\n        if not val:\n            val = ''\n        if not isinstance(val, unicode_type):\n            val = val.decode('utf-8')\n        elems = document.getElementsByTagName(self.tag_name)\n        elem = None\n        if len(elems):\n            for candidate in elems:\n                if candidate.parentNode.nodeName == self.parent:\n                    elem = candidate\n            if not elem:\n                elem = create_elem()\n            else:\n                elem.normalize()\n                while elem.hasChildNodes():\n                    elem.removeChild(elem.lastChild)\n        else:\n            elem = create_elem()\n        elem.appendChild(document.createTextNode(val))\n        obj.info = document\n", "docstring": "if not val:"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/meta.py", "original_string": "        def decorator(f):\n            def restore_pos(*args, **kwargs):\n                obj = args[0]\n                pos = obj._file.tell()\n                res = f(*args, **kwargs)\n                obj._file.seek(0, 2)\n                if obj._file.tell() >= pos:\n                    obj._file.seek(pos)\n                return res\n            return restore_pos\n", "docstring": "def restore_pos(*args, **kwargs):"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/meta.py", "original_string": "    def _detect_thumbnail_type(cls, slice):\n        \"\"\" @param slice: The first 16 bytes of the thumbnail \"\"\"\n        ttype = 0x14  # GIF\n        if \"PNG\" in slice:\n            ttype = 0x12\n        if \"BM\" in slice:\n            ttype = 0x13\n        if \"JFIF\" in slice:\n            ttype = 0x11\n        return ttype\n", "docstring": "@param slice: The first 16 bytes of the thumbnail \n"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/meta.py", "original_string": "    def update_object_offsets(self, delta):\n        \"\"\" Run through the LRF Object index changing the offset by C{delta}. \"\"\"\n        self._file.seek(self.object_index_offset)\n        count = self.number_of_objects\n        while count > 0:\n            raw = self._file.read(8)\n            new_offset = struct.unpack(DWORD, raw[4:8])[0] + delta\n            if new_offset >= (2**8)**4 or new_offset < 0x4C:\n                raise LRFException(_('Invalid LRF file. Could not set metadata.'))\n            self._file.seek(-4, os.SEEK_CUR)\n            self._file.write(struct.pack(DWORD, new_offset))\n            self._file.seek(8, os.SEEK_CUR)\n            count -= 1\n        self._file.flush()\n", "docstring": "Run through the LRF Object index changing the offset by C{delta}. \n"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/meta.py", "original_string": "    def tell(self):\n        \"\"\" See L{file.tell} \"\"\"\n        return self._file.tell()\n", "docstring": "See L{file.tell} \n"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/meta.py", "original_string": "    def write(self, val):\n        \"\"\" See L{file.write} \"\"\"\n        self._file.write(val)\n", "docstring": "See L{file.write} \n"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/meta.py", "original_string": "    def get_objects_by_type(self, type):\n        from calibre.ebooks.lrf.tags import Tag\n        objects = []\n        for id, offset, size in self._objects():\n            self._file.seek(offset)\n            tag = Tag(self._file)\n            if tag.id == 0xF500:\n                obj_id, obj_type = struct.unpack(\"<IH\", tag.contents)\n                if obj_type == type:\n                    objects.append((obj_id, offset, size))\n        return objects\n", "docstring": "from calibre.ebooks.lrf.tags import Tag"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/lrs/convert_from.py", "original_string": "        def me(base, tagname):\n            tag = base.find(tagname.lower())\n            if tag is None:\n                return ('', '', '')\n            tag = (self.tag_to_string(tag), tag.get('reading') if 'reading' in tag else '')  # noqa\n            return tag\n", "docstring": "tag = base.find(tagname.lower())"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrf.py", "original_string": "def writeColor(f, color):\n    # TODO: allow color names, web format\n    f.write(struct.pack(\">I\", int(color, 0)))\n", "docstring": "TODO: allow color names, web format"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrf.py", "original_string": "    def writeObjects(self, lrf):\n        # also appends object entries to the object table\n        self.objectTable = []\n        for obj in self.objects:\n            objStart = lrf.tell()\n            obj.write(lrf, self.sourceEncoding)\n            objEnd = lrf.tell()\n            self.objectTable.append(\n                    ObjectTableEntry(obj.objId, objStart, objEnd-objStart))\n", "docstring": "also appends object entries to the object table"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrs.py", "original_string": "def ElementWithText(tag, text, **extra):\n    \"\"\" A shorthand function to create Elements with text. \"\"\"\n    e = Element(tag, **extra)\n    e.text = text\n    return e\n", "docstring": "A shorthand function to create Elements with text. \n"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrs.py", "original_string": "def appendTextElements(e, contentsList, se):\n    \"\"\" A helper function to convert text streams into the proper elements. \"\"\"\n    def uconcat(text, newText, se):\n        if isinstance(text, bytes):\n            text = text.decode(se)\n        if isinstance(newText, bytes):\n            newText = newText.decode(se)\n        return text + newText\n    e.text = \"\"\n    lastElement = None\n    for content in contentsList:\n        if not isinstance(content, Text):\n            newElement = content.toElement(se)\n            if newElement is None:\n                continue\n            lastElement = newElement\n            lastElement.tail = \"\"\n            e.append(lastElement)\n        else:\n            if lastElement is None:\n                e.text = uconcat(e.text, content.text, se)\n            else:\n                lastElement.tail = uconcat(lastElement.tail, content.text, se)\n", "docstring": "A helper function to convert text streams into the proper elements. \n"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrs.py", "original_string": "    def setParent(self, parent):\n        if self.parent is not None:\n            raise LrsError(\"object already has parent\")\n        self.parent = parent\n", "docstring": "if self.parent is not None:"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrs.py", "original_string": "    def pages(self):\n        '''Return list of Page objects in this book '''\n        ans = []\n        for item in self.delegates:\n            if isinstance(item, Main):\n                for candidate in item.contents:\n                    if isinstance(candidate, Page):\n                        ans.append(candidate)\n                break\n        return ans\n", "docstring": "Return list of Page objects in this book '''"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrs.py", "original_string": "    def embed_font(self, file, facename):\n        f = Font(file, facename)\n        self.append(f)\n", "docstring": "f = Font(file, facename)"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrs.py", "original_string": "    def append(self, content):\n        \"\"\" Find and invoke the correct appender for this content. \"\"\"\n        className = content.__class__.__name__\n        try:\n            method = getattr(self, \"append\" + className)\n        except AttributeError:\n            raise LrsError(\"can't append %s to Book\" % className)\n        method(content)\n", "docstring": "Find and invoke the correct appender for this content. \n"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrs.py", "original_string": "    def toLrf(self, lrfWriter):\n        # does nothing\n        pass\n", "docstring": "does nothing"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrs.py", "original_string": "    def __init__(self, **settings):\n        # self.fixHeaderSettings(settings)\n        LrsStyle.__init__(self, \"PageStyle\", self.defaults,\n                alsoAllow=self.alsoAllow, **settings)\n", "docstring": "self.fixHeaderSettings(settings)"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrs.py", "original_string": "    def TextBlock(self, *args, **kwargs):\n        \"\"\" Create and append a new text block (shortcut). \"\"\"\n        tb = TextBlock(*args, **kwargs)\n        self.append(tb)\n        return tb\n", "docstring": "Create and append a new text block (shortcut). \n"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrs.py", "original_string": "    def getReferencedObjIds(self):\n        ids = [self.objId, self.extraId, self.blockStyle.objId,\n                self.textStyle.objId]\n        for content in self.contents:\n            if hasattr(content, \"getReferencedObjIds\"):\n                ids.extend(content.getReferencedObjIds())\n        return ids\n", "docstring": "ids = [self.objId, self.extraId, self.blockStyle.objId,"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrs.py", "original_string": "    def toLrfContainer(self, lrfWriter, container):\n        # id really belongs to the outer block\n        extraId = LrsObject.getNextObjId()\n        b = LrfObject(\"Block\", self.objId)\n        b.appendLrfTag(LrfTag(\"Link\", self.blockStyle.objId))\n        b.appendLrfTags(\n                LrfTagStream(0, [LrfTag(\"Link\", extraId)]).getStreamTags(lrfWriter.getSourceEncoding()))\n        b.appendTagDict(self.blockSettings)\n        container.addLrfObject(b.objId)\n        lrfWriter.append(b)\n        tb = LrfObject(\"TextBlock\", extraId)\n        tb.appendLrfTag(LrfTag(\"Link\", self.textStyle.objId))\n        tb.appendTagDict(self.textSettings)\n        stream = LrfTagStream(STREAM_COMPRESSED)\n        for content in self.contents:\n            content.toLrfContainer(lrfWriter, stream)\n        if lrfWriter.saveStreamTags:  # true only if testing\n            tb.saveStreamTags = stream.tags\n        tb.appendLrfTags(\n                stream.getStreamTags(lrfWriter.getSourceEncoding(),\n                    optimizeTags=lrfWriter.optimizeTags,\n                    optimizeCompression=lrfWriter.optimizeCompression))\n        lrfWriter.append(tb)\n        self.extraId = extraId\n", "docstring": "id really belongs to the outer block"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrs.py", "original_string": "    def toLrfContainer(self, lrfWriter, container):\n        # find the currentTextStyle\n        oldTextStyle = self.findCurrentTextStyle()\n        # set the attributes we want changed\n        for (name, value) in tuple(iteritems(self.attrs)):\n            if name in oldTextStyle.attrs and oldTextStyle.attrs[name] == self.attrs[name]:\n                self.attrs.pop(name)\n            else:\n                container.appendLrfTag(LrfTag(name, value))\n        # set a currentTextStyle so nested span can put things back\n        oldTextStyle = self.findCurrentTextStyle()\n        self.currentTextStyle = oldTextStyle.copy()\n        self.currentTextStyle.attrs.update(self.attrs)\n        for content in self.contents:\n            content.toLrfContainer(lrfWriter, container)\n        # put the attributes back the way we found them\n        # the attributes persist beyond the next </P>\n        # if self.hasFollowingContent():\n        for name in self.attrs.keys():\n            container.appendLrfTag(LrfTag(name, oldTextStyle.attrs[name]))\n", "docstring": "find the currentTextStyle"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/pylrs/pylrfopt.py", "original_string": "def _optimize(tagList, tagName, conversion):\n    # copy the tag of interest plus any text\n    newTagList = []\n    for tag in tagList:\n        if tag.name == tagName or tag.name == \"rawtext\":\n            newTagList.append(tag)\n    # now, eliminate any duplicates (leaving the last one)\n    for i, newTag in enumerate(newTagList[:-1]):\n        if newTag.name == tagName and newTagList[i+1].name == tagName:\n            tagList.remove(newTag)\n    # eliminate redundant settings to same value across text strings\n    newTagList = []\n    for tag in tagList:\n        if tag.name == tagName:\n            newTagList.append(tag)\n    for i, newTag in enumerate(newTagList[:-1]):\n        value = conversion(newTag.parameter)\n        nextValue = conversion(newTagList[i+1].parameter)\n        if value == nextValue:\n            tagList.remove(newTagList[i+1])\n    # eliminate any setting that don't have text after them\n    while len(tagList) > 0 and tagList[-1].name == tagName:\n        del tagList[-1]\n", "docstring": "copy the tag of interest plus any text"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/html/convert_from.py", "original_string": "    def is_book_designer(self, raw):\n        return bool(re.search('<H2[^><]*id=BookTitle', raw))\n", "docstring": "return bool(re.search('<H2[^><]*id=BookTitle', raw))"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/html/convert_from.py", "original_string": "        def merge_parent_css(prop, pcss):\n            # float should not be inherited according to the CSS spec\n            # however we need to as we don't do alignment at a block level.\n            # float is removed by the process_alignment function.\n            inherited = ['text-align', 'float', 'white-space', 'color',\n                         'line-height', 'vertical-align']\n            temp = {}\n            for key in pcss.keys():\n                chk = key.lower()\n                # float should not be inherited according to the CSS spec\n                # however we need to as we don't do alignment at a block level.\n                # float is removed by the process_alignment function.\n                if chk.startswith('font') or chk in inherited:\n                    temp[key] = pcss[key]\n            prop.update(temp)\n", "docstring": "float should not be inherited according to the CSS spec"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/html/convert_from.py", "original_string": "    def parse_file(self, soup):\n        def get_valid_block(page):\n            for item in page.contents:\n                if isinstance(item, (Canvas, TextBlock, ImageBlock, RuledLine)):\n                    if isinstance(item, TextBlock) and not item.contents:\n                        continue\n                    return item\n        if not self.current_page:\n            self.current_page = self.book.create_page()\n        self.current_block = self.book.create_text_block()\n        self.current_para = Paragraph()\n        if self.cover:\n            self.add_image_page(self.cover)\n            self.cover = None\n        top = self.current_block\n        self.current_block.must_append = True\n        self.soup = soup\n        self.process_children(soup, {}, {})\n        self.soup = None\n        if self.current_para and self.current_block:\n            self.current_para.append_to(self.current_block)\n        if self.current_block and self.current_page:\n            self.current_block.append_to(self.current_page)\n        if self.avoid_page_break:\n            self.avoid_page_break = False\n        elif self.current_page and self.current_page.has_text():\n            self.book.append(self.current_page)\n            self.current_page = None\n        if top not in top.parent.contents:  # May have been removed for a cover image\n            top = top.parent.contents[0]\n        if not top.has_text() and top.parent.contents.index(top) == len(top.parent.contents)-1:\n            # Empty block at the bottom of a page\n            opage = top.parent\n            top.parent.contents.remove(top)\n            if self.book.last_page() is opage:\n                if self.current_page and self.current_page.has_text():\n                    for c in self.current_page.contents:\n                        if isinstance(c, (TextBlock, ImageBlock)):\n                            return c\n                raise ConversionError(_('Could not parse file: %s')%self.file_name)\n            else:\n                try:\n                    index = self.book.pages().index(opage)\n                except ValueError:\n                    self.log.warning(_('%s is an empty file')%self.file_name)\n                    tb = self.book.create_text_block()\n                    self.current_page.append(tb)\n                    return tb\n                for page in list(self.book.pages()[index+1:]):\n                    for c in page.contents:\n                        if isinstance(c, (TextBlock, ImageBlock, Canvas)):\n                            return c\n                raise ConversionError(_('Could not parse file: %s')%self.file_name)\n        return top\n", "docstring": "def get_valid_block(page):"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/html/convert_from.py", "original_string": "        def add_toc_entry(text, target):\n            # TextBlocks in Canvases have a None parent or an Objects Parent\n            if target.parent is not None and \\\n               hasattr(target.parent, 'objId'):\n                self.book.addTocEntry(ascii_text, tb)\n            else:\n                self.log.debug(\"Cannot add link %s to TOC\"%ascii_text)\n", "docstring": "TextBlocks in Canvases have a None parent or an Objects Parent"}
{"repo": "calibre-master/src/calibre/ebooks/lrf/html/convert_from.py", "original_string": "    def process_block(self, tag, tag_css):\n        ''' Ensure padding and text-indent properties are respected '''\n        text_properties = self.text_properties(tag_css)\n        block_properties = self.block_properties(tag_css)\n        indent = (float(text_properties['parindent'])/10) * (self.profile.dpi/72)\n        margin = float(block_properties['sidemargin'])\n        # Since we're flattening the block structure, we need to ensure that text\n        # doesn't go off the left edge of the screen\n        if indent < 0 and margin + indent < 0:\n            text_properties['parindent'] = int(-margin * (72/self.profile.dpi) * 10)\n        align = self.get_alignment(tag_css)\n        def fill_out_properties(props, default):\n            for key in default.keys():\n                if key not in props:\n                    props[key] = default[key]\n        fill_out_properties(block_properties, self.book.defaultBlockStyle.attrs)\n        fill_out_properties(text_properties, self.book.defaultTextStyle.attrs)\n        def properties_different(dict1, dict2):\n            for key in dict1.keys():\n                if dict1[key] != dict2[key]:\n                    return True\n            return False\n        if properties_different(self.current_block.blockStyle.attrs, block_properties) or \\\n           properties_different(self.current_block.textStyle.attrs, text_properties) or\\\n           align != self.current_block.textStyle.attrs['align']:\n            ts = self.current_block.textStyle.copy()\n            ts.attrs.update(text_properties)\n            ts.attrs['align'] = align\n            bs = self.current_block.blockStyle.copy()\n            if not self.preserve_block_style:\n                bs.attrs.update(block_properties)\n            self.current_block.append_to(self.current_page)\n            try:\n                index = self.text_styles.index(ts)\n                ts = self.text_styles[index]\n            except ValueError:\n                self.text_styles.append(ts)\n            try:\n                index = self.block_styles.index(bs)\n                bs = self.block_styles[index]\n            except ValueError:\n                self.block_styles.append(bs)\n            self.current_block = self.book.create_text_block(blockStyle=bs,\n                                                             textStyle=ts)\n            return True\n        return False\n", "docstring": "Ensure padding and text-indent properties are respected '''"}
{"repo": "calibre-master/src/calibre/ebooks/odt/input.py", "original_string": "    def filter_load(self, odffile, mi, log):\n        \"\"\" This is an adaption from ODF2XHTML. It adds a step between\n            load and parse of the document where the Element tree can be\n            modified.\n        \"\"\"\n        # first load the odf structure\n        self.lines = []\n        self._wfunc = self._wlines\n        if isinstance(odffile, string_or_bytes) \\\n                or hasattr(odffile, 'read'):  # Added by Kovid\n            self.document = odLoad(odffile)\n        else:\n            self.document = odffile\n        # filter stuff\n        self.search_page_img(mi, log)\n        try:\n            self.filter_cover(mi, log)\n        except:\n            pass\n        # parse the modified tree and generate xhtml\n        self._walknode(self.document.topnode)\n", "docstring": "This is an adaption from ODF2XHTML. It adds a step between"}
{"repo": "calibre-master/src/calibre/ebooks/fb2/fb2ml.py", "original_string": "    def clean_text(self, text):\n        # Remove pointless tags, but keep their contents.\n        text = re.sub(r'(?mu)<(strong|emphasis|strikethrough|sub|sup)>(\\s*)</\\1>', r'\\2', text)\n        # Clean up paragraphs endings.\n        text = re.sub(r'(?ma)\\s+</p>', '</p>', text)\n        # Condense empty paragraphs into a line break.\n        text = re.sub(r'(?mu)(?:<p></p>\\s*){3,}', '<empty-line/>', text)\n        # Remove empty paragraphs.\n        text = re.sub(r'(?mu)<p></p>\\s*', '', text)\n        # Put the paragraph following a paragraph on a separate line.\n        text = re.sub(r'(?mu)</p>\\s*<p>', '</p>\\n<p>', text)\n        if self.opts.insert_blank_line:\n            text = re.sub(r'(?mu)</p>', '</p><empty-line/>', text)\n        # Clean up title endings.\n        text = re.sub(r'(?mu)\\s+</title>', '</title>', text)\n        # Remove empty title elements.\n        text = re.sub(r'(?mu)<title></title>\\s*', '', text)\n        # Put the paragraph following a title on a separate line.\n        text = re.sub(r'(?mu)</title>\\s*<p>', '</title>\\n<p>', text)\n        # Put line breaks between paragraphs on a separate line.\n        text = re.sub(r'(?mu)</(p|title)>\\s*<empty-line/>', r'</\\1>\\n<empty-line/>', text)\n        text = re.sub(r'(?mu)<empty-line/>\\s*<p>', '<empty-line/>\\n<p>', text)\n        # Remove empty sections.\n        text = re.sub(r'(?mu)<section>\\s*</section>', '', text)\n        # Clean up sections starts and ends.\n        text = re.sub(r'(?mu)\\s*<section>', '\\n<section>', text)\n        text = re.sub(r'(?mu)<section>\\s*', '<section>\\n', text)\n        text = re.sub(r'(?mu)\\s*</section>', '\\n</section>', text)\n        text = re.sub(r'(?mu)</section>\\s*', '</section>\\n', text)\n        return text\n", "docstring": "Remove pointless tags, but keep their contents."}
{"repo": "calibre-master/src/calibre/ebooks/comic/input.py", "original_string": "    def __init__(self, path_to_page, dest, opts, num):\n        list.__init__(self)\n        self.path_to_page = path_to_page\n        self.opts         = opts\n        self.num          = num\n        self.dest         = dest\n        self.rotate       = False\n        self.render()\n", "docstring": "list.__init__(self)"}
{"repo": "calibre-master/src/calibre/ebooks/comic/input.py", "original_string": "    def __init__(self, total, update):\n        self.total  = total\n        self.update = update\n        self.done   = 0\n", "docstring": "self.total  = total"}
{"repo": "calibre-master/src/calibre/ebooks/rtf/rtfml.py", "original_string": "def txt2rtf(text):\n    # Escape { and } in the text.\n    text = text.replace('{', r'\\'7b')\n    text = text.replace('}', r'\\'7d')\n    text = text.replace('\\\\', r'\\'5c')\n    if not isinstance(text, unicode_type):\n        return text\n    buf = io.StringIO()\n    for x in text:\n        val = ord(x)\n        if val == 160:\n            buf.write(r'\\~')\n        elif val <= 127:\n            buf.write(x)\n        else:\n            # python2 and ur'\\u' does not work\n            c = '\\\\u{0:d}?'.format(val)\n            buf.write(c)\n    return buf.getvalue()\n", "docstring": "Escape { and } in the text."}
{"repo": "calibre-master/src/calibre/ebooks/rtf/rtfml.py", "original_string": "    def image_to_hexstring(self, data):\n        # Images must be hex-encoded in 128 character lines\n        data = save_cover_data_to(data)\n        width, height = identify(data)[1:]\n        lines = []\n        v = memoryview(data)\n        for i in range(0, len(data), 64):\n            lines.append(hexlify(v[i:i+64]))\n        hex_string = b'\\n'.join(lines).decode('ascii')\n        return hex_string, width, height\n", "docstring": "Images must be hex-encoded in 128 character lines"}
{"repo": "calibre-master/src/css_selectors/ordered_set.py", "original_string": "    def __init__(self, iterable=None):\n        self.items = []\n        self.map = {}\n        if iterable is not None:\n            for item in iterable:\n                idx = self.map.get(item)\n                if idx is None:\n                    self.map[item] = len(self.items)\n                    self.items.append(item)\n", "docstring": "self.items = []"}
{"repo": "calibre-master/src/css_selectors/ordered_set.py", "original_string": "    def __getstate__(self):\n        return tuple(self)\n", "docstring": "return tuple(self)"}
{"repo": "calibre-master/src/css_selectors/ordered_set.py", "original_string": "    def __iter__(self):\n        return iter(self.items)\n", "docstring": "return iter(self.items)"}
{"repo": "calibre-master/src/css_selectors/select.py", "original_string": "def select_combinedselector(cache, combined):\n    \"\"\"Translate a combined selector.\"\"\"\n    combinator = cache.combinator_mapping[combined.combinator]\n    # Fast path for when the sub-selector is all elements\n    right = None if isinstance(combined.subselector, Element) and (\n        combined.subselector.element or '*') == '*' else cache.iterparsedselector(combined.subselector)\n    for item in cache.dispatch_map[combinator](cache, cache.iterparsedselector(combined.selector), right):\n        yield item\n", "docstring": "Translate a combined selector.\n"}
{"repo": "calibre-master/src/css_selectors/select.py", "original_string": "def select_child(cache, left, right):\n    \"\"\"right is an immediate child of left\"\"\"\n    right = always_in if right is None else frozenset(right)\n    for parent in left:\n        for child in cache.iterchildren(parent):\n            if child in right:\n                yield child\n", "docstring": "right is an immediate child of left\n"}
{"repo": "calibre-master/src/css_selectors/select.py", "original_string": "def select_indirect_adjacent(cache, left, right):\n    \"\"\"right is a sibling after left, immediately or not\"\"\"\n    right = always_in if right is None else frozenset(right)\n    for parent in left:\n        for sibling in cache.itersiblings(parent):\n            if sibling in right:\n                yield sibling\n", "docstring": "right is a sibling after left, immediately or not\n"}
{"repo": "calibre-master/src/css_selectors/select.py", "original_string": "def select_element(cache, selector):\n    \"\"\"A type or universal selector.\"\"\"\n    element = selector.element\n    if not element or element == '*':\n        for elem in cache.itertag():\n            yield elem\n    else:\n        for elem in cache.element_map[ascii_lower(element)]:\n            yield elem\n", "docstring": "A type or universal selector.\n"}
{"repo": "calibre-master/src/css_selectors/select.py", "original_string": "def select_function(cache, function):\n    \"\"\"Select with a functional pseudo-class.\"\"\"\n    fname = function.name.replace('-', '_')\n    try:\n        func = cache.dispatch_map[fname]\n    except KeyError:\n        raise ExpressionError(\n            \"The pseudo-class :%s() is unknown\" % function.name)\n    if fname == 'lang':\n        items = frozenset(func(cache, function))\n        for item in cache.iterparsedselector(function.selector):\n            if item in items:\n                yield item\n    else:\n        for item in cache.iterparsedselector(function.selector):\n            if func(cache, function, item):\n                yield item\n", "docstring": "Select with a functional pseudo-class.\n"}
{"repo": "calibre-master/src/css_selectors/parser.py", "original_string": "    def ascii_lower(string):\n        \"\"\"Lower-case, but only in the ASCII range.\"\"\"\n        return string.translate(utab if isinstance(string, unicode_type) else tab)\n", "docstring": "Lower-case, but only in the ASCII range.\n"}
{"repo": "calibre-master/src/css_selectors/parser.py", "original_string": "    def specificity(self):\n        \"\"\"Return the specificity_ of this selector as a tuple of 3 integers.\n        .. _specificity: http://www.w3.org/TR/selectors/#specificity\n        \"\"\"\n        a, b, c = self.parsed_tree.specificity()\n        if self.pseudo_element:\n            c += 1\n        return a, b, c\n", "docstring": "Return the specificity_ of this selector as a tuple of 3 integers."}
{"repo": "calibre-master/src/css_selectors/parser.py", "original_string": "def parse(css):\n    \"\"\"Parse a CSS *group of selectors*.\n    :param css:\n        A *group of selectors* as an Unicode string.\n    :raises:\n        :class:`SelectorSyntaxError` on invalid selectors.\n    :returns:\n        A list of parsed :class:`Selector` objects, one for each\n        selector in the comma-separated group.\n    \"\"\"\n    # Fast path for simple cases\n    match = _el_re.match(css)\n    if match:\n        return [Selector(Element(element=match.group(1)))]\n    match = _id_re.match(css)\n    if match is not None:\n        return [Selector(Hash(Element(element=match.group(1) or None),\n                              match.group(2)))]\n    match = _class_re.match(css)\n    if match is not None:\n        return [Selector(Class(Element(element=match.group(1) or None),\n                               match.group(2)))]\n    stream = TokenStream(tokenize(css))\n    stream.source = css\n    return list(parse_selector_group(stream))\n", "docstring": "Parse a CSS *group of selectors*."}
{"repo": "calibre-master/src/tinycss/parsing.py", "original_string": "def split_on_comma(tokens):\n    \"\"\"Split a list of tokens on commas, ie ``,`` DELIM tokens.\n    Only \"top-level\" comma tokens are splitting points, not commas inside a\n    function or other :class:`ContainerToken`.\n    :param tokens:\n        An iterable of :class:`~.token_data.Token` or\n        :class:`~.token_data.ContainerToken`.\n    :returns:\n        A list of lists of tokens\n    \"\"\"\n    parts = []\n    this_part = []\n    for token in tokens:\n        if token.type == 'DELIM' and token.value == ',':\n            parts.append(this_part)\n            this_part = []\n        else:\n            this_part.append(token)\n    parts.append(this_part)\n    return parts\n", "docstring": "Split a list of tokens on commas, ie ``,`` DELIM tokens."}
{"repo": "calibre-master/src/tinycss/parsing.py", "original_string": "def remove_whitespace(tokens):\n    \"\"\"Remove any top-level whitespace in a token list.\n    Whitespace tokens inside recursive :class:`~.token_data.ContainerToken`\n    are preserved.\n    :param tokens:\n        A list of :class:`~.token_data.Token` or\n        :class:`~.token_data.ContainerToken`.\n    :return:\n        A new sub-sequence of the list.\n    \"\"\"\n    return [token for token in tokens if token.type != 'S']\n", "docstring": "Remove any top-level whitespace in a token list."}
{"repo": "calibre-master/src/tinycss/token_data.py", "original_string": "def _init():\n    \"\"\"Import-time initialization.\"\"\"\n    COMPILED_MACROS.clear()\n    for line in MACROS.splitlines():\n        if line.strip():\n            name, value = line.split('\\t')\n            COMPILED_MACROS[name.strip()] = '(?:%s)' \\\n                % value.format(**COMPILED_MACROS)\n    COMPILED_TOKEN_REGEXPS[:] = (\n        (\n            name.strip(),\n            re.compile(\n                value.format(**COMPILED_MACROS),\n                # Case-insensitive when matching eg. uRL(foo)\n                # but preserve the case in extracted groups\n                re.I\n            ).match\n        )\n        for line in TOKENS.splitlines()\n        if line.strip()\n        for name, value in [line.split('\\t')]\n    )\n    COMPILED_TOKEN_INDEXES.clear()\n    for i, (name, regexp) in enumerate(COMPILED_TOKEN_REGEXPS):\n        COMPILED_TOKEN_INDEXES[name] = i\n    dispatch = [[] for i in range(161)]\n    for chars, names in [\n        (' \\t\\r\\n\\f', ['S']),\n        ('uU', ['URI', 'BAD_URI', 'UNICODE-RANGE']),\n        # \\ is an escape outside of another token\n        (string.ascii_letters + '\\\\_-' + unichr(160), ['FUNCTION', 'IDENT']),\n        (string.digits + '.+-', ['DIMENSION', 'PERCENTAGE', 'NUMBER']),\n        ('@', ['ATKEYWORD']),\n        ('#', ['HASH']),\n        ('\\'\"', ['STRING', 'BAD_STRING']),\n        ('/', ['COMMENT', 'BAD_COMMENT']),\n        ('<', ['CDO']),\n        ('-', ['CDC']),\n    ]:\n        for char in chars:\n            dispatch[ord(char)].extend(names)\n    for char in ':;{}()[]':\n        dispatch[ord(char)] = [char]\n    TOKEN_DISPATCH[:] = (\n        [\n            (index,) + COMPILED_TOKEN_REGEXPS[index]\n            for name in names\n            for index in [COMPILED_TOKEN_INDEXES[name]]\n        ]\n        for names in dispatch\n    )\n", "docstring": "Import-time initialization.\n"}
{"repo": "calibre-master/src/tinycss/token_data.py", "original_string": "    def line(self):\n        \"\"\"The line number in the CSS source of the first token.\"\"\"\n        return self[0].line\n", "docstring": "The line number in the CSS source of the first token.\n"}
{"repo": "calibre-master/src/tinycss/token_data.py", "original_string": "    def column(self):\n        \"\"\"The column number (inside a source line) of the first token.\"\"\"\n        return self[0].column\n", "docstring": "The column number (inside a source line) of the first token.\n"}
{"repo": "calibre-master/src/tinycss/tokenizer.py", "original_string": "def tokenize_flat(css_source, ignore_comments=True,\n    # Make these local variable to avoid global lookups in the loop\n    tokens_dispatch=token_data.TOKEN_DISPATCH,\n    unicode_unescape=token_data.UNICODE_UNESCAPE,\n    newline_unescape=token_data.NEWLINE_UNESCAPE,\n    simple_unescape=token_data.SIMPLE_UNESCAPE,\n    find_newlines=token_data.FIND_NEWLINES,\n    Token=token_data.Token,\n    len=len,\n    int=int,\n    float=float,\n    list=list,\n    _None=None,\n", "docstring": "Make these local variable to avoid global lookups in the loop"}
{"repo": "calibre-master/src/tinycss/__init__.py", "original_string": "def make_parser(*features, **kwargs):\n    \"\"\"Make a parser object with the chosen features.\n    :param features:\n        Positional arguments are base classes the new parser class will extend.\n        The string ``'page3'`` is accepted as short for\n        :class:`~page3.CSSPage3Parser`.\n    :param kwargs:\n        Keyword arguments are passed to the parser’s constructor.\n    :returns:\n        An instance of a new subclass of :class:`CSS21Parser`\n    \"\"\"\n    if features:\n        bases = tuple(PARSER_MODULES.get(f, f) for f in features)\n        parser_class = type('CustomCSSParser', bases + (CSS21Parser,), {})\n    else:\n        parser_class = CSS21Parser\n    return parser_class(**kwargs)\n", "docstring": "Make a parser object with the chosen features."}
{"repo": "calibre-master/src/tinycss/css21.py", "original_string": "def _remove_at_charset(tokens):\n    \"\"\"Remove any valid @charset at the beggining of a token stream.\n    :param tokens:\n        An iterable of tokens\n    :returns:\n        A possibly truncated iterable of tokens\n    \"\"\"\n    tokens = iter(tokens)\n    header = list(islice(tokens, 4))\n    if [t.type for t in header] == ['ATKEYWORD', 'S', 'STRING', ';']:\n        atkw, space, string, semicolon = header\n        if ((atkw.value, space.value) == ('@charset', ' ')\n                and string.as_css()[0] == '\"'):\n            # Found a valid @charset rule, only keep what’s after it.\n            return tokens\n    return chain(header, tokens)\n", "docstring": "Remove any valid @charset at the beggining of a token stream."}
{"repo": "calibre-master/src/tinycss/css21.py", "original_string": "    def parse_stylesheet(self, css_unicode, encoding=None):\n        \"\"\"Parse a stylesheet from an Unicode string.\n        :param css_unicode:\n            A CSS stylesheet as an unicode string.\n        :param encoding:\n            The character encoding used to decode the stylesheet from bytes,\n            if any.\n        :return:\n            A :class:`Stylesheet`.\n        \"\"\"\n        tokens = tokenize_grouped(css_unicode)\n        if encoding:\n            tokens = _remove_at_charset(tokens)\n        rules, errors = self.parse_rules(tokens, context='stylesheet')\n        return Stylesheet(rules, errors, encoding)\n", "docstring": "Parse a stylesheet from an Unicode string."}
{"repo": "calibre-master/src/tinycss/css21.py", "original_string": "    def parse_rules(self, tokens, context):\n        \"\"\"Parse a sequence of rules (rulesets and at-rules).\n        :param tokens:\n            An iterable of tokens.\n        :param context:\n            Either ``'stylesheet'`` or an at-keyword such as ``'@media'``.\n            (Most at-rules are only allowed in some contexts.)\n        :return:\n            A tuple of a list of parsed rules and a list of\n            :class:`~.parsing.ParseError`.\n        \"\"\"\n        rules = []\n        errors = []\n        tokens = iter(tokens)\n        for token in tokens:\n            if token.type not in ('S', 'CDO', 'CDC'):\n                try:\n                    if token.type == 'ATKEYWORD':\n                        rule = self.read_at_rule(token, tokens)\n                        result = self.parse_at_rule(\n                            rule, rules, errors, context)\n                        rules.append(result)\n                    else:\n                        rule, rule_errors = self.parse_ruleset(token, tokens)\n                        rules.append(rule)\n                        errors.extend(rule_errors)\n                except ParseError as exc:\n                    errors.append(exc)\n                    # Skip the entire rule\n        return rules, errors\n", "docstring": "Parse a sequence of rules (rulesets and at-rules)."}
{"repo": "calibre-master/src/tinycss/css21.py", "original_string": "    def parse_at_rule(self, rule, previous_rules, errors, context):\n        \"\"\"Parse an at-rule.\n        Subclasses that override this method must use ``super()`` and\n        pass its return value for at-rules they do not know.\n        In CSS 2.1, this method handles @charset, @import, @media and @page\n        rules.\n        :param rule:\n            An unparsed :class:`AtRule`.\n        :param previous_rules:\n            The list of at-rules and rulesets that have been parsed so far\n            in this context. This list can be used to decide if the current\n            rule is valid. (For example, @import rules are only allowed\n            before anything but a @charset rule.)\n        :param context:\n            Either ``'stylesheet'`` or an at-keyword such as ``'@media'``.\n            (Most at-rules are only allowed in some contexts.)\n        :raises:\n            :class:`~.parsing.ParseError` if the rule is invalid.\n        :return:\n            A parsed at-rule\n        \"\"\"\n        try:\n            parser = self.at_parsers[rule.at_keyword]\n        except KeyError:\n            raise ParseError(rule, 'unknown at-rule in {0} context: {1}'\n                                    .format(context, rule.at_keyword))\n        else:\n            return parser(rule, previous_rules, errors, context)\n", "docstring": "Parse an at-rule."}
{"repo": "calibre-master/src/tinycss/css21.py", "original_string": "    def parse_page_selector(self, tokens):\n        \"\"\"Parse an @page selector.\n        :param tokens:\n            An iterable of token, typically from the  ``head`` attribute of\n            an unparsed :class:`AtRule`.\n        :returns:\n            A page selector. For CSS 2.1, this is ``'first'``, ``'left'``,\n            ``'right'`` or ``None``.\n        :raises:\n            :class:`~.parsing.ParseError` on invalid selectors\n        \"\"\"\n        if not tokens:\n            return None, (0, 0)\n        if (len(tokens) == 2 and tokens[0].type == ':'\n                and tokens[1].type == 'IDENT'):\n            pseudo_class = tokens[1].value\n            specificity = {\n                'first': (1, 0), 'left': (0, 1), 'right': (0, 1),\n            }.get(pseudo_class)\n            if specificity:\n                return pseudo_class, specificity\n        raise ParseError(tokens[0], 'invalid @page selector')\n", "docstring": "Parse an @page selector."}
{"repo": "calibre-master/src/tinycss/css21.py", "original_string": "    def parse_ruleset(self, first_token, tokens):\n        \"\"\"Parse a ruleset: a selector followed by declaration block.\n        :param first_token:\n            The first token of the ruleset (probably of the selector).\n            You may have read it already to distinguish the rule\n            from an at-rule.\n        :param tokens:\n            an iterator of subsequent tokens. Will be consumed just enough\n            for one ruleset.\n        :return:\n            a tuple of a :class:`RuleSet` and an error list.\n            The errors are recovered :class:`~.parsing.ParseError` in declarations.\n            (Parsing continues from the next declaration on such errors.)\n        :raises:\n            :class:`~.parsing.ParseError` if the selector is invalid for the\n            core grammar.\n            Note a that a selector can be valid for the core grammar but\n            not for CSS 2.1 or another level.\n        \"\"\"\n        selector = []\n        for token in chain([first_token], tokens):\n            if token.type == '{':\n                # Parse/validate once we’ve read the whole rule\n                selector = strip_whitespace(selector)\n                if not selector:\n                    raise ParseError(first_token, 'empty selector')\n                for selector_token in selector:\n                    validate_any(selector_token, 'selector')\n                declarations, errors = self.parse_declaration_list(\n                    token.content)\n                ruleset = RuleSet(selector, declarations,\n                                  first_token.line, first_token.column)\n                return ruleset, errors\n            else:\n                selector.append(token)\n        raise ParseError(token, 'no declaration block found for ruleset')\n", "docstring": "Parse a ruleset: a selector followed by declaration block."}
{"repo": "calibre-master/src/tinycss/css21.py", "original_string": "    def parse_declaration(self, tokens):\n        \"\"\"Parse a single declaration.\n        :param tokens:\n            an iterable of at least one token. Should stop at (before)\n            the end of the declaration, as marked by a ``;`` or ``}``.\n            Empty declarations (ie. consecutive ``;`` with only white space\n            in-between) should be skipped earlier and not passed to\n            this method.\n        :returns:\n            a :class:`Declaration`\n        :raises:\n            :class:`~.parsing.ParseError` if the tokens do not match the\n            'declaration' production of the core grammar.\n        \"\"\"\n        tokens = iter(tokens)\n        name_token = next(tokens)  # assume there is at least one\n        if name_token.type == 'IDENT':\n            # CSS syntax is case-insensitive\n            property_name = name_token.value.lower()\n        else:\n            raise ParseError(name_token,\n                'expected a property name, got {0}'.format(name_token.type))\n        token = name_token  # In case ``tokens`` is now empty\n        for token in tokens:\n            if token.type == ':':\n                break\n            elif token.type != 'S':\n                raise ParseError(\n                    token, \"expected ':', got {0}\".format(token.type))\n        else:\n            raise ParseError(token, \"expected ':'\")\n        value = strip_whitespace(list(tokens))\n        if not value:\n            raise ParseError(token, 'expected a property value')\n        validate_value(value)\n        value, priority = self.parse_value_priority(value)\n        return Declaration(\n            property_name, value, priority, name_token.line, name_token.column)\n", "docstring": "Parse a single declaration."}
{"repo": "calibre-master/src/tinycss/color3.py", "original_string": "def parse_color_string(css_string):\n    \"\"\"Parse a CSS string as a color value.\n    This is a convenience wrapper around :func:`parse_color` in case you\n    have a string that is not from a CSS stylesheet.\n    :param css_string:\n        An unicode string in CSS syntax.\n    :returns:\n        Same as :func:`parse_color`.\n    \"\"\"\n    tokens = list(tokenize_grouped(css_string.strip()))\n    if len(tokens) == 1:\n        return parse_color(tokens[0])\n", "docstring": "Parse a CSS string as a color value."}
{"repo": "calibre-master/src/tinycss/color3.py", "original_string": "    def hue_to_rgb(m1, m2, h):\n        if h < 0:\n            h += 1\n        if h > 1:\n            h -= 1\n        if h * 6 < 1:\n            return m1 + (m2 - m1) * h * 6\n        if h * 2 < 1:\n            return m2\n        if h * 3 < 2:\n            return m1 + (m2 - m1) * (2 / 3 - h) * 6\n        return m1\n", "docstring": "if h < 0:"}
{"repo": "calibre-master/src/tinycss/color3.py", "original_string": "def parse_comma_separated(tokens):\n    \"\"\"Parse a list of tokens (typically the content of a function token)\n    as arguments made of a single token each, separated by mandatory commas,\n    with optional white space around each argument.\n    return the argument list without commas or white space;\n    or None if the function token content do not match the description above.\n    \"\"\"\n    tokens = [token for token in tokens if token.type != 'S']\n    if not tokens:\n        return []\n    if len(tokens) % 2 == 1 and all(\n            token.type == 'DELIM' and token.value == ','\n            for token in tokens[1::2]):\n        return tokens[::2]\n", "docstring": "Parse a list of tokens (typically the content of a function token)"}
{"repo": "calibre-master/src/tinycss/tests/decoding.py", "original_string": "def params(css, encoding, use_bom=False, expect_error=False, **kwargs):\n    \"\"\"Nicer syntax to make a tuple.\"\"\"\n    return css, encoding, use_bom, expect_error, kwargs\n", "docstring": "Nicer syntax to make a tuple.\n"}
{"repo": "calibre-master/src/tinycss/tests/__init__.py", "original_string": "def jsonify(tokens):\n    \"\"\"Turn tokens into \"JSON-compatible\" data structures.\"\"\"\n    for token in tokens:\n        if token.type == 'FUNCTION':\n            yield (token.type, token.function_name,\n                   list(jsonify(token.content)))\n        elif token.is_container:\n            yield token.type, list(jsonify(token.content))\n        else:\n            yield token.type, token.value\n", "docstring": "Turn tokens into \"JSON-compatible\" data structures.\n"}
{"repo": "calibre-master/src/tinycss/tests/__init__.py", "original_string": "    def assert_errors(self, errors, expected_errors):\n        \"\"\"Test not complete error messages but only substrings.\"\"\"\n        self.ae(len(errors), len(expected_errors))\n        for error, expected in zip(errors, expected_errors):\n            self.assertIn(expected, type(u'')(error))\n", "docstring": "Test not complete error messages but only substrings.\n"}
{"repo": "calibre-master/src/odf/userfield.py", "original_string": "    def __init__(self, src=None, dest=None):\n        \"\"\"Constructor\n        src ... source document name, file like object or None for stdin\n        dest ... destination document name, file like object or None for stdout\n        \"\"\"\n        self.src_file = src\n        self.dest_file = dest\n        self.document = None\n", "docstring": "Constructor"}
{"repo": "calibre-master/src/odf/userfield.py", "original_string": "    def savedoc(self):\n        # write output\n        if self.dest_file is None:\n            # use stdout if no filename given\n            self.document.save('-')\n        else:\n            self.document.save(self.dest_file)\n", "docstring": "write output"}
{"repo": "calibre-master/src/odf/userfield.py", "original_string": "    def list_fields_and_values(self, field_names=None):\n        \"\"\"List (extract) user-fields with type and value.\n        field_names ... list of field names to show or None for all.\n        Returns list of tuples (<field name>, <field type>, <value>).\n        \"\"\"\n        self.loaddoc()\n        found_fields = []\n        all_fields = self.document.getElementsByType(UserFieldDecl)\n        for f in all_fields:\n            value_type = f.getAttribute('valuetype')\n            if value_type == 'string':\n                value = f.getAttribute('stringvalue')\n            else:\n                value = f.getAttribute('value')\n            field_name = f.getAttribute('name')\n            if field_names is None or field_name in field_names:\n                found_fields.append((field_name.encode(OUTENCODING),\n                                     value_type.encode(OUTENCODING),\n                                     value.encode(OUTENCODING)))\n        return found_fields\n", "docstring": "List (extract) user-fields with type and value."}
{"repo": "calibre-master/src/odf/userfield.py", "original_string": "    def get(self, field_name):\n        \"\"\"Extract the contents of this field from the file.\n        Returns field value or None if field does not exist.\n        \"\"\"\n        values = self.list_values([field_name])\n        if not values:\n            return None\n        return values[0]\n", "docstring": "Extract the contents of this field from the file."}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def __init__(self):\n        # Font declarations\n        self.fontdict = {}\n        # Fill-images from presentations for backgrounds\n        self.fillimages = {}\n        self.ruleconversions = {\n            (DRAWNS,u'fill-image-name'): self.c_drawfillimage,\n            (FONS,u\"background-color\"): self.c_fo,\n            (FONS,u\"border\"): self.c_fo,\n            (FONS,u\"border-bottom\"): self.c_fo,\n            (FONS,u\"border-left\"): self.c_fo,\n            (FONS,u\"border-right\"): self.c_fo,\n            (FONS,u\"border-top\"): self.c_fo,\n            (FONS,u\"break-after\"): self.c_break,  # Added by Kovid\n            (FONS,u\"break-before\"): self.c_break,  # Added by Kovid\n            (FONS,u\"color\"): self.c_fo,\n            (FONS,u\"font-family\"): self.c_fo,\n            (FONS,u\"font-size\"): self.c_fo,\n            (FONS,u\"font-style\"): self.c_fo,\n            (FONS,u\"font-variant\"): self.c_fo,\n            (FONS,u\"font-weight\"): self.c_fo,\n            (FONS,u\"line-height\"): self.c_fo,\n            (FONS,u\"margin\"): self.c_fo,\n            (FONS,u\"margin-bottom\"): self.c_fo,\n            (FONS,u\"margin-left\"): self.c_fo,\n            (FONS,u\"margin-right\"): self.c_fo,\n            (FONS,u\"margin-top\"): self.c_fo,\n            (FONS,u\"min-height\"): self.c_fo,\n            (FONS,u\"padding\"): self.c_fo,\n            (FONS,u\"padding-bottom\"): self.c_fo,\n            (FONS,u\"padding-left\"): self.c_fo,\n            (FONS,u\"padding-right\"): self.c_fo,\n            (FONS,u\"padding-top\"): self.c_fo,\n            (FONS,u\"page-width\"): self.c_page_width,\n            (FONS,u\"page-height\"): self.c_page_height,\n            (FONS,u\"text-align\"): self.c_text_align,\n            (FONS,u\"text-indent\") :self.c_fo,\n            (TABLENS,u'border-model') :self.c_border_model,\n            (STYLENS,u'column-width') : self.c_width,\n            (STYLENS,u\"font-name\"): self.c_fn,\n            (STYLENS,u'horizontal-pos'): self.c_hp,\n            (STYLENS,u'text-position'): self.c_text_position,\n            (STYLENS,u'text-line-through-style'): self.c_text_line_through_style,\n            (STYLENS,u'text-underline-style'): self.c_text_underline_style,\n            (STYLENS,u'width') : self.c_width,\n            # FIXME Should do style:vertical-pos here\n        }\n", "docstring": "Font declarations"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def c_drawfillimage(self, ruleset, sdict, rule, val):\n        \"\"\" Fill a figure with an image. Since CSS doesn't let you resize images\n            this should really be implemented as an absolutely position <img>\n            with a width and a height\n        \"\"\"\n        sdict['background-image'] = \"url('%s')\" % self.fillimages[val]\n", "docstring": "Fill a figure with an image. Since CSS doesn't let you resize images"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def c_width(self, ruleset, sdict, rule, val):\n        \"\"\" Set width of box \"\"\"\n        sdict['width'] = val\n", "docstring": "Set width of box \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def c_fn(self, ruleset, sdict, rule, fontstyle):\n        \"\"\" Generate the CSS font family\n            A generic font can be found in two ways. In a <style:font-face>\n            element or as a font-family-generic attribute in text-properties.\n        \"\"\"\n        generic = ruleset.get((STYLENS,'font-family-generic'))\n        if generic is not None:\n            self.save_font(fontstyle, fontstyle, generic)\n        family, htmlgeneric = self.fontdict.get(fontstyle, (fontstyle, 'serif'))\n        sdict['font-family'] = '%s, %s'  % (family, htmlgeneric)\n", "docstring": "Generate the CSS font family"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def c_hp(self, ruleset, sdict, rule, hpos):\n        # FIXME: Frames wrap-style defaults to 'parallel', graphics to 'none'.\n        # It is properly set in the parent-styles, but the program doesn't\n        # collect the information.\n        wrap = ruleset.get((STYLENS,'wrap'),'parallel')\n        # Can have: from-left, left, center, right, from-inside, inside, outside\n        if hpos == \"center\":\n            sdict['margin-left'] = \"auto\"\n            sdict['margin-right'] = \"auto\"\n        # else:\n        #     # force it to be *something* then delete it\n        #     sdict['margin-left'] = sdict['margin-right'] = ''\n        #     del sdict['margin-left'], sdict['margin-right']\n        if hpos in (\"right\",\"outside\"):\n            if wrap in (\"left\", \"parallel\",\"dynamic\"):\n                sdict['float'] = \"right\"\n            elif wrap == \"run-through\":\n                sdict['position'] = \"absolute\"  # Simulate run-through\n                sdict['top'] = \"0\"\n                sdict['right'] = \"0\"\n            else:  # No wrapping\n                sdict['margin-left'] = \"auto\"\n                sdict['margin-right'] = \"0px\"\n        elif hpos in (\"left\", \"inside\"):\n            if wrap in (\"right\", \"parallel\",\"dynamic\"):\n                sdict['float'] = \"left\"\n            elif wrap == \"run-through\":\n                sdict['position'] = \"absolute\"  # Simulate run-through\n                sdict['top'] = \"0\"\n                sdict['left'] = \"0\"\n            else:  # No wrapping\n                sdict['margin-left'] = \"0px\"\n                sdict['margin-right'] = \"auto\"\n        elif hpos in (\"from-left\", \"from-inside\"):\n            if wrap in (\"right\", \"parallel\"):\n                sdict['float'] = \"left\"\n            else:\n                sdict['position'] = \"relative\"  # No wrapping\n                if (SVGNS,'x') in ruleset:\n                    sdict['left'] = ruleset[(SVGNS,'x')]\n", "docstring": "FIXME: Frames wrap-style defaults to 'parallel', graphics to 'none'."}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def c_text_underline_style(self, ruleset, sdict, rule, val):\n        \"\"\" Set underline decoration\n            HTML doesn't really have a page-width. It is always 100% of the browser width\n        \"\"\"\n        if val and val != \"none\":\n            sdict['text-decoration'] = \"underline\"\n", "docstring": "Set underline decoration"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def c_page_height(self, ruleset, sdict, rule, val):\n        \"\"\" Set height of box \"\"\"\n        sdict['height'] = val\n", "docstring": "Set height of box \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def rfindattr(self, attr):\n        \"\"\" Find a tag with the given attribute \"\"\"\n        for tag, attrs in self.stack:\n            if attr in attrs:\n                return attrs[attr]\n        return None\n", "docstring": "Find a tag with the given attribute \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def set_plain(self):\n        \"\"\" Tell the parser to not generate CSS \"\"\"\n        self.generate_css = False\n", "docstring": "Tell the parser to not generate CSS \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def add_style_file(self, stylefilename, media=None):\n        \"\"\" Add a link to an external style file.\n            Also turns of the embedding of styles in the HTML\n        \"\"\"\n        self.use_internal_css = False\n        self.stylefilename = stylefilename\n        if media:\n            self.metatags.append('<link rel=\"stylesheet\" type=\"text/css\" href=\"%s\" media=\"%s\"/>\\n' % (stylefilename,media))\n        else:\n            self.metatags.append('<link rel=\"stylesheet\" type=\"text/css\" href=\"%s\"/>\\n' % (stylefilename))\n", "docstring": "Add a link to an external style file."}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def closetag(self, tag, block=True):\n        \"\"\" Close an open HTML tag \"\"\"\n        self.htmlstack.pop()\n        self.writeout(\"</%s>\" % tag)\n        if block:\n            self.writeout(\"\\n\")\n", "docstring": "Close an open HTML tag \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_ignorexml(self, tag, attrs):\n        \"\"\" Ignore this xml element and all children of it\n            It will automatically stop ignoring\n        \"\"\"\n        self.processelem = False\n", "docstring": "Ignore this xml element and all children of it"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_processcont(self, tag, attrs):\n        \"\"\" Start processing the text nodes \"\"\"\n        self.processcont = True\n", "docstring": "Start processing the text nodes \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def get_anchor(self, name):\n        \"\"\" Create a unique anchor id for a href name \"\"\"\n        if name not in self.anchors:\n            # Changed by Kovid\n            self.anchors[name] = \"anchor%d\" % (len(self.anchors) + 1)\n        return self.anchors.get(name)\n", "docstring": "Create a unique anchor id for a href name \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def e_dc_title(self, tag, attrs):\n        \"\"\" Get the title from the meta data and create a HTML <title>\n        \"\"\"\n        self.title = ''.join(self.data)\n        # self.metatags.append('<title>%s</title>\\n' % escape(self.title))\n        self.data = []\n", "docstring": "Get the title from the meta data and create a HTML <title>"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def e_dc_contentlanguage(self, tag, attrs):\n        \"\"\" Set the content language. Identifies the targeted audience\n        \"\"\"\n        self.language = ''.join(self.data)\n        self.metatags.append('<meta http-equiv=\"content-language\" content=\"%s\"/>\\n' % escape(self.language))\n        self.data = []\n", "docstring": "Set the content language. Identifies the targeted audience"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_custom_shape(self, tag, attrs):\n        \"\"\" A <draw:custom-shape> is made into a <div> in HTML which is then styled\n        \"\"\"\n        anchor_type = attrs.get((TEXTNS,'anchor-type'),'notfound')\n        htmltag = 'div'\n        name = \"G-\" + attrs.get((DRAWNS,'style-name'), \"\")\n        if name == 'G-':\n            name = \"PR-\" + attrs.get((PRESENTATIONNS,'style-name'), \"\")\n        name = name.replace(\".\",\"_\")\n        if anchor_type == \"paragraph\":\n            style = 'position:absolute;'\n        elif anchor_type == 'char':\n            style = \"position:absolute;\"\n        elif anchor_type == 'as-char':\n            htmltag = 'div'\n            style = ''\n        else:\n            style = \"position: absolute;\"\n        if (SVGNS,\"width\") in attrs:\n            style = style + \"width:\" + attrs[(SVGNS,\"width\")] + \";\"\n        if (SVGNS,\"height\") in attrs:\n            style = style + \"height:\" +  attrs[(SVGNS,\"height\")] + \";\"\n        if (SVGNS,\"x\") in attrs:\n            style = style + \"left:\" +  attrs[(SVGNS,\"x\")] + \";\"\n        if (SVGNS,\"y\") in attrs:\n            style = style + \"top:\" +  attrs[(SVGNS,\"y\")] + \";\"\n        if self.generate_css:\n            self.opentag(htmltag, {'class': name, 'style': style})\n        else:\n            self.opentag(htmltag)\n", "docstring": "A <draw:custom-shape> is made into a <div> in HTML which is then styled"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_draw_frame(self, tag, attrs):\n        \"\"\" A <draw:frame> is made into a <div> in HTML which is then styled\n        \"\"\"\n        self.frame_stack.append([])\n        anchor_type = attrs.get((TEXTNS,'anchor-type'),'notfound')\n        htmltag = 'div'\n        name = \"G-\" + attrs.get((DRAWNS,'style-name'), \"\")\n        if name == 'G-':\n            name = \"PR-\" + attrs.get((PRESENTATIONNS,'style-name'), \"\")\n        name = name.replace(\".\",\"_\")\n        if anchor_type == \"paragraph\":\n            style = 'position:relative;'\n        elif anchor_type == 'char':\n            style = \"position:relative;\"\n        elif anchor_type == 'as-char':\n            htmltag = 'div'\n            style = ''\n        else:\n            style = \"position:absolute;\"\n        if (SVGNS,\"width\") in attrs:\n            style = style + \"width:\" + attrs[(SVGNS,\"width\")] + \";\"\n        if (SVGNS,\"height\") in attrs:\n            style = style + \"height:\" +  attrs[(SVGNS,\"height\")] + \";\"\n        if (SVGNS,\"x\") in attrs:\n            style = style + \"left:\" +  attrs[(SVGNS,\"x\")] + \";\"\n        if (SVGNS,\"y\") in attrs:\n            style = style + \"top:\" +  attrs[(SVGNS,\"y\")] + \";\"\n        if self.generate_css:\n            self.opentag(htmltag, {'class': name, 'style': style})\n        else:\n            self.opentag(htmltag)\n", "docstring": "A <draw:frame> is made into a <div> in HTML which is then styled"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_draw_image(self, tag, attrs):\n        \"\"\" A <draw:image> becomes an <img/> element\n        \"\"\"\n        if self.frame_stack:\n            if self.frame_stack[-1]:\n                return\n            self.frame_stack[-1].append('img')\n        parent = self.tagstack.stackparent()\n        anchor_type = parent.get((TEXTNS,'anchor-type'))\n        imghref = attrs[(XLINKNS,\"href\")]\n        imghref = self.rewritelink(imghref)\n        htmlattrs = {'alt':\"\", 'src':imghref}\n        if self.generate_css:\n            if anchor_type != \"char\":\n                htmlattrs['style'] = \"display: block;\"\n        self.emptytag('img', htmlattrs)\n", "docstring": "A <draw:image> becomes an <img/> element"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_draw_object_ole(self, tag, attrs):\n        \"\"\" A <draw:object-ole> is embedded OLE object in the document (e.g. MS Graph).\n        \"\"\"\n        try:\n            class_id = attrs[(DRAWNS,\"class-id\")]\n        except KeyError:  # Added by Kovid to ignore <draw> without the right\n            return       # attributes\n        if class_id and class_id.lower() == \"00020803-0000-0000-c000-000000000046\":  # Microsoft Graph 97 Chart\n            tagattrs = {'name':'object_ole_graph', 'class':'ole-graph'}\n            self.opentag('a', tagattrs)\n            self.closetag('a', tagattrs)\n", "docstring": "A <draw:object-ole> is embedded OLE object in the document (e.g. MS Graph)."}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def e_draw_textbox(self, tag, attrs):\n        \"\"\" End the <draw:text-box>\n        \"\"\"\n        self.closetag('div')\n", "docstring": "End the <draw:text-box>"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def e_office_document_content(self, tag, attrs):\n        \"\"\" Last tag \"\"\"\n        self.closetag('html')\n", "docstring": "Last tag \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_office_presentation(self, tag, attrs):\n        \"\"\" For some odd reason, OpenOffice Impress doesn't define a default-style\n            for the 'paragraph'. We therefore force a standard when we see\n            it is a presentation\n        \"\"\"\n        self.styledict['p'] = {(FONS,u'font-size'): u\"24pt\"}\n        self.styledict['presentation'] = {(FONS,u'font-size'): u\"24pt\"}\n        self.html_body(tag, attrs)\n", "docstring": "For some odd reason, OpenOffice Impress doesn't define a default-style"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_style_default_style(self, tag, attrs):\n        \"\"\" A default style is like a style on an HTML tag\n        \"\"\"\n        family = attrs[(STYLENS,'family')]\n        htmlfamily = self.familymap.get(family,'unknown')\n        self.currentstyle = htmlfamily\n", "docstring": "A default style is like a style on an HTML tag"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_style_default_page_layout(self, tag, attrs):\n        \"\"\" Collect the formatting for the default page layout style.\n        \"\"\"\n        self.currentstyle = \"@page\"\n        self.stylestack.append(self.currentstyle)\n        self.styledict[self.currentstyle] = {}\n", "docstring": "Collect the formatting for the default page layout style."}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def e_style_page_layout(self, tag, attrs):\n        \"\"\" End this style\n        \"\"\"\n        self.currentstyle = None\n", "docstring": "End this style"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_style_style(self, tag, attrs):\n        \"\"\" Collect the formatting for the style.\n            Styles have scope. The same name can be used for both paragraph and\n            character styles Since CSS has no scope we use a prefix. (Not elegant)\n            In ODF a style can have a parent, these parents can be chained.\n            We may not have encountered the parent yet, but if we have, we resolve it.\n        \"\"\"\n        name = attrs[(STYLENS,'name')]\n        name = name.replace(\".\",\"_\")\n        family = attrs[(STYLENS,'family')]\n        htmlfamily = self.familymap.get(family,'unknown')\n        sfamily = self._familyshort.get(family,'X')\n        name = \"%s%s-%s\" % (self.autoprefix, sfamily, name)\n        parent = attrs.get((STYLENS,'parent-style-name'))\n        self.currentstyle = special_styles.get(name,\".\"+name)\n        self.stylestack.append(self.currentstyle)\n        if self.currentstyle not in self.styledict:\n            self.styledict[self.currentstyle] = {}\n        self.styledict[self.currentstyle]['__style-family'] = htmlfamily\n        # Then load the parent style if we find it\n        if parent:\n            parent = parent.replace(\".\", \"_\")\n            parent = \"%s-%s\" % (sfamily, parent)\n            parent = special_styles.get(parent, \".\"+parent)\n            if parent in self.styledict:\n                styles = self.styledict[parent]\n                for style, val in styles.items():\n                    self.styledict[self.currentstyle][style] = val\n            else:\n                self.styledict[self.currentstyle]['__parent-style-name'] = parent\n", "docstring": "Collect the formatting for the style."}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_table_table(self, tag, attrs):\n        \"\"\" Start a table\n        \"\"\"\n        c = attrs.get((TABLENS,'style-name'), None)\n        if c and self.generate_css:\n            c = c.replace(\".\",\"_\")\n            self.opentag('table',{'class': \"T-%s\" % c})\n        else:\n            self.opentag('table')\n        self.purgedata()\n", "docstring": "Start a table"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_table_table_cell(self, tag, attrs):\n        \"\"\" Start a table cell \"\"\"\n        # FIXME: number-columns-repeated § 8.1.3\n        # repeated = int(attrs.get( (TABLENS,'number-columns-repeated'), 1))\n        htmlattrs = {}\n        rowspan = attrs.get((TABLENS,'number-rows-spanned'))\n        if rowspan:\n            htmlattrs['rowspan'] = rowspan\n        colspan = attrs.get((TABLENS,'number-columns-spanned'))\n        if colspan:\n            htmlattrs['colspan'] = colspan\n        c = attrs.get((TABLENS,'style-name'))\n        if c:\n            htmlattrs['class'] = 'TD-%s' % c.replace(\".\",\"_\")\n        self.opentag('td', htmlattrs)\n        self.purgedata()\n", "docstring": "Start a table cell \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_table_table_column(self, tag, attrs):\n        \"\"\" Start a table column \"\"\"\n        c = attrs.get((TABLENS,'style-name'), None)\n        repeated = int(attrs.get((TABLENS,'number-columns-repeated'), 1))\n        htmlattrs = {}\n        if c:\n            htmlattrs['class'] = \"TC-%s\" % c.replace(\".\",\"_\")\n        for x in range(repeated):\n            self.emptytag('col', htmlattrs)\n        self.purgedata()\n", "docstring": "Start a table column \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def e_table_table_row(self, tag, attrs):\n        \"\"\" End a table row \"\"\"\n        self.writedata()\n        self.closetag('tr')\n        self.purgedata()\n", "docstring": "End a table row \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def e_text_a(self, tag, attrs):\n        \"\"\" End an anchor or bookmark reference \"\"\"\n        self.writedata()\n        self.closetag('a', False)\n        self.purgedata()\n", "docstring": "End an anchor or bookmark reference \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_text_bookmark_ref(self, tag, attrs):\n        \"\"\" Bookmark reference \"\"\"\n        name = attrs[(TEXTNS,'ref-name')]\n        html_id = \"#\" + self.get_anchor(name)\n        self.writedata()\n        self.opentag('a', {'href':html_id})\n        self.purgedata()\n", "docstring": "Bookmark reference \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def e_text_h(self, tag, attrs):\n        \"\"\" Headings end\n            Side-effect: If there is no title in the metadata, then it is taken\n            from the first heading of any level.\n        \"\"\"\n        self.writedata()\n        level = int(attrs[(TEXTNS,'outline-level')])\n        if level > 6:\n            level = 6  # Heading levels go only to 6 in XHTML\n        if level < 1:\n            level = 1\n        lev = self.headinglevels[1:level+1]\n        outline = '.'.join(map(str,lev))\n        heading = ''.join(self.data)\n        if self.title == '':\n            self.title = heading\n        # Changed by Kovid\n        tail = ''.join(self.data)\n        anchor = self.get_anchor(\"%s.%s\" % (outline, tail))\n        anchor2 = self.get_anchor(tail)  # Added by kovid to fix #7506\n        self.opentag('a', {'id': anchor})\n        self.closetag('a', False)\n        self.opentag('a', {'id': anchor2})\n        self.closetag('a', False)\n        self.closetag('h%s' % level)\n        self.purgedata()\n", "docstring": "Headings end"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_text_list(self, tag, attrs):\n        \"\"\" Start a list (<ul> or <ol>)\n            To know which level we're at, we have to count the number\n            of <text:list> elements on the tagstack.\n        \"\"\"\n        name = attrs.get((TEXTNS,'style-name'))\n        continue_numbering = attrs.get((TEXTNS, 'continue-numbering')) == 'true'\n        continue_list = attrs.get((TEXTNS, 'continue-list'))\n        list_id = attrs.get(('http://www.w3.org/XML/1998/namespace', 'id'))\n        level = self.tagstack.count_tags(tag) + 1\n        if name:\n            name = name.replace(\".\",\"_\")\n        else:\n            # FIXME: If a list is contained in a table cell or text box,\n            # the list level must return to 1, even though the table or\n            # textbox itself may be nested within another list.\n            name = self.tagstack.rfindattr((TEXTNS,'style-name'))\n        list_class = \"%s_%d\" % (name, level)\n        tag_name = self.listtypes.get(list_class,'ul')\n        number_class = tag_name + list_class\n        if list_id:\n            self.list_id_map[list_id] = number_class\n        if continue_list:\n            if continue_list in self.list_id_map:\n                tglc = self.list_id_map[continue_list]\n                self.list_number_map[number_class] = self.list_number_map[tglc]\n            else:\n                self.list_number_map.pop(number_class, None)\n        else:\n            if not continue_numbering:\n                self.list_number_map.pop(number_class, None)\n        self.list_class_stack.append(number_class)\n        attrs = {}\n        if tag_name == 'ol' and self.list_number_map[number_class] != 1:\n            attrs = {'start': unicode_type(self.list_number_map[number_class])}\n        if self.generate_css:\n            attrs['class'] = list_class\n        self.opentag('%s' % tag_name, attrs)\n        self.purgedata()\n", "docstring": "Start a list (<ul> or <ol>)"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_text_list_item(self, tag, attrs):\n        \"\"\" Start list item \"\"\"\n        number_class = self.list_class_stack[-1] if self.list_class_stack else None\n        if number_class:\n            self.list_number_map[number_class] += 1\n        self.opentag('li')\n        self.purgedata()\n", "docstring": "Start list item \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_text_list_level_style_bullet(self, tag, attrs):\n        \"\"\" CSS doesn't have the ability to set the glyph\n            to a particular character, so we just go through\n            the available glyphs\n        \"\"\"\n        name = self.tagstack.rfindattr((STYLENS,'name'))\n        level = attrs[(TEXTNS,'level')]\n        self.prevstyle = self.currentstyle\n        list_class = \"%s_%s\" % (name, level)\n        self.listtypes[list_class] = 'ul'\n        self.currentstyle = \".%s_%s\" % (name.replace(\".\",\"_\"), level)\n        self.stylestack.append(self.currentstyle)\n        self.styledict[self.currentstyle] = {}\n        level = int(level)\n        listtype = (\"square\", \"disc\", \"circle\")[level % 3]\n        self.styledict[self.currentstyle][('','list-style-type')] = listtype\n", "docstring": "CSS doesn't have the ability to set the glyph"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_text_p(self, tag, attrs):\n        \"\"\" Paragraph\n        \"\"\"\n        htmlattrs = {}\n        specialtag = \"p\"\n        c = attrs.get((TEXTNS,'style-name'), None)\n        if c:\n            c = c.replace(\".\",\"_\")\n            specialtag = special_styles.get(\"P-\"+c)\n            if specialtag is None:\n                specialtag = 'p'\n                if self.generate_css:\n                    htmlattrs['class'] = \"P-%s\" % c\n        self.opentag(specialtag, htmlattrs)\n        self.purgedata()\n", "docstring": "Paragraph"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_text_s(self, tag, attrs):\n        # Changed by Kovid to fix non breaking spaces being prepended to\n        # element instead of being part of the text flow.\n        # We don't use an entity for the nbsp as the contents of self.data will\n        # be escaped on writeout.\n        \"\"\" Generate a number of spaces. We use the non breaking space for\n        the text:s ODF element.\n        \"\"\"\n        try:\n            c = int(attrs.get((TEXTNS, 'c'), 1))\n        except:\n            c = 0\n        if c > 0:\n            self.data.append(u'\\u00a0'*c)\n", "docstring": "Changed by Kovid to fix non breaking spaces being prepended to"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def e_text_span(self, tag, attrs):\n        \"\"\" End the <text:span> \"\"\"\n        self.writedata()\n        c = attrs.get((TEXTNS,'style-name'), None)\n        # Changed by Kovid to handle inline special styles defined on <text:span> tags.\n        # Apparently LibreOffice does this.\n        special = 'span'\n        if c:\n            c = c.replace(\".\",\"_\")\n            special = special_styles.get(\"S-\"+c)\n            if special is None:\n                special = 'span'\n        self.closetag(special, False)\n        self.purgedata()\n", "docstring": "End the <text:span> \n"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def s_text_x_source(self, tag, attrs):\n        \"\"\" Various indexes and tables of contents. We ignore those.\n        \"\"\"\n        self.writedata()\n        self.purgedata()\n        self.s_ignorexml(tag, attrs)\n", "docstring": "Various indexes and tables of contents. We ignore those."}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def load(self, odffile):\n        \"\"\" Loads a document into the parser and parses it.\n            The argument can either be a filename or a document in memory.\n        \"\"\"\n        self.lines = []\n        self._wfunc = self._wlines\n        if isinstance(odffile, (bytes, type(u''))) or hasattr(odffile, 'read'):  # Added by Kovid\n            self.document = load(odffile)\n        else:\n            self.document = odffile\n        self._walknode(self.document.topnode)\n", "docstring": "Loads a document into the parser and parses it."}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def odf2xhtml(self, odffile):\n        \"\"\" Load a file and return the XHTML\n        \"\"\"\n        self.load(odffile)\n        return self.xhtml()\n", "docstring": "Load a file and return the XHTML"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def xhtml(self):\n        \"\"\" Returns the xhtml\n        \"\"\"\n        return ''.join(self.lines)\n", "docstring": "Returns the xhtml"}
{"repo": "calibre-master/src/odf/odf2xhtml.py", "original_string": "    def save(self, outputfile, addsuffix=False):\n        \"\"\" Save the HTML under the filename.\n            If the filename is '-' then save to stdout\n            We have the last style filename in self.stylefilename\n        \"\"\"\n        if outputfile == '-':\n            import sys  # Added by Kovid\n            outputfp = sys.stdout\n        else:\n            if addsuffix:\n                outputfile = outputfile + \".html\"\n            outputfp = open(outputfile, \"wb\")\n        outputfp.write(self.xhtml().encode('us-ascii','xmlcharrefreplace'))\n        outputfp.close()\n", "docstring": "Save the HTML under the filename."}
{"repo": "calibre-master/src/odf/teletype.py", "original_string": "    def _emitTextBuffer(self, odfElement):\n        \"\"\" Creates a Text Node whose contents are the current textBuffer.\n            Side effect: clears the text buffer.\n        \"\"\"\n        if len(self.textBuffer) > 0:\n            odfElement.addText(''.join(self.textBuffer))\n        self.textBuffer = []\n", "docstring": "Creates a Text Node whose contents are the current textBuffer."}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "    def __register_stylename(self, element):\n        ''' Register a style. But there are three style dictionaries:\n            office:styles, office:automatic-styles and office:master-styles\n            Chapter 14\n        '''\n        name = element.getAttrNS(STYLENS, u'name')\n        if name is None:\n            return\n        if element.parentNode.qname in ((OFFICENS,u'styles'), (OFFICENS,u'automatic-styles')):\n            if name in self._styles_dict:\n                newname = 'M'+name  # Rename style\n                self._styles_ooo_fix[name] = newname\n                # From here on all references to the old name will refer to the new one\n                name = newname\n                element.setAttrNS(STYLENS, u'name', name)\n            self._styles_dict[name] = element\n", "docstring": "Register a style. But there are three style dictionaries:"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "    def xml(self):\n        \"\"\" Generates the full document as an XML file\n            Always written as a bytestream in UTF-8 encoding\n        \"\"\"\n        self.__replaceGenerator()\n        xml=PolyglotBytesIO()\n        xml.write(_XMLPROLOGUE)\n        self.topnode.toXml(0, xml)\n        return xml.getvalue()\n", "docstring": "Generates the full document as an XML file"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "    def __manifestxml(self):\n        \"\"\" Generates the manifest.xml file\n            The self.manifest isn't available unless the document is being saved\n        \"\"\"\n        xml=PolyglotBytesIO()\n        xml.write(_XMLPROLOGUE)\n        self.manifest.toXml(0,xml)\n        return xml.getvalue()\n", "docstring": "Generates the manifest.xml file"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "    def settingsxml(self):\n        \"\"\" Generates the settings.xml file \"\"\"\n        x = DocumentSettings()\n        x.addElement(self.settings)\n        xml=PolyglotStringIO()\n        xml.write(_XMLPROLOGUE)\n        x.toXml(0,xml)\n        return xml.getvalue()\n", "docstring": "Generates the settings.xml file \n"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "    def _used_auto_styles(self, segments):\n        \"\"\" Loop through the masterstyles elements, and find the automatic\n            styles that are used. These will be added to the automatic-styles\n            element in styles.xml\n        \"\"\"\n        stylenamelist = []\n        for top in segments:\n            stylenamelist = self._parseoneelement(top, stylenamelist)\n        stylelist = []\n        for e in self.automaticstyles.childNodes:\n            if e.getAttrNS(STYLENS,u'name') in stylenamelist:\n                stylelist.append(e)\n        return stylelist\n", "docstring": "Loop through the masterstyles elements, and find the automatic"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "    def addPicture(self, filename, mediatype=None, content=None):\n        \"\"\" Add a picture\n            It uses the same convention as OOo, in that it saves the picture in\n            the zipfile in the subdirectory 'Pictures'\n            If passed a file ptr, mediatype must be set\n        \"\"\"\n        if content is None:\n            if mediatype is None:\n                mediatype, encoding = mimetypes.guess_type(filename)\n            if mediatype is None:\n                mediatype = ''\n                try:\n                    ext = filename[filename.rindex('.'):]\n                except:\n                    ext=''\n            else:\n                ext = mimetypes.guess_extension(mediatype)\n            manifestfn = \"Pictures/%0.0f%s\" % ((time.time()*10000000000), ext)\n            self.Pictures[manifestfn] = (IS_FILENAME, filename, mediatype)\n        else:\n            manifestfn = filename\n            self.Pictures[manifestfn] = (IS_IMAGE, content, mediatype)\n        return manifestfn\n", "docstring": "Add a picture"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "    def addPictureFromString(self, content, mediatype):\n        \"\"\" Add a picture\n            It uses the same convention as OOo, in that it saves the picture in\n            the zipfile in the subdirectory 'Pictures'. The content variable\n            is a string that contains the binary image data. The mediatype\n            indicates the image format.\n        \"\"\"\n        ext = mimetypes.guess_extension(mediatype)\n        manifestfn = \"Pictures/%0.0f%s\" % ((time.time()*10000000000), ext)\n        self.Pictures[manifestfn] = (IS_IMAGE, content, mediatype)\n        return manifestfn\n", "docstring": "Add a picture"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "    def addObject(self, document, objectname=None):\n        \"\"\" Adds an object (subdocument). The object must be an OpenDocument class\n            The return value will be the folder in the zipfile the object is stored in\n        \"\"\"\n        self.childobjects.append(document)\n        if objectname is None:\n            document.folder = \"%s/Object %d\" % (self.folder, len(self.childobjects))\n        else:\n            document.folder = objectname\n        return \".%s\" % document.folder\n", "docstring": "Adds an object (subdocument). The object must be an OpenDocument class"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "    def __replaceGenerator(self):\n        \"\"\" Section 3.1.1: The application MUST NOT export the original identifier\n            belonging to the application that created the document.\n        \"\"\"\n        for m in self.meta.childNodes[:]:\n            if m.qname == (METANS, u'generator'):\n                self.meta.removeChild(m)\n        self.meta.addElement(meta.Generator(text=TOOLSVERSION))\n", "docstring": "Section 3.1.1: The application MUST NOT export the original identifier"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "    def write(self, outputfp):\n        \"\"\" User API to write the ODF file to an open file descriptor\n            Writes the ZIP format\n        \"\"\"\n        zipoutputfp = zipfile.ZipFile(outputfp,\"w\")\n        self.__zipwrite(zipoutputfp)\n", "docstring": "User API to write the ODF file to an open file descriptor"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "    def createElement(self, element):\n        \"\"\" Inconvenient interface to create an element, but follows XML-DOM.\n            Does not allow attributes as argument, therefore can't check grammar.\n        \"\"\"\n        return element(check_grammar=False)\n", "docstring": "Inconvenient interface to create an element, but follows XML-DOM."}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "    def createCDATASection(self, data):\n        \"\"\" Method to create a CDATA section \"\"\"\n        return element.CDATASection(data)\n", "docstring": "Method to create a CDATA section \n"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "    def getStyleByName(self, name):\n        \"\"\" Finds a style object based on the name \"\"\"\n        ncname = make_NCName(name)\n        if self._styles_dict == {}:\n            self.rebuild_caches()\n        return self._styles_dict.get(ncname, None)\n", "docstring": "Finds a style object based on the name \n"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "def OpenDocumentChart():\n    \"\"\" Creates a chart document \"\"\"\n    doc = OpenDocument('application/vnd.oasis.opendocument.chart')\n    doc.chart = Chart()\n    doc.body.addElement(doc.chart)\n    return doc\n", "docstring": "Creates a chart document \n"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "def OpenDocumentImage():\n    \"\"\" Creates an image document \"\"\"\n    doc = OpenDocument('application/vnd.oasis.opendocument.image')\n    doc.image = Image()\n    doc.body.addElement(doc.image)\n    return doc\n", "docstring": "Creates an image document \n"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "def OpenDocumentSpreadsheet():\n    \"\"\" Creates a spreadsheet document \"\"\"\n    doc = OpenDocument('application/vnd.oasis.opendocument.spreadsheet')\n    doc.spreadsheet = Spreadsheet()\n    doc.body.addElement(doc.spreadsheet)\n    return doc\n", "docstring": "Creates a spreadsheet document \n"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "def OpenDocumentTextMaster():\n    \"\"\" Creates a text master document \"\"\"\n    doc = OpenDocument('application/vnd.oasis.opendocument.text-master')\n    doc.text = Text()\n    doc.body.addElement(doc.text)\n    return doc\n", "docstring": "Creates a text master document \n"}
{"repo": "calibre-master/src/odf/opendocument.py", "original_string": "def load(odffile):\n    \"\"\" Load an ODF file into memory\n        Returns a reference to the structure\n    \"\"\"\n    z = zipfile.ZipFile(odffile)\n    try:\n        mimetype = z.read('mimetype')\n    except KeyError:  # Added by Kovid to handle malformed odt files\n        mimetype = 'application/vnd.oasis.opendocument.text'\n    doc = OpenDocument(mimetype, add_generator=False)\n    # Look in the manifest file to see if which of the four files there are\n    manifestpart = z.read('META-INF/manifest.xml')\n    manifest =  manifestlist(manifestpart)\n    __loadxmlparts(z, manifest, doc, '')\n    for mentry,mvalue in manifest.items():\n        if mentry[:9] == \"Pictures/\" and len(mentry) > 9:\n            doc.addPicture(mvalue['full-path'], mvalue['media-type'], z.read(mentry))\n        elif mentry == \"Thumbnails/thumbnail.png\":\n            doc.addThumbnail(z.read(mentry))\n        elif mentry in ('settings.xml', 'meta.xml', 'content.xml', 'styles.xml'):\n            pass\n        # Load subobjects into structure\n        elif mentry[:7] == \"Object \" and len(mentry) < 11 and mentry[-1] == \"/\":\n            subdoc = OpenDocument(mvalue['media-type'], add_generator=False)\n            doc.addObject(subdoc, \"/\" + mentry[:-1])\n            __loadxmlparts(z, manifest, subdoc, mentry)\n        elif mentry[:7] == \"Object \":\n            pass  # Don't load subobjects as opaque objects\n        else:\n            if mvalue['full-path'][-1] == '/':\n                doc._extra.append(OpaqueObject(mvalue['full-path'], mvalue['media-type'], None))\n            else:\n                doc._extra.append(OpaqueObject(mvalue['full-path'], mvalue['media-type'], z.read(mentry)))\n            # Add the SUN junk here to the struct somewhere\n            # It is cached data, so it can be out-of-date\n    z.close()\n    b = doc.getElementsByType(Body)\n    if mimetype[:39] == 'application/vnd.oasis.opendocument.text':\n        doc.text = b[0].firstChild\n    elif mimetype[:43] == 'application/vnd.oasis.opendocument.graphics':\n        doc.graphics = b[0].firstChild\n    elif mimetype[:47] == 'application/vnd.oasis.opendocument.presentation':\n        doc.presentation = b[0].firstChild\n    elif mimetype[:46] == 'application/vnd.oasis.opendocument.spreadsheet':\n        doc.spreadsheet = b[0].firstChild\n    elif mimetype[:40] == 'application/vnd.oasis.opendocument.chart':\n        doc.chart = b[0].firstChild\n    elif mimetype[:40] == 'application/vnd.oasis.opendocument.image':\n        doc.image = b[0].firstChild\n    elif mimetype[:42] == 'application/vnd.oasis.opendocument.formula':\n        doc.formula = b[0].firstChild\n    return doc\n", "docstring": "Load an ODF file into memory"}
{"repo": "calibre-master/src/odf/odf2moinmoin.py", "original_string": "    def extractTextProperties(self, style, parent=None):\n        \"\"\" Extracts text properties from a style element. \"\"\"\n        textProps = TextProps()\n        textPropEl = style.getElementsByTagName(\"style:text-properties\")\n        if not textPropEl:\n            return textProps\n        textPropEl = textPropEl[0]\n        textProps.setItalic(textPropEl.getAttribute(\"fo:font-style\"))\n        textProps.setBold(textPropEl.getAttribute(\"fo:font-weight\"))\n        textProps.setUnderlined(textPropEl.getAttribute(\"style:text-underline-style\"))\n        textProps.setStrikethrough(textPropEl.getAttribute(\"style:text-line-through-style\"))\n        textProps.setPosition(textPropEl.getAttribute(\"style:text-position\"))\n        if textPropEl.getAttribute(\"style:font-name\") in self.fixedFonts:\n            textProps.setFixed(True)\n        return textProps\n", "docstring": "Extracts text properties from a style element. \n"}
{"repo": "calibre-master/src/odf/odf2moinmoin.py", "original_string": "    def processStyles(self, styleElements):\n        \"\"\" Runs through \"style\" elements extracting necessary information.\n        \"\"\"\n        for style in styleElements:\n            name = style.getAttribute(\"style:name\")\n            if name == \"Standard\":\n                continue\n            family = style.getAttribute(\"style:family\")\n            parent = style.getAttribute(\"style:parent-style-name\")\n            if family == \"text\":\n                self.textStyles[name] = self.extractTextProperties(style, parent)\n            elif family == \"paragraph\":\n                self.paragraphStyles[name] = \\\n                                 self.extractParagraphProperties(style, parent)\n                self.textStyles[name] = self.extractTextProperties(style, parent)\n", "docstring": "Runs through \"style\" elements extracting necessary information."}
{"repo": "calibre-master/src/odf/odf2moinmoin.py", "original_string": "    def load(self, filepath):\n        \"\"\" Loads an ODT file. \"\"\"\n        zip = zipfile.ZipFile(filepath)\n        styles_doc = xml.dom.minidom.parseString(zip.read(\"styles.xml\"))\n        fontfacedecls = styles_doc.getElementsByTagName(\"office:font-face-decls\")\n        if fontfacedecls:\n            self.processFontDeclarations(fontfacedecls[0])\n        self.processStyles(styles_doc.getElementsByTagName(\"style:style\"))\n        self.processListStyles(styles_doc.getElementsByTagName(\"text:list-style\"))\n        self.content = xml.dom.minidom.parseString(zip.read(\"content.xml\"))\n        fontfacedecls = self.content.getElementsByTagName(\"office:font-face-decls\")\n        if fontfacedecls:\n            self.processFontDeclarations(fontfacedecls[0])\n        self.processStyles(self.content.getElementsByTagName(\"style:style\"))\n        self.processListStyles(self.content.getElementsByTagName(\"text:list-style\"))\n", "docstring": "Loads an ODT file. \n"}
{"repo": "calibre-master/src/odf/odf2moinmoin.py", "original_string": "    def toString(self):\n        \"\"\" Converts the document to a string.\n            FIXME: Result from second call differs from first call\n        \"\"\"\n        body = self.content.getElementsByTagName(\"office:body\")[0]\n        text = body.childNodes[0]\n        buffer = []\n        paragraphs = [el for el in text.childNodes\n                      if el.tagName in [\"draw:page\", \"text:p\", \"text:h\",\"text:section\",\n                                        \"text:list\", \"table:table\"]]\n        for paragraph in paragraphs:\n            if paragraph.tagName == \"text:list\":\n                text = self.listToString(paragraph)\n            elif paragraph.tagName == \"text:section\":\n                text = self.textToString(paragraph)\n            elif paragraph.tagName == \"table:table\":\n                text = self.tableToString(paragraph)\n            else:\n                text = self.paragraphToString(paragraph)\n            if text:\n                buffer.append(text)\n        if self.footnotes:\n            buffer.append(\"----\")\n            for cite, body in self.footnotes:\n                buffer.append(\"%s: %s\" % (cite, body))\n        buffer.append(\"\")\n        return self.compressCodeBlocks('\\n'.join(buffer))\n", "docstring": "Converts the document to a string."}
{"repo": "calibre-master/src/odf/attrconverters.py", "original_string": "def cnv_color(attribute, arg, element):\n    \"\"\" A RGB color in conformance with §5.9.11 of [XSL], that is a RGB color in notation “#rrggbb”, where\n        rr, gg and bb are 8-bit hexadecimal digits.\n    \"\"\"\n    return unicode_type(arg)\n", "docstring": "A RGB color in conformance with §5.9.11 of [XSL], that is a RGB color in notation “#rrggbb”, where"}
{"repo": "calibre-master/src/odf/attrconverters.py", "original_string": "def cnv_date(attribute, arg, element):\n    \"\"\" A dateOrDateTime value is either an [xmlschema-2] date value or an [xmlschema-2] dateTime\n        value.\n    \"\"\"\n    return unicode_type(arg)\n", "docstring": "A dateOrDateTime value is either an [xmlschema-2] date value or an [xmlschema-2] dateTime"}
{"repo": "calibre-master/src/odf/attrconverters.py", "original_string": "def cnv_family(attribute, arg, element):\n    \"\"\" A style family \"\"\"\n    if unicode_type(arg) not in (\"text\", \"paragraph\", \"section\", \"ruby\", \"table\", \"table-column\", \"table-row\", \"table-cell\",\n      \"graphic\", \"presentation\", \"drawing-page\", \"chart\"):\n        raise ValueError(\"'%s' not allowed\" % unicode_type(arg))\n    return unicode_type(arg)\n", "docstring": "A style family \n"}
{"repo": "calibre-master/src/odf/attrconverters.py", "original_string": "def cnv_formula(attribute, arg, element):\n    \"\"\" A string containing a formula. Formulas do not have a predefined syntax, but the string should\n        begin with a namespace prefix, followed by a “:” (COLON, U+003A) separator, followed by the text\n        of the formula. The namespace bound to the prefix determines the syntax and semantics of the\n        formula.\n    \"\"\"\n    return __save_prefix(attribute, arg, element)\n", "docstring": "A string containing a formula. Formulas do not have a predefined syntax, but the string should"}
{"repo": "calibre-master/src/odf/attrconverters.py", "original_string": "def cnv_length(attribute, arg, element):\n    \"\"\" A (positive or negative) physical length, consisting of magnitude and unit, in conformance with the\n        Units of Measure defined in §5.9.13 of [XSL].\n    \"\"\"\n    global pattern_length\n    if not pattern_length.match(arg):\n        raise ValueError(\"'%s' is not a valid length\" % arg)\n    return arg\n", "docstring": "A (positive or negative) physical length, consisting of magnitude and unit, in conformance with the"}
{"repo": "calibre-master/src/odf/element.py", "original_string": "def _escape(data, entities={}):\n    \"\"\" Escape &, <, and > in a string of data.\n        You can escape other strings of data by passing a dictionary as\n        the optional entities parameter.  The keys and values must all be\n        strings; each key will be replaced with its corresponding value.\n    \"\"\"\n    data = data.replace(\"&\", \"&amp;\")\n    data = data.replace(\"<\", \"&lt;\")\n    data = data.replace(\">\", \"&gt;\")\n    for chars, entity in entities.items():\n        data = data.replace(chars, entity)\n    return data\n", "docstring": "Escape &, <, and > in a string of data."}
{"repo": "calibre-master/src/odf/element.py", "original_string": "def _nssplit(qualifiedName):\n    \"\"\" Split a qualified name into namespace part and local part.  \"\"\"\n    fields = qualifiedName.split(':', 1)\n    if len(fields) == 2:\n        return fields\n    else:\n        return (None, fields[0])\n", "docstring": "Split a qualified name into namespace part and local part.  \n"}
{"repo": "calibre-master/src/odf/element.py", "original_string": "    def hasChildNodes(self):\n        \"\"\" Tells whether this element has any children; text nodes,\n            subelements, whatever.\n        \"\"\"\n        if self.childNodes:\n            return True\n        else:\n            return False\n", "docstring": "Tells whether this element has any children; text nodes,"}
{"repo": "calibre-master/src/odf/element.py", "original_string": "    def insertBefore(self, newChild, refChild):\n        \"\"\" Inserts the node newChild before the existing child node refChild.\n            If refChild is null, insert newChild at the end of the list of children.\n        \"\"\"\n        if newChild.nodeType not in self._child_node_types:\n            raise IllegalChild(\"%s cannot be child of %s\" % (newChild.tagName, self.tagName))\n        if newChild.parentNode is not None:\n            newChild.parentNode.removeChild(newChild)\n        if refChild is None:\n            self.appendChild(newChild)\n        else:\n            try:\n                index = self.childNodes.index(refChild)\n            except ValueError:\n                raise xml.dom.NotFoundErr()\n            self.childNodes.insert(index, newChild)\n            newChild.nextSibling = refChild\n            refChild.previousSibling = newChild\n            if index:\n                node = self.childNodes[index-1]\n                node.nextSibling = newChild\n                newChild.previousSibling = node\n            else:\n                newChild.previousSibling = None\n            newChild.parentNode = self\n        return newChild\n", "docstring": "Inserts the node newChild before the existing child node refChild."}
{"repo": "calibre-master/src/odf/element.py", "original_string": "    def removeChild(self, oldChild):\n        \"\"\" Removes the child node indicated by oldChild from the list of children, and returns it.\n        \"\"\"\n        # FIXME: update ownerDocument.element_dict or find other solution\n        try:\n            self.childNodes.remove(oldChild)\n        except ValueError:\n            raise xml.dom.NotFoundErr()\n        if oldChild.nextSibling is not None:\n            oldChild.nextSibling.previousSibling = oldChild.previousSibling\n        if oldChild.previousSibling is not None:\n            oldChild.previousSibling.nextSibling = oldChild.nextSibling\n        oldChild.nextSibling = oldChild.previousSibling = None\n        if self.ownerDocument:\n            self.ownerDocument.clear_caches()\n        oldChild.parentNode = None\n        return oldChild\n", "docstring": "Removes the child node indicated by oldChild from the list of children, and returns it."}
{"repo": "calibre-master/src/odf/element.py", "original_string": "def _append_child(self, node):\n    # fast path with less checks; usable by DOM builders if careful\n    childNodes = self.childNodes\n    if childNodes:\n        last = childNodes[-1]\n        node.__dict__[\"previousSibling\"] = last\n        last.__dict__[\"nextSibling\"] = node\n    childNodes.append(node)\n    node.__dict__[\"parentNode\"] = self\n", "docstring": "fast path with less checks; usable by DOM builders if careful"}
{"repo": "calibre-master/src/odf/element.py", "original_string": "    def appendChild(self, node):\n        \"\"\" Raises an error \"\"\"\n        raise xml.dom.HierarchyRequestErr(\n            self.tagName + \" nodes cannot have children\")\n", "docstring": "Raises an error \n"}
{"repo": "calibre-master/src/odf/element.py", "original_string": "    def insertBefore(self, newChild, refChild):\n        \"\"\" Raises an error \"\"\"\n        raise xml.dom.HierarchyRequestErr(\n            self.tagName + \" nodes do not have children\")\n", "docstring": "Raises an error \n"}
{"repo": "calibre-master/src/odf/element.py", "original_string": "    def replaceChild(self, newChild, oldChild):\n        \"\"\" Raises an error \"\"\"\n        raise xml.dom.HierarchyRequestErr(\n            self.tagName + \" nodes do not have children\")\n", "docstring": "Raises an error \n"}
{"repo": "calibre-master/src/odf/element.py", "original_string": "    def toXml(self,level,f):\n        \"\"\" Write XML in UTF-8 \"\"\"\n        if self.data:\n            f.write(_escape(type(u'')(self.data).encode('utf-8')))\n", "docstring": "Write XML in UTF-8 \n"}
{"repo": "calibre-master/src/odf/element.py", "original_string": "    def toXml(self,level,f):\n        \"\"\" Generate XML output of the node. If the text contains \"]]>\", then\n            escape it by going out of CDATA mode (]]>), then write the string\n            and then go into CDATA mode again. (<![CDATA[)\n        \"\"\"\n        if self.data:\n            f.write('<![CDATA[%s]]>' % self.data.replace(']]>',']]>]]><![CDATA['))\n", "docstring": "Generate XML output of the node. If the text contains \"]]>\", then"}
{"repo": "calibre-master/src/odf/element.py", "original_string": "    def get_nsprefix(self, namespace):\n        \"\"\" Odfpy maintains a list of known namespaces. In some cases we have a namespace URL,\n            and needs to look up or assign the prefix for it.\n        \"\"\"\n        if namespace is None:\n            namespace = \"\"\n        prefix = _nsassign(namespace)\n        if namespace not in self.namespaces:\n            self.namespaces[namespace] = prefix\n        return prefix\n", "docstring": "Odfpy maintains a list of known namespaces. In some cases we have a namespace URL,"}
{"repo": "calibre-master/src/odf/element.py", "original_string": "    def addText(self, text, check_grammar=True):\n        \"\"\" Adds text to an element\n            Setting check_grammar=False turns off grammar checking\n        \"\"\"\n        if check_grammar and self.qname not in grammar.allows_text:\n            raise IllegalText(\"The <%s> element does not allow text\" % self.tagName)\n        else:\n            if text != '':\n                self.appendChild(Text(text))\n", "docstring": "Adds text to an element"}
{"repo": "calibre-master/src/odf/element.py", "original_string": "    def removeAttribute(self, attr, check_grammar=True):\n        \"\"\" Removes an attribute by name. \"\"\"\n        allowed_attrs = self.allowed_attributes()\n        if allowed_attrs is None:\n            if isinstance(attr, tuple):\n                prefix, localname = attr\n                self.removeAttrNS(prefix, localname)\n            else:\n                raise AttributeError(\"Unable to add simple attribute - use (namespace, localpart)\")\n        else:\n            # Construct a list of allowed arguments\n            allowed_args = [a[1].lower().replace('-','') for a in allowed_attrs]\n            if check_grammar and attr not in allowed_args:\n                raise AttributeError(\"Attribute %s is not allowed in <%s>\" % (attr, self.tagName))\n            i = allowed_args.index(attr)\n            self.removeAttrNS(allowed_attrs[i][0], allowed_attrs[i][1])\n", "docstring": "Removes an attribute by name. \n"}
{"repo": "calibre-master/src/odf/element.py", "original_string": "    def setAttrNS(self, namespace, localpart, value):\n        \"\"\" Add an attribute to the element\n            In case you need to add an attribute the library doesn't know about\n            then you must provide the full qualified name\n            It will not check that the attribute is legal according to the schema.\n            Must overwrite, If attribute already exists.\n        \"\"\"\n        c = AttrConverters()\n        self.attributes[(namespace, localpart)] = c.convert((namespace, localpart), value, self)\n", "docstring": "Add an attribute to the element"}
{"repo": "calibre-master/src/odf/element.py", "original_string": "    def toXml(self, level, f):\n        \"\"\" Generate XML stream out of the tree structure \"\"\"\n        f.write('<'+self.tagName)\n        if level == 0:\n            for namespace, prefix in self.namespaces.items():\n                f.write(' xmlns:' + prefix + '=\"'+ _escape(unicode_type(namespace))+'\"')\n        for qname in self.attributes.keys():\n            prefix = self.get_nsprefix(qname[0])\n            f.write(' '+_escape(unicode_type(prefix+':'+qname[1]))+'='+_quoteattr(type(u'')(self.attributes[qname]).encode('utf-8')))\n        if self.childNodes:\n            f.write('>')\n            for element in self.childNodes:\n                element.toXml(level+1,f)\n            f.write('</'+self.tagName+'>')\n        else:\n            f.write('/>')\n", "docstring": "Generate XML stream out of the tree structure \n"}
{"repo": "calibre-master/src/odf/element.py", "original_string": "    def getElementsByType(self, element):\n        \"\"\" Gets elements based on the type, which is function from text.py, draw.py etc. \"\"\"\n        obj = element(check_grammar=False)\n        return self._getElementsByObj(obj,[])\n", "docstring": "Gets elements based on the type, which is function from text.py, draw.py etc. \n"}
{"repo": "calibre-master/manual/plugin_examples/webengine_demo/ui.py", "original_string": "    def genesis(self):\n        # This method is called once per plugin, do initial setup here\n        # Set the icon for this interface action\n        # The get_icons function is a builtin function defined for all your\n        # plugin code. It loads icons from the plugin zip file. It returns\n        # QIcon objects, if you want the actual data, use the analogous\n        # get_resources builtin function.\n        #\n        # Note that if you are loading more than one icon, for performance, you\n        # should pass a list of names to get_icons. In this case, get_icons\n        # will return a dictionary mapping names to QIcons. Names that\n        # are not found in the zip file will result in null QIcons.\n        icon = get_icons('images/icon.png')\n        # The qaction is automatically created from the action_spec defined\n        # above\n        self.qaction.setIcon(icon)\n        self.qaction.triggered.connect(self.show_dialog)\n", "docstring": "This method is called once per plugin, do initial setup here"}
{"repo": "calibre-master/manual/plugin_examples/editor_demo/main.py", "original_string": "    def create_action(self, for_toolbar=True):\n        # Create an action, this will be added to the plugins toolbar and\n        # the plugins menu\n        ac = QAction(get_icons('images/icon.png'), 'Magnify fonts', self.gui)  # noqa\n        if not for_toolbar:\n            # Register a keyboard shortcut for this toolbar action. We only\n            # register it for the action created for the menu, not the toolbar,\n            # to avoid a double trigger\n            self.register_shortcut(ac, 'magnify-fonts-tool', default_keys=('Ctrl+Shift+Alt+D',))\n        ac.triggered.connect(self.ask_user)\n        return ac\n", "docstring": "Create an action, this will be added to the plugins toolbar and"}
{"repo": "calibre-master/manual/plugin_examples/editor_demo/main.py", "original_string": "    def magnify_fonts(self, factor):\n        # Magnify all font sizes defined in the book by the specified factor\n        # First we create a restore point so that the user can undo all changes\n        # we make.\n        self.boss.add_savepoint('Before: Magnify fonts')\n        container = self.current_container  # The book being edited as a container object\n        # Iterate over all style declarations in the book, this means css\n        # stylesheets, <style> tags and style=\"\" attributes\n        for name, media_type in container.mime_map.items():\n            if media_type in OEB_STYLES:\n                # A stylesheet. Parsed stylesheets are css_parser CSSStylesheet\n                # objects.\n                self.magnify_stylesheet(container.parsed(name), factor)\n                container.dirty(name)  # Tell the container that we have changed the stylesheet\n            elif media_type in OEB_DOCS:\n                # A HTML file. Parsed HTML files are lxml elements\n                for style_tag in container.parsed(name).xpath('//*[local-name=\"style\"]'):\n                    if style_tag.text and style_tag.get('type', None) in {None, 'text/css'}:\n                        # We have an inline CSS <style> tag, parse it into a\n                        # stylesheet object\n                        sheet = container.parse_css(style_tag.text)\n                        self.magnify_stylesheet(sheet, factor)\n                        style_tag.text = serialize(sheet, 'text/css', pretty_print=True)\n                        container.dirty(name)  # Tell the container that we have changed the stylesheet\n                for elem in container.parsed(name).xpath('//*[@style]'):\n                    # Process inline style attributes\n                    block = container.parse_css(elem.get('style'), is_declaration=True)\n                    self.magnify_declaration(block, factor)\n                    elem.set('style', force_unicode(block.getCssText(separator=' '), 'utf-8'))\n", "docstring": "Magnify all font sizes defined in the book by the specified factor"}
{"repo": "calibre-master/manual/plugin_examples/interface_demo/main.py", "original_string": "    def marked(self):\n        ''' Show books with only one format '''\n        db = self.db.new_api\n        matched_ids = {book_id for book_id in db.all_book_ids() if len(db.formats(book_id)) == 1}\n        # Mark the records with the matching ids\n        # new_api does not know anything about marked books, so we use the full\n        # db object\n        self.db.set_marked_ids(matched_ids)\n        # Tell the GUI to search for all marked records\n        self.gui.search.setEditText('marked:true')\n        self.gui.search.do_search()\n", "docstring": "Show books with only one format '''"}
{"repo": "calibre-master/manual/plugin_examples/interface_demo/ui.py", "original_string": "    def genesis(self):\n        # This method is called once per plugin, do initial setup here\n        # Set the icon for this interface action\n        # The get_icons function is a builtin function defined for all your\n        # plugin code. It loads icons from the plugin zip file. It returns\n        # QIcon objects, if you want the actual data, use the analogous\n        # get_resources builtin function.\n        #\n        # Note that if you are loading more than one icon, for performance, you\n        # should pass a list of names to get_icons. In this case, get_icons\n        # will return a dictionary mapping names to QIcons. Names that\n        # are not found in the zip file will result in null QIcons.\n        icon = get_icons('images/icon.png')\n        # The qaction is automatically created from the action_spec defined\n        # above\n        self.qaction.setIcon(icon)\n        self.qaction.triggered.connect(self.show_dialog)\n", "docstring": "This method is called once per plugin, do initial setup here"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def _2021(self):\n        \"\"\" http://www.gov.cn/zhengce/content/2020-11/25/content_5564127.htm\n        一、元旦：2021年1月1日至3日放假，共3天。\n        二、春节：2月11日至17日放假调休，共7天。2月7日（星期日）、2月20日（星期六）上班。\n        三、清明节：4月3日至5日放假调休，共3天。\n        四、劳动节：5月1日至5日放假调休，共5天。4月25日（星期日）、5月8日（星期六）上班。\n        五、端午节：6月12日至14日放假，共3天。\n        六、中秋节：9月19日至21日放假调休，共3天。9月18日（星期六）上班。\n        七、国庆节：10月1日至7日放假调休，共7天。9月26日（星期日）、10月9日（星期六）上班。\n        \"\"\"\n        self.year_at(2021) \\\n            .nyd().rest(1, 1).to(1, 3) \\\n            .sf().rest(2, 11).to(2, 17).work(2, 7).work(2, 20).in_lieu(2, 16).to(2, 17) \\\n            .tsd().rest(4, 3).to(4, 5) \\\n            .ld().rest(5, 1).to(5, 5).work(4, 25).work(5, 8).in_lieu(5, 4).to(5, 5) \\\n            .dbf().rest(6, 12).to(6, 14) \\\n            .maf().rest(9, 19).to(9, 21).work(9, 18).in_lieu(9, 20) \\\n            .nd().rest(10, 1).to(10, 7).work(9, 26).work(10, 9).in_lieu(10, 6).to(10, 7)\n", "docstring": "http://www.gov.cn/zhengce/content/2020-11/25/content_5564127.htm"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def _2019(self):\n        \"\"\" http://www.gov.cn/xinwen/2018-12/06/content_5346287.htm\n        一、元旦：12月30日至1月1日放假，共3天。 12月29日（星期六）上班。\n        二、春节：2月4日至10日放假调休，共7天。2月2日（星期六）、2月3日（星期天）上班。\n        三、清明节：4月5日放假，与周末连休。\n        四、劳动节：5月1日放假，共1天。\n        五、端午节：6月7日放假，与周末连休。\n        六、中秋节：9月13日放假，与周末连休。\n        七、国庆节：10月1日至7日放假调休，共7天。9月29日（星期天）、10月12日（周六）上班。\n        http://www.gov.cn/zhengce/content/2019-03/22/content_5375877.htm\n        经国务院批准，现将调整2019年劳动节放假安排通知如下。\n        2019年5月1日至4日放假调休，共4天。4月28日（星期日）、5月5日（星期日）上班。\n        \"\"\"\n        self.year_at(2019) \\\n            .nyd().rest(1, 1) \\\n            .sf().rest(2, 4).to(2, 10).work(2, 2).to(2, 3).in_lieu(2, 4).in_lieu(2, 8) \\\n            .tsd().rest(4, 5).to(4, 7) \\\n            .ld().rest(5, 1).to(5, 4).work(4, 28).work(5, 5).in_lieu(5, 2).in_lieu(5, 3) \\\n            .dbf().rest(6, 7).to(6, 9) \\\n            .maf().rest(9, 13).to(9, 15) \\\n            .nd().rest(10, 1).to(10, 7).work(9, 29).work(10, 12).in_lieu(10, 4).in_lieu(10, 7)\n", "docstring": "http://www.gov.cn/xinwen/2018-12/06/content_5346287.htm"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def _2017(self):\n        \"\"\" http://www.gov.cn/zhengce/content/2016-12/01/content_5141603.htm\n", "docstring": "http://www.gov.cn/zhengce/content/2016-12/01/content_5141603.htm"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def _2016(self):\n        \"\"\" http://www.gov.cn/zhengce/content/2015-12/10/content_10394.htm\n", "docstring": "http://www.gov.cn/zhengce/content/2015-12/10/content_10394.htm"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def _2015(self):\n        \"\"\" http://www.gov.cn/zhengce/content/2014-12/16/content_9302.htm\n", "docstring": "http://www.gov.cn/zhengce/content/2014-12/16/content_9302.htm"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def _2014(self):\n        \"\"\" http://www.gov.cn/zwgk/2013-12/11/content_2546204.htm\n", "docstring": "http://www.gov.cn/zwgk/2013-12/11/content_2546204.htm"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def _2013(self):\n        \"\"\" http://www.gov.cn/zwgk/2012-12/10/content_2286598.htm\n", "docstring": "http://www.gov.cn/zwgk/2012-12/10/content_2286598.htm"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def _2012(self):\n        \"\"\" http://www.gov.cn/zwgk/2011-12/06/content_2012097.htm\n", "docstring": "http://www.gov.cn/zwgk/2011-12/06/content_2012097.htm"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def _2011(self):\n        \"\"\" http://www.gov.cn/zwgk/2010-12/10/content_1762643.htm\n", "docstring": "http://www.gov.cn/zwgk/2010-12/10/content_1762643.htm"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def _2010(self):\n        \"\"\" http://www.gov.cn/zwgk/2009-12/08/content_1482691.htm\n", "docstring": "http://www.gov.cn/zwgk/2009-12/08/content_1482691.htm"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def _2009(self):\n        \"\"\" http://www.gov.cn/zwgk/2008-12/10/content_1174014.htm\n", "docstring": "http://www.gov.cn/zwgk/2008-12/10/content_1174014.htm"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def _2008(self):\n        \"\"\" http://www.gov.cn/zwgk/2007-12/18/content_837184.htm\n", "docstring": "http://www.gov.cn/zwgk/2007-12/18/content_837184.htm"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def _2007(self):\n        \"\"\" http://www.gov.cn/fwxx/sh/2006-12/18/content_471877.htm\n", "docstring": "http://www.gov.cn/fwxx/sh/2006-12/18/content_471877.htm"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def _2006(self):\n        \"\"\" http://www.gov.cn/jrzg/2005-12/22/content_133837.htm\n", "docstring": "http://www.gov.cn/jrzg/2005-12/22/content_133837.htm"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def year_at(self, number):\n        self.year = number\n        return self\n", "docstring": "self.year = number"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def sf(self):\n        \"\"\"春节 Sprint Festival\"\"\"\n        return self.mark(chinese_calendar.Holiday.spring_festival)\n", "docstring": "春节 Sprint Festival\n"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def ld(self):\n        \"\"\"劳动节 Labour Day\"\"\"\n        return self.mark(chinese_calendar.Holiday.labour_day)\n", "docstring": "劳动节 Labour Day\n"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def nd(self):\n        \"\"\"国庆节 National Day\"\"\"\n        return self.mark(chinese_calendar.Holiday.national_day)\n", "docstring": "国庆节 National Day\n"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def afd(self):\n        \"\"\"中国人民抗日战争暨世界反法西斯战争胜利70周年纪念日 Anti-Fascist 70th Day\"\"\"\n        return self.mark(chinese_calendar.Holiday.anti_fascist_70th_day)\n", "docstring": "中国人民抗日战争暨世界反法西斯战争胜利70周年纪念日 Anti-Fascist 70th Day\n"}
{"repo": "chinese-calendar-master/chinese_calendar/scripts/data.py", "original_string": "    def in_lieu(self, month, day):\n        \"\"\"调休 in lieu\"\"\"\n        return self.save(month, day, self.IN_LIEU)\n", "docstring": "调休 in lieu\n"}
{"repo": "SimpleCoin-master/simpleCoin/wallet.py", "original_string": "def send_transaction(addr_from, private_key, addr_to, amount):\n    \"\"\"Sends your transaction to different nodes. Once any of the nodes manage\n    to mine a block, your transaction will be added to the blockchain. Despite\n    that, there is a low chance your transaction gets canceled due to other nodes\n    having a longer chain. So make sure your transaction is deep into the chain\n    before claiming it as approved!\n    \"\"\"\n    # For fast debugging REMOVE LATER\n    # private_key=\"181f2448fa4636315032e15bb9cbc3053e10ed062ab0b2680a37cd8cb51f53f2\"\n    # amount=\"3000\"\n    # addr_from=\"SD5IZAuFixM3PTmkm5ShvLm1tbDNOmVlG7tg6F5r7VHxPNWkNKbzZfa+JdKmfBAIhWs9UKnQLOOL1U+R3WxcsQ==\"\n    # addr_to=\"SD5IZAuFixM3PTmkm5ShvLm1tbDNOmVlG7tg6F5r7VHxPNWkNKbzZfa+JdKmfBAIhWs9UKnQLOOL1U+R3WxcsQ==\"\n    if len(private_key) == 64:\n        signature, message = sign_ECDSA_msg(private_key)\n        url = 'http://localhost:5000/txion'\n        payload = {\"from\": addr_from,\n                   \"to\": addr_to,\n                   \"amount\": amount,\n                   \"signature\": signature.decode(),\n                   \"message\": message}\n        headers = {\"Content-Type\": \"application/json\"}\n        res = requests.post(url, json=payload, headers=headers)\n        print(res.text)\n    else:\n        print(\"Wrong address or key length! Verify and try again.\")\n", "docstring": "Sends your transaction to different nodes. Once any of the nodes manage"}
{"repo": "SimpleCoin-master/simpleCoin/wallet.py", "original_string": "def generate_ECDSA_keys():\n    \"\"\"This function takes care of creating your private and public (your address) keys.\n    It's very important you don't lose any of them or those wallets will be lost\n    forever. If someone else get access to your private key, you risk losing your coins.\n    private_key: str\n    public_ley: base64 (to make it shorter)\n    \"\"\"\n    sk = ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1) #this is your sign (private key)\n    private_key = sk.to_string().hex() #convert your private key to hex\n    vk = sk.get_verifying_key() #this is your verification key (public key)\n    public_key = vk.to_string().hex()\n    #we are going to encode the public key to make it shorter\n    public_key = base64.b64encode(bytes.fromhex(public_key))\n    filename = input(\"Write the name of your new address: \") + \".txt\"\n    with open(filename, \"w\") as f:\n        f.write(\"Private key: {0}\\nWallet address / Public key: {1}\".format(private_key, public_key.decode()))\n    print(\"Your new address and private key are now in the file {0}\".format(filename))\n", "docstring": "This function takes care of creating your private and public (your address) keys."}
{"repo": "SimpleCoin-master/simpleCoin/miner.py", "original_string": "    def __init__(self, index, timestamp, data, previous_hash):\n        \"\"\"Returns a new Block object. Each block is \"chained\" to its previous\n        by calling its unique hash.\n        Args:\n            index (int): Block number.\n            timestamp (int): Block creation timestamp.\n            data (str): Data to be sent.\n            previous_hash(str): String representing previous block unique hash.\n        Attrib:\n            index (int): Block number.\n            timestamp (int): Block creation timestamp.\n            data (str): Data to be sent.\n            previous_hash(str): String representing previous block unique hash.\n            hash(str): Current block unique hash.\n        \"\"\"\n        self.index = index\n        self.timestamp = timestamp\n        self.data = data\n        self.previous_hash = previous_hash\n        self.hash = self.hash_block()\n", "docstring": "Returns a new Block object. Each block is \"chained\" to its previous"}
{"repo": "SimpleCoin-master/simpleCoin/miner.py", "original_string": "def create_genesis_block():\n    \"\"\"To create each block, it needs the hash of the previous one. First\n    block has no previous, so it must be created manually (with index zero\n     and arbitrary previous hash)\"\"\"\n    return Block(0, time.time(), {\n        \"proof-of-work\": 9,\n        \"transactions\": None},\n        \"0\")\n", "docstring": "To create each block, it needs the hash of the previous one. First"}
{"repo": "SimpleCoin-master/simpleCoin/miner.py", "original_string": "def proof_of_work(last_proof, blockchain):\n    # Creates a variable that we will use to find our next proof of work\n    incrementer = last_proof + 1\n    # Keep incrementing the incrementer until it's equal to a number divisible by 7919\n    # and the proof of work of the previous block in the chain\n    start_time = time.time()\n    while not (incrementer % 7919 == 0 and incrementer % last_proof == 0):\n        incrementer += 1\n        # Check if any node found the solution every 60 seconds\n        if int((time.time()-start_time) % 60) == 0:\n            # If any other node got the proof, stop searching\n            new_blockchain = consensus(blockchain)\n            if new_blockchain:\n                # (False: another node got proof first, new blockchain)\n                return False, new_blockchain\n    # Once that number is found, we can return it as a proof of our work\n    return incrementer, blockchain\n", "docstring": "Creates a variable that we will use to find our next proof of work"}
{"repo": "SimpleCoin-master/simpleCoin/miner.py", "original_string": "def find_new_chains():\n    # Get the blockchains of every other node\n    other_chains = []\n    for node_url in PEER_NODES:\n        # Get their chains using a GET request\n        block = requests.get(url = node_url + \"/blocks\").content\n        # Convert the JSON object to a Python dictionary\n        block = json.loads(block)\n        # Verify other node block is correct\n        validated = validate_blockchain(block)\n        if validated:\n            # Add it to our list\n            other_chains.append(block)\n    return other_chains\n", "docstring": "Get the blockchains of every other node"}
{"repo": "SimpleCoin-master/simpleCoin/miner.py", "original_string": "def validate_blockchain(block):\n    \"\"\"Validate the submitted chain. If hashes are not correct, return false\n    block(str): json\n    \"\"\"\n    return True\n", "docstring": "Validate the submitted chain. If hashes are not correct, return false"}
{"repo": "SimpleCoin-master/simpleCoin/miner.py", "original_string": "def get_blocks():\n    # Load current blockchain. Only you should update your blockchain\n    if request.args.get(\"update\") == MINER_ADDRESS:\n        global BLOCKCHAIN\n        BLOCKCHAIN = b.recv()\n    chain_to_send = BLOCKCHAIN\n    # Converts our blocks into dictionaries so we can send them as json objects later\n    chain_to_send_json = []\n    for block in chain_to_send:\n        block = {\n            \"index\": str(block.index),\n            \"timestamp\": str(block.timestamp),\n            \"data\": str(block.data),\n            \"hash\": block.hash\n        }\n        chain_to_send_json.append(block)\n    # Send our chain to whomever requested it\n    chain_to_send = json.dumps(chain_to_send_json, sort_keys=True)\n    return chain_to_send\n", "docstring": "Load current blockchain. Only you should update your blockchain"}
{"repo": "SimpleCoin-master/simpleCoin/miner.py", "original_string": "def transaction():\n    \"\"\"Each transaction sent to this node gets validated and submitted.\n    Then it waits to be added to the blockchain. Transactions only move\n    coins, they don't create it.\n    \"\"\"\n    if request.method == 'POST':\n        # On each new POST request, we extract the transaction data\n        new_txion = request.get_json()\n        # Then we add the transaction to our list\n        if validate_signature(new_txion['from'], new_txion['signature'], new_txion['message']):\n            NODE_PENDING_TRANSACTIONS.append(new_txion)\n            # Because the transaction was successfully\n            # submitted, we log it to our console\n            print(\"New transaction\")\n            print(\"FROM: {0}\".format(new_txion['from']))\n            print(\"TO: {0}\".format(new_txion['to']))\n            print(\"AMOUNT: {0}\\n\".format(new_txion['amount']))\n            # Then we let the client know it worked out\n            return \"Transaction submission successful\\n\"\n        else:\n            return \"Transaction submission failed. Wrong signature\\n\"\n    # Send pending transactions to the mining process\n    elif request.method == 'GET' and request.args.get(\"update\") == MINER_ADDRESS:\n        pending = json.dumps(NODE_PENDING_TRANSACTIONS, sort_keys=True)\n        # Empty transaction list\n        NODE_PENDING_TRANSACTIONS[:] = []\n        return pending\n", "docstring": "Each transaction sent to this node gets validated and submitted."}
{"repo": "python-jsonpath-rw-master/jsonpath_rw/jsonpath.py", "original_string": "    def wrap(cls, data):\n        if isinstance(data, cls):\n            return data\n        else:\n            return cls(data)\n", "docstring": "if isinstance(data, cls):"}
{"repo": "python-jsonpath-rw-master/jsonpath_rw/jsonpath.py", "original_string": "    def __eq__(self, other):\n        return isinstance(other, DatumInContext) and other.value == self.value and other.path == self.path and self.context == other.context\n", "docstring": "return isinstance(other, DatumInContext) and other.value == self.value and other.path == self.path and self.context == other.context"}
{"repo": "python-jsonpath-rw-master/jsonpath_rw/jsonpath.py", "original_string": "    def value(self):\n        return str(self.datum.id_pseudopath)\n", "docstring": "return str(self.datum.id_pseudopath)"}
{"repo": "python-jsonpath-rw-master/jsonpath_rw/jsonpath.py", "original_string": "        def update_recursively(data):\n            # Update only mutable values corresponding to JSON types\n            if not (isinstance(data, list) or isinstance(data, dict)):\n                return\n            self.right.update(data, val)\n            # Manually do the * or [*] to avoid coercion and recurse just the right-hand pattern\n            if isinstance(data, list):\n                for i in range(0, len(data)):\n                    update_recursively(data[i])\n            elif isinstance(data, dict):\n                for field in data.keys():\n                    update_recursively(data[field])\n", "docstring": "Update only mutable values corresponding to JSON types"}
{"repo": "python-jsonpath-rw-master/jsonpath_rw/parser.py", "original_string": "    def parse_token_stream(self, token_iterator, start_symbol='jsonpath'):\n        # Since PLY has some crufty aspects and dumps files, we try to keep them local\n        # However, we need to derive the name of the output Python file :-/\n        output_directory = os.path.dirname(__file__)\n        try:\n            module_name = os.path.splitext(os.path.split(__file__)[1])[0]\n        except:\n            module_name = __name__\n        \n        parsing_table_module = '_'.join([module_name, start_symbol, 'parsetab'])\n        # And we regenerate the parse table every time; it doesn't actually take that long!\n        new_parser = ply.yacc.yacc(module=self,\n                                   debug=self.debug,\n                                   tabmodule = parsing_table_module,\n                                   outputdir = output_directory,\n                                   write_tables=0,\n                                   start = start_symbol,\n                                   errorlog = logger)\n        return new_parser.parse(lexer = IteratorToTokenStream(token_iterator))\n", "docstring": "Since PLY has some crufty aspects and dumps files, we try to keep them local"}
{"repo": "python-jsonpath-rw-master/jsonpath_rw/parser.py", "original_string": "    def p_fields_or_any(self, p):\n        \"\"\"fields_or_any : fields \n                         | '*'    \"\"\"\n        if p[1] == '*':\n            p[0] = ['*']\n        else:\n            p[0] = p[1]\n", "docstring": "fields_or_any : fields"}
{"repo": "python-jsonpath-rw-master/jsonpath_rw/parser.py", "original_string": "    def p_maybe_int(self, p):\n        \"\"\"maybe_int : NUMBER\n                     | empty\"\"\"\n        p[0] = p[1]\n", "docstring": "maybe_int : NUMBER"}
{"repo": "python-jsonpath-rw-master/tests/test_jsonpath.py", "original_string": "    def check_cases(self, test_cases):\n        # Note that just manually building an AST would avoid this dep and isolate the tests, but that would suck a bit\n        # Also, we coerce iterables, etc, into the desired target type\n        for string, data, target in test_cases:\n            print('parse(\"%s\").find(%s) =?= %s' % (string, data, target))\n            result = parse(string).find(data)\n            if isinstance(target, list):\n                assert [r.value for r in result] == target\n            elif isinstance(target, set):\n                assert set([r.value for r in result]) == target\n            else:\n                assert result.value == target\n", "docstring": "Note that just manually building an AST would avoid this dep and isolate the tests, but that would suck a bit"}
{"repo": "python-jsonpath-rw-master/tests/test_jsonpath.py", "original_string": "    def check_paths(self, test_cases):\n        # Note that just manually building an AST would avoid this dep and isolate the tests, but that would suck a bit\n        # Also, we coerce iterables, etc, into the desired target type\n        for string, data, target in test_cases:\n            print('parse(\"%s\").find(%s).paths =?= %s' % (string, data, target))\n            result = parse(string).find(data)\n            if isinstance(target, list):\n                assert [str(r.full_path) for r in result] == target\n            elif isinstance(target, set):\n                assert set([str(r.full_path) for r in result]) == target\n            else:\n                assert str(result.path) == target\n", "docstring": "Note that just manually building an AST would avoid this dep and isolate the tests, but that would suck a bit"}
{"repo": "vecstack-master/vecstack/core.py", "original_string": "def transformer(y, func=None):\n    \"\"\"Transforms target variable and prediction\"\"\"\n    if func is None:\n        return y\n    else:\n        return func(y)\n        \n", "docstring": "Transforms target variable and prediction\n"}
{"repo": "vecstack-master/vecstack/coresk.py", "original_string": "        def your_metric(y_true, y_pred):\n            # calculate\n            return result\n", "docstring": "calculate"}
{"repo": "vecstack-master/vecstack/coresk.py", "original_string": "    def fit_transform(self, X, y, sample_weight=None):\n        \"\"\"Fit all base estimators and transform (predict) train set.\n        Parameters\n        ----------\n        See docs for ``fit`` and ``transform`` methods.\n        Returns\n        -------\n        X_transformed : 2d numpy array of shape [n_samples, n_estimators] or\n                        [n_samples, n_estimators * n_classes]\n            Out-of-fold predictions (OOF) for train set.\n            This is stacked features for next level.\n        \"\"\"\n        # ---------------------------------------------------------------------\n        # All validation and procedures are done inside corresponding methods\n        # fit and transform\n        # ---------------------------------------------------------------------\n        return self.fit(X, y, sample_weight).transform(X)\n", "docstring": "Fit all base estimators and transform (predict) train set."}
{"repo": "vecstack-master/vecstack/coresk.py", "original_string": "    def _transformer(self, y, func=None):\n        \"\"\"Transforms target variable and prediction\n        \"\"\"\n        if func is None:\n            return y\n        else:\n            return func(y)\n", "docstring": "Transforms target variable and prediction"}
{"repo": "vecstack-master/vecstack/coresk.py", "original_string": "    def _get_footprint(self, X, n_items=1000):\n        \"\"\"Selects ``n_items`` random elements from 2d numpy array or\n        sparse matrix (or all elements if their number is less or equal\n        to ``n_items``).\n        \"\"\"\n        try:\n            footprint = []\n            r, c = X.shape\n            n = r * c\n            # np.random.seed(0) # for development\n            # OOM with large arrays (see #29)\n            # ids = np.random.choice(n, min(n_items, n), replace=False)\n            ids = self._random_choice(n, min(n_items, n))\n            for i in ids:\n                row = i // c\n                col = i - row * c\n                footprint.append((row, col, X[row, col]))\n            return footprint\n        except Exception:\n            raise ValueError('Internal error. '\n                             'Please save traceback and inform developers.')\n", "docstring": "Selects ``n_items`` random elements from 2d numpy array or"}
{"repo": "vecstack-master/vecstack/coresk.py", "original_string": "    def _check_identity(self, X,\n                        rtol=1e-05, atol=1e-08,\n                        equal_nan=False):\n        \"\"\"Checks 2d numpy array or sparse matrix identity\n        by its shape and footprint.\n        \"\"\"\n        try:\n            # Check shape\n            if X.shape != self.train_shape_:\n                return False\n            # Check footprint\n            try:\n                for coo in self.train_footprint_:\n                    assert np.isclose(X[coo[0], coo[1]], coo[2], rtol=rtol, atol=atol, equal_nan=equal_nan)\n                return True\n            except AssertionError:\n                return False\n        except Exception:\n            raise ValueError('Internal error. '\n                             'Please save traceback and inform developers.')\n", "docstring": "rtol=1e-05, atol=1e-08,"}
{"repo": "vecstack-master/vecstack/coresk.py", "original_string": "    def _get_params(self, attr, deep=True):\n        \"\"\"Gives ability to get parameters of nested estimators\n        \"\"\"\n        out = super(StackingTransformer, self).get_params(deep=False)\n        if not deep:\n            return out\n        estimators = getattr(self, attr)\n        if estimators is None:\n            return out\n        out.update(estimators)\n        for name, estimator in estimators:\n            for key, value in iter(estimator.get_params(deep=True).items()):\n                out['%s__%s' % (name, key)] = value\n        return out\n", "docstring": "Gives ability to get parameters of nested estimators"}
{"repo": "vecstack-master/vecstack/coresk.py", "original_string": "    def get_params(self, deep=True):\n        \"\"\"Get parameters of StackingTransformer and base estimators.\n        Parameters\n        ----------\n        deep : boolean\n            If False - get parameters of StackingTransformer\n            If True - get parameters of StackingTransformer and base estimators\n        \"\"\"\n        return self._get_params('estimators', deep=deep)\n", "docstring": "Get parameters of StackingTransformer and base estimators."}
{"repo": "vecstack-master/vecstack/coresk.py", "original_string": "    def _validate_names(self, names):\n        \"\"\"Validates estimator names\n        \"\"\"\n        if len(set(names)) != len(names):\n            raise ValueError('Names provided are not unique: '\n                             '%s' % list(names))\n        invalid_names = set(names).intersection(self.get_params(deep=False))\n        if invalid_names:\n            raise ValueError('Estimator names conflict with constructor '\n                             'arguments: %s' % sorted(invalid_names))\n        invalid_names = [name for name in names if '__' in name]\n        if invalid_names:\n            raise ValueError('Estimator names must not contain __: got '\n                             '%s' % invalid_names)\n", "docstring": "Validates estimator names"}
{"repo": "vecstack-master/vecstack/coresk.py", "original_string": "    def is_train_set(self, X):\n        \"\"\"Checks if given data set was used to train\n        StackingTransformer instance.\n        Parameters\n        ----------\n        X : 2d numpy array or sparse matrix of shape [n_samples, n_features]\n            Input data\n        Returns\n        -------\n        check_result : boolean\n            True - if X was used to train StackingTransformer instance\n            False - otherwise\n        \"\"\"\n        # Check if fitted\n        check_is_fitted(self, ['models_A_'])\n        # Input validation\n        X = check_array(X, accept_sparse=['csr'], force_all_finite=True)\n        return self._check_identity(X)\n", "docstring": "Checks if given data set was used to train"}
{"repo": "vecstack-master/tests/test_func_api_classification_multiclass.py", "original_string": "    def test_oof_pred_mode_2_models(self):\n        # Model a\n        model = LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr')\n        S_train_1_a = cross_val_predict(model, X_train, y = y_train, cv = n_folds, \n            n_jobs = 1, verbose = 0, method = 'predict').reshape(-1, 1)\n        _ = model.fit(X_train, y_train)\n        S_test_1_a = model.predict(X_test).reshape(-1, 1)\n        \n        # Model b\n        model = GaussianNB()\n        S_train_1_b = cross_val_predict(model, X_train, y = y_train, cv = n_folds, \n            n_jobs = 1, verbose = 0, method = 'predict').reshape(-1, 1)\n        _ = model.fit(X_train, y_train)\n        S_test_1_b = model.predict(X_test).reshape(-1, 1)\n        \n        S_train_1 = np.c_[S_train_1_a, S_train_1_b]\n        S_test_1 = np.c_[S_test_1_a, S_test_1_b]\n        models = [LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr'),\n                  GaussianNB()]\n        S_train_2, S_test_2 = stacking(models, X_train, y_train, X_test, \n            regression = False, n_folds = n_folds, shuffle = False, save_dir=temp_dir, \n            mode = 'oof_pred', random_state = 0, verbose = 0, stratified = True)\n            \n        # Load OOF from file\n        # Normally if cleaning is performed there is only one .npy file at given moment\n        # But if we have no cleaning there may be more then one file so we take the latest\n        file_name = sorted(glob.glob(os.path.join(temp_dir, '*.npy')))[-1] # take the latest file\n        S = np.load(file_name, allow_pickle=True)\n        S_train_3 = S[0]\n        S_test_3 = S[1]\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n        \n", "docstring": "Model a"}
{"repo": "vecstack-master/tests/test_func_api_classification_multiclass.py", "original_string": "    def test_oof_pred_mode_proba_2_models(self):\n        # Model a\n        model = LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr')\n        S_train_1_a = cross_val_predict(model, X_train, y = y_train, cv = n_folds, \n            n_jobs = 1, verbose = 0, method = 'predict_proba')\n        _ = model.fit(X_train, y_train)\n        S_test_1_a = model.predict_proba(X_test)\n        \n        # Model b\n        model = GaussianNB()\n        S_train_1_b = cross_val_predict(model, X_train, y = y_train, cv = n_folds, \n            n_jobs = 1, verbose = 0, method = 'predict_proba')\n        _ = model.fit(X_train, y_train)\n        S_test_1_b = model.predict_proba(X_test)\n        \n        S_train_1 = np.c_[S_train_1_a, S_train_1_b]\n        S_test_1 = np.c_[S_test_1_a, S_test_1_b]\n        models = [LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr'),\n                  GaussianNB()]\n        S_train_2, S_test_2 = stacking(models, X_train, y_train, X_test, \n            regression = False, n_folds = n_folds, shuffle = False, stratified = True,\n            mode = 'oof_pred', random_state = 0, verbose = 0, needs_proba = True, save_dir=temp_dir)\n            \n        # Load OOF from file\n        # Normally if cleaning is performed there is only one .npy file at given moment\n        # But if we have no cleaning there may be more then one file so we take the latest\n        file_name = sorted(glob.glob(os.path.join(temp_dir, '*.npy')))[-1] # take the latest file\n        S = np.load(file_name, allow_pickle=True)\n        S_train_3 = S[0]\n        S_test_3 = S[1]\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n        \n        \n", "docstring": "Model a"}
{"repo": "vecstack-master/tests/test_func_api_classification_binary.py", "original_string": "    def test_oof_pred_mode_2_models(self):\n        # Model a\n        model = LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr')\n        S_train_1_a = cross_val_predict(model, X_train, y = y_train, cv = n_folds, \n            n_jobs = 1, verbose = 0, method = 'predict').reshape(-1, 1)\n        _ = model.fit(X_train, y_train)\n        S_test_1_a = model.predict(X_test).reshape(-1, 1)\n        \n        # Model b\n        model = GaussianNB()\n        S_train_1_b = cross_val_predict(model, X_train, y = y_train, cv = n_folds, \n            n_jobs = 1, verbose = 0, method = 'predict').reshape(-1, 1)\n        _ = model.fit(X_train, y_train)\n        S_test_1_b = model.predict(X_test).reshape(-1, 1)\n        \n        S_train_1 = np.c_[S_train_1_a, S_train_1_b]\n        S_test_1 = np.c_[S_test_1_a, S_test_1_b]\n        models = [LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr'),\n                  GaussianNB()]\n        S_train_2, S_test_2 = stacking(models, X_train, y_train, X_test, \n            regression = False, n_folds = n_folds, shuffle = False, save_dir=temp_dir, \n            mode = 'oof_pred', random_state = 0, verbose = 0, stratified = True)\n            \n        # Load OOF from file\n        # Normally if cleaning is performed there is only one .npy file at given moment\n        # But if we have no cleaning there may be more then one file so we take the latest\n        file_name = sorted(glob.glob(os.path.join(temp_dir, '*.npy')))[-1] # take the latest file\n        S = np.load(file_name, allow_pickle=True)\n        S_train_3 = S[0]\n        S_test_3 = S[1]\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n        \n", "docstring": "Model a"}
{"repo": "vecstack-master/tests/test_func_api_classification_binary.py", "original_string": "    def test_oof_pred_mode_proba_2_models(self):\n        # Model a\n        model = LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr')\n        S_train_1_a = cross_val_predict(model, X_train, y = y_train, cv = n_folds, \n            n_jobs = 1, verbose = 0, method = 'predict_proba')\n        _ = model.fit(X_train, y_train)\n        S_test_1_a = model.predict_proba(X_test)\n        \n        # Model b\n        model = GaussianNB()\n        S_train_1_b = cross_val_predict(model, X_train, y = y_train, cv = n_folds, \n            n_jobs = 1, verbose = 0, method = 'predict_proba')\n        _ = model.fit(X_train, y_train)\n        S_test_1_b = model.predict_proba(X_test)\n        \n        S_train_1 = np.c_[S_train_1_a, S_train_1_b]\n        S_test_1 = np.c_[S_test_1_a, S_test_1_b]\n        models = [LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr'),\n                  GaussianNB()]\n        S_train_2, S_test_2 = stacking(models, X_train, y_train, X_test, \n            regression = False, n_folds = n_folds, shuffle = False, stratified = True,\n            mode = 'oof_pred', random_state = 0, verbose = 0, needs_proba = True, save_dir=temp_dir)\n            \n        # Load OOF from file\n        # Normally if cleaning is performed there is only one .npy file at given moment\n        # But if we have no cleaning there may be more then one file so we take the latest\n        file_name = sorted(glob.glob(os.path.join(temp_dir, '*.npy')))[-1] # take the latest file\n        S = np.load(file_name, allow_pickle=True)\n        S_train_3 = S[0]\n        S_test_3 = S[1]\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n        \n        \n", "docstring": "Model a"}
{"repo": "vecstack-master/tests/test_sklearn_api_regression.py", "original_string": "    def test_variant_B(self):\n        # reference\n        model = LinearRegression()\n        S_train_1 = cross_val_predict(model, X_train, y=y_train,\n                                      cv=n_folds, n_jobs=1, verbose=0,\n                                      method='predict').reshape(-1, 1)\n        model = model.fit(X_train, y_train)\n        S_test_1 = model.predict(X_test).reshape(-1, 1)\n        # fit then transform\n        estimators = [('lr', LinearRegression())]\n        stack = StackingTransformer(estimators, regression=True,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    verbose=0)\n        stack = stack.fit(X_train, y_train)\n        S_train_2 = stack.transform(X_train)\n        S_test_2 = stack.transform(X_test)\n            \n        # fit_transform\n        # also check refitting already fitted transformer\n        S_train_3 = stack.fit_transform(X_train, y_train)\n        S_test_3 = stack.transform(X_test)\n        \n        # compare\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n", "docstring": "reference"}
{"repo": "vecstack-master/tests/test_sklearn_api_regression.py", "original_string": "    def test_variant_B_default_regressor(self):\n        # reference\n        model = DummyRegressor(strategy='constant', constant=5.5)\n        S_train_1 = cross_val_predict(model, X_train, y=y_train,\n                                      cv=n_folds, n_jobs=1, verbose=0,\n                                      method='predict').reshape(-1, 1)\n        model = model.fit(X_train, y_train)\n        S_test_1 = model.predict(X_test).reshape(-1, 1)\n        # fit then transform\n        stack = StackingTransformer(estimators=None, regression=True,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    verbose=0)\n        stack = stack.fit(X_train, y_train)\n        S_train_2 = stack.transform(X_train)\n        S_test_2 = stack.transform(X_test)\n            \n        # fit_transform\n        # also check refitting already fitted transformer\n        S_train_3 = stack.fit_transform(X_train, y_train)\n        S_test_3 = stack.transform(X_test)\n        \n        # compare\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n        \n", "docstring": "reference"}
{"repo": "vecstack-master/tests/test_sklearn_api_regression.py", "original_string": "    def test_parameter_warnings(self):\n        # Parameters specific for classification are ignored if regression=True\n        stack = StackingTransformer(regression=True, needs_proba=True)\n        assert_warns(UserWarning, stack.fit, X_train, y_train)\n        \n        stack = StackingTransformer(regression=True, stratified=True)\n        assert_warns(UserWarning, stack.fit, X_train, y_train)\n        \n        stack = StackingTransformer(regression=True, needs_proba=True, stratified=True)\n        assert_warns(UserWarning, stack.fit, X_train, y_train)\n        \n", "docstring": "Parameters specific for classification are ignored if regression=True"}
{"repo": "vecstack-master/tests/test_sklearn_api_regression.py", "original_string": "    def test_pickle(self):\n        # reference\n        model = LinearRegression()\n        S_train_1 = cross_val_predict(model, X_train, y=y_train,\n                                      cv=n_folds, n_jobs=1, verbose=0,\n                                      method='predict').reshape(-1, 1)\n        model = model.fit(X_train, y_train)\n        S_test_1 = model.predict(X_test).reshape(-1, 1)\n        # fit\n        estimators = [('lr', LinearRegression())]\n        stack = StackingTransformer(estimators, regression=True,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    verbose=0)\n        stack = stack.fit(X_train, y_train)\n        \n        # save\n        _ = joblib.dump(stack, os.path.join(temp_dir, 'stack.pkl'))\n        \n        # load\n        stack_loaded = joblib.load(os.path.join(temp_dir, 'stack.pkl'))\n        \n        # transform using loaded instance\n        S_train_2 = stack_loaded.transform(X_train)\n        S_test_2 = stack_loaded.transform(X_test)\n            \n        # refit loaded instance with fit_transform\n        S_train_3 = stack_loaded.fit_transform(X_train, y_train)\n        S_test_3 = stack_loaded.transform(X_test)\n        \n        # compare\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n        \n", "docstring": "reference"}
{"repo": "vecstack-master/tests/test_sklearn_api_regression.py", "original_string": "    def test_fallback_parameter_of_transform_method(self):\n        # reference\n        model = LinearRegression()\n        S_train_1 = cross_val_predict(model, X_train, y=y_train,\n                                      cv=n_folds, n_jobs=1, verbose=0,\n                                      method='predict').reshape(-1, 1)\n        model = model.fit(X_train, y_train)\n        S_test_1 = model.predict(X_test).reshape(-1, 1)\n        # fit then transform\n        estimators = [('lr', LinearRegression())]\n        stack = StackingTransformer(estimators, regression=True,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    verbose=0)\n        stack = stack.fit(X_train, y_train)\n        # We explicitly tell that this is train set and it actually IS train set\n        # MUST work as usual\n        S_train_2 = stack.transform(X_train, is_train_set=True)\n        S_test_2 = stack.transform(X_test)\n        \n        # compare\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        # We explicitly tell that this is train set but it actually is NOT train set (different shape)\n        # MUST raise\n        assert_raises(ValueError, stack.transform, X_train[:10], is_train_set=True)\n", "docstring": "reference"}
{"repo": "vecstack-master/tests/test_sklearn_api_regression.py", "original_string": "    def test_pipeline(self):\n        # reference\n        model = LinearRegression(fit_intercept=True)\n        S_train_1_lr = cross_val_predict(model, X_train, y=y_train,\n                                         cv=n_folds, n_jobs=1, verbose=0,\n                                         method='predict').reshape(-1, 1)\n        model = model.fit(X_train, y_train)\n        S_test_1_lr = model.predict(X_test).reshape(-1, 1)\n        \n        model = DecisionTreeRegressor(random_state=0, max_depth=2)\n        S_train_1_ridge = cross_val_predict(model, X_train, y=y_train,\n                                            cv=n_folds, n_jobs=1, verbose=0,\n                                            method='predict').reshape(-1, 1)\n        model = model.fit(X_train, y_train)\n        S_test_1_ridge = model.predict(X_test).reshape(-1, 1)\n        \n        S_train_1 = np.c_[S_train_1_lr, S_train_1_ridge]\n        S_test_1 = np.c_[S_test_1_lr, S_test_1_ridge]\n        \n        model = Ridge(random_state=0, alpha=2)\n        model = model.fit(S_train_1, y_train)\n        y_pred_1 = model.predict(S_test_1)\n        # We intentionally set different parameter values to reset them\n        # later using ``set_params`` method\n        # We have 4 parameters which differs from reference:\n        # ``fit_intercept``, ``max_depth``, ``variant``, and ``alpha``\n        estimators = [('lr', LinearRegression(fit_intercept=False)),\n                      ('tree', DecisionTreeRegressor(random_state=0, max_depth=4))]\n        stack = StackingTransformer(estimators, regression=True,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='A', random_state=0,\n                                    verbose=0)\n        ridge = Ridge(random_state=0, alpha=7)\n        \n        steps = [('stack', stack),\n                 ('ridge', ridge)]\n                 \n        pipe = Pipeline(steps)\n        \n        pipe = pipe.fit(X_train, y_train)\n        y_pred_2 = pipe.predict(X_test)\n        \n        # Here we expect that final predictions are different \n        # because we've set different parameters\n        assert_raises(AssertionError, assert_array_equal, y_pred_1, y_pred_2)\n        \n        # Reset original parameters used in reference\n        pipe = pipe.set_params(stack__lr__fit_intercept=True,\n                               stack__tree__max_depth=2,\n                               stack__variant='B',\n                               ridge__alpha=2)\n                               \n        pipe = pipe.fit(X_train, y_train)\n        y_pred_3 = pipe.predict(X_test)\n        \n        # Here we expect that final predictions are equal\n        assert_array_equal(y_pred_1, y_pred_3)\n        \n", "docstring": "reference"}
{"repo": "vecstack-master/tests/test_sklearn_api_regression.py", "original_string": "    def test_variant_B_shuffle_and_random_state(self):\n        # reference\n        model = LinearRegression()\n        kf = KFold(n_splits=n_folds, shuffle=True, random_state=0)\n        # !!! below we pass KFold object (not a number of folds)\n        S_train_1 = cross_val_predict(model, X_train, y=y_train,\n                                      cv=kf, n_jobs=1, verbose=0,\n                                      method='predict').reshape(-1, 1)\n        model = model.fit(X_train, y_train)\n        S_test_1 = model.predict(X_test).reshape(-1, 1)\n        # fit then transform\n        estimators = [('lr', LinearRegression())]\n        stack = StackingTransformer(estimators, regression=True,\n                                    n_folds=n_folds, shuffle=True,\n                                    variant='B', random_state=0,\n                                    verbose=0)\n        stack = stack.fit(X_train, y_train)\n        S_train_2 = stack.transform(X_train)\n        S_test_2 = stack.transform(X_test)\n            \n        # fit_transform\n        # also check refitting already fitted transformer\n        S_train_3 = stack.fit_transform(X_train, y_train)\n        S_test_3 = stack.transform(X_test)\n        \n        # compare\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n", "docstring": "reference"}
{"repo": "vecstack-master/tests/test_sklearn_api_regression.py", "original_string": "    def test_get_footprint(self):\n        # fit then transform\n        estimators = [('lr', LinearRegression())]\n        stack = StackingTransformer(estimators, regression=True,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    verbose=0)\n        stack = stack.fit(X_train, y_train)\n        # ``X`` argument is correct - must NOT raise\n        assert_raises(AssertionError, assert_raises, ValueError, stack._get_footprint, X_train)\n        # ``X`` argument is INcorrect - MUST raise\n        assert_raises(ValueError, stack._get_footprint, 5)\n        \n", "docstring": "fit then transform"}
{"repo": "vecstack-master/tests/test_sklearn_api_regression.py", "original_string": "    def test_check_identity(self):\n        # fit then transform\n        estimators = [('lr', LinearRegression())]\n        stack = StackingTransformer(estimators, regression=True,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    verbose=0)\n        stack = stack.fit(X_train, y_train)\n        # ``X`` argument is correct - must NOT raise\n        assert_raises(AssertionError, assert_raises, ValueError, stack._check_identity, X_train)\n        # ``X`` argument is INcorrect - MUST raise\n        assert_raises(ValueError, stack._check_identity, 5)\n", "docstring": "fit then transform"}
{"repo": "vecstack-master/tests/test_sklearn_api_regression.py", "original_string": "    def test_random_choice(self):\n        # fit then transform\n        estimators = [('lr', LinearRegression())]\n        stack = StackingTransformer(estimators, regression=True,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    verbose=0)\n        stack = stack.fit(X_train, y_train)\n        # very large range - must NOT raise\n        assert_raises(AssertionError, assert_raises, ValueError, stack._random_choice, 19999999999, 1000)\n        # ``size`` is less than ``n`` - must NOT raise\n        assert_raises(AssertionError, assert_raises, ValueError, stack._random_choice, 200, 20)\n        # ``size`` is greater than ``n`` - MUST raise\n        assert_raises(ValueError, stack._random_choice, 20, 200)\n        \n", "docstring": "fit then transform"}
{"repo": "vecstack-master/tests/test_sklearn_api_regression.py", "original_string": "    def test_x_test_has_same_shape(self):\n        # reference\n        X_test_same_shape = np.r_[X_test[:101], X_test[:101], X_test[:101], X_test[:101]]\n        \n        model = LinearRegression()\n        S_train_1 = cross_val_predict(model, X_train, y=y_train,\n                                      cv=n_folds, n_jobs=1, verbose=0,\n                                      method='predict').reshape(-1, 1)\n        model = model.fit(X_train, y_train)\n        S_test_1 = model.predict(X_test_same_shape).reshape(-1, 1)\n        # fit then transform\n        estimators = [('lr', LinearRegression())]\n        stack = StackingTransformer(estimators, regression=True,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    verbose=0)\n        stack = stack.fit(X_train, y_train)\n        S_train_2 = stack.transform(X_train)\n        S_test_2 = stack.transform(X_test_same_shape)\n            \n        # fit_transform\n        # also check refitting already fitted transformer\n        S_train_3 = stack.fit_transform(X_train, y_train)\n        S_test_3 = stack.transform(X_test_same_shape)\n        \n        # compare\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n", "docstring": "reference"}
{"repo": "vecstack-master/tests/test_sklearn_api_classification_multiclass.py", "original_string": "def roc_auc_score_universal(y_true, y_pred):\n    \"\"\"ROC AUC metric for both binary and multiclass classification.\n    \n    Parameters\n    ----------\n    y_true - 1d numpy array\n        True class labels\n    y_pred - 2d numpy array\n        Predicted probabilities for each class\n    \"\"\"\n    ohe = OneHotEncoder(sparse=False)\n    y_true = ohe.fit_transform(y_true.reshape(-1, 1))\n    auc_score = roc_auc_score(y_true, y_pred)\n    return auc_score\n", "docstring": "ROC AUC metric for both binary and multiclass classification."}
{"repo": "vecstack-master/tests/test_sklearn_api_classification_multiclass.py", "original_string": "    def test_variant_B_labels(self):\n        # reference\n        model = LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr')\n        S_train_1 = cross_val_predict(model, X_train, y=y_train,\n                                      cv=n_folds, n_jobs=1, verbose=0,\n                                      method='predict').reshape(-1, 1)\n        model = model.fit(X_train, y_train)\n        S_test_1 = model.predict(X_test).reshape(-1, 1)\n        # fit then transform\n        estimators = [('logit', LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr'))]\n        stack = StackingTransformer(estimators, regression=False,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    stratified=True, verbose=0)\n        stack = stack.fit(X_train, y_train)\n        S_train_2 = stack.transform(X_train)\n        S_test_2 = stack.transform(X_test)\n            \n        # fit_transform\n        # also check refitting already fitted transformer\n        S_train_3 = stack.fit_transform(X_train, y_train)\n        S_test_3 = stack.transform(X_test)\n        \n        # compare\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n        \n", "docstring": "reference"}
{"repo": "vecstack-master/tests/test_sklearn_api_classification_multiclass.py", "original_string": "    def test_variant_B_proba(self):\n        # reference\n        model = LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr')\n        S_train_1 = cross_val_predict(model, X_train, y=y_train,\n                                      cv=n_folds, n_jobs=1, verbose=0,\n                                      method='predict_proba')\n        model = model.fit(X_train, y_train)\n        S_test_1 = model.predict_proba(X_test)\n        # fit then transform\n        estimators = [('logit', LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr'))]\n        stack = StackingTransformer(estimators, regression=False,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    stratified=True, needs_proba=True,\n                                    verbose=0)\n        stack = stack.fit(X_train, y_train)\n        S_train_2 = stack.transform(X_train)\n        S_test_2 = stack.transform(X_test)\n            \n        # fit_transform\n        # also check refitting already fitted transformer\n        S_train_3 = stack.fit_transform(X_train, y_train)\n        S_test_3 = stack.transform(X_test)\n        \n        # compare\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n        \n", "docstring": "reference"}
{"repo": "vecstack-master/tests/test_sklearn_api_classification_multiclass.py", "original_string": "    def test_variant_B_default_classifier_labels(self):\n        # reference\n        model = DummyClassifier(strategy='constant', constant=1)\n        S_train_1 = cross_val_predict(model, X_train, y=y_train,\n                                      cv=n_folds, n_jobs=1, verbose=0,\n                                      method='predict').reshape(-1, 1)\n        model = model.fit(X_train, y_train)\n        S_test_1 = model.predict(X_test).reshape(-1, 1)\n        # fit then transform\n        stack = StackingTransformer(estimators=None, regression=False,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    verbose=0)\n        stack = stack.fit(X_train, y_train)\n        S_train_2 = stack.transform(X_train)\n        S_test_2 = stack.transform(X_test)\n            \n        # fit_transform\n        # also check refitting already fitted transformer\n        S_train_3 = stack.fit_transform(X_train, y_train)\n        S_test_3 = stack.transform(X_test)\n        \n        # compare\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n        \n", "docstring": "reference"}
{"repo": "vecstack-master/tests/test_sklearn_api_classification_multiclass.py", "original_string": "    def test_variant_B_default_classifier_proba(self):\n        # reference\n        model = DummyClassifier(strategy='constant', constant=1)\n        S_train_1 = cross_val_predict(model, X_train, y=y_train,\n                                      cv=n_folds, n_jobs=1, verbose=0,\n                                      method='predict_proba')\n        model = model.fit(X_train, y_train)\n        S_test_1 = model.predict_proba(X_test)\n        # fit then transform\n        stack = StackingTransformer(estimators=None, regression=False,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    needs_proba=True, verbose=0)\n        stack = stack.fit(X_train, y_train)\n        S_train_2 = stack.transform(X_train)\n        S_test_2 = stack.transform(X_test)\n            \n        # fit_transform\n        # also check refitting already fitted transformer\n        S_train_3 = stack.fit_transform(X_train, y_train)\n        S_test_3 = stack.transform(X_test)\n        \n        # compare\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n        \n", "docstring": "reference"}
{"repo": "vecstack-master/tests/test_func_api_regression.py", "original_string": "    def tearDown(self):\n        # Remove files after each test\n        files = glob.glob(os.path.join(temp_dir, '*.npy'))\n        files.extend(glob.glob(os.path.join(temp_dir, '*.log.txt')))\n        try:\n            for file in files:\n                os.remove(file)\n        except:\n            print('Unable to remove temp file')\n", "docstring": "Remove files after each test"}
{"repo": "vecstack-master/tests/test_func_api_regression.py", "original_string": "    def test_B_mode(self):\n        \"\"\" 'B' is alias for 'oof_pred' \"\"\"\n        model = LinearRegression()\n        S_train_1 = cross_val_predict(model, X_train, y = y_train, cv = n_folds,\n            n_jobs = 1, verbose = 0, method = 'predict').reshape(-1, 1)\n        _ = model.fit(X_train, y_train)\n        S_test_1 = model.predict(X_test).reshape(-1, 1)\n        models = [LinearRegression()]\n        S_train_2, S_test_2 = stacking(models, X_train, y_train, X_test,\n            regression = True, n_folds = n_folds, shuffle = False, save_dir=temp_dir,\n            mode = 'B', random_state = 0, verbose = 0)\n        # Load OOF from file\n        # Normally if cleaning is performed there is only one .npy file at given moment\n        # But if we have no cleaning there may be more then one file so we take the latest\n        file_name = sorted(glob.glob(os.path.join(temp_dir, '*.npy')))[-1] # take the latest file\n        S = np.load(file_name, allow_pickle=True)\n        S_train_3 = S[0]\n        S_test_3 = S[1]\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n", "docstring": "'B' is alias for 'oof_pred' \n"}
{"repo": "vecstack-master/tests/test_func_api_regression.py", "original_string": "    def test_A_mode(self):\n        \"\"\" 'A' is alias for 'oof_pred_bag' \"\"\"\n        S_test_temp = np.zeros((X_test.shape[0], n_folds))\n        kf = KFold(n_splits = n_folds, shuffle = False, random_state = 0)\n        for fold_counter, (tr_index, te_index) in enumerate(kf.split(X_train, y_train)):\n            # Split data and target\n            X_tr = X_train[tr_index]\n            y_tr = y_train[tr_index]\n            X_te = X_train[te_index]\n            y_te = y_train[te_index]\n            model = LinearRegression()\n            _ = model.fit(X_tr, y_tr)\n            S_test_temp[:, fold_counter] = model.predict(X_test)\n        S_test_1 = np.mean(S_test_temp, axis = 1).reshape(-1, 1)\n        model = LinearRegression()\n        S_train_1 = cross_val_predict(model, X_train, y = y_train, cv = n_folds,\n            n_jobs = 1, verbose = 0, method = 'predict').reshape(-1, 1)\n        models = [LinearRegression()]\n        S_train_2, S_test_2 = stacking(models, X_train, y_train, X_test,\n            regression = True, n_folds = n_folds, shuffle = False, save_dir=temp_dir,\n            mode = 'A', random_state = 0, verbose = 0)\n        # Load OOF from file\n        # Normally if cleaning is performed there is only one .npy file at given moment\n        # But if we have no cleaning there may be more then one file so we take the latest\n        file_name = sorted(glob.glob(os.path.join(temp_dir, '*.npy')))[-1] # take the latest file\n        S = np.load(file_name, allow_pickle=True)\n        S_train_3 = S[0]\n        S_test_3 = S[1]\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n", "docstring": "'A' is alias for 'oof_pred_bag' \n"}
{"repo": "vecstack-master/tests/test_func_api_regression.py", "original_string": "    def test_exceptions(self):\n        # Empty model list\n        assert_raises(ValueError, stacking, [], X_train, y_train, X_test)\n        # Wrong mode\n        assert_raises(ValueError, stacking, [LinearRegression()], \n                      X_train, y_train, X_test, mode='abc')\n        # Path does not exist\n        assert_raises(ValueError, stacking, [LinearRegression()], \n                      X_train, y_train, X_test, save_dir='./As26bV85')\n        # n_folds is not int\n        assert_raises(ValueError, stacking, [LinearRegression()], \n                      X_train, y_train, X_test, n_folds='A')\n        # n_folds is less than 2\n        assert_raises(ValueError, stacking, [LinearRegression()], \n                      X_train, y_train, X_test, n_folds=1)\n        # Wrong verbose value\n        assert_raises(ValueError, stacking, [LinearRegression()], \n                      X_train, y_train, X_test, verbose=25)\n                      \n        # Internal function model_action\n        assert_raises(ValueError, model_action, LinearRegression(),\n                      X_train, y_train, X_test, sample_weight=None,\n                      action='abc', transform=None)\n        # X_test is None when mode != 'oof'\n        assert_raises(ValueError, stacking, [LinearRegression()],\n                      X_train, y_train, None, mode='oof_pred_bag')\n                      \n", "docstring": "Empty model list"}
{"repo": "vecstack-master/tests/test_func_api_regression.py", "original_string": "    def test_warnings(self):\n        # Parameters specific for classification are ignored if regression=True\n        assert_warns(UserWarning, stacking, [LinearRegression()], \n                      X_train, y_train, X_test, regression=True, \n                      needs_proba=True)\n                      \n        assert_warns(UserWarning, stacking, [LinearRegression()], \n                      X_train, y_train, X_test, regression=True, \n                      stratified=True)\n                      \n        assert_warns(UserWarning, stacking, [LinearRegression()], \n                      X_train, y_train, X_test, regression=True, \n                      needs_proba=True, stratified=True)\n                      \n", "docstring": "Parameters specific for classification are ignored if regression=True"}
{"repo": "vecstack-master/tests/test_func_api_regression.py", "original_string": "    def test_inconsistent_data(self):\n        # nan or inf in y\n        y_train_nan = y_train.copy()\n        y_train_nan[0] = np.nan\n        assert_raises(ValueError, stacking, [LinearRegression()], \n                      X_train, y_train_nan, X_test)\n                      \n        # y has two or more columns\n        assert_raises(ValueError, stacking, [LinearRegression()], \n                      X_train, np.c_[y_train, y_train], X_test)\n                      \n        # X_train and y_train shape nismatch\n        assert_raises(ValueError, stacking, [LinearRegression()], \n                      X_train, y_train[:10], X_test)\n", "docstring": "nan or inf in y"}
{"repo": "vecstack-master/tests/test_func_api_regression.py", "original_string": "    def test_oof_mode_with_none(self):\n        model = LinearRegression()\n        S_train_1 = cross_val_predict(model, X_train, y = y_train, cv = n_folds,\n            n_jobs = 1, verbose = 0, method = 'predict').reshape(-1, 1)\n        S_test_1 = None\n        models = [LinearRegression()]\n        S_train_2, S_test_2 = stacking(models, X_train, y_train, None,\n            regression = True, n_folds = n_folds, shuffle = False, save_dir=temp_dir,\n            mode = 'oof', random_state = 0, verbose = 0)\n        # Load OOF from file\n        # Normally if cleaning is performed there is only one .npy file at given moment\n        # But if we have no cleaning there may be more then one file so we take the latest\n        file_name = sorted(glob.glob(os.path.join(temp_dir, '*.npy')))[-1] # take the latest file\n        S = np.load(file_name, allow_pickle=True)\n        S_train_3 = S[0]\n        S_test_3 = S[1]\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n", "docstring": "model = LinearRegression()"}
{"repo": "vecstack-master/tests/test_func_api_regression.py", "original_string": "    def test_all_defaults(self):\n        # Override global n_folds=5, because default value in stacking function is 4\n        n_folds=4\n        S_test_temp = np.zeros((X_test.shape[0], n_folds))\n        kf = KFold(n_splits = n_folds, shuffle = False, random_state = 0)\n        for fold_counter, (tr_index, te_index) in enumerate(kf.split(X_train, y_train)):\n            # Split data and target\n            X_tr = X_train[tr_index]\n            y_tr = y_train[tr_index]\n            X_te = X_train[te_index]\n            y_te = y_train[te_index]\n            model = LinearRegression()\n            _ = model.fit(X_tr, y_tr)\n            S_test_temp[:, fold_counter] = model.predict(X_test)\n        S_test_1 = np.mean(S_test_temp, axis = 1).reshape(-1, 1)\n        model = LinearRegression()\n        S_train_1 = cross_val_predict(model, X_train, y = y_train, cv = n_folds,\n            n_jobs = 1, verbose = 0, method = 'predict').reshape(-1, 1)\n        models = [LinearRegression()]\n        S_train_2, S_test_2 = stacking(models, X_train, y_train, X_test, save_dir=temp_dir)\n        # Load OOF from file\n        # Normally if cleaning is performed there is only one .npy file at given moment\n        # But if we have no cleaning there may be more then one file so we take the latest\n        file_name = sorted(glob.glob(os.path.join(temp_dir, '*.npy')))[-1] # take the latest file\n        S = np.load(file_name, allow_pickle=True)\n        S_train_3 = S[0]\n        S_test_3 = S[1]\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n", "docstring": "Override global n_folds=5, because default value in stacking function is 4"}
{"repo": "vecstack-master/tests/test_sklearn_api_classification_binary.py", "original_string": "def roc_auc_score_universal(y_true, y_pred):\n    \"\"\"ROC AUC metric for both binary and multiclass classification.\n    \n    Parameters\n    ----------\n    y_true - 1d numpy array\n        True class labels\n    y_pred - 2d numpy array\n        Predicted probabilities for each class\n    \"\"\"\n    ohe = OneHotEncoder(sparse=False)\n    y_true = ohe.fit_transform(y_true.reshape(-1, 1))\n    #@@@@\n    if len(y_pred.shape) == 1:\n        y_pred = np.c_[y_pred, y_pred]\n        y_pred[:, 0] = 1 - y_pred[:, 1]\n    #@@@@\n    auc_score = roc_auc_score(y_true, y_pred)\n    return auc_score\n", "docstring": "ROC AUC metric for both binary and multiclass classification."}
{"repo": "vecstack-master/tests/test_sklearn_api_classification_binary.py", "original_string": "    def test_variant_B_labels(self):\n        # reference\n        model = LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr')\n        S_train_1 = cross_val_predict(model, X_train, y=y_train,\n                                      cv=n_folds, n_jobs=1, verbose=0,\n                                      method='predict').reshape(-1, 1)\n        model = model.fit(X_train, y_train)\n        S_test_1 = model.predict(X_test).reshape(-1, 1)\n        # fit then transform\n        estimators = [('logit', LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr'))]\n        stack = StackingTransformer(estimators, regression=False,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    stratified=True, verbose=0)\n        stack = stack.fit(X_train, y_train)\n        S_train_2 = stack.transform(X_train)\n        S_test_2 = stack.transform(X_test)\n            \n        # fit_transform\n        # also check refitting already fitted transformer\n        S_train_3 = stack.fit_transform(X_train, y_train)\n        S_test_3 = stack.transform(X_test)\n        \n        # compare\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n        \n", "docstring": "reference"}
{"repo": "vecstack-master/tests/test_sklearn_api_classification_binary.py", "original_string": "    def test_variant_B_proba(self):\n        # reference\n        model = LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr')\n        S_train_1 = cross_val_predict(model, X_train, y=y_train,\n                                      cv=n_folds, n_jobs=1, verbose=0,\n                                      method='predict_proba')\n        model = model.fit(X_train, y_train)\n        S_test_1 = model.predict_proba(X_test)\n        # fit then transform\n        estimators = [('logit', LogisticRegression(random_state=0, solver='liblinear', multi_class='ovr'))]\n        stack = StackingTransformer(estimators, regression=False,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    stratified=True, needs_proba=True,\n                                    verbose=0)\n        stack = stack.fit(X_train, y_train)\n        S_train_2 = stack.transform(X_train)\n        S_test_2 = stack.transform(X_test)\n            \n        # fit_transform\n        # also check refitting already fitted transformer\n        S_train_3 = stack.fit_transform(X_train, y_train)\n        S_test_3 = stack.transform(X_test)\n        \n        # compare\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n        \n", "docstring": "reference"}
{"repo": "vecstack-master/tests/test_sklearn_api_classification_binary.py", "original_string": "    def test_variant_B_default_classifier_labels(self):\n        # reference\n        model = DummyClassifier(strategy='constant', constant=1)\n        S_train_1 = cross_val_predict(model, X_train, y=y_train,\n                                      cv=n_folds, n_jobs=1, verbose=0,\n                                      method='predict').reshape(-1, 1)\n        model = model.fit(X_train, y_train)\n        S_test_1 = model.predict(X_test).reshape(-1, 1)\n        # fit then transform\n        stack = StackingTransformer(estimators=None, regression=False,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    verbose=0)\n        stack = stack.fit(X_train, y_train)\n        S_train_2 = stack.transform(X_train)\n        S_test_2 = stack.transform(X_test)\n            \n        # fit_transform\n        # also check refitting already fitted transformer\n        S_train_3 = stack.fit_transform(X_train, y_train)\n        S_test_3 = stack.transform(X_test)\n        \n        # compare\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n        \n", "docstring": "reference"}
{"repo": "vecstack-master/tests/test_sklearn_api_classification_binary.py", "original_string": "    def test_variant_B_default_classifier_proba(self):\n        # reference\n        model = DummyClassifier(strategy='constant', constant=1)\n        S_train_1 = cross_val_predict(model, X_train, y=y_train,\n                                      cv=n_folds, n_jobs=1, verbose=0,\n                                      method='predict_proba')\n        model = model.fit(X_train, y_train)\n        S_test_1 = model.predict_proba(X_test)\n        # fit then transform\n        stack = StackingTransformer(estimators=None, regression=False,\n                                    n_folds=n_folds, shuffle=False,\n                                    variant='B', random_state=0,\n                                    needs_proba=True, verbose=0)\n        stack = stack.fit(X_train, y_train)\n        S_train_2 = stack.transform(X_train)\n        S_test_2 = stack.transform(X_test)\n            \n        # fit_transform\n        # also check refitting already fitted transformer\n        S_train_3 = stack.fit_transform(X_train, y_train)\n        S_test_3 = stack.transform(X_test)\n        \n        # compare\n        assert_array_equal(S_train_1, S_train_2)\n        assert_array_equal(S_test_1, S_test_2)\n        \n        assert_array_equal(S_train_1, S_train_3)\n        assert_array_equal(S_test_1, S_test_3)\n        \n", "docstring": "reference"}
{"repo": "raytrace-master/rt4.py", "original_string": "def raytrace(O, D, scene, bounce = 0):\n    # O is the ray origin, D is the normalized ray direction\n    # scene is a list of Sphere objects (see below)\n    # bounce is the number of the bounce, starting at zero for camera rays\n    distances = [s.intersect(O, D) for s in scene]\n    nearest = reduce(np.minimum, distances)\n    color = rgb(0, 0, 0)\n    for (s, d) in zip(scene, distances):\n        hit = (nearest != FARAWAY) & (d == nearest)\n        if np.any(hit):\n            dc = extract(hit, d)\n            Oc = O.extract(hit)\n            Dc = D.extract(hit)\n            cc = s.light(Oc, Dc, dc, scene, bounce)\n            color += cc.place(hit)\n    return color\n", "docstring": "O is the ray origin, D is the normalized ray direction"}
{"repo": "raytrace-master/rt2.py", "original_string": "def raytrace(O, D, scene, bounce = 0):\n    # O is the ray origin, D is the normalized ray direction\n    # scene is a list of Sphere objects (see below)\n    # bounce is the number of the bounce, starting at zero for camera rays\n    distances = [s.intersect(O, D) for s in scene]\n    nearest = reduce(np.minimum, distances)\n    color = rgb(0, 0, 0)\n    for (s, d) in zip(scene, distances):\n        color += s.light(O, D, d, scene, bounce) * (nearest != FARAWAY) * (d == nearest)\n    return color\n", "docstring": "O is the ray origin, D is the normalized ray direction"}
{"repo": "raytrace-master/watch.py", "original_string": "def raytrace(O, D, scene, bounce = 0):\n    # O is the ray origin, D is the normalized ray direction\n    # scene is a list of Sphere objects (see below)\n    # bounce is the number of the bounce, starting at zero for camera rays\n    distances = [s.intersect(O, D) for s in scene]\n    nearest = reduce(np.minimum, distances)\n    color = rgb(0, 0, 0)\n    for (s, d) in zip(scene, distances):\n        cc = s.light(O, D, d, scene, bounce) * (nearest != FARAWAY) * (d == nearest)\n        color += cc\n        _rgb = [Image.fromarray((255 * np.clip(c, 0, 1).reshape((h, w))).astype(np.uint8), \"L\") for c in cc.components()]\n        global gen\n        Image.merge(\"RGB\", _rgb).save(\"p%02d.png\" % gen)\n        gen += 1\n    return color\n", "docstring": "O is the ray origin, D is the normalized ray direction"}
{"repo": "raytrace-master/rt3.py", "original_string": "def raytrace(O, D, scene, bounce = 0):\n    # O is the ray origin, D is the normalized ray direction\n    # scene is a list of Sphere objects (see below)\n    # bounce is the number of the bounce, starting at zero for camera rays\n    distances = [s.intersect(O, D) for s in scene]\n    nearest = reduce(np.minimum, distances)\n    color = rgb(0, 0, 0)\n    for (s, d) in zip(scene, distances):\n        hit = (nearest != FARAWAY) & (d == nearest)\n        if np.any(hit):\n            dc = extract(hit, d)\n            Oc = O.extract(hit)\n            Dc = D.extract(hit)\n            cc = s.light(Oc, Dc, dc, scene, bounce)\n            color += cc.place(hit)\n    return color\n", "docstring": "O is the ray origin, D is the normalized ray direction"}
{"repo": "raytrace-master/raytracing.py", "original_string": "def intersect_sphere(O, D, S, R):\n    # Return the distance from O to the intersection of the ray (O, D) with the \n    # sphere (S, R), or +inf if there is no intersection.\n    # O and S are 3D points, D (direction) is a normalized vector, R is a scalar.\n    a = np.dot(D, D)\n    OS = O - S\n    b = 2 * np.dot(D, OS)\n    c = np.dot(OS, OS) - R * R\n    disc = b * b - 4 * a * c\n    if disc > 0:\n        distSqrt = np.sqrt(disc)\n        q = (-b - distSqrt) / 2.0 if b < 0 else (-b + distSqrt) / 2.0\n        t0 = q / a\n        t1 = c / q\n        t0, t1 = min(t0, t1), max(t0, t1)\n        if t1 >= 0:\n            return t1 if t0 < 0 else t0\n    return np.inf\n", "docstring": "Return the distance from O to the intersection of the ray (O, D) with the"}
{"repo": "raytrace-master/raytracing.py", "original_string": "def get_normal(obj, M):\n    # Find normal.\n    if obj['type'] == 'sphere':\n        N = normalize(M - obj['position'])\n    elif obj['type'] == 'plane':\n        N = obj['normal']\n    return N\n    \n", "docstring": "Find normal."}
{"repo": "raytrace-master/raytracing.py", "original_string": "def trace_ray(rayO, rayD):\n    # Find first point of intersection with the scene.\n    t = np.inf\n    for i, obj in enumerate(scene):\n        t_obj = intersect(rayO, rayD, obj)\n        if t_obj < t:\n            t, obj_idx = t_obj, i\n    # Return None if the ray does not intersect any object.\n    if t == np.inf:\n        return\n    # Find the object.\n    obj = scene[obj_idx]\n    # Find the point of intersection on the object.\n    M = rayO + rayD * t\n    # Find properties of the object.\n    N = get_normal(obj, M)\n    color = get_color(obj, M)\n    toL = normalize(L - M)\n    toO = normalize(O - M)\n    # Shadow: find if the point is shadowed or not.\n    l = [intersect(M + N * .0001, toL, obj_sh) \n            for k, obj_sh in enumerate(scene) if k != obj_idx]\n    if l and min(l) < np.inf:\n        return\n    # Start computing the color.\n    col_ray = ambient\n    # Lambert shading (diffuse).\n    col_ray += obj.get('diffuse_c', diffuse_c) * max(np.dot(N, toL), 0) * color\n    # Blinn-Phong shading (specular).\n    col_ray += obj.get('specular_c', specular_c) * max(np.dot(N, normalize(toL + toO)), 0) ** specular_k * color_light\n    return obj, M, N, col_ray\n", "docstring": "Find first point of intersection with the scene."}
{"repo": "raytrace-master/gauss.py", "original_string": "    def norm(v):\n        # v -= min(v)\n        v /= max(v)\n        return v\n", "docstring": "v -= min(v)"}
{"repo": "Chatistics-master/export.py", "original_string": "def main():\n    \"\"\"Simple method to export message logs to either stdout or to a file\"\"\"\n    def get_f_name(compressed):\n        ts = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')\n        f_path = os.path.join('exports', f'chatistics_export_{ts}.{args.format}')\n        if compressed:\n            f_path += '.zip'\n        return f_path\n    parser = ArgParseDefault(description='Export parsed chatlog data')\n    parser = add_load_data_args(parser)\n    parser.add_argument('-n', '--num-rows', dest='num_rows', type=int,\n                        default=50, help='Print first n rows (use negative for last rows) (only used if output format is stdout)')\n    parser.add_argument('-c', '--cols', dest='cols', nargs='+',\n                        default=['timestamp', 'conversationWithName', 'senderName', 'outgoing', 'text', 'language', 'platform'],\n                        help='Only show specific columns (only used if output format is stdout)')\n    parser.add_argument('-f', '--format', dest='format', default='stdout', choices=['stdout', 'json', 'csv', 'pkl'], help='Output format')\n    parser.add_argument('--compress', action='store_true', help='Compress the output (only used for json and csv formats)')\n    args = parser.parse_args()\n    df = load_data(args)\n    if args.format == 'stdout':\n        # Print data to stdout\n        df = df.iloc[:args.num_rows]\n        df.loc[:, 'timestamp'] = pd.to_datetime(df.timestamp, unit='s')\n        pd.set_option('display.max_colwidth', 100)\n        with pd.option_context('display.max_rows', 1000, 'display.width', -1):\n            print(df[args.cols].to_string(index=False))\n    else:\n        # Exporting data to a file\n        f_name = get_f_name(args.compress)\n        log.info(f'Exporting data to file {f_name}')\n        compression = 'zip' if args.compress else None\n        if args.format == 'json':\n            df.to_json(f_name, orient='records', compression=compression)\n        elif args.format == 'csv':\n            df.to_csv(f_name, index=False, compression=compression)\n        elif args.format == 'pkl':\n            with open(f_name, 'wb', encoding=\"utf8\") as f:\n                pickle.dump(df, f)\n        else:\n            raise Exception(f'Format {args.format} is not supported.')\n", "docstring": "Simple method to export message logs to either stdout or to a file\n"}
{"repo": "Chatistics-master/parsers/messenger.py", "original_string": "def fix_text_encoding(text):\n    \"\"\"Fixes text encoding, see https://stackoverflow.com/questions/50008296/facebook-json-badly-encoded\"\"\"\n    return text.encode('latin1').decode('utf8')\n", "docstring": "Fixes text encoding, see https://stackoverflow.com/questions/50008296/facebook-json-badly-encoded\n"}
{"repo": "Chatistics-master/visualizers/breakdown.py", "original_string": "def render_barplot(df, args):\n    # create figure\n    sns.set()\n    fig, ax = plt.subplots(1, 1, figsize=(20, 10))\n    df['timestamp'] = pd.to_datetime(df.timestamp, unit='s')\n    df['count'] = 0\n    df = df.set_index('timestamp')\n    df = df.groupby('conversationWithName').resample(args.bin_size).count()['count']\n    df = df.unstack(fill_value=0).T\n    df = df.reset_index()\n    df = df.set_index('timestamp')\n    df.plot(kind='bar', stacked=True, ax=ax)\n    # Axis labels\n    ax.set_xlabel('')\n    ax.set_ylabel('Messages per month')\n    # Legend\n    ax.legend(loc='center left', bbox_to_anchor=(1, .5))\n    # Make most of the ticklabels empty so the labels don't get too crowded\n    ticklabels = [''] * len(df.index)\n    # Every 4th ticklable shows the month and day\n    ticklabels[::4] = [item.strftime('%b') for item in df.index[::4]]\n    # Every 12th ticklabel includes the year\n    ticklabels[::12] = [item.strftime('%b %Y') for item in df.index[::12]]\n    ax.xaxis.set_major_formatter(ticker.FixedFormatter(ticklabels))\n    plt.gcf().autofmt_xdate()\n    plt.tight_layout()\n    save_fig(fig, 'breakdown')\n", "docstring": "create figure"}
{"repo": "Chatistics-master/visualizers/utils.py", "original_string": "def save_fig(fig, name, output_formats=('png',), dpi=300):\n    \"\"\"Save figure with timestamps\"\"\"\n    date = time.strftime('%Y%m%d')\n    ts = int(time.time() * 1000)\n    for fmt in output_formats:\n        save_name = os.path.join('plots', f'{name}_{ts}.{fmt}')\n        log.info(f'Saving figure as {save_name}')\n        fig.savefig(save_name, dpi=dpi)\n", "docstring": "Save figure with timestamps\n"}
{"repo": "Chatistics-master/visualizers/cloud.py", "original_string": "def main(args):\n    # load data\n    df = load_data(args)\n    # load stopwords\n    stopwords = get_stopwords(args.stopword_paths)\n    # clean up data\n    text = cleanup_text(df['text'], stopwords)\n    # render word cloud\n    render_wordcloud(args, text)\n", "docstring": "load data"}
{"repo": "AlphaPy-master/alphapy/portfolio.py", "original_string": "    def __new__(cls,\n                group_name,\n                tag,\n                space = Space(),\n                maxpos = 10,\n                posby = 'close',\n                kopos = 0,\n                koby = '-profit',\n                restricted = False,\n                weightby = 'quantity',\n                startcap = 100000,\n                margin = 0.5,\n                mincash = 0.2,\n                fixedfrac = 0.1,\n                maxloss = 0.1):\n        # create portfolio name\n        pn = portfolio_name(group_name, tag)\n        if not pn in Portfolio.portfolios:\n            return super(Portfolio, cls).__new__(cls)\n        else:\n            logger.info(\"Portfolio %s already exists\", pn)\n", "docstring": "group_name,"}
{"repo": "PyHDB-master/pyhdb/connection.py", "original_string": "    def connect(self):\n        with self._socket_lock:\n            if self._socket is not None:\n                # Socket already established\n                return\n            self._open_socket_and_init_protocoll()\n            # Perform the authenication handshake and get the part\n            # with the agreed authentication data\n            agreed_auth_part = self._auth_manager.perform_handshake()\n            request = RequestMessage.new(\n                self,\n                RequestSegment(\n                    message_types.CONNECT,\n                    (\n                        agreed_auth_part,\n                        ClientId(\n                            \"pyhdb-%s@%s\" % (os.getpid(), socket.getfqdn())\n                        ),\n                        ConnectOptions(DEFAULT_CONNECTION_OPTIONS)\n                    )\n                )\n            )\n            self.send_request(request)\n", "docstring": "with self._socket_lock:"}
{"repo": "PyHDB-master/pyhdb/connection.py", "original_string": "    def cursor(self):\n        \"\"\"Return a new Cursor Object using the connection.\"\"\"\n        self._check_closed()\n        return Cursor(self)\n", "docstring": "Return a new Cursor Object using the connection.\n"}
{"repo": "PyHDB-master/pyhdb/cursor.py", "original_string": "    def __init__(self, connection, statement_id, params_metadata, result_metadata_part):\n        \"\"\"Initialize PreparedStatement part object\n        :param connection: connection object\n        :param statement_id: 8-byte statement identifier\n        :param params_metadata: A tuple of named-tuple instances containing parameter meta data:\n               Example: (ParameterMetadata(options=2, datatype=26, mode=1, id=0, length=24, fraction=0),)\n        :param result_metadata_part: can be None\n        \"\"\"\n        self._connection = connection\n        self.statement_id = statement_id\n        self._params_metadata = params_metadata\n        self.result_metadata_part = result_metadata_part\n        self._multi_row_parameters = None\n        self._num_rows = None\n        self._iter_row_count = None\n", "docstring": "Initialize PreparedStatement part object"}
{"repo": "PyHDB-master/pyhdb/cursor.py", "original_string": "    def prepare(self, statement):\n        \"\"\"Prepare SQL statement in HANA and cache it\n        :param statement; a valid SQL statement\n        :returns: statement_id (of prepared and cached statement)\n        \"\"\"\n        self._check_closed()\n        self._column_types = None\n        statement_id = params_metadata = result_metadata_part = None\n        request = RequestMessage.new(\n            self.connection,\n            RequestSegment(\n                message_types.PREPARE,\n                Command(statement)\n            )\n        )\n        response = self.connection.send_request(request)\n        for part in response.segments[0].parts:\n            if part.kind == part_kinds.STATEMENTID:\n                statement_id = part.statement_id\n            elif part.kind == part_kinds.PARAMETERMETADATA:\n                params_metadata = part.values\n            elif part.kind == part_kinds.RESULTSETMETADATA:\n                result_metadata_part = part\n        # Check that both variables have been set in previous loop, we need them:\n        assert statement_id is not None\n        assert params_metadata is not None\n        # cache statement:\n        self._prepared_statements[statement_id] = PreparedStatement(self.connection, statement_id,\n                                                                    params_metadata, result_metadata_part)\n        return statement_id\n", "docstring": "Prepare SQL statement in HANA and cache it"}
{"repo": "PyHDB-master/pyhdb/cursor.py", "original_string": "    def _execute_direct(self, operation):\n        \"\"\"Execute statements which are not going through 'prepare_statement' (aka 'direct execution').\n        Either their have no parameters, or Python's string expansion has been applied to the SQL statement.\n        :param operation:\n        \"\"\"\n        request = RequestMessage.new(\n            self.connection,\n            RequestSegment(\n                message_types.EXECUTEDIRECT,\n                Command(operation)\n            )\n        )\n        reply = self.connection.send_request(request)\n        parts = reply.segments[0].parts\n        function_code = reply.segments[0].function_code\n        if function_code == function_codes.SELECT:\n            self._handle_select(parts)\n        elif function_code in function_codes.DML:\n            self._handle_upsert(parts)\n        elif function_code == function_codes.DDL:\n            # No additional handling is required\n            pass\n        elif function_code in (function_codes.DBPROCEDURECALL, function_codes.DBPROCEDURECALLWITHRESULT):\n            self._handle_dbproc_call(parts, None)\n        else:\n            raise InterfaceError(\"Invalid or unsupported function code received: %d\" % function_code)\n", "docstring": "Execute statements which are not going through 'prepare_statement' (aka 'direct execution')."}
{"repo": "PyHDB-master/pyhdb/cursor.py", "original_string": "    def executemany(self, statement, parameters):\n        \"\"\"Execute statement on database with multiple rows to be inserted/updated\n        :param statement: a valid SQL statement\n        :param parameters: a nested list/tuple of parameters for multiple rows\n        :returns: this cursor\n        \"\"\"\n        # First try safer hana-style parameter expansion:\n        try:\n            statement_id = self.prepare(statement)\n        except DatabaseError as msg:\n            # Hana expansion failed, check message to be sure of reason:\n            if 'incorrect syntax near \"%\"' not in str(msg):\n                # Probably some other error than related to string expansion -> raise an error\n                raise\n            # Statement contained percentage char, so perform Python style parameter expansion:\n            for row_params in parameters:\n                operation = format_operation(statement, row_params)\n                self._execute_direct(operation)\n        else:\n            # Continue with Hana style statement execution:\n            prepared_statement = self.get_prepared_statement(statement_id)\n            self.execute_prepared(prepared_statement, parameters)\n        # Return cursor object:\n        return self\n", "docstring": "Execute statement on database with multiple rows to be inserted/updated"}
{"repo": "PyHDB-master/pyhdb/cursor.py", "original_string": "    def _perform_lob_write_requests(self, unwritten_lobs):\n        \"\"\"After sending incomplete LOB data during an INSERT or UPDATE this method will be called.\n        It sends missing LOB data possibly in multiple LOBWRITE requests for all LOBs.\n        :param unwritten_lobs: A deque list of LobBuffer instances containing LOB data.\n               Those buffers have been assembled in the parts.Parameter.pack_lob_data() method.\n        \"\"\"\n        while unwritten_lobs:\n            request = RequestMessage.new(\n                self.connection,\n                RequestSegment(\n                    message_types.WRITELOB,\n                    WriteLobRequest(unwritten_lobs)\n                )\n            )\n            self.connection.send_request(request)\n", "docstring": "After sending incomplete LOB data during an INSERT or UPDATE this method will be called."}
{"repo": "PyHDB-master/pyhdb/cursor.py", "original_string": "    def _handle_dbproc_call(self, parts, parameters_metadata):\n        \"\"\"Handle reply messages from STORED PROCEDURE statements\"\"\"\n        for part in parts:\n            if part.kind == part_kinds.ROWSAFFECTED:\n                self.rowcount = part.values[0]\n            elif part.kind == part_kinds.TRANSACTIONFLAGS:\n                pass\n            elif part.kind == part_kinds.STATEMENTCONTEXT:\n                pass\n            elif part.kind == part_kinds.OUTPUTPARAMETERS:\n                self._buffer = part.unpack_rows(parameters_metadata, self.connection)\n                self._received_last_resultset_part = True\n                self._executed = True\n            elif part.kind == part_kinds.RESULTSETMETADATA:\n                self.description, self._column_types = self._handle_result_metadata(part)\n            elif part.kind == part_kinds.RESULTSETID:\n                self._resultset_id = part.value\n            elif part.kind == part_kinds.RESULTSET:\n                self._buffer = part.unpack_rows(self._column_types, self.connection)\n                self._received_last_resultset_part = part.attribute & 1\n                self._executed = True\n            else:\n                raise InterfaceError(\"Stored procedure call, unexpected part kind %d.\" % part.kind)\n        self._executed = True\n", "docstring": "Handle reply messages from STORED PROCEDURE statements\n"}
{"repo": "PyHDB-master/pyhdb/cursor.py", "original_string": "    def fetchmany(self, size=None):\n        \"\"\"Fetch many rows from select result set.\n        :param size: Number of rows to return.\n        :returns: list of row records (tuples)\n        \"\"\"\n        self._check_closed()\n        if not self._executed:\n            raise ProgrammingError(\"Require execute() first\")\n        if size is None:\n            size = self.arraysize\n        result = []\n        cnt = 0\n        while cnt != size:\n            try:\n                result.append(next(self._buffer))\n                cnt += 1\n            except StopIteration:\n                break\n        if cnt == size or self._received_last_resultset_part:\n            # No rows are missing or there are no additional rows\n            return result\n        request = RequestMessage.new(\n            self.connection,\n            RequestSegment(\n                message_types.FETCHNEXT,\n                (ResultSetId(self._resultset_id), FetchSize(size - cnt))\n            )\n        )\n        response = self.connection.send_request(request)\n        resultset_part = response.segments[0].parts[1]\n        if resultset_part.attribute & 1:\n            self._received_last_resultset_part = True\n        result.extend(resultset_part.unpack_rows(self._column_types, self.connection))\n        return result\n", "docstring": "Fetch many rows from select result set."}
{"repo": "PyHDB-master/pyhdb/cursor.py", "original_string": "    def fetchall(self):\n        \"\"\"Fetch all available rows from select result set.\n        :returns: list of row tuples\n        \"\"\"\n        result = r = self.fetchmany(size=self.FETCHALL_BLOCKSIZE)\n        while len(r) == self.FETCHALL_BLOCKSIZE or not self._received_last_resultset_part:\n            r = self.fetchmany(size=self.FETCHALL_BLOCKSIZE)\n            result.extend(r)\n        return result\n", "docstring": "Fetch all available rows from select result set."}
{"repo": "PyHDB-master/pyhdb/protocol/headers.py", "original_string": "    def __init__(self, payload):\n        \"\"\"Parse LOB header from payload\"\"\"\n        raw_header_p1 = payload.read(self.header_struct_part1.size)\n        self.lob_type, self.options = self.header_struct_part1.unpack(raw_header_p1)\n        if not self.isnull():\n            raw_header_p2 = payload.read(self.header_struct_part2.size)\n            header = self.header_struct_part2.unpack(raw_header_p2)\n            (reserved, self.char_length, self.byte_length, self.locator_id, self.chunk_length) = header\n            # Set total_lob_length attribute differently for binary and character lobs:\n            self.total_lob_length = self.byte_length if self.lob_type == self.BLOB_TYPE else self.char_length\n", "docstring": "Parse LOB header from payload\n"}
{"repo": "PyHDB-master/pyhdb/protocol/parts.py", "original_string": "    def pack(self, remaining_size):\n        \"\"\"Pack data of part into binary format\"\"\"\n        arguments_count, payload = self.pack_data(remaining_size - self.header_size)\n        payload_length = len(payload)\n        # align payload length to multiple of 8\n        if payload_length % 8 != 0:\n            payload += b\"\\x00\" * (8 - payload_length % 8)\n        self.header = PartHeader(self.kind, self.attribute, arguments_count, self.bigargumentcount,\n                                 payload_length, remaining_size)\n        hdr = self.header_struct.pack(*self.header)\n        if pyhdb.tracing:\n            self.trace_header = humanhexlify(hdr, 30)\n            self.trace_payload = humanhexlify(payload, 30)\n        return hdr + payload\n", "docstring": "Pack data of part into binary format\n"}
{"repo": "PyHDB-master/pyhdb/protocol/parts.py", "original_string": "    def unpack_from(cls, payload, expected_parts):\n        \"\"\"Unpack parts from payload\"\"\"\n        for num_part in iter_range(expected_parts):\n            hdr = payload.read(cls.header_size)\n            try:\n                part_header = PartHeader(*cls.header_struct.unpack(hdr))\n            except struct.error:\n                raise InterfaceError(\"No valid part header\")\n            if part_header.payload_size % 8 != 0:\n                part_payload_size = part_header.payload_size + 8 - (part_header.payload_size % 8)\n            else:\n                part_payload_size = part_header.payload_size\n            pl = payload.read(part_payload_size)\n            part_payload = io.BytesIO(pl)\n            try:\n                _PartClass = PART_MAPPING[part_header.part_kind]\n            except KeyError:\n                raise InterfaceError(\"Unknown part kind %s\" % part_header.part_kind)\n            debug('%s (%d/%d): %s', _PartClass.__name__, num_part+1, expected_parts, str(part_header))\n            debug('Read %d bytes payload for part %d', part_payload_size, num_part + 1)\n            init_arguments = _PartClass.unpack_data(part_header.argument_count, part_payload)\n            debug('Part data: %s', init_arguments)\n            part = _PartClass(*init_arguments)\n            part.header = part_header\n            part.attribute = part_header.part_attributes\n            part.source = 'server'\n            if pyhdb.tracing:\n                part.trace_header = humanhexlify(hdr[:part_header.payload_size])\n                part.trace_payload = humanhexlify(pl, 30)\n            yield part\n", "docstring": "Unpack parts from payload\n"}
{"repo": "PyHDB-master/pyhdb/protocol/parts.py", "original_string": "    def pack_data(self, max_payload_size):\n        offset = 0  # a value of zero means: append lob data to existing LOB data in DB\n        num_lobs = 0\n        max_payload_size -= self.part_struct.size  # reduce by struct header size to simply math below\n        payload = io.BytesIO()\n        while payload.tell() < max_payload_size and self.lob_buffers:\n            lb = self.lob_buffers.popleft()\n            remaining_payload_size = max_payload_size - payload.tell()\n            num_bytes_to_write = min(lb.num_bytes_to_write, remaining_payload_size)\n            lob_options = WriteLobHeader.LOB_OPTION_DATAINCLUDED\n            if num_bytes_to_write == lb.num_bytes_to_write:\n                # i.e. the entire (rest of the) LOB will be written, so set LASTDATA flag:\n                lob_options |= WriteLobHeader.LOB_OPTION_LASTDATA\n            payload.write(self.part_struct.pack(lb.locator_id, lob_options, offset, num_bytes_to_write))\n            payload.write(lb.encoded_data.read(num_bytes_to_write))\n            num_lobs += 1\n        # Since loop above was run at least once both 'lob_options' and 'lb' will be defined\n        if not lob_options & WriteLobHeader.LOB_OPTION_LASTDATA:\n            # last lob object was not written entirely -> put it back into lob_buffers for next round of writing:\n            self.lob_buffers.appendleft(lb)\n        return num_lobs, payload.getvalue()\n", "docstring": "offset = 0  # a value of zero means: append lob data to existing LOB data in DB"}
{"repo": "PyHDB-master/pyhdb/protocol/parts.py", "original_string": "    def unpack_data(cls, argument_count, payload):\n        \"\"\"Unpack payload by splitting up the raw payload into list of locator_ids\n        :param argument_count: number of locator_ids in payload is equal to argument_count\n        :param payload: BytesIO instance with list of concatenated locator_ids, where each locator_id is 8 bytes long\n        \"\"\"\n        pl = payload.read()\n        locator_ids = [pl[start:start+8] for start in range(0, len(pl), 8)]\n        return locator_ids,\n", "docstring": "Unpack payload by splitting up the raw payload into list of locator_ids"}
{"repo": "PyHDB-master/pyhdb/protocol/parts.py", "original_string": "    def num_bytes_to_write(self):\n        \"\"\"Return number of bytes of lobs which still have to be written\"\"\"\n        return self.encoded_lob_size - self.encoded_data.tell()\n", "docstring": "Return number of bytes of lobs which still have to be written\n"}
{"repo": "PyHDB-master/pyhdb/protocol/parts.py", "original_string": "    def __init__(self, parameters):\n        \"\"\"Initialize parameter part\n        :param parameters: A generator producing lists (1 per row) of named tuples containing parameter meta\n                          data and values (usually an instance of class 'cursor.PreparedStatement')\n               Example: [Parameter(id=0, datatype=9, length=255, value='row2'), Parameter(id=1, ...), ]\n        :returns: tuple (arguments_count, payload)\n        \"\"\"\n        self.parameters = parameters\n        self.unwritten_lobs = []\n", "docstring": "Initialize parameter part"}
{"repo": "PyHDB-master/pyhdb/protocol/parts.py", "original_string": "    def __init__(self, user, methods):\n        self.user = user\n        self.methods = methods\n", "docstring": "self.user = user"}
{"repo": "PyHDB-master/pyhdb/protocol/lobs.py", "original_string": "    def CLOB_STRING_IO(init_value):\n        # factory function to obtain a read-writable StringIO object\n        # (not possible when directly instantiated with initial value ...)\n        c = cStringIO.StringIO()\n        c.write(init_value)\n        c.seek(0)\n        return c\n", "docstring": "factory function to obtain a read-writable StringIO object"}
{"repo": "PyHDB-master/pyhdb/protocol/lobs.py", "original_string": "def from_payload(type_code, payload, connection):\n    \"\"\"Generator function to create lob from payload.\n    Depending on lob type a BLOB, CLOB, or NCLOB instance will be returned.\n    This function is usually called from types.*LobType.from_resultset()\n    \"\"\"\n    lob_header = ReadLobHeader(payload)\n    if lob_header.isnull():\n        lob = None\n    else:\n        data = payload.read(lob_header.chunk_length)\n        _LobClass = LOB_TYPE_CODE_MAP[type_code]\n        lob = _LobClass.from_payload(data, lob_header, connection)\n        logger.debug('Lob Header %r' % lob)\n    return lob\n", "docstring": "Generator function to create lob from payload."}
{"repo": "PyHDB-master/pyhdb/protocol/lobs.py", "original_string": "    def length(self):\n        \"\"\"Return total length of a lob.\n        If a lob was received from the database the length denotes the final absolute length of the lob even if\n        not all data has yet been read from the database.\n        For a lob constructed from local data length represents the amount of data currently stored in it.\n        \"\"\"\n        if self._lob_header:\n            return self._lob_header.total_lob_length\n        else:\n            return self._current_lob_length\n", "docstring": "Return total length of a lob."}
{"repo": "PyHDB-master/pyhdb/protocol/lobs.py", "original_string": "    def seek(self, offset, whence=SEEK_SET):\n        \"\"\"Seek pointer in lob data buffer to requested position.\n        Might trigger further loading of data from the database if the pointer is beyond currently read data.\n        \"\"\"\n        # A nice trick is to (ab)use BytesIO.seek() to go to the desired position for easier calculation.\n        # This will not add any data to the buffer however - very convenient!\n        self.data.seek(offset, whence)\n        new_pos = self.data.tell()\n        missing_bytes_to_read = new_pos - self._current_lob_length\n        if missing_bytes_to_read > 0:\n            # Trying to seek beyond currently available LOB data, so need to load some more first.\n            # We are smart here: (at least trying...):\n            #         If a user sets a certain file position s/he probably wants to read data from\n            #         there. So already read some extra data to avoid yet another immediate\n            #         reading step. Try with EXTRA_NUM_ITEMS_TO_READ_AFTER_SEEK additional items (bytes/chars).\n            # jump to the end of the current buffer and read the new data:\n            self.data.seek(0, SEEK_END)\n            self.read(missing_bytes_to_read + self.EXTRA_NUM_ITEMS_TO_READ_AFTER_SEEK)\n            # reposition file pointer a originally desired position:\n            self.data.seek(new_pos)\n        return new_pos\n", "docstring": "Seek pointer in lob data buffer to requested position."}
{"repo": "PyHDB-master/pyhdb/protocol/lobs.py", "original_string": "    def _read_missing_lob_data_from_db(self, readoffset, readlength):\n        \"\"\"Read LOB request part from database\"\"\"\n        logger.debug('Reading missing lob data from db. Offset: %d, readlength: %d' % (readoffset, readlength))\n        lob_data = self._make_read_lob_request(readoffset, readlength)\n        # make sure we really got as many items (not bytes!) as requested:\n        enc_lob_data = self._decode_lob_data(lob_data)\n        assert readlength == len(enc_lob_data), 'expected: %d, received; %d' % (readlength, len(enc_lob_data))\n        # jump to end of data, and append new and properly decoded data to it:\n        # import pdb;pdb.set_trace()\n        self.data.seek(0, SEEK_END)\n        self.data.write(enc_lob_data)\n        self._current_lob_length = len(self.data.getvalue())\n", "docstring": "Read LOB request part from database\n"}
{"repo": "PyHDB-master/pyhdb/protocol/lobs.py", "original_string": "    def getvalue(self):\n        \"\"\"Return all currently available lob data (might be shorter than the one in the database)\"\"\"\n        return self.data.getvalue()\n", "docstring": "Return all currently available lob data (might be shorter than the one in the database)\n"}
{"repo": "PyHDB-master/pyhdb/protocol/lobs.py", "original_string": "    def __unicode__(self):\n        \"\"\"Convert lob into its unicode format\"\"\"\n        return self.data.getvalue().decode(self.encoding)\n", "docstring": "Convert lob into its unicode format\n"}
{"repo": "PyHDB-master/pyhdb/protocol/lobs.py", "original_string": "    def __unicode__(self):\n        \"\"\"Convert lob into its unicode format\"\"\"\n        return self.data.getvalue()\n", "docstring": "Convert lob into its unicode format\n"}
{"repo": "PyHDB-master/pyhdb/protocol/message.py", "original_string": "    def build_payload(self, payload):\n        \"\"\" Build payload of message. \"\"\"\n        for segment in self.segments:\n            segment.pack(payload, commit=self.autocommit)\n", "docstring": "Build payload of message. \n"}
{"repo": "PyHDB-master/pyhdb/protocol/message.py", "original_string": "    def new(cls, connection, segments=()):\n        \"\"\"Return a new request message instance - extracts required data from connection object\n        :param connection: connection object\n        :param segments: a single segment instance, or a list/tuple of segment instances\n        :returns: RequestMessage instance\n        \"\"\"\n        return cls(connection.session_id, connection.get_next_packet_count(), segments,\n                   autocommit=connection.autocommit)\n", "docstring": "Return a new request message instance - extracts required data from connection object"}
{"repo": "PyHDB-master/pyhdb/protocol/message.py", "original_string": "    def unpack_reply(cls, header, payload):\n        \"\"\"Take already unpacked header and binary payload of received request reply and creates message instance\n        :param header: a namedtuple header object providing header information\n        :param payload: payload (BytesIO instance) of message\n        \"\"\"\n        reply = cls(\n            header.session_id, header.packet_count,\n            segments=tuple(ReplySegment.unpack_from(payload, expected_segments=header.num_segments)),\n            header=header\n        )\n        trace(reply)\n        return reply\n", "docstring": "Take already unpacked header and binary payload of received request reply and creates message instance"}
{"repo": "PyHDB-master/pyhdb/protocol/segments.py", "original_string": "    def pack(self, payload, **kwargs):\n        # remember position in payload object:\n        segment_payload_start_pos = payload.tell()\n        # Advance num bytes equal to header size. The header is written later\n        # after the payload of all segments and parts has been written:\n        payload.seek(self.header_size, io.SEEK_CUR)\n        # Generate payload of parts:\n        self.build_payload(payload)\n        segment_length = payload.tell() - segment_payload_start_pos  # calc length of parts payload\n        self.header = RequestSegmentHeader(segment_length, self.offset, len(self.parts), self.number, self.segment_kind,\n                                           self.message_type, int(kwargs.get('commit', 0)), self.command_options)\n        packed_header = self.header_struct.pack(*self.header)\n        # Go back to beginning of payload header for writing segment header:\n        payload.seek(segment_payload_start_pos)\n        payload.write(packed_header)\n        # Put file pointer at the end of the bffer so that next segment can be appended:\n        payload.seek(0, io.SEEK_END)\n", "docstring": "remember position in payload object:"}
{"repo": "PyHDB-master/pyhdb/protocol/types.py", "original_string": "    def prepare(cls, type_code):\n        \"\"\"Prepare a binary NULL value for given type code\"\"\"\n        # This is achieved by setting the MSB of the type_code byte to 1\n        return struct.pack('<B', type_code | 0x80)\n", "docstring": "Prepare a binary NULL value for given type code\n"}
{"repo": "PyHDB-master/pyhdb/protocol/types.py", "original_string": "    def prepare(cls, value):\n        \"\"\"Pack datetime value into proper binary format\"\"\"\n        pfield = struct.pack('b', cls.type_code)\n        if isinstance(value, string_types):\n            value = datetime.datetime.strptime(value, \"%Y-%m-%d\")\n        year = value.year | 0x8000  # for some unknown reasons year has to be bit-or'ed with 0x8000\n        month = value.month - 1     # for some unknown reasons HANA counts months starting from zero\n        pfield += cls._struct.pack(year, month, value.day)\n        return pfield\n", "docstring": "Pack datetime value into proper binary format\n"}
{"repo": "PyHDB-master/pyhdb/protocol/types.py", "original_string": "    def from_resultset(cls, payload, connection=None):\n        hour, minute, millisec = cls._struct.unpack(payload.read(4))\n        if not hour & 0x80:\n            return None\n        hour = hour & 0x7f\n        second, millisec = divmod(millisec, 1000)\n        return cls.python_type(hour, minute, second, millisec * 1000)\n", "docstring": "hour, minute, millisec = cls._struct.unpack(payload.read(4))"}
{"repo": "PyHDB-master/pyhdb/protocol/types.py", "original_string": "    def prepare(cls, value):\n        \"\"\"Pack time value into proper binary format\"\"\"\n        pfield = struct.pack('b', cls.type_code)\n        if isinstance(value, string_types):\n            if \".\" in value:\n                value = datetime.datetime.strptime(value, \"%H:%M:%S.%f\")\n            else:\n                value = datetime.datetime.strptime(value, \"%H:%M:%S\")\n        millisecond = value.second * 1000 + value.microsecond // 1000\n        hour = value.hour | 0x80    # for some unknown reasons hour has to be bit-or'ed with 0x80\n        pfield += cls._struct.pack(hour, value.minute, millisecond)\n        return pfield\n", "docstring": "Pack time value into proper binary format\n"}
{"repo": "PyHDB-master/pyhdb/protocol/types.py", "original_string": "    def prepare(cls, value):\n        \"\"\"Pack datetime value into proper binary format\"\"\"\n        pfield = struct.pack('b', cls.type_code)\n        if isinstance(value, string_types):\n            if \".\" in value:\n                value = datetime.datetime.strptime(value, \"%Y-%m-%d %H:%M:%S.%f\")\n            else:\n                value = datetime.datetime.strptime(value, \"%Y-%m-%d %H:%M:%S\")\n        millisecond = value.second * 1000 + value.microsecond // 1000\n        year = value.year | 0x8000  # for some unknown reasons year has to be bit-or'ed with 0x8000\n        month = value.month - 1     # for some unknown reasons HANA counts months starting from zero\n        hour = value.hour | 0x80    # for some unknown reasons hour has to be bit-or'ed with 0x80\n        pfield += cls._struct.pack(year, month, value.day, hour, value.minute, millisecond)\n        return pfield\n", "docstring": "Pack datetime value into proper binary format\n"}
{"repo": "PyHDB-master/pyhdb/protocol/types.py", "original_string": "    def from_resultset(cls, payload, connection=None):\n        # to avoid circular import the 'lobs' module has to be imported here:\n        from . import lobs\n        return lobs.from_payload(cls.type_code, payload, connection)\n", "docstring": "to avoid circular import the 'lobs' module has to be imported here:"}
{"repo": "PyHDB-master/pyhdb/protocol/types.py", "original_string": "    def prepare(cls, value, length=0, position=0, is_last_data=True):\n        \"\"\"Prepare Lob header.\n        Note that the actual lob data is NOT written here but appended after the parameter block for each row!\n        \"\"\"\n        hstruct = WriteLobHeader.header_struct\n        lob_option_dataincluded = WriteLobHeader.LOB_OPTION_DATAINCLUDED if length > 0 else 0\n        lob_option_lastdata = WriteLobHeader.LOB_OPTION_LASTDATA if is_last_data else 0\n        options = lob_option_dataincluded | lob_option_lastdata\n        pfield = hstruct.pack(cls.type_code, options, length, position)\n        return pfield\n", "docstring": "Prepare Lob header."}
{"repo": "PyHDB-master/pyhdb/protocol/types.py", "original_string": "    def encode_value(cls, value):\n        \"\"\"Return value if it is a string, otherwise properly encode unicode to binary ascii string\"\"\"\n        return value.encode('ascii') if isinstance(value, string_types) else value\n", "docstring": "Return value if it is a string, otherwise properly encode unicode to binary ascii string\n"}
{"repo": "PyHDB-master/pyhdb/protocol/types.py", "original_string": "    def encode_value(cls, value):\n        \"\"\"Return value if it is a string, otherwise properly encode unicode to binary unicode string\"\"\"\n        return value.encode('utf8') if isinstance(value, text_type) else value\n", "docstring": "Return value if it is a string, otherwise properly encode unicode to binary unicode string\n"}
{"repo": "PyHDB-master/pyhdb/protocol/types.py", "original_string": "    def encode_value(cls, value):\n        \"\"\"Return value if it is a string, otherwise properly encode unicode to binary unicode string\"\"\"\n        return value.encode('utf8') if isinstance(value, text_type) else value\n", "docstring": "Return value if it is a string, otherwise properly encode unicode to binary unicode string\n"}
{"repo": "PyHDB-master/pyhdb/lib/tracing.py", "original_string": "def trace(trace_obj):\n    \"\"\"Print recursive trace of given network protocol object\n    :param trace_obj: either a message, segement, or kind object\n    \"\"\"\n    if pyhdb.tracing:\n        t = TraceLogger()\n        tr = t.trace(trace_obj)\n        print(tr)\n        return tr\n", "docstring": "Print recursive trace of given network protocol object"}
{"repo": "PyHDB-master/pyhdb/lib/stringlib.py", "original_string": "def allhexlify(data):\n    \"\"\"Hexlify given data into a string representation with hex values for all chars\n    Input like\n        'ab\\x04ce'\n    becomes\n        '\\x61\\x62\\x04\\x63\\x65'\n    \"\"\"\n    hx = binascii.hexlify(data)\n    return b''.join([b'\\\\x' + o for o in re.findall(b'..', hx)])\n", "docstring": "Hexlify given data into a string representation with hex values for all chars"}
{"repo": "PyHDB-master/tests/test_transactions.py", "original_string": "def test_table(request, connection):\n    \"\"\"Fixture to create table for testing, and dropping it after test run\"\"\"\n    tests.helper.create_table_fixture(request, connection, TABLE, TABLE_FIELDS)\n", "docstring": "Fixture to create table for testing, and dropping it after test run\n"}
{"repo": "PyHDB-master/tests/helper.py", "original_string": "def exists_table(connection, table):\n    \"\"\"Check whether table exists\n    :param table: name of table\n    :returns: bool\n    \"\"\"\n    cursor = connection.cursor()\n    cursor.execute('SELECT 1 FROM \"SYS\".\"TABLES\" WHERE \"TABLE_NAME\" = %s', (table,))\n    return cursor.fetchone() is not None\n", "docstring": "Check whether table exists"}
{"repo": "PyHDB-master/tests/test_cursor.py", "original_string": "def test_table_1(request, connection):\n    \"\"\"Fixture to create table for testing, and dropping it after test run\"\"\"\n    tests.helper.create_table_fixture(request, connection, TABLE, TABLE_FIELDS)\n", "docstring": "Fixture to create table for testing, and dropping it after test run\n"}
{"repo": "PyHDB-master/tests/test_cursor.py", "original_string": "def test_table_2(request, connection):\n    \"\"\"Fixture to create table for testing, and dropping it after test run\"\"\"\n    tests.helper.create_table_fixture(request, connection, 'PYHDB_TEST_2', 'TEST DECIMAL')\n", "docstring": "Fixture to create table for testing, and dropping it after test run\n"}
{"repo": "PyHDB-master/tests/test_cursor.py", "original_string": "def content_table_1(request, connection):\n    \"\"\"Additional fixture to test_table_1, inserts some rows for testing\"\"\"\n    cursor = connection.cursor()\n    cursor.execute(\"insert into PYHDB_TEST_1 values('row1')\")\n    cursor.execute(\"insert into PYHDB_TEST_1 values('row2')\")\n    cursor.execute(\"insert into PYHDB_TEST_1 values('row3')\")\n", "docstring": "Additional fixture to test_table_1, inserts some rows for testing\n"}
{"repo": "PyHDB-master/tests/test_cursor.py", "original_string": "def test_format_operation_without_parameters(parameters):\n    \"\"\"Test that providing no parameter produces correct result.\"\"\"\n    operation = \"SELECT * FROM TEST WHERE fuu = 'bar'\"\n    assert format_operation(operation, parameters) == operation\n", "docstring": "Test that providing no parameter produces correct result.\n"}
{"repo": "PyHDB-master/tests/test_cursor.py", "original_string": "def test_format_operation_with_too_few_positional_parameters_raises():\n    \"\"\"Test that providing too few parameters raises exception\"\"\"\n    with pytest.raises(ProgrammingError):\n        format_operation(\"INSERT INTO TEST VALUES(%s, %s)\", ('Hello World',))\n", "docstring": "Test that providing too few parameters raises exception\n"}
{"repo": "PyHDB-master/tests/test_cursor.py", "original_string": "def test_format_operation_with_named_parameters():\n    \"\"\"format_operation() is used for Python style parameter expansion\"\"\"\n    assert format_operation(\n        \"INSERT INTO TEST VALUES(%(name)s, %(val)s)\",\n        {'name': 'Hello World', 'val': 2}\n    ) == \"INSERT INTO TEST VALUES('Hello World', 2)\"\n", "docstring": "format_operation() is used for Python style parameter expansion\n"}
{"repo": "PyHDB-master/tests/test_cursor.py", "original_string": "def test_cursor_execute_with_params1(connection, test_table_1, content_table_1):\n    \"\"\"Test qmark parameter expansion style - uses cursor.prepare*() methods\"\"\"\n    # Note: use fetchall() to check that only one row gets returned\n    cursor = connection.cursor()\n    sql = 'select test from PYHDB_TEST_1 where test=?'\n    # correct way:\n    assert cursor.execute(sql, ['row2']).fetchall() == [('row2',)]\n    # invalid - extra unexpected parameter\n    with pytest.raises(ProgrammingError):\n        cursor.execute(sql, ['row2', 'extra']).fetchall()\n", "docstring": "Test qmark parameter expansion style - uses cursor.prepare*() methods\n"}
{"repo": "PyHDB-master/tests/test_cursor.py", "original_string": "def test_cursor_execute_with_params2(connection, test_table_1, content_table_1):\n    \"\"\"Test numeric parameter expansion style - uses cursor.prepare() methods\"\"\"\n    # Note: use fetchall() to check that only one row gets returned\n    cursor = connection.cursor()\n    sql = 'select test from PYHDB_TEST_1 where test=?'\n    # correct way:\n    assert cursor.execute(sql, ['row2']).fetchall() == [('row2',)]\n    # invalid - extra unexpected parameter\n    with pytest.raises(ProgrammingError):\n        cursor.execute(sql, ['row2', 'extra']).fetchall()\n", "docstring": "Test numeric parameter expansion style - uses cursor.prepare() methods\n"}
{"repo": "PyHDB-master/tests/test_cursor.py", "original_string": "def test_cursor_execute_with_params4(connection, test_table_1, content_table_1):\n    \"\"\"Test format (positional) parameter expansion style\"\"\"\n    # Uses prepare_operation method\n    cursor = connection.cursor()\n    sql = 'select test from PYHDB_TEST_1 where test=%s'\n    # correct way:\n    assert cursor.execute(sql, ['row2']).fetchall() == [('row2',)]\n    # invalid - extra unexpected parameter\n    with pytest.raises(ProgrammingError):\n        cursor.execute(sql, ['row2', 'extra']).fetchall()\n", "docstring": "Test format (positional) parameter expansion style\n"}
{"repo": "PyHDB-master/tests/test_cursor.py", "original_string": "def test_cursor_execute_with_params5(connection, test_table_1, content_table_1):\n    \"\"\"Test pyformat (named) parameter expansion style\"\"\"\n    # Note: use fetchall() to check that only one row gets returned\n    cursor = connection.cursor()\n    sql = 'select test from {} where test=%(test)s'.format(TABLE)\n    # correct way:\n    assert cursor.execute(sql, {'test': 'row2'}).fetchall() == [('row2',)]\n    # also correct way, additional dict value should just be ignored\n    assert cursor.execute(sql, {'test': 'row2', 'd': 2}).fetchall() == \\\n        [('row2',)]\n", "docstring": "Test pyformat (named) parameter expansion style\n"}
{"repo": "PyHDB-master/tests/test_cursor.py", "original_string": "def test_received_last_resultset_part_resets_after_execute(connection):\n    # The private attribute was not reseted to False after\n    # executing another statement\n    cursor = connection.cursor()\n    cursor.execute(\"SELECT 1 FROM DUMMY\")\n    # Result is very small we got everything direct into buffer\n    assert cursor._received_last_resultset_part\n    cursor.execute(\"SELECT VIEW_NAME FROM PUBLIC.VIEWS\")\n    # Result is not small enouth for single resultset part\n    assert not cursor._received_last_resultset_part\n", "docstring": "The private attribute was not reseted to False after"}
{"repo": "PyHDB-master/tests/dbapi/test_connection.py", "original_string": "def test_fixture_connection(connection):\n    # Smoke test of the connection fixture\n    pass\n", "docstring": "Smoke test of the connection fixture"}
{"repo": "PyHDB-master/tests/lib/test_stringlib.py", "original_string": "def test_humanhexlify():\n    \"\"\"Test plain humanhexlify function without shortening\"\"\"\n    b = b'\\x01\\x62\\x70\\x00\\xff'\n    assert humanhexlify(b) == b'01 62 70 00 ff'\n", "docstring": "Test plain humanhexlify function without shortening\n"}
{"repo": "PyHDB-master/tests/lib/test_stringlib.py", "original_string": "def test_allhexlify():\n    \"\"\"Test that ALL byte chars are converted into hex values\"\"\"\n    b = b'ab\\x04ce'\n    assert allhexlify(b) == b'\\\\x61\\\\x62\\\\x04\\\\x63\\\\x65'\n", "docstring": "Test that ALL byte chars are converted into hex values\n"}
{"repo": "PyHDB-master/tests/types/test_geometry.py", "original_string": "def test_insert_point(connection, test_table_point):\n    \"\"\"Insert spatial point into table\"\"\"\n    cursor = connection.cursor()\n    point_x = random.randint(-100.0, 100.0)\n    point_y = random.randint(-100.0, 100.0)\n    wkt_string = \"POINT(%f %f)\" % (point_x, point_y)\n    cursor.execute(\"insert into %s (point) values (:1)\" % TABLE_POINT, [wkt_string])\n    connection.commit()\n    cursor = connection.cursor()\n    row = cursor.execute('select point.ST_X(), point.ST_Y() from %s' % TABLE_POINT).fetchone()\n    assert row[0] == point_x\n    assert row[1] == point_y\n", "docstring": "Insert spatial point into table\n"}
{"repo": "PyHDB-master/tests/types/test_geometry.py", "original_string": "def test_insert_linestring(connection, test_table_geometry):\n    \"\"\"Insert spatial linestring into table\"\"\"\n    cursor = connection.cursor()\n    point1_x = random.randint(-100.0, 100.0)\n    point1_y = random.randint(-100.0, 100.0)\n    point2_x = random.randint(-100.0, 100.0)\n    point2_y = random.randint(-100.0, 100.0)\n    wkt_string = \"LINESTRING(%f %f, %f %f)\" % (point1_x, point1_y, point2_x, point2_y)\n    cursor.execute(\"insert into %s (geo) values (:1)\" % TABLE_GEOMETRY, [wkt_string])\n    connection.commit()\n    cursor = connection.cursor()\n    sql = \"\"\"\n        Select geo.ST_StartPoint().ST_X(), geo.ST_StartPoint().ST_Y(),\n               geo.ST_EndPoint().ST_X(), geo.ST_EndPoint().ST_Y()\n        From %s\n    \"\"\"\n    row = cursor.execute(sql % TABLE_GEOMETRY).fetchone()\n    assert row[0] == point1_x\n    assert row[1] == point1_y\n    assert row[2] == point2_x\n    assert row[3] == point2_y\n", "docstring": "Insert spatial linestring into table\n"}
{"repo": "PyHDB-master/tests/types/test_string.py", "original_string": "def test_table(request, connection):\n    \"\"\"Fixture to create table for testing lobs, and dropping it after test run\"\"\"\n    tests.helper.create_table_fixture(request, connection, TABLE, TABLE_FIELDS)\n", "docstring": "Fixture to create table for testing lobs, and dropping it after test run\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_clob_from_nonascii_unicode_raises():\n    \"\"\"Feeding unicode string with non-ascii chars should raise an exception\"\"\"\n    data = u'朱の子ましけ'\n    with pytest.raises(UnicodeEncodeError):\n        lobs.Clob(data)\n", "docstring": "Feeding unicode string with non-ascii chars should raise an exception\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_clob___str___method():\n    \"\"\"Test that the magic __str__ method returns a proper string\"\"\"\n    data = string.ascii_letters\n    clob = lobs.Clob(data)\n    assert str(clob) == data\n", "docstring": "Test that the magic __str__ method returns a proper string\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_nclob__str___method_for_nonascii_chars():\n    \"\"\"Test that the magic __str__ method raise Unicode error for non-ascii chars\"\"\"\n    if not PY3:\n        pytest.skip('test only makes sense in PY3')\n    data = u'朱の子ましけ'\n    nclob = lobs.NClob(data)\n    uni_nclob = str(nclob)\n    assert type(uni_nclob) == str\n    assert uni_nclob == data\n", "docstring": "Test that the magic __str__ method raise Unicode error for non-ascii chars\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_nclob___unicode___method_for_nonascii_chars():\n    \"\"\"Test that the magic __unicode__ method returns a proper text_type\"\"\"\n    if not PY2:\n        pytest.skip('test only makes sense in PY2')\n    data = u'朱の子ましけ'\n    nclob = lobs.NClob(data)\n    uni_nclob = unicode(nclob)\n    assert type(uni_nclob) == text_type\n    assert uni_nclob == data\n", "docstring": "Test that the magic __unicode__ method returns a proper text_type\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_read_lob(type_code, lob_header, bin_lob_data, lob_data, lob_data_empty):\n    \"\"\"Read/parse a LOB with given payload (data)\"\"\"\n    payload = io.BytesIO(lob_header + bin_lob_data)\n    lob = lobs.from_payload(type_code, payload, None)\n    _ExpectedLobClass = lobs.LOB_TYPE_CODE_MAP[type_code]\n    assert isinstance(lob, _ExpectedLobClass)  # check for correct instance\n    assert lob._lob_header.lob_type in (0, lob._lob_header.LOB_TYPES[type_code])\n    assert lob._lob_header.options & lob._lob_header.LOB_OPTION_DATAINCLUDED\n    assert lob._lob_header.char_length == len(lob_data)\n    assert lob._lob_header.byte_length == len(bin_lob_data)\n    assert lob._lob_header.locator_id == lob_header[20:28]\n    # assert lob._lob_header.chunk_length == min(len(bin_lob_data), MAX_LOB_DATA_LENGTH) - chunklength can vary ...\n    assert lob._lob_header.total_lob_length == lob.length == len(lob_data)\n    assert lob._current_lob_length == len(lob.data.getvalue())\n    assert lob.data.getvalue() == lob_data[:1024]\n    assert repr(lob) == '<%s length: %d (currently loaded from hana: %d)>' % \\\n        (_ExpectedLobClass.__name__, lob.length, lob._current_lob_length)\n", "docstring": "Read/parse a LOB with given payload (data)\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_read_lob__str__method_python2():\n    \"\"\"Read/parse a LOB with given payload (data) and check ___str__ method\"\"\"\n    if PY3:\n        pytest.skip(\"See test_read_lob__str__method_python3\")\n    payload = io.BytesIO(BLOB_HEADER + BLOB_DATA)\n    lob = lobs.from_payload(type_codes.BLOB, payload, None)\n    len = lob._lob_header.byte_length\n    assert str(lob._lob_header) == \"<ReadLobHeader type: 1, options 2 (data_included), charlength: %d, bytelength: \" \\\n                                   \"%d, locator_id: '\\\\x00\\\\x00\\\\x00\\\\x00\\\\xb2\\\\xb9\\\\x04\\\\x00', chunklength: 1024>\" % \\\n                                   (len, len)\n", "docstring": "Read/parse a LOB with given payload (data) and check ___str__ method\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_blob_io_functions(type_code, lob_header, bin_lob_data, lob_data, lob_data_empty):\n    \"\"\"Test that io functionality (read/seek/getvalue()/...) works fine\n    Stay below the 1024 item range when reading to avoid lazy loading of additional lob data from DB.\n    This feature is tested in a separate unittest.\n    \"\"\"\n    payload = io.BytesIO(lob_header + bin_lob_data)\n    lob = lobs.from_payload(type_code, payload, None)\n    assert lob.tell() == 0   # should be at start of lob initially\n    assert lob.read(10) == lob_data[:10]\n    assert lob.tell() == 10\n    lob.seek(20)\n    assert lob.tell() == 20\n    assert lob.read(10) == lob_data[20:30]\n    assert lob.read(10) == lob_data[30:40]\n    assert lob.tell() == 40\n", "docstring": "Test that io functionality (read/seek/getvalue()/...) works fine"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_blob_read_triggers_further_loading(_make_read_lob_request, type_code, lob_header, bin_lob_data, lob_data, lob_data_empty):\n    \"\"\"Test that reading beyond currently available data (> 1024 items) triggers a READLOB request\"\"\"\n    return_value = lob_data[1024:1024 + 100]\n    _ExpectedLobClass = lobs.LOB_TYPE_CODE_MAP[type_code]\n    enc_return_value = return_value.encode(_ExpectedLobClass.encoding) if _ExpectedLobClass.encoding else return_value\n    _make_read_lob_request.return_value = enc_return_value\n    payload = io.BytesIO(lob_header + bin_lob_data)\n    lob = lobs.from_payload(type_code, payload, None)\n    lob_len = len(lob.data.getvalue())\n    assert lob._current_lob_length == lob_len\n    assert repr(lob) == '<%s length: %d (currently loaded from hana: %d)>' % \\\n        (_ExpectedLobClass.__name__, lob.length, lob._current_lob_length)\n    lob.read(lob_len + 100)  # read 100 items (chars/bytes) more than available\n    # Reading extra 100 items should have triggered _read_missing_lob_data_from_db():\n    _make_read_lob_request.assert_called_once_with(1024, 100)\n    assert lob.getvalue() == lob_data[:1024 + 100]\n    assert lob._current_lob_length == lob_len + 100\n    assert repr(lob) == '<%s length: %d (currently loaded from hana: %d)>' % \\\n        (_ExpectedLobClass.__name__, lob.length, lob._current_lob_length)\n", "docstring": "Test that reading beyond currently available data (> 1024 items) triggers a READLOB request\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_blob_seek_triggers_further_loading(_make_read_lob_request):\n    \"\"\"Test that seeking beyond currently available data (> 1024 items) triggers a READLOB request\"\"\"\n    # Since the actual size of the blob is smaller than the look ahead we are planning for, calculate\n    # the correct number of items to be read:\n    num_items_to_read = min(100 + lobs.Lob.EXTRA_NUM_ITEMS_TO_READ_AFTER_SEEK, len(BLOB_DATA) - 1024)\n    _make_read_lob_request.return_value = BLOB_DATA[1024:1024 + num_items_to_read]\n    payload = io.BytesIO(BLOB_HEADER + BLOB_DATA)\n    lob = lobs.from_payload(type_codes.BLOB, payload, None)\n    lob_len = len(lob.data.getvalue())\n    lob.seek(lob_len + 100)  # seek to position 100 items (bytes/chars) after what is available\n    # This should have triggered _read_missing_lob_data_from_db().\n    # Since seek() makes the assumption that the user wants to read data from the new position\n    # another EXTRA_NUM_ITEMS_TO_READ_AFTER_SEEK are read in addition to the 100 beyond the current num items:\n    _make_read_lob_request.assert_called_once_with(1024, num_items_to_read)\n    assert lob.getvalue() == BLOB_DATA[:1024 + num_items_to_read]\n    assert lob.tell() == lob_len + 100\n", "docstring": "Test that seeking beyond currently available data (> 1024 items) triggers a READLOB request\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_parse_null_blob(type_code, null_lob_header):\n    \"\"\"Parse a BLOB which is NULL -> a None object is expected\"\"\"\n    payload = io.BytesIO(null_lob_header)\n    lob = lobs.from_payload(type_code, payload, None)\n    assert lob is None\n", "docstring": "Parse a BLOB which is NULL -> a None object is expected\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_table(request, connection):\n    \"\"\"Fixture to create table for testing lobs, and dropping it after test run\"\"\"\n    tests.helper.create_table_fixture(request, connection, TABLE, TABLE_FIELDS)\n", "docstring": "Fixture to create table for testing lobs, and dropping it after test run\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def content_table(request, connection):\n    \"\"\"Additional fixture to test_table, inserts some rows for testing\"\"\"\n    cursor = connection.cursor()\n    cursor.execute(\"insert into %s (name) values('nulls')\" % TABLE)  # all lobs are NULL\n    cursor.execute(\"insert into %s values('lob0', 'blob0', 'clob0', 'nclob0')\" % TABLE)\n", "docstring": "Additional fixture to test_table, inserts some rows for testing\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_insert_single_string_blob_row(connection, test_table):\n    \"\"\"Insert a single row providing blob data in string format (argument order: name, blob)\"\"\"\n    cursor = connection.cursor()\n    blob_data = BLOB_DATA\n    cursor.execute(\"insert into %s (name, fblob) values (:1, :2)\" % TABLE, ['blob1', blob_data])\n    blob = cursor.execute(\"select fblob from %s where name='blob1' \" % TABLE).fetchone()[0]\n    assert blob.read() == blob_data\n", "docstring": "Insert a single row providing blob data in string format (argument order: name, blob)\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_insert_single_object_blob_row(connection, test_table):\n    \"\"\"Insert a single row providing blob data as LOB object (argument order: blob, name)\"\"\"\n    cursor = connection.cursor()\n    blob_data = b'ab \\0x1 \\0x17 yz'\n    blob_obj = lobs.Blob(blob_data)\n    cursor.execute(\"insert into %s (fblob, name) values (:1, :2)\" % TABLE, [blob_obj, 'blob1'])\n    blob = cursor.execute(\"select fblob from %s where name='blob1' \" % TABLE).fetchone()[0]\n    assert blob.read() == blob_data\n", "docstring": "Insert a single row providing blob data as LOB object (argument order: blob, name)\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_insert_single_string_clob_row(connection, test_table):\n    \"\"\"Insert a single row providing clob data in string format (argument order: name, clob)\"\"\"\n    cursor = connection.cursor()\n    clob_data = CLOB_DATA\n    cursor.execute(\"insert into %s (name, fclob) values (:1, :2)\" % TABLE, ['clob1', clob_data])\n    clob = cursor.execute(\"select fclob from %s where name='clob1' \" % TABLE).fetchone()[0]\n    assert clob.read() == clob_data\n", "docstring": "Insert a single row providing clob data in string format (argument order: name, clob)\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_insert_single_object_clob_row(connection, test_table):\n    \"\"\"Insert a single row providing clob data in string format (argument order: name, clob)\"\"\"\n    cursor = connection.cursor()\n    clob_data = CLOB_DATA\n    clob_obj = lobs.Clob(clob_data)\n    cursor.execute(\"insert into %s (name, fclob) values (:1, :2)\" % TABLE, ['clob1', clob_obj])\n    clob = cursor.execute(\"select fclob from %s where name='clob1' \" % TABLE).fetchone()[0]\n    assert clob.read() == clob_data\n", "docstring": "Insert a single row providing clob data in string format (argument order: name, clob)\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_insert_single_object_nclob_row(connection, test_table):\n    \"\"\"Insert a single row providing blob data as LOB object (argument order: nclob, name)\"\"\"\n    cursor = connection.cursor()\n    nclob_data = NCLOB_DATA\n    nclob_obj = lobs.NClob(nclob_data)\n    cursor.execute(\"insert into %s (fnclob, name) values (:1, :2)\" % TABLE, [nclob_obj, 'nclob1'])\n    nclob = cursor.execute(\"select fnclob from %s where name='nclob1' \" % TABLE).fetchone()[0]\n    assert nclob.read() == nclob_data\n", "docstring": "Insert a single row providing blob data as LOB object (argument order: nclob, name)\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_insert_single_object_nclob_row(connection, test_table):\n    \"\"\"Insert a single row providing nclob data as LOB object (argument order: nclob, name)\"\"\"\n    cursor = connection.cursor()\n    nclob_data = NCLOB_DATA\n    nclob_obj = lobs.NClob(nclob_data)\n    cursor.execute(\"insert into %s (fnclob, name) values (:1, :2)\" % TABLE, [nclob_obj, 'nclob1'])\n    nclob = cursor.execute(\"select fnclob from %s where name='nclob1' \" % TABLE).fetchone()[0]\n    assert nclob.read() == nclob_data\n", "docstring": "Insert a single row providing nclob data as LOB object (argument order: nclob, name)\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_insert_single_blob_and_clob_row(connection, test_table):\n    \"\"\"Insert a single row providing blob (as string) and clob (as LOB obj) (argument order: blob, name, clob)\"\"\"\n    cursor = connection.cursor()\n    blob_data = b'ab \\0x1 \\0x17 yz'\n    clob_data = string.ascii_letters\n    clob_obj = lobs.Clob(clob_data)\n    cursor.execute(\"insert into %s (fblob, name, fclob) values (:1, :2, :3)\" % TABLE, [blob_data, 'blob1', clob_obj])\n    blob, clob = cursor.execute(\"select fblob, fclob from %s where name='blob1' \" % TABLE).fetchone()\n    assert blob.read() == blob_data\n    assert clob.read() == clob_data\n", "docstring": "Insert a single row providing blob (as string) and clob (as LOB obj) (argument order: blob, name, clob)\n"}
{"repo": "PyHDB-master/tests/types/test_lob.py", "original_string": "def test_insert_multiple_clob_and_nclob_rows(connection, test_table):\n    \"\"\"Insert multiple rows of clob and nclob. Providing wild mix of string, unicode, and lob objects\"\"\"\n    nclob_data1 = u'เขืองลาจะปเที่ยวเมได้ไาว'   # unicode format\n    clob_data1 = string.ascii_letters[:10]\n    nclob_data2 = 'ずはしにさはる事侍'  # string format\n    clob_data2 = string.ascii_letters[10:20]\n    nclob_data3 = 'λάμβδαี่'   # string format\n    nclob_obj = lobs.NClob(nclob_data3)\n    clob_data3 = string.ascii_letters[20:30]\n    clob_obj = lobs.Clob(clob_data3)\n    cursor = connection.cursor()\n    cursor.executemany(\"insert into %s (fnclob, name, fclob) values (:1, :2, :3)\" % TABLE,\n                       [[nclob_data1, 'blob1', clob_data1],\n                        [nclob_data2, 'blob2', clob_data2],\n                        [nclob_obj, 'blob3', clob_obj]])\n    connection.commit()\n    cursor = connection.cursor()\n    rows = cursor.execute(\"select name, fnclob, fclob from %s order by name\" % TABLE).fetchall()\n    assert len(rows) == 3\n    n_name, n_nclob, n_clob = rows[0]\n    assert n_name == 'blob1'\n    assert n_nclob.read() == nclob_data1\n    assert n_clob.read() == clob_data1\n    n_name, n_nclob, n_clob = rows[1]\n    assert n_name == 'blob2'\n    if PY2:\n        assert n_nclob.read() == nclob_data2.decode('utf8')\n    else:\n        assert n_nclob.read() == nclob_data2\n    assert n_clob.read() == clob_data2\n    n_name, n_nclob, n_clob = rows[2]\n    assert n_name == 'blob3'\n    if PY2:\n        assert n_nclob.read() == nclob_data3.decode('utf8')\n    else:\n        assert n_nclob.read() == nclob_data3\n    assert n_clob.read() == clob_data3\n", "docstring": "Insert multiple rows of clob and nclob. Providing wild mix of string, unicode, and lob objects\n"}
{"repo": "lstm-master/lstm.py", "original_string": "    def __init__(self, lstm_param, lstm_state):\n        # store reference to parameters and to activations\n        self.state = lstm_state\n        self.param = lstm_param\n        # non-recurrent input concatenated with recurrent input\n        self.xc = None\n", "docstring": "store reference to parameters and to activations"}
{"repo": "lstm-master/lstm.py", "original_string": "    def top_diff_is(self, top_diff_h, top_diff_s):\n        # notice that top_diff_s is carried along the constant error carousel\n        ds = self.state.o * top_diff_h + top_diff_s\n        do = self.state.s * top_diff_h\n        di = self.state.g * ds\n        dg = self.state.i * ds\n        df = self.s_prev * ds\n        # diffs w.r.t. vector inside sigma / tanh function\n        di_input = sigmoid_derivative(self.state.i) * di \n        df_input = sigmoid_derivative(self.state.f) * df \n        do_input = sigmoid_derivative(self.state.o) * do \n        dg_input = tanh_derivative(self.state.g) * dg\n        # diffs w.r.t. inputs\n        self.param.wi_diff += np.outer(di_input, self.xc)\n        self.param.wf_diff += np.outer(df_input, self.xc)\n        self.param.wo_diff += np.outer(do_input, self.xc)\n        self.param.wg_diff += np.outer(dg_input, self.xc)\n        self.param.bi_diff += di_input\n        self.param.bf_diff += df_input       \n        self.param.bo_diff += do_input\n        self.param.bg_diff += dg_input       \n        # compute bottom diff\n        dxc = np.zeros_like(self.xc)\n        dxc += np.dot(self.param.wi.T, di_input)\n        dxc += np.dot(self.param.wf.T, df_input)\n        dxc += np.dot(self.param.wo.T, do_input)\n        dxc += np.dot(self.param.wg.T, dg_input)\n        # save bottom diffs\n        self.state.bottom_diff_s = ds * self.state.f\n        self.state.bottom_diff_h = dxc[self.param.x_dim:]\n", "docstring": "notice that top_diff_s is carried along the constant error carousel"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem_shutil.py", "original_string": "    def dir():\n        \"\"\"Return the list of patched function names. Used for patching\n        functions imported from the module.\n        \"\"\"\n        return 'disk_usage',\n", "docstring": "Return the list of patched function names. Used for patching"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem_shutil.py", "original_string": "    def disk_usage(self, path):\n        \"\"\"Return the total, used and free disk space in bytes as named tuple\n        or placeholder holder values simulating unlimited space if not set.\n        Args:\n          path: defines the filesystem device which is queried\n        \"\"\"\n        return self.filesystem.get_disk_usage(path)\n", "docstring": "Return the total, used and free disk space in bytes as named tuple"}
{"repo": "pyfakefs-master/pyfakefs/mox3_stubout.py", "original_string": "    def smart_set(self, obj, attr_name, new_attr):\n        \"\"\"Replace obj.attr_name with new_attr.\n        This method is smart and works at the module, class, and instance level\n        while preserving proper inheritance. It will not stub out C types\n        however unless that has been explicitly allowed by the type.\n        This method supports the case where attr_name is a staticmethod or a\n        classmethod of obj.\n        Notes:\n          - If obj is an instance, then it is its class that will actually be\n            stubbed. Note that the method Set() does not do that: if obj is\n            an instance, it (and not its class) will be stubbed.\n          - The stubbing is using the builtin getattr and setattr. So, the\n            __get__ and __set__ will be called when stubbing (TODO: A better\n            idea would probably be to manipulate obj.__dict__ instead of\n            getattr() and setattr()).\n        Raises AttributeError if the attribute cannot be found.\n        \"\"\"\n        if (inspect.ismodule(obj) or\n                (not inspect.isclass(obj) and attr_name in obj.__dict__)):\n            orig_obj = obj\n            orig_attr = getattr(obj, attr_name)\n        else:\n            if not inspect.isclass(obj):\n                mro = list(inspect.getmro(obj.__class__))\n            else:\n                mro = list(inspect.getmro(obj))\n            mro.reverse()\n            orig_attr = None\n            for cls in mro:\n                try:\n                    orig_obj = cls\n                    orig_attr = getattr(obj, attr_name)\n                except AttributeError:\n                    continue\n        if orig_attr is None:\n            raise AttributeError(\"Attribute not found.\")\n        # Calling getattr() on a staticmethod transforms it to a 'normal'\n        # function. We need to ensure that we put it back as a staticmethod.\n        old_attribute = obj.__dict__.get(attr_name)\n        if (old_attribute is not None\n                and isinstance(old_attribute, staticmethod)):\n            orig_attr = staticmethod(orig_attr)\n        self.stubs.append((orig_obj, attr_name, orig_attr))\n        setattr(orig_obj, attr_name, new_attr)\n", "docstring": "Replace obj.attr_name with new_attr."}
{"repo": "pyfakefs-master/pyfakefs/mox3_stubout.py", "original_string": "    def set(self, parent, child_name, new_child):\n        \"\"\"Replace child_name's old definition with new_child.\n        Replace definition in the context of the given parent. The parent could\n        be a module when the child is a function at module scope. Or the parent\n        could be a class when a class' method is being replaced. The named\n        child is set to new_child, while the prior definition is saved away\n        for later, when unset_all() is called.\n        This method supports the case where child_name is a staticmethod or a\n        classmethod of parent.\n        \"\"\"\n        old_child = getattr(parent, child_name)\n        old_attribute = parent.__dict__.get(child_name)\n        if old_attribute is not None:\n            if isinstance(old_attribute, staticmethod):\n                old_child = staticmethod(old_child)\n            elif isinstance(old_attribute, classmethod):\n                old_child = classmethod(old_child.__func__)\n        self.cache.append((parent, old_child, child_name))\n        setattr(parent, child_name, new_child)\n", "docstring": "Replace child_name's old definition with new_child."}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "def is_int_type(val: Any) -> bool:\n    \"\"\"Return True if `val` is of integer type.\"\"\"\n    return isinstance(val, int)\n", "docstring": "Return True if `val` is of integer type.\n"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "def is_unicode_string(val: Any) -> bool:\n    \"\"\"Return True if `val` is a unicode string, False for a bytes-like\n    object.\"\"\"\n    return hasattr(val, 'encode')\n", "docstring": "Return True if `val` is a unicode string, False for a bytes-like"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "def to_string(path: Union[AnyStr, Union[str, bytes]]) -> str:\n    \"\"\"Return the string representation of a byte string using the preferred\n     encoding, or the string itself if path is a str.\"\"\"\n    if isinstance(path, bytes):\n        return path.decode(locale.getpreferredencoding(False))\n    return path\n", "docstring": "Return the string representation of a byte string using the preferred"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "def join_strings(s1: AnyStr, s2: AnyStr) -> AnyStr:\n    \"\"\"This is a bit of a hack to satisfy mypy - may be refactored.\"\"\"\n    return s1 + s2\n", "docstring": "This is a bit of a hack to satisfy mypy - may be refactored.\n"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "    def set_from_stat_result(self, stat_result: os.stat_result) -> None:\n        \"\"\"Set values from a real os.stat_result.\n        Note: values that are controlled by the fake filesystem are not set.\n        This includes st_ino, st_dev and st_nlink.\n        \"\"\"\n        self.st_mode = stat_result.st_mode\n        self.st_uid = stat_result.st_uid\n        self.st_gid = stat_result.st_gid\n        self._st_size = stat_result.st_size\n        self._st_atime_ns = stat_result.st_atime_ns\n        self._st_mtime_ns = stat_result.st_mtime_ns\n        self._st_ctime_ns = stat_result.st_ctime_ns\n", "docstring": "Set values from a real os.stat_result."}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "    def stat_float_times(cls, newvalue: Optional[bool] = None) -> bool:\n        \"\"\"Determine whether a file's time stamps are reported as floats\n        or ints.\n        Calling without arguments returns the current value.\n        The value is shared by all instances of FakeOsModule.\n        Args:\n            newvalue: If `True`, mtime, ctime, atime are reported as floats.\n                Otherwise, they are returned as ints (rounding down).\n        \"\"\"\n        if newvalue is not None:\n            cls._stat_float_times = bool(newvalue)\n        return cls._stat_float_times\n", "docstring": "Determine whether a file's time stamps are reported as floats"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "    def st_ctime(self) -> Union[int, float]:\n        \"\"\"Return the creation time in seconds.\"\"\"\n        ctime = self._st_ctime_ns / 1e9\n        return ctime if self.use_float else int(ctime)\n", "docstring": "Return the creation time in seconds.\n"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "    def st_ctime(self, val: Union[int, float]) -> None:\n        \"\"\"Set the creation time in seconds.\"\"\"\n        self._st_ctime_ns = int(val * 1e9)\n", "docstring": "Set the creation time in seconds.\n"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "    def st_atime(self) -> Union[int, float]:\n        \"\"\"Return the access time in seconds.\"\"\"\n        atime = self._st_atime_ns / 1e9\n        return atime if self.use_float else int(atime)\n", "docstring": "Return the access time in seconds.\n"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "    def st_atime(self, val: Union[int, float]) -> None:\n        \"\"\"Set the access time in seconds.\"\"\"\n        self._st_atime_ns = int(val * 1e9)\n", "docstring": "Set the access time in seconds.\n"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "    def st_mtime(self) -> Union[int, float]:\n        \"\"\"Return the modification time in seconds.\"\"\"\n        mtime = self._st_mtime_ns / 1e9\n        return mtime if self.use_float else int(mtime)\n", "docstring": "Return the modification time in seconds.\n"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "    def st_mtime(self, val: Union[int, float]) -> None:\n        \"\"\"Set the modification time in seconds.\"\"\"\n        self._st_mtime_ns = int(val * 1e9)\n", "docstring": "Set the modification time in seconds.\n"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "    def st_atime_ns(self) -> int:\n        \"\"\"Return the access time in nanoseconds.\"\"\"\n        return self._st_atime_ns\n", "docstring": "Return the access time in nanoseconds.\n"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "    def st_atime_ns(self, val: int) -> None:\n        \"\"\"Set the access time in nanoseconds.\"\"\"\n        self._st_atime_ns = val\n", "docstring": "Set the access time in nanoseconds.\n"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "    def st_mtime_ns(self) -> int:\n        \"\"\"Return the modification time in nanoseconds.\"\"\"\n        return self._st_mtime_ns\n", "docstring": "Return the modification time in nanoseconds.\n"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "    def st_mtime_ns(self, val: int) -> None:\n        \"\"\"Set the modification time of the fake file in nanoseconds.\"\"\"\n        self._st_mtime_ns = val\n", "docstring": "Set the modification time of the fake file in nanoseconds.\n"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "    def st_ctime_ns(self) -> int:\n        \"\"\"Return the creation time in nanoseconds.\"\"\"\n        return self._st_ctime_ns\n", "docstring": "Return the creation time in nanoseconds.\n"}
{"repo": "pyfakefs-master/pyfakefs/helpers.py", "original_string": "    def st_ctime_ns(self, val: int) -> None:\n        \"\"\"Set the creation time of the fake file in nanoseconds.\"\"\"\n        self._st_ctime_ns = val\n", "docstring": "Set the creation time of the fake file in nanoseconds.\n"}
{"repo": "pyfakefs-master/pyfakefs/patched_packages.py", "original_string": "        def __getattr__(self, name):\n            \"\"\"Forwards any unfaked calls to the standard xlrd module.\"\"\"\n            return getattr(self._xlrd_module, name)\n", "docstring": "Forwards any unfaked calls to the standard xlrd module.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_scandir.py", "original_string": "    def __init__(self, filesystem):\n        \"\"\"Initialize the dir entry with unset values.\n        Args:\n            filesystem: the fake filesystem used for implementation.\n        \"\"\"\n        self._filesystem = filesystem\n        self.name = ''\n        self.path = ''\n        self._abspath = ''\n        self._inode = None\n        self._islink = False\n        self._isdir = False\n        self._statresult = None\n        self._statresult_symlink = None\n", "docstring": "Initialize the dir entry with unset values."}
{"repo": "pyfakefs-master/pyfakefs/fake_scandir.py", "original_string": "    def is_dir(self, follow_symlinks=True):\n        \"\"\"Return True if this entry is a directory entry.\n        Args:\n            follow_symlinks: If True, also return True if this entry is a\n                symlink pointing to a directory.\n        Returns:\n            True if this entry is an existing directory entry, or if\n                follow_symlinks is set, and this entry points to an existing\n                directory entry.\n        \"\"\"\n        return self._isdir and (follow_symlinks or not self._islink)\n", "docstring": "Return True if this entry is a directory entry."}
{"repo": "pyfakefs-master/pyfakefs/fake_scandir.py", "original_string": "    def is_symlink(self):\n        \"\"\"Return True if this entry is a symbolic link (even if broken).\"\"\"\n        return self._islink\n", "docstring": "Return True if this entry is a symbolic link (even if broken).\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_scandir.py", "original_string": "def _classify_directory_contents(filesystem, root):\n    \"\"\"Classify contents of a directory as files/directories.\n    Args:\n        filesystem: The fake filesystem used for implementation\n        root: (str) Directory to examine.\n    Returns:\n        (tuple) A tuple consisting of three values: the directory examined,\n        a list containing all of the directory entries, and a list\n        containing all of the non-directory entries.\n        (This is the same format as returned by the `os.walk` generator.)\n    Raises:\n        Nothing on its own, but be ready to catch exceptions generated by\n        underlying mechanisms like `os.listdir`.\n    \"\"\"\n    dirs = []\n    files = []\n    for entry in filesystem.listdir(root):\n        if filesystem.isdir(filesystem.joinpaths(root, entry)):\n            dirs.append(entry)\n        else:\n            files.append(entry)\n    return root, dirs, files\n", "docstring": "Classify contents of a directory as files/directories."}
{"repo": "pyfakefs-master/pyfakefs/fake_scandir.py", "original_string": "    def dir():\n        \"\"\"Return the list of patched function names. Used for patching\n        functions imported from the module.\n        \"\"\"\n        return 'scandir', 'walk'\n", "docstring": "Return the list of patched function names. Used for patching"}
{"repo": "pyfakefs-master/pyfakefs/fake_scandir.py", "original_string": "    def scandir(self, path='.'):\n        \"\"\"Return an iterator of DirEntry objects corresponding to the entries\n        in the directory given by path.\n        Args:\n            path: Path to the target directory within the fake filesystem.\n        Returns:\n            an iterator to an unsorted list of os.DirEntry objects for\n            each entry in path.\n        Raises:\n            OSError: if the target is not a directory.\n        \"\"\"\n        return scandir(self.filesystem, path)\n", "docstring": "Return an iterator of DirEntry objects corresponding to the entries"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "def set_uid(uid: int) -> None:\n    \"\"\"Set the global user id. This is used as st_uid for new files\n    and to differentiate between a normal user and the root user (uid 0).\n    For the root user, some permission restrictions are ignored.\n    Args:\n        uid: (int) the user ID of the user calling the file system functions.\n    \"\"\"\n    global USER_ID\n    USER_ID = uid\n", "docstring": "Set the global user id. This is used as st_uid for new files"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "def reset_ids() -> None:\n    \"\"\"Set the global user ID and group ID back to default values.\"\"\"\n    if sys.platform == 'win32':\n        set_uid(1)\n        set_gid(1)\n    else:\n        set_uid(os.getuid())\n        set_gid(os.getgid())\n", "docstring": "Set the global user ID and group ID back to default values.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def byte_contents(self) -> Optional[bytes]:\n        \"\"\"Return the contents as raw byte array.\"\"\"\n        return self._byte_contents\n", "docstring": "Return the contents as raw byte array.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def contents(self) -> Optional[str]:\n        \"\"\"Return the contents as string with the original encoding.\"\"\"\n        if isinstance(self.byte_contents, bytes):\n            return self.byte_contents.decode(\n                self.encoding or locale.getpreferredencoding(False),\n                errors=self.errors)\n        return None\n", "docstring": "Return the contents as string with the original encoding.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def st_ctime(self) -> float:\n        \"\"\"Return the creation time of the fake file.\"\"\"\n        return self.stat_result.st_ctime\n", "docstring": "Return the creation time of the fake file.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def st_ctime(self, val: float) -> None:\n        \"\"\"Set the creation time of the fake file.\"\"\"\n        self.stat_result.st_ctime = val\n", "docstring": "Set the creation time of the fake file.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def st_atime(self) -> float:\n        \"\"\"Return the access time of the fake file.\"\"\"\n        return self.stat_result.st_atime\n", "docstring": "Return the access time of the fake file.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def st_atime(self, val: float) -> None:\n        \"\"\"Set the access time of the fake file.\"\"\"\n        self.stat_result.st_atime = val\n", "docstring": "Set the access time of the fake file.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def st_mtime(self) -> float:\n        \"\"\"Return the modification time of the fake file.\"\"\"\n        return self.stat_result.st_mtime\n", "docstring": "Return the modification time of the fake file.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def st_mtime(self, val: float) -> None:\n        \"\"\"Set the modification time of the fake file.\"\"\"\n        self.stat_result.st_mtime = val\n", "docstring": "Set the modification time of the fake file.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def _check_positive_int(self, size: int) -> None:\n        # the size should be an positive integer value\n        if not is_int_type(size) or size < 0:\n            self.filesystem.raise_os_error(errno.ENOSPC, self.name)\n", "docstring": "the size should be an positive integer value"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def size(self) -> int:\n        \"\"\"Return the size in bytes of the file contents.\n        \"\"\"\n        return self.st_size\n", "docstring": "Return the size in bytes of the file contents."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def size(self, st_size: int) -> None:\n        \"\"\"Resizes file content, padding with nulls if new size exceeds the\n        old size.\n        Args:\n          st_size: The desired size for the file.\n        Raises:\n          OSError: if the st_size arg is not a non-negative integer\n                   or if st_size exceeds the available file system space\n        \"\"\"\n        self._check_positive_int(st_size)\n        current_size = self.st_size or 0\n        self.filesystem.change_disk_usage(\n            st_size - current_size, self.name, self.st_dev)\n        if self._byte_contents:\n            if st_size < current_size:\n                self._byte_contents = self._byte_contents[:st_size]\n            else:\n                self._byte_contents += b'\\0' * (st_size - current_size)\n        self.st_size = st_size\n        self.epoch += 1\n", "docstring": "Resizes file content, padding with nulls if new size exceeds the"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def path(self) -> AnyStr:\n        \"\"\"Return the full path of the current object.\"\"\"\n        names: List[AnyStr] = []\n        obj: Optional[FakeFile] = self\n        while obj:\n            names.insert(\n                0, matching_string(self.name, obj.name))  # type: ignore\n            obj = obj.parent_dir\n        sep = self.filesystem.get_path_separator(names[0])\n        if names[0] == sep:\n            names.pop(0)\n            dir_path = sep.join(names)\n            drive = self.filesystem.splitdrive(dir_path)[0]\n            # if a Windows path already starts with a drive or UNC path,\n            # no extra separator is needed\n            if not drive:\n                dir_path = sep + dir_path\n        else:\n            dir_path = sep.join(names)\n        dir_path = self.filesystem.absnormpath(dir_path)\n        return dir_path\n", "docstring": "Return the full path of the current object.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def SetATime(self, st_atime):\n        \"\"\"Set the self.st_atime attribute.\n        Args:\n          st_atime: The desired access time.\n        \"\"\"\n        self.st_atime = st_atime\n", "docstring": "Set the self.st_atime attribute."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def SetMTime(self, st_mtime):\n        \"\"\"Set the self.st_mtime attribute.\n        Args:\n          st_mtime: The desired modification time.\n        \"\"\"\n        self.st_mtime = st_mtime\n", "docstring": "Set the self.st_mtime attribute."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def SetCTime(self, st_ctime):\n        \"\"\"Set the self.st_ctime attribute.\n        Args:\n          st_ctime: The desired creation time.\n        \"\"\"\n        self.st_ctime = st_ctime\n", "docstring": "Set the self.st_ctime attribute."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def __setattr__(self, key: str, value: Any) -> None:\n        \"\"\"Forward some properties to stat_result.\"\"\"\n        if key in self.stat_types:\n            return setattr(self.stat_result, key, value)\n        return super().__setattr__(key, value)\n", "docstring": "Forward some properties to stat_result.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def SetIno(self, st_ino):\n        \"\"\"Set the self.st_ino attribute.\n        Note that a unique inode is assigned automatically to a new fake file.\n        This function does not guarantee uniqueness and should be used with\n        caution.\n        Args:\n          st_ino: (int) The desired inode.\n        \"\"\"\n        self.st_ino = st_ino\n", "docstring": "Set the self.st_ino attribute."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def is_large_file(self):\n        \"\"\"The contents are never faked.\"\"\"\n        return False\n", "docstring": "The contents are never faked.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def entries(self) -> Dict[str, FakeFile]:\n        \"\"\"Return the list of contained directory entries.\"\"\"\n        return self._entries\n", "docstring": "Return the list of contained directory entries.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def ordered_dirs(self) -> List[str]:\n        \"\"\"Return the list of contained directory entry names ordered by\n        creation order.\n        \"\"\"\n        return [item[0] for item in sorted(\n            self._entries.items(), key=lambda entry: entry[1].st_ino)]\n", "docstring": "Return the list of contained directory entry names ordered by"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def get_entry(self, pathname_name: str) -> AnyFile:\n        \"\"\"Retrieves the specified child file or directory entry.\n        Args:\n            pathname_name: The basename of the child object to retrieve.\n        Returns:\n            The fake file or directory object.\n        Raises:\n            KeyError: if no child exists by the specified name.\n        \"\"\"\n        pathname_name = self._normalized_entryname(pathname_name)\n        return self.entries[to_string(pathname_name)]\n", "docstring": "Retrieves the specified child file or directory entry."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def remove_entry(self, pathname_name: str, recursive: bool = True) -> None:\n        \"\"\"Removes the specified child file or directory.\n        Args:\n            pathname_name: Basename of the child object to remove.\n            recursive: If True (default), the entries in contained directories\n                are deleted first. Used to propagate removal errors\n                (e.g. permission problems) from contained entries.\n        Raises:\n            KeyError: if no child exists by the specified name.\n            OSError: if user lacks permission to delete the file,\n                or (Windows only) the file is open.\n        \"\"\"\n        pathname_name = self._normalized_entryname(pathname_name)\n        entry = self.get_entry(pathname_name)\n        if self.filesystem.is_windows_fs:\n            if entry.st_mode & PERM_WRITE == 0:\n                self.filesystem.raise_os_error(errno.EACCES, pathname_name)\n            if self.filesystem.has_open_file(entry):\n                self.filesystem.raise_os_error(errno.EACCES, pathname_name)\n        else:\n            if (not is_root() and (self.st_mode & (PERM_WRITE | PERM_EXE) !=\n                                   PERM_WRITE | PERM_EXE)):\n                self.filesystem.raise_os_error(errno.EACCES, pathname_name)\n        if recursive and isinstance(entry, FakeDirectory):\n            while entry.entries:\n                entry.remove_entry(list(entry.entries)[0])\n        elif entry.st_nlink == 1:\n            self.filesystem.change_disk_usage(\n                -entry.size, pathname_name, entry.st_dev)\n        self.st_nlink -= 1\n        entry.st_nlink -= 1\n        assert entry.st_nlink >= 0\n        del self.entries[to_string(pathname_name)]\n", "docstring": "Removes the specified child file or directory."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def size(self) -> int:\n        \"\"\"Return the total size of all files contained in this directory tree.\n        \"\"\"\n        return sum([item[1].size for item in self.entries.items()])\n", "docstring": "Return the total size of all files contained in this directory tree."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def size(self, st_size: int) -> None:\n        \"\"\"Setting the size is an error for a directory.\"\"\"\n        raise self.filesystem.raise_os_error(errno.EISDIR, self.path)\n", "docstring": "Setting the size is an error for a directory.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def entries(self) -> Dict[str, FakeFile]:\n        \"\"\"Return the list of contained directory entries, loading them\n        if not already loaded.\"\"\"\n        if not self.contents_read:\n            self.contents_read = True\n            base = self.path\n            for entry in os.listdir(self.source_path):\n                source_path = os.path.join(self.source_path, entry)\n                target_path = os.path.join(base, entry)  # type: ignore\n                if os.path.islink(source_path):\n                    self.filesystem.add_real_symlink(source_path, target_path)\n                elif os.path.isdir(source_path):\n                    self.filesystem.add_real_directory(\n                        source_path, self.read_only, target_path=target_path)\n                else:\n                    self.filesystem.add_real_file(\n                        source_path, self.read_only, target_path=target_path)\n        return self._entries\n", "docstring": "Return the list of contained directory entries, loading them"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def size(self) -> int:\n        # we cannot get the size until the contents are loaded\n        if not self.contents_read:\n            return 0\n        return super(FakeDirectoryFromRealDirectory, self).size\n", "docstring": "we cannot get the size until the contents are loaded"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def os(self) -> OSType:\n        \"\"\"Return the real or simulated type of operating system.\"\"\"\n        return (OSType.WINDOWS if self.is_windows_fs else\n                OSType.MACOS if self.is_macos else OSType.LINUX)\n", "docstring": "Return the real or simulated type of operating system.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def os(self, value: OSType) -> None:\n        \"\"\"Set the simulated type of operating system underlying the fake\n        file system.\"\"\"\n        self.is_windows_fs = value == OSType.WINDOWS\n        self.is_macos = value == OSType.MACOS\n        self.is_case_sensitive = value == OSType.LINUX\n        self.path_separator = '\\\\' if value == OSType.WINDOWS else '/'\n        self.alternative_path_separator = ('/' if value == OSType.WINDOWS\n                                           else None)\n        self.reset()\n        FakePathModule.reset(self)\n", "docstring": "Set the simulated type of operating system underlying the fake"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def pause(self) -> None:\n        \"\"\"Pause the patching of the file system modules until `resume` is\n        called. After that call, all file system calls are executed in the\n        real file system.\n        Calling pause() twice is silently ignored.\n        Only allowed if the file system object was created by a\n        Patcher object. This is also the case for the pytest `fs` fixture.\n        Raises:\n            RuntimeError: if the file system was not created by a Patcher.\n        \"\"\"\n        if self.patcher is None:\n            raise RuntimeError('pause() can only be called from a fake file '\n                               'system object created by a Patcher object')\n        self.patcher.pause()\n", "docstring": "Pause the patching of the file system modules until `resume` is"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def clear_cache(self) -> None:\n        \"\"\"Clear the cache of non-patched modules.\"\"\"\n        if self.patcher:\n            self.patcher.clear_cache()\n", "docstring": "Clear the cache of non-patched modules.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def get_path_separator(self, path: AnyStr) -> AnyStr:\n        \"\"\"Return the path separator as the same type as path\"\"\"\n        return matching_string(path, self.path_separator)\n", "docstring": "Return the path separator as the same type as path\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def _starts_with_sep(self, path: AnyStr) -> bool:\n        \"\"\"Return True if path starts with a path separator.\"\"\"\n        sep = self.get_path_separator(path)\n        altsep = self._alternative_path_separator(path)\n        return (path.startswith(sep) or altsep is not None and\n                path.startswith(altsep))\n", "docstring": "Return True if path starts with a path separator.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def SetIno(self, path, st_ino):\n        \"\"\"Set the self.st_ino attribute of file at 'path'.\n        Note that a unique inode is assigned automatically to a new fake file.\n        Using this function does not guarantee uniqueness and should used\n        with caution.\n        Args:\n            path: Path to file.\n            st_ino: The desired inode.\n        \"\"\"\n        self.get_object(path).st_ino = st_ino\n", "docstring": "Set the self.st_ino attribute of file at 'path'."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def _close_open_file(self, file_des: int) -> None:\n        \"\"\"Remove file object with given descriptor from the list\n        of open files.\n        Sets the entry in open_files to None.\n        Args:\n            file_des: Descriptor of file object to be removed from\n            open files list.\n        \"\"\"\n        self.open_files[file_des] = None\n        heapq.heappush(self._free_fd_heap, file_des)\n", "docstring": "Remove file object with given descriptor from the list"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def has_open_file(self, file_object: FakeFile) -> bool:\n        \"\"\"Return True if the given file object is in the list of open files.\n        Args:\n            file_object: The FakeFile object to be checked.\n        Returns:\n            `True` if the file is open.\n        \"\"\"\n        return (file_object in [wrappers[0].get_object()\n                                for wrappers in self.open_files if wrappers])\n", "docstring": "Return True if the given file object is in the list of open files."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def normcase(self, path: AnyStr) -> AnyStr:\n        \"\"\"Replace all appearances of alternative path separator\n        with path separator.\n        Do nothing if no alternative separator is set.\n        Args:\n            path: The path to be normalized.\n        Returns:\n            The normalized path that will be used internally.\n        \"\"\"\n        file_path = make_string_path(path)\n        return self._normalize_path_sep(file_path)\n", "docstring": "Replace all appearances of alternative path separator"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def _original_path(self, path: AnyStr) -> AnyStr:\n        \"\"\"Return a normalized case version of the given path for\n        case-insensitive file systems. For case-sensitive file systems,\n        return path unchanged.\n        Args:\n            path: the file path to be transformed\n        Returns:\n            A version of path matching the case of existing path elements.\n        \"\"\"\n        def components_to_path():\n            if len(path_components) > len(normalized_components):\n                normalized_components.extend(\n                    to_string(p) for p in path_components[len(\n                        normalized_components):])\n            sep = self.path_separator\n            normalized_path = sep.join(normalized_components)\n            if (self._starts_with_sep(path)\n                    and not self._starts_with_sep(normalized_path)):\n                normalized_path = sep + normalized_path\n            return normalized_path\n        if self.is_case_sensitive or not path:\n            return path\n        path_components = self._path_components(path)\n        normalized_components = []\n        current_dir = self.root\n        for component in path_components:\n            if not isinstance(current_dir, FakeDirectory):\n                return components_to_path()\n            dir_name, directory = self._directory_content(\n                current_dir, to_string(component))\n            if directory is None or (\n                    isinstance(directory, FakeDirectory) and\n                    directory._byte_contents is None and\n                    directory.st_size == 0):\n                return components_to_path()\n            current_dir = cast(FakeDirectory, directory)\n            normalized_components.append(dir_name)\n        return components_to_path()\n", "docstring": "Return a normalized case version of the given path for"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def splitpath(self, path: AnyStr) -> Tuple[AnyStr, AnyStr]:\n        \"\"\"Mimic os.path.split using the specified path_separator.\n        Mimics os.path.split using the path_separator that was specified\n        for this FakeFilesystem.\n        Args:\n            path:  (str) The path to split.\n        Returns:\n            (str) A duple (pathname, basename) for which pathname does not\n            end with a slash, and basename does not contain a slash.\n        \"\"\"\n        full_path = path\n        path = self.normcase(path)\n        sep: AnyStr = self.get_path_separator(path)\n        drive, path = self.splitdrive(path)\n        path_components: List[AnyStr] = path.split(sep)\n        if not path_components:\n            return drive, matching_string(path, '')\n        basename = path_components.pop()\n        if not path_components:\n            return drive, basename\n        for component in path_components:\n            if component:\n                # The path is not the root; it contains a non-separator\n                # component. Strip all trailing separators.\n                while not path_components[-1]:\n                    path_components.pop()\n                if not path_components:\n                    return drive, basename\n                return drive + sep.join(path_components), basename\n        # Root path.  Collapse all leading separators.\n        if drive and not basename:\n            return full_path, basename\n        if drive and len(drive) == 2:\n            drive += sep\n        return drive or sep, basename\n", "docstring": "Mimic os.path.split using the specified path_separator."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def _starts_with_drive_letter(self, file_path: AnyStr) -> bool:\n        \"\"\"Return True if file_path starts with a drive letter.\n        Args:\n            file_path: the full path to be examined.\n        Returns:\n            `True` if drive letter support is enabled in the filesystem and\n            the path starts with a drive letter.\n        \"\"\"\n        colon = matching_string(file_path, ':')\n        if (len(file_path) >= 2 and\n                file_path[:1].isalpha and file_path[1:2] == colon):\n            if self.is_windows_fs:\n                return True\n            if os.name == 'nt':\n                # special case if we are emulating Posix under Windows\n                # check if the path exists because it has been mapped in\n                # this is not foolproof, but handles most cases\n                try:\n                    self.get_object_from_normpath(file_path)\n                    return True\n                except OSError:\n                    return False\n        return False\n", "docstring": "Return True if file_path starts with a drive letter."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def exists(self, file_path: AnyPath, check_link: bool = False) -> bool:\n        \"\"\"Return true if a path points to an existing file system object.\n        Args:\n            file_path:  The path to examine.\n            check_link: If True, links are not followed\n        Returns:\n            (bool) True if the corresponding object exists.\n        Raises:\n            TypeError: if file_path is None.\n        \"\"\"\n        if check_link and self.islink(file_path):\n            return True\n        path = to_string(make_string_path(file_path))\n        if path is None:\n            raise TypeError\n        if not path:\n            return False\n        if path == self.dev_null.name:\n            return not self.is_windows_fs or sys.version_info >= (3, 8)\n        try:\n            if self.is_filepath_ending_with_separator(path):\n                return False\n            path = self.resolve_path(path)\n        except OSError:\n            return False\n        if path == self.root.name:\n            return True\n        path_components: List[str] = self._path_components(path)\n        current_dir = self.root\n        for component in path_components:\n            directory = self._directory_content(\n                current_dir, to_string(component))[1]\n            if directory is None:\n                return False\n            current_dir = cast(FakeDirectory, directory)\n        return True\n", "docstring": "Return true if a path points to an existing file system object."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def add_object(self, file_path: AnyStr, file_object: AnyFile) -> None:\n        \"\"\"Add a fake file or directory into the filesystem at file_path.\n        Args:\n            file_path: The path to the file to be added relative to self.\n            file_object: File or directory to add.\n        Raises:\n            OSError: if file_path does not correspond to a\n                directory.\n        \"\"\"\n        if not file_path:\n            target_directory = self.root\n        else:\n            target_directory = cast(FakeDirectory, self.resolve(file_path))\n            if not S_ISDIR(target_directory.st_mode):\n                error = errno.ENOENT if self.is_windows_fs else errno.ENOTDIR\n                self.raise_os_error(error, file_path)\n        target_directory.add_entry(file_object)\n", "docstring": "Add a fake file or directory into the filesystem at file_path."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def _handle_broken_link_with_trailing_sep(self, path: AnyStr) -> None:\n        # note that the check for trailing sep has to be done earlier\n        if self.islink(path):\n            if not self.exists(path):\n                error = (errno.ENOENT if self.is_macos else\n                         errno.EINVAL if self.is_windows_fs else errno.ENOTDIR)\n                self.raise_os_error(error, path)\n", "docstring": "note that the check for trailing sep has to be done earlier"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def readlink(self, path: AnyPath) -> str:\n        \"\"\"Read the target of a symlink.\n        Args:\n            path:  symlink to read the target of.\n        Returns:\n            the string representing the path to which the symbolic link points.\n        Raises:\n            TypeError: if path is None\n            OSError: (with errno=ENOENT) if path is not a valid path, or\n                (with errno=EINVAL) if path is valid, but is not a symlink,\n                or if the path ends with a path separator (Posix only)\n        \"\"\"\n        if path is None:\n            raise TypeError\n        link_path = make_string_path(path)\n        link_obj = self.lresolve(link_path)\n        if S_IFMT(link_obj.st_mode) != S_IFLNK:\n            self.raise_os_error(errno.EINVAL, link_path)\n        if self.ends_with_path_separator(link_path):\n            if not self.is_windows_fs and self.exists(link_path):\n                self.raise_os_error(errno.EINVAL, link_path)\n            if not self.exists(link_obj.path):  # type: ignore\n                if self.is_windows_fs:\n                    error = errno.EINVAL\n                elif self._is_circular_link(link_obj):\n                    if self.is_macos:\n                        return link_obj.path  # type: ignore[return-value]\n                    error = errno.ELOOP\n                else:\n                    error = errno.ENOENT\n                self.raise_os_error(error, link_obj.path)\n        assert link_obj.contents\n        return link_obj.contents\n", "docstring": "Read the target of a symlink."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def isfile(self, path: AnyPath, follow_symlinks: bool = True) -> bool:\n        \"\"\"Determine if path identifies a regular file.\n        Args:\n            path: Path to filesystem object.\n        Returns:\n            `True` if path points to a regular file (following symlinks).\n        Raises:\n            TypeError: if path is None.\n        \"\"\"\n        return self._is_of_type(path, S_IFREG, follow_symlinks,\n                                check_read_perm=False)\n", "docstring": "Determine if path identifies a regular file."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def confirmdir(self, target_directory: AnyStr) -> FakeDirectory:\n        \"\"\"Test that the target is actually a directory, raising OSError\n        if not.\n        Args:\n            target_directory: Path to the target directory within the fake\n                filesystem.\n        Returns:\n            The FakeDirectory object corresponding to target_directory.\n        Raises:\n            OSError: if the target is not a directory.\n        \"\"\"\n        directory = cast(FakeDirectory, self.resolve(target_directory))\n        if not directory.st_mode & S_IFDIR:\n            self.raise_os_error(errno.ENOTDIR, target_directory, 267)\n        return directory\n", "docstring": "Test that the target is actually a directory, raising OSError"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def dir() -> List[str]:\n        \"\"\"Return the list of patched function names. Used for patching\n        functions imported from the module.\n        \"\"\"\n        return [\n            'abspath', 'dirname', 'exists', 'expanduser', 'getatime',\n            'getctime', 'getmtime', 'getsize', 'isabs', 'isdir', 'isfile',\n            'islink', 'ismount', 'join', 'lexists', 'normcase', 'normpath',\n            'realpath', 'relpath', 'split', 'splitdrive', 'samefile'\n        ]\n", "docstring": "Return the list of patched function names. Used for patching"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def lexists(self, path: AnyStr) -> bool:\n        \"\"\"Test whether a path exists.  Returns True for broken symbolic links.\n        Args:\n          path:  path to the symlink object.\n        Returns:\n          bool (if file exists).\n        \"\"\"\n        return self.filesystem.exists(path, check_link=True)\n", "docstring": "Test whether a path exists.  Returns True for broken symbolic links."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def isabs(self, path: AnyStr) -> bool:\n        \"\"\"Return True if path is an absolute pathname.\"\"\"\n        if self.filesystem.is_windows_fs:\n            path = self.splitdrive(path)[1]\n        path = make_string_path(path)\n        return self.filesystem._starts_with_sep(path)\n", "docstring": "Return True if path is an absolute pathname.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def isfile(self, path: AnyStr) -> bool:\n        \"\"\"Determine if path identifies a regular file.\"\"\"\n        return self.filesystem.isfile(path)\n", "docstring": "Determine if path identifies a regular file.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def getmtime(self, path: AnyStr) -> float:\n        \"\"\"Returns the modification time of the fake file.\n        Args:\n            path: the path to fake file.\n        Returns:\n            (int, float) the modification time of the fake file\n                         in number of seconds since the epoch.\n        Raises:\n            OSError: if the file does not exist.\n        \"\"\"\n        try:\n            file_obj = self.filesystem.resolve(path)\n            return file_obj.st_mtime\n        except OSError:\n            self.filesystem.raise_os_error(errno.ENOENT, winerror=3)\n", "docstring": "Returns the modification time of the fake file."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def getctime(self, path: AnyStr) -> float:\n        \"\"\"Returns the creation time of the fake file.\n        Args:\n            path: the path to fake file.\n        Returns:\n            (int, float) the creation time of the fake file in number of\n                seconds since the epoch.\n        Raises:\n            OSError: if the file does not exist.\n        \"\"\"\n        try:\n            file_obj = self.filesystem.resolve(path)\n        except OSError:\n            self.filesystem.raise_os_error(errno.ENOENT)\n        return file_obj.st_ctime\n", "docstring": "Returns the creation time of the fake file."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "        def getcwd():\n            \"\"\"Return the current working directory.\"\"\"\n            # pylint: disable=undefined-variable\n            if isinstance(path, bytes):\n                return self.os.getcwdb()\n            else:\n                return self.os.getcwd()\n", "docstring": "Return the current working directory.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def join(self, *p: AnyStr) -> AnyStr:\n        \"\"\"Return the completed path with a separator of the parts.\"\"\"\n        return self.filesystem.joinpaths(*p)\n", "docstring": "Return the completed path with a separator of the parts.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def splitdrive(self, path: AnyStr) -> Tuple[AnyStr, AnyStr]:\n        \"\"\"Split the path into the drive part and the rest of the path, if\n        supported.\"\"\"\n        return self.filesystem.splitdrive(path)\n", "docstring": "Split the path into the drive part and the rest of the path, if"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def normcase(self, path: AnyStr) -> AnyStr:\n        \"\"\"Convert to lower case under windows, replaces additional path\n        separator.\"\"\"\n        path = self.filesystem.normcase(path)\n        if self.filesystem.is_windows_fs:\n            path = path.lower()\n        return path\n", "docstring": "Convert to lower case under windows, replaces additional path"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def realpath(self, filename: AnyStr, strict: bool = None) -> AnyStr:\n        \"\"\"Return the canonical path of the specified filename, eliminating any\n        symbolic links encountered in the path.\n        \"\"\"\n        if strict is not None and sys.version_info < (3, 10):\n            raise TypeError(\"realpath() got an unexpected \"\n                            \"keyword argument 'strict'\")\n        if strict:\n            # raises in strict mode if the file does not exist\n            self.filesystem.resolve(filename)\n        if self.filesystem.is_windows_fs:\n            return self.abspath(filename)\n        filename = make_string_path(filename)\n        path, ok = self._join_real_path(filename[:0], filename, {})\n        path = self.abspath(path)\n        return path\n", "docstring": "Return the canonical path of the specified filename, eliminating any"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def dirname(self, path: AnyStr) -> AnyStr:\n        \"\"\"Returns the first part of the result of `split()`.\"\"\"\n        return self.split(path)[0]\n", "docstring": "Returns the first part of the result of `split()`.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def ismount(self, path: AnyStr) -> bool:\n        \"\"\"Return true if the given path is a mount point.\n        Args:\n            path: Path to filesystem object to be checked\n        Returns:\n            `True` if path is a mount point added to the fake file system.\n            Under Windows also returns True for drive and UNC roots\n            (independent of their existence).\n        \"\"\"\n        if not path:\n            return False\n        path_str = to_string(make_string_path(path))\n        normed_path = self.filesystem.absnormpath(path_str)\n        sep = self.filesystem.path_separator\n        if self.filesystem.is_windows_fs:\n            path_seps: Union[Tuple[str, Optional[str]], Tuple[str]]\n            if self.filesystem.alternative_path_separator is not None:\n                path_seps = (\n                    sep, self.filesystem.alternative_path_separator\n                )\n            else:\n                path_seps = (sep,)\n            drive, rest = self.filesystem.splitdrive(normed_path)\n            if drive and drive[:1] in path_seps:\n                return (not rest) or (rest in path_seps)\n            if rest in path_seps:\n                return True\n        for mount_point in self.filesystem.mount_points:\n            if (to_string(normed_path).rstrip(sep) ==\n                    to_string(mount_point).rstrip(sep)):\n                return True\n        return False\n", "docstring": "Return true if the given path is a mount point."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def dir() -> List[str]:\n        \"\"\"Return the list of patched function names. Used for patching\n        functions imported from the module.\n        \"\"\"\n        _dir = [\n            'access', 'chdir', 'chmod', 'chown', 'close', 'fstat', 'fsync',\n            'getcwd', 'lchmod', 'link', 'listdir', 'lstat', 'makedirs',\n            'mkdir', 'mknod', 'open', 'read', 'readlink', 'remove',\n            'removedirs', 'rename', 'rmdir', 'stat', 'symlink', 'umask',\n            'unlink', 'utime', 'walk', 'write', 'getcwdb', 'replace'\n        ]\n        if sys.platform.startswith('linux'):\n            _dir += [\n                'fdatasync', 'getxattr', 'listxattr',\n                'removexattr', 'setxattr'\n            ]\n        if use_scandir:\n            _dir += ['scandir']\n        return _dir\n", "docstring": "Return the list of patched function names. Used for patching"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def _umask(self) -> int:\n        \"\"\"Return the current umask.\"\"\"\n        if self.filesystem.is_windows_fs:\n            # windows always returns 0 - it has no real notion of umask\n            return 0\n        if sys.platform == 'win32':\n            # if we are testing Unix under Windows we assume a default mask\n            return 0o002\n        else:\n            # under Unix, we return the real umask;\n            # as there is no pure getter for umask, so we have to first\n            # set a mode to get the previous one and then re-set that\n            mask = os.umask(0)\n            os.umask(mask)\n            return mask\n", "docstring": "Return the current umask.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def close(self, fd: int) -> None:\n        \"\"\"Close a file descriptor.\n        Args:\n            fd: An integer file descriptor for the file object requested.\n        Raises:\n            OSError: bad file descriptor.\n            TypeError: if file descriptor is not an integer.\n        \"\"\"\n        file_handle = self.filesystem.get_open_file(fd)\n        file_handle.close()\n", "docstring": "Close a file descriptor."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def write(self, fd: int, contents: bytes) -> int:\n        \"\"\"Write string to file descriptor, returns number of bytes written.\n        Args:\n            fd: An integer file descriptor for the file object requested.\n            contents: String of bytes to write to file.\n        Returns:\n            Number of bytes written.\n        Raises:\n            OSError: bad file descriptor.\n            TypeError: if file descriptor is not an integer.\n        \"\"\"\n        file_handle = cast(FakeFileWrapper, self.filesystem.get_open_file(fd))\n        if isinstance(file_handle, FakeDirWrapper):\n            self.filesystem.raise_os_error(errno.EBADF, file_handle.file_path)\n        if isinstance(file_handle, FakePipeWrapper):\n            return file_handle.write(contents)\n        file_handle.raw_io = True\n        file_handle._sync_io()\n        file_handle.update_flush_pos()\n        file_handle.write(contents)\n        file_handle.flush()\n        return len(contents)\n", "docstring": "Write string to file descriptor, returns number of bytes written."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def stat_float_times(newvalue: Optional[bool] = None) -> bool:\n        \"\"\"Determine whether a file's time stamps are reported as floats\n        or ints.\n        Calling without arguments returns the current value. The value is\n        shared by all instances of FakeOsModule.\n        Args:\n            newvalue: If `True`, mtime, ctime, atime are reported as floats.\n                Otherwise, they are returned as ints (rounding down).\n        \"\"\"\n        return FakeStatResult.stat_float_times(newvalue)\n", "docstring": "Determine whether a file's time stamps are reported as floats"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def umask(self, mask: int) -> int:\n        \"\"\"Change the current umask.\n        Args:\n            mask: (int) The new umask value.\n        Returns:\n            The old umask.\n        Raises:\n            TypeError: if new_mask is of an invalid type.\n        \"\"\"\n        if not is_int_type(mask):\n            raise TypeError('an integer is required')\n        old_umask = self.filesystem.umask\n        self.filesystem.umask = mask\n        return old_umask\n", "docstring": "Change the current umask."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def getcwd(self) -> str:\n        \"\"\"Return current working directory.\"\"\"\n        return to_string(self.filesystem.cwd)\n", "docstring": "Return current working directory.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def listdir(self, path: AnyStr) -> List[AnyStr]:\n        \"\"\"Return a list of file names in target_directory.\n        Args:\n            path: Path to the target directory within the fake\n                filesystem.\n        Returns:\n            A list of file names within the target directory in arbitrary\n                order.\n        Raises:\n          OSError:  if the target is not a directory.\n        \"\"\"\n        return self.filesystem.listdir(path)\n", "docstring": "Return a list of file names in target_directory."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def scandir(self, path: str = '.') -> ScanDirIter:\n        \"\"\"Return an iterator of DirEntry objects corresponding to the\n        entries in the directory given by path.\n        Args:\n            path: Path to the target directory within the fake filesystem.\n        Returns:\n            An iterator to an unsorted list of os.DirEntry objects for\n            each entry in path.\n        Raises:\n            OSError: if the target is not a directory.\n        \"\"\"\n        return scandir(self.filesystem, path)\n", "docstring": "Return an iterator of DirEntry objects corresponding to the"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def readlink(self, path: AnyStr, dir_fd: Optional[int] = None) -> str:\n        \"\"\"Read the target of a symlink.\n        Args:\n            path:  Symlink to read the target of.\n            dir_fd: If not `None`, the file descriptor of a directory,\n                with `path` being relative to this directory.\n        Returns:\n            the string representing the path to which the symbolic link points.\n        Raises:\n            TypeError: if `path` is None\n            OSError: (with errno=ENOENT) if path is not a valid path, or\n                     (with errno=EINVAL) if path is valid, but is not a symlink\n        \"\"\"\n        path = self._path_with_dir_fd(path, self.readlink, dir_fd)\n        return self.filesystem.readlink(path)\n", "docstring": "Read the target of a symlink."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def unlink(self, path: AnyStr, *, dir_fd: Optional[int] = None) -> None:\n        \"\"\"Remove the FakeFile object at the specified file path.\n        Args:\n            path: Path to file to be removed.\n            dir_fd: If not `None`, the file descriptor of a directory,\n                with `path` being relative to this directory.\n        Raises:\n            OSError: if path points to a directory.\n            OSError: if path does not exist.\n            OSError: if removal failed.\n        \"\"\"\n        path = self._path_with_dir_fd(path, self.unlink, dir_fd)\n        self.filesystem.remove(path)\n", "docstring": "Remove the FakeFile object at the specified file path."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def removedirs(self, name: AnyStr) -> None:\n        \"\"\"Remove a leaf fake directory and all empty intermediate ones.\n        Args:\n            name: the directory to be removed.\n        Raises:\n            OSError: if target_directory does not exist or is not a directory.\n            OSError: if target_directory is not empty.\n        \"\"\"\n        name = self.filesystem.absnormpath(name)\n        directory = self.filesystem.confirmdir(name)\n        if directory.entries:\n            self.filesystem.raise_os_error(\n                errno.ENOTEMPTY, self.path.basename(name))\n        else:\n            self.rmdir(name)\n        head, tail = self.path.split(name)\n        if not tail:\n            head, tail = self.path.split(head)\n        while head and tail:\n            head_dir = self.filesystem.confirmdir(head)\n            if head_dir.entries:\n                break\n            # only the top-level dir may not be a symlink\n            self.filesystem.rmdir(head, allow_symlink=True)\n            head, tail = self.path.split(head)\n", "docstring": "Remove a leaf fake directory and all empty intermediate ones."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def truncate(self, path: AnyStr, length: int) -> None:\n        \"\"\"Truncate the file corresponding to path, so that it is\n         length bytes in size. If length is larger than the current size,\n         the file is filled up with zero bytes.\n        Args:\n            path: (str or int) Path to the file, or an integer file\n                descriptor for the file object.\n            length: (int) Length of the file after truncating it.\n        Raises:\n            OSError: if the file does not exist or the file descriptor is\n                invalid.\n         \"\"\"\n        file_object = self.filesystem.resolve(path, allow_fd=True)\n        file_object.size = length\n", "docstring": "Truncate the file corresponding to path, so that it is"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def lchmod(self, path: AnyStr, mode: int) -> None:\n        \"\"\"Change the permissions of a file as encoded in integer mode.\n        If the file is a link, the permissions of the link are changed.\n        Args:\n          path: (str) Path to the file.\n          mode: (int) Permissions.\n        \"\"\"\n        if self.filesystem.is_windows_fs:\n            raise NameError(\"name 'lchmod' is not defined\")\n        self.filesystem.chmod(path, mode, follow_symlinks=False)\n", "docstring": "Change the permissions of a file as encoded in integer mode."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def fsync(self, fd: int) -> None:\n        \"\"\"Perform fsync for a fake file (in other words, do nothing).\n        Args:\n            fd: The file descriptor of the open file.\n        Raises:\n            OSError: file_des is an invalid file descriptor.\n            TypeError: file_des is not an integer.\n        \"\"\"\n        # Throw an error if file_des isn't valid\n        if 0 <= fd < NR_STD_STREAMS:\n            self.filesystem.raise_os_error(errno.EINVAL)\n        file_object = cast(FakeFileWrapper, self.filesystem.get_open_file(fd))\n        if self.filesystem.is_windows_fs:\n            if (not hasattr(file_object, 'allow_update') or\n                    not file_object.allow_update):\n                self.filesystem.raise_os_error(\n                    errno.EBADF, file_object.file_path)\n", "docstring": "Perform fsync for a fake file (in other words, do nothing)."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def dir() -> List[str]:\n        \"\"\"Return the list of patched function names. Used for patching\n        functions imported from the module.\n        \"\"\"\n        _dir = ['open']\n        if sys.version_info >= (3, 8):\n            _dir.append('open_code')\n        return _dir\n", "docstring": "Return the list of patched function names. Used for patching"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "        def open_code(self, path):\n            \"\"\"Redirect the call to open. Note that the behavior of the real\n            function may be overridden by an earlier call to the\n            PyFile_SetOpenCodeHook(). This behavior is not reproduced here.\n            \"\"\"\n            if not isinstance(path, str):\n                raise TypeError(\n                    \"open_code() argument 'path' must be str, not int\")\n            patch_mode = self.filesystem.patch_open_code\n            if (patch_mode == PatchMode.AUTO and self.filesystem.exists(path)\n                    or patch_mode == PatchMode.ON):\n                return self.open(path, mode='rb')\n            # mostly this is used for compiled code -\n            # don't patch these, as the files are probably in the real fs\n            return self._io_module.open_code(path)\n", "docstring": "Redirect the call to open. Note that the behavior of the real"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def get_object(self) -> FakeFile:\n        \"\"\"Return the FakeFile object that is wrapped by the current instance.\n        \"\"\"\n        return self.file_object\n", "docstring": "Return the FakeFile object that is wrapped by the current instance."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def close(self) -> None:\n        \"\"\"Close the file.\"\"\"\n        # ignore closing a closed file\n        if not self._is_open():\n            return\n        # for raw io, all writes are flushed immediately\n        if self.allow_update and not self.raw_io:\n            self.flush()\n            if self._filesystem.is_windows_fs and self._changed:\n                self.file_object.st_mtime = now()\n        assert self.filedes is not None\n        if self._closefd:\n            self._filesystem._close_open_file(self.filedes)\n        else:\n            open_files = self._filesystem.open_files[self.filedes]\n            assert open_files is not None\n            open_files.remove(self)\n        if self.delete_on_close:\n            self._filesystem.remove_object(\n                self.get_object().path)  # type: ignore[arg-type]\n", "docstring": "Close the file.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def closed(self) -> bool:\n        \"\"\"Simulate the `closed` attribute on file.\"\"\"\n        return not self._is_open()\n", "docstring": "Simulate the `closed` attribute on file.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def flush(self) -> None:\n        \"\"\"Flush file contents to 'disk'.\"\"\"\n        self._check_open_file()\n        if self.allow_update and not self.is_stream:\n            contents = self._io.getvalue()\n            if self._append:\n                self._sync_io()\n                old_contents = self.file_object.byte_contents\n                assert old_contents is not None\n                contents = old_contents + contents[self._flush_pos:]\n                self._set_stream_contents(contents)\n            else:\n                self._io.flush()\n            self.update_flush_pos()\n            if self.file_object.set_contents(contents, self._encoding):\n                if self._filesystem.is_windows_fs:\n                    self._changed = True\n                else:\n                    current_time = now()\n                    self.file_object.st_ctime = current_time\n                    self.file_object.st_mtime = current_time\n            self._file_epoch = self.file_object.epoch\n            if not self.is_stream:\n                self._flush_related_files()\n", "docstring": "Flush file contents to 'disk'.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def tell(self) -> int:\n        \"\"\"Return the file's current position.\n        Returns:\n          int, file's current position in bytes.\n        \"\"\"\n        self._check_open_file()\n        if not self.is_stream:\n            self.flush()\n        if not self._append:\n            return self._io.tell()\n        if self._read_whence:\n            write_seek = self._io.tell()\n            self._io.seek(self._read_seek, self._read_whence)\n            self._read_seek = self._io.tell()\n            self._read_whence = 0\n            self._io.seek(write_seek)\n        return self._read_seek\n", "docstring": "Return the file's current position."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "        def read_wrapper(*args, **kwargs):\n            \"\"\"Wrap all read calls to the stream object.\n            We do this to track the read pointer separate from the write\n            pointer.  Anything that wants to read from the stream object\n            while we're in append mode goes through this.\n            Args:\n                *args: pass through args\n                **kwargs: pass through kwargs\n            Returns:\n                Wrapped stream object method\n            \"\"\"\n            self._io.seek(self._read_seek, self._read_whence)\n            ret_value = io_attr(*args, **kwargs)\n            self._read_seek = self._io.tell()\n            self._read_whence = 0\n            self._io.seek(0, 2)\n            return ret_value\n", "docstring": "Wrap all read calls to the stream object."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def _other_wrapper(self, name: str) -> Callable:\n        \"\"\"Wrap a stream attribute in an other_wrapper.\n        Args:\n          name: the name of the stream attribute to wrap.\n        Returns:\n          other_wrapper which is described below.\n        \"\"\"\n        io_attr = getattr(self._io, name)\n        def other_wrapper(*args, **kwargs):\n            \"\"\"Wrap all other calls to the stream Object.\n            We do this to track changes to the write pointer.  Anything that\n            moves the write pointer in a file open for appending should move\n            the read pointer as well.\n            Args:\n                *args: Pass through args.\n                **kwargs: Pass through kwargs.\n            Returns:\n                Wrapped stream object method.\n            \"\"\"\n            write_seek = self._io.tell()\n            ret_value = io_attr(*args, **kwargs)\n            if write_seek != self._io.tell():\n                self._read_seek = self._io.tell()\n                self._read_whence = 0\n            return ret_value\n        return other_wrapper\n", "docstring": "Wrap a stream attribute in an other_wrapper."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "        def write_wrapper(*args, **kwargs):\n            \"\"\"Wrap all other calls to the stream Object.\n            We do this to track changes to the write pointer.  Anything that\n            moves the write pointer in a file open for appending should move\n            the read pointer as well.\n            Args:\n                *args: Pass through args.\n                **kwargs: Pass through kwargs.\n            Returns:\n                Wrapped stream object method.\n            \"\"\"\n            old_pos = self._io.tell()\n            ret_value = io_attr(*args, **kwargs)\n            new_pos = self._io.tell()\n            # if the buffer size is exceeded, we flush\n            use_line_buf = self._use_line_buffer and '\\n' in args[0]\n            if new_pos - self._flush_pos > self._buffer_size or use_line_buf:\n                flush_all = (new_pos - old_pos > self._buffer_size or\n                             use_line_buf)\n                # if the current write does not exceed the buffer size,\n                # we revert to the previous position and flush that,\n                # otherwise we flush all\n                if not flush_all:\n                    self._io.seek(old_pos)\n                    self._io.truncate()\n                self._try_flush(old_pos)\n                if not flush_all:\n                    ret_value = io_attr(*args, **kwargs)\n            if self._append:\n                self._read_seek = self._io.tell()\n                self._read_whence = 0\n            return ret_value\n", "docstring": "Wrap all other calls to the stream Object."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "        def truncate_wrapper(*args, **kwargs):\n            \"\"\"Wrap truncate call to call flush after truncate.\"\"\"\n            if self._append:\n                self._io.seek(self._read_seek, self._read_whence)\n            size = io_attr(*args, **kwargs)\n            self.flush()\n            if not self.is_stream:\n                self.file_object.size = size\n                buffer_size = len(self._io.getvalue())\n                if buffer_size < size:\n                    self._io.seek(buffer_size)\n                    self._io.putvalue(b'\\0' * (size - buffer_size))\n                    self.file_object.set_contents(\n                        self._io.getvalue(), self._encoding)\n                    self._flush_pos = size\n                    self._adapt_size_for_related_files(size - buffer_size)\n            self.flush()\n            return size\n", "docstring": "Wrap truncate call to call flush after truncate.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def size(self) -> int:\n        \"\"\"Return the content size in bytes of the wrapped file.\"\"\"\n        return self.file_object.st_size\n", "docstring": "Return the content size in bytes of the wrapped file.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "        def write_error(*args, **kwargs):\n            \"\"\"Throw an error.\"\"\"\n            if self.raw_io:\n                if (self._filesystem.is_windows_fs and args\n                        and len(args[0]) == 0):\n                    return 0\n            self._raise('File is not open for writing.')\n", "docstring": "Throw an error.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def fileno(self) -> int:\n        \"\"\"Return the file descriptor of the wrapped standard stream.\"\"\"\n        if self.filedes is not None:\n            return self.filedes\n        raise OSError(errno.EBADF, 'Invalid file descriptor')\n", "docstring": "Return the file descriptor of the wrapped standard stream.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def close(self) -> None:\n        \"\"\"We do not support closing standard streams.\"\"\"\n        pass\n", "docstring": "We do not support closing standard streams.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def fileno(self) -> int:\n        \"\"\"Return the file descriptor of the file object.\"\"\"\n        if self.filedes is not None:\n            return self.filedes\n        raise OSError(errno.EBADF, 'Invalid file descriptor')\n", "docstring": "Return the file descriptor of the file object.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def fileno(self) -> int:\n        \"\"\"Return the fake file descriptor of the pipe object.\"\"\"\n        if self.filedes is not None:\n            return self.filedes\n        raise OSError(errno.EBADF, 'Invalid file descriptor')\n", "docstring": "Return the fake file descriptor of the pipe object.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def flush(self) -> None:\n        \"\"\"Flush the real pipe?\"\"\"\n        pass\n", "docstring": "Flush the real pipe?\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem.py", "original_string": "    def close(self) -> None:\n        \"\"\"Close the pipe descriptor.\"\"\"\n        assert self.filedes is not None\n        open_files = self._filesystem.open_files[self.filedes]\n        assert open_files is not None\n        open_files.remove(self)\n        os.close(self.fd)\n", "docstring": "Close the pipe descriptor.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "def init_module(filesystem):\n    \"\"\"Initializes the fake module with the fake file system.\"\"\"\n    # pylint: disable=protected-access\n    FakePath.filesystem = filesystem\n    FakePathlibModule.PureWindowsPath._flavour = _FakeWindowsFlavour(\n        filesystem)\n    FakePathlibModule.PurePosixPath._flavour = _FakePosixFlavour(filesystem)\n", "docstring": "Initializes the fake module with the fake file system.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "        def lchmod(self, pathobj,  *args, **kwargs):\n            \"\"\"Raises not implemented for Windows systems.\"\"\"\n            raise NotImplementedError(\"lchmod() not available on this system\")\n", "docstring": "Raises not implemented for Windows systems.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def casefold(self, path):\n        \"\"\"Return the lower-case version of s for a Windows filesystem.\"\"\"\n        if self.filesystem.is_windows_fs:\n            return path.lower()\n        return path\n", "docstring": "Return the lower-case version of s for a Windows filesystem.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def resolve(self, path, strict):\n        \"\"\"Make the path absolute, resolving any symlinks.\"\"\"\n        if self.filesystem.is_windows_fs:\n            return self._resolve_windows(path, strict)\n        return self._resolve_posix(path, strict)\n", "docstring": "Make the path absolute, resolving any symlinks.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def is_reserved(self, parts):\n        \"\"\"Return True if the path is considered reserved under Windows.\"\"\"\n        # NOTE: the rules for reserved names seem somewhat complicated\n        # (e.g. r\"..\\NUL\" is reserved but not r\"foo\\NUL\").\n        # We err on the side of caution and return True for paths which are\n        # not considered reserved by Windows.\n        if not parts:\n            return False\n        if self.filesystem.is_windows_fs and parts[0].startswith('\\\\\\\\'):\n            # UNC paths are never reserved\n            return False\n        return parts[-1].partition('.')[0].upper() in self.reserved_names\n", "docstring": "Return True if the path is considered reserved under Windows.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def gethomedir(self, username):\n        \"\"\"Return the home directory of the current user.\"\"\"\n        # original version, not faked\n        if 'HOME' in os.environ:\n            userhome = os.environ['HOME']\n        elif 'USERPROFILE' in os.environ:\n            userhome = os.environ['USERPROFILE']\n        elif 'HOMEPATH' in os.environ:\n            try:\n                drv = os.environ['HOMEDRIVE']\n            except KeyError:\n                drv = ''\n            userhome = drv + os.environ['HOMEPATH']\n        else:\n            raise RuntimeError(\"Can't determine home directory\")\n        if username:\n            # Try to guess user home directory.  By default all users\n            # directories are located in the same place and are named by\n            # corresponding usernames.  If current user home directory points\n            # to nonstandard place, this guess is likely wrong.\n            if os.environ['USERNAME'] != username:\n                drv, root, parts = self.parse_parts((userhome,))\n                if parts[-1] != os.environ['USERNAME']:\n                    raise RuntimeError(\"Can't determine home directory \"\n                                       \"for %r\" % username)\n                parts[-1] = username\n                if drv or root:\n                    userhome = drv + root + self.join(parts[1:])\n                else:\n                    userhome = self.join(parts)\n        return userhome\n", "docstring": "Return the home directory of the current user.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def gethomedir(self, username):\n        # original version, not faked\n        if not username:\n            try:\n                return os.environ['HOME']\n            except KeyError:\n                import pwd\n                return pwd.getpwuid(os.getuid()).pw_dir\n        else:\n            import pwd\n            try:\n                return pwd.getpwnam(username).pw_dir\n            except KeyError:\n                raise RuntimeError(\"Can't determine home directory \"\n                                   \"for %r\" % username)\n", "docstring": "original version, not faked"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def __new__(cls, *args, **kwargs):\n        \"\"\"Creates the correct subclass based on OS.\"\"\"\n        if cls is FakePathlibModule.Path:\n            cls = (FakePathlibModule.WindowsPath\n                   if cls.filesystem.is_windows_fs\n                   else FakePathlibModule.PosixPath)\n        self = cls._from_parts(args)\n        return self\n", "docstring": "Creates the correct subclass based on OS.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def _from_parts(cls, args, init=False):  # pylint: disable=unused-argument\n        # Overwritten to call _init to set the fake accessor,\n        # which is not done since Python 3.10\n        self = object.__new__(cls)\n        self._init()\n        drv, root, parts = self._parse_args(args)\n        self._drv = drv\n        self._root = root\n        self._parts = parts\n        return self\n", "docstring": "Overwritten to call _init to set the fake accessor,"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def _from_parsed_parts(cls, drv, root, parts):\n        # Overwritten to call _init to set the fake accessor,\n        # which is not done since Python 3.10\n        self = object.__new__(cls)\n        self._init()\n        self._drv = drv\n        self._root = root\n        self._parts = parts\n        return self\n", "docstring": "Overwritten to call _init to set the fake accessor,"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def _path(self):\n        \"\"\"Returns the underlying path string as used by the fake filesystem.\n        \"\"\"\n        return str(self)\n", "docstring": "Returns the underlying path string as used by the fake filesystem."}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def cwd(cls):\n        \"\"\"Return a new path pointing to the current working directory\n        (as returned by os.getcwd()).\n        \"\"\"\n        return cls(cls.filesystem.cwd)\n", "docstring": "Return a new path pointing to the current working directory"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def write_text(self, data, encoding=None, errors=None, newline=None):\n        \"\"\"Open the fake file in text mode, write to it, and close\n        the file.\n        Args:\n            data: the string to be written\n            encoding: the encoding used for the string; if not given, the\n                default locale encoding is used\n            errors: (str) Defines how encoding errors are handled.\n            newline: Controls universal newlines, passed to stream object.\n                New in Python 3.10.\n        Raises:\n            TypeError: if data is not of type 'str'.\n            OSError: if the target object is a directory, the path is\n                invalid or permission is denied.\n        \"\"\"\n        if not isinstance(data, str):\n            raise TypeError('data must be str, not %s' %\n                            data.__class__.__name__)\n        if newline is not None and sys.version_info < (3, 10):\n            raise TypeError(\"write_text() got an unexpected \"\n                            \"keyword argument 'newline'\")\n        with FakeFileOpen(self.filesystem)(self._path(),\n                                           mode='w',\n                                           encoding=encoding,\n                                           errors=errors,\n                                           newline=newline) as f:\n            return f.write(data)\n", "docstring": "Open the fake file in text mode, write to it, and close"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def home(cls):\n        \"\"\"Return a new path pointing to the user's home directory (as\n        returned by os.path.expanduser('~')).\n        \"\"\"\n        home = os.path.expanduser(\"~\")\n        if cls.filesystem.is_windows_fs != (os.name == 'nt'):\n            username = os.path.split(home)[1]\n            if cls.filesystem.is_windows_fs:\n                home = os.path.join('C:', 'Users', username)\n            else:\n                home = os.path.join('home', username)\n            cls.filesystem.create_dir(home)\n        return cls(home.replace(os.sep, cls.filesystem.path_separator))\n", "docstring": "Return a new path pointing to the user's home directory (as"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def expanduser(self):\n        \"\"\" Return a new path with expanded ~ and ~user constructs\n        (as returned by os.path.expanduser)\n        \"\"\"\n        return FakePath(os.path.expanduser(self._path())\n                        .replace(os.path.sep,\n                                 self.filesystem.path_separator))\n", "docstring": "Return a new path with expanded ~ and ~user constructs"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def __getattr__(self, name):\n        \"\"\"Forwards any unfaked calls to the standard pathlib module.\"\"\"\n        return getattr(self._pathlib_module, name)\n", "docstring": "Forwards any unfaked calls to the standard pathlib module.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def __init__(self, filesystem=None):\n        if self.fake_pathlib is None:\n            self.__class__.fake_pathlib = FakePathlibModule(filesystem)\n", "docstring": "if self.fake_pathlib is None:"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def __new__(cls, *args, **kwargs):\n        \"\"\"Creates the correct subclass based on OS.\"\"\"\n        if cls is RealPathlibModule.Path:\n            cls = (RealPathlibModule.WindowsPath if os.name == 'nt'\n                   else RealPathlibModule.PosixPath)\n        self = cls._from_parts(args)\n        return self\n", "docstring": "Creates the correct subclass based on OS.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_pathlib.py", "original_string": "    def __getattr__(self, name):\n        \"\"\"Forwards any unfaked calls to the standard pathlib module.\"\"\"\n        return getattr(self._pathlib_module, name)\n", "docstring": "Forwards any unfaked calls to the standard pathlib module.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem_unittest.py", "original_string": "    def pause(self) -> None:\n        \"\"\"Pause the patching of the file system modules until `resume` is\n        called. After that call, all file system calls are executed in the\n        real file system.\n        Calling pause() twice is silently ignored.\n        \"\"\"\n        self._stubber.pause()\n", "docstring": "Pause the patching of the file system modules until `resume` is"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem_unittest.py", "original_string": "    def _init_fake_module_classes(self) -> None:\n        # IMPORTANT TESTING NOTE: Whenever you add a new module below, test\n        # it by adding an attribute in fixtures/module_with_attributes.py\n        # and a test in fake_filesystem_unittest_test.py, class\n        # TestAttributesWithFakeModuleNames.\n        self._fake_module_classes = {\n            'os': fake_filesystem.FakeOsModule,\n            'shutil': fake_filesystem_shutil.FakeShutilModule,\n            'io': fake_filesystem.FakeIoModule,\n            'pathlib': fake_pathlib.FakePathlibModule\n        }\n        if IS_PYPY:\n            # in PyPy io.open, the module is referenced as _io\n            self._fake_module_classes['_io'] = fake_filesystem.FakeIoModule\n        # class modules maps class names against a list of modules they can\n        # be contained in - this allows for alternative modules like\n        # `pathlib` and `pathlib2`\n        self._class_modules['Path'] = ['pathlib']\n        self._unfaked_module_classes[\n            'pathlib'] = fake_pathlib.RealPathlibModule\n        if pathlib2:\n            self._fake_module_classes[\n                'pathlib2'] = fake_pathlib.FakePathlibModule\n            self._class_modules['Path'].append('pathlib2')\n            self._unfaked_module_classes[\n                'pathlib2'] = fake_pathlib.RealPathlibModule\n        self._fake_module_classes[\n            'Path'] = fake_pathlib.FakePathlibPathModule\n        self._unfaked_module_classes[\n            'Path'] = fake_pathlib.RealPathlibPathModule\n        if use_scandir:\n            self._fake_module_classes[\n                'scandir'] = fake_scandir.FakeScanDirModule\n", "docstring": "IMPORTANT TESTING NOTE: Whenever you add a new module below, test"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem_unittest.py", "original_string": "    def __enter__(self) -> 'Patcher':\n        \"\"\"Context manager for usage outside of\n        fake_filesystem_unittest.TestCase.\n        Ensure that all patched modules are removed in case of an\n        unhandled exception.\n        \"\"\"\n        self.setUp()\n        return self\n", "docstring": "Context manager for usage outside of"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem_unittest.py", "original_string": "    def _find_modules(self) -> None:\n        \"\"\"Find and cache all modules that import file system modules.\n        Later, `setUp()` will stub these with the fake file system\n        modules.\n        \"\"\"\n        module_names = list(self._fake_module_classes.keys()) + [PATH_MODULE]\n        for name, module in list(sys.modules.items()):\n            try:\n                if (self.use_cache and module in self.CACHED_MODULES or\n                        module in self.SKIPMODULES or\n                        not inspect.ismodule(module)):\n                    continue\n            except Exception:\n                # workaround for some py (part of pytest) versions\n                # where py.error has no __name__ attribute\n                # see https://github.com/pytest-dev/py/issues/73\n                # and any other exception triggered by inspect.ismodule\n                if self.use_cache:\n                    self.__class__.CACHED_MODULES.add(module)\n                continue\n            skipped = (any([sn.startswith(module.__name__)\n                            for sn in self._skip_names]))\n            module_items = module.__dict__.copy().items()\n            modules = {name: mod for name, mod in module_items\n                       if self._is_fs_module(mod, name, module_names)}\n            if skipped:\n                for name, mod in modules.items():\n                    self.__class__.SKIPPED_FS_MODULES.setdefault(\n                        name, set()).add((module, mod.__name__))\n                continue\n            for name, mod in modules.items():\n                self.__class__.FS_MODULES.setdefault(name, set()).add(\n                    (module, mod.__name__))\n            functions = {name: fct for name, fct in\n                         module_items\n                         if self._is_fs_function(fct)}\n            for name, fct in functions.items():\n                self.__class__.FS_FUNCTIONS.setdefault(\n                    (name, fct.__name__, fct.__module__), set()).add(module)\n            # find default arguments that are file system functions\n            if self.patch_default_args:\n                self._find_def_values(module_items)\n            if self.use_cache:\n                self.__class__.CACHED_MODULES.add(module)\n", "docstring": "Find and cache all modules that import file system modules."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem_unittest.py", "original_string": "    def setUp(self, doctester: Any = None) -> None:\n        \"\"\"Bind the file-related modules to the :py:mod:`pyfakefs` fake\n        modules real ones.  Also bind the fake `file()` and `open()` functions.\n        \"\"\"\n        self.has_fcopy_file = (sys.platform == 'darwin' and\n                               hasattr(shutil, '_HAS_FCOPYFILE') and\n                               shutil._HAS_FCOPYFILE)\n        if self.has_fcopy_file:\n            shutil._HAS_FCOPYFILE = False  # type: ignore[attr-defined]\n        temp_dir = tempfile.gettempdir()\n        with warnings.catch_warnings():\n            # ignore warnings, see #542 and #614\n            warnings.filterwarnings(\n                'ignore'\n            )\n            self._find_modules()\n        self._refresh()\n        if doctester is not None:\n            doctester.globs = self.replace_globs(doctester.globs)\n        self.start_patching()\n        linecache.open = self.original_open  # type: ignore[attr-defined]\n        tokenize._builtin_open = self.original_open  # type: ignore\n        # the temp directory is assumed to exist at least in `tempfile1`,\n        # so we create it here for convenience\n        assert self.fs is not None\n        self.fs.create_dir(temp_dir)\n", "docstring": "Bind the file-related modules to the :py:mod:`pyfakefs` fake"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem_unittest.py", "original_string": "    def tearDown(self, doctester: Any = None):\n        \"\"\"Clear the fake filesystem bindings created by `setUp()`.\"\"\"\n        self.stop_patching()\n        if self.has_fcopy_file:\n            shutil._HAS_FCOPYFILE = True  # type: ignore[attr-defined]\n        reset_ids()\n", "docstring": "Clear the fake filesystem bindings created by `setUp()`.\n"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem_unittest.py", "original_string": "    def resume(self) -> None:\n        \"\"\"Resume the patching of the file system modules if `pause` has\n        been called before. After that call, all file system calls are\n        executed in the fake file system.\n        Does nothing if patching is not paused.\n        \"\"\"\n        self.start_patching()\n", "docstring": "Resume the patching of the file system modules if `pause` has"}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem_unittest.py", "original_string": "    def __init__(self, caller: Union[Patcher, TestCaseMixin, FakeFilesystem]):\n        \"\"\"Initializes the context manager with the fake filesystem.\n        Args:\n            caller: either the FakeFilesystem instance, the Patcher instance\n                or the pyfakefs test case.\n        \"\"\"\n        if isinstance(caller, (Patcher, TestCaseMixin)):\n            assert caller.fs is not None\n            self._fs: FakeFilesystem = caller.fs\n        elif isinstance(caller, FakeFilesystem):\n            self._fs = caller\n        else:\n            raise ValueError('Invalid argument - should be of type '\n                             '\"fake_filesystem_unittest.Patcher\", '\n                             '\"fake_filesystem_unittest.TestCase\" '\n                             'or \"fake_filesystem.FakeFilesystem\"')\n", "docstring": "Initializes the context manager with the fake filesystem."}
{"repo": "pyfakefs-master/pyfakefs/fake_filesystem_unittest.py", "original_string": "    def needs_patch(self, name: str) -> bool:\n        \"\"\"Check if the module with the given name shall be replaced.\"\"\"\n        if name not in self.modules:\n            self._loaded_module_names.add(name)\n            return False\n        if (name in sys.modules and\n                type(sys.modules[name]) == self.modules[name]):\n            return False\n        return True\n", "docstring": "Check if the module with the given name shall be replaced.\n"}
{"repo": "pyfakefs-master/pyfakefs/pytest_tests/pytest_doctest_test.py", "original_string": "def make_file_factory(func_name, fake, result):\n    \"\"\" Return a simple function with parametrized doctest. \"\"\"\n    def make_file(name, content=''):\n        with open(name, 'w') as f:\n            f.write(content)\n    make_file.__doc__ = \"\"\"\n        >>> import os\n        >>> {command}\n        >>> name, content = 'foo', 'bar'\n        >>> {func_name}(name, content)\n        >>> open(name).read() == content\n        {result}\n        >>> os.remove(name)  # Cleanup\n        \"\"\".format(\n        command=\"getfixture('fs')\" if fake else \"pass\",\n        func_name=func_name,\n        result=result)\n    return make_file\n", "docstring": "Return a simple function with parametrized doctest. \n"}
{"repo": "pyfakefs-master/pyfakefs/pytest_tests/conftest.py", "original_string": "def fs_reload_example():\n    \"\"\" Fake filesystem. \"\"\"\n    patcher = Patcher(modules_to_reload=[example])\n    patcher.setUp()\n    yield patcher.fs\n    patcher.tearDown()\n", "docstring": "Fake filesystem. \n"}
{"repo": "pyfakefs-master/pyfakefs/pytest_tests/pytest_fixture_test.py", "original_string": "def test_example_file_failing(fs):\n    \"\"\"Test fails because EXAMPLE_FILE is cached in the module\n    and not patched.\"\"\"\n    fs.create_file(example.EXAMPLE_FILE, contents='stuff here')\n    check_that_example_file_is_in_fake_fs()\n", "docstring": "Test fails because EXAMPLE_FILE is cached in the module"}
{"repo": "pyfakefs-master/pyfakefs/pytest_tests/pytest_fixture_test.py", "original_string": "def test_example_file_passing_using_patcher():\n    \"\"\"Test passes if using a Patcher instance that reloads the module\n    containing EXAMPLE_FILE\"\"\"\n    with Patcher(modules_to_reload=[example]) as patcher:\n        patcher.fs.create_file(example.EXAMPLE_FILE, contents='stuff here')\n        check_that_example_file_is_in_fake_fs()\n", "docstring": "Test passes if using a Patcher instance that reloads the module"}
{"repo": "pyfakefs-master/pyfakefs/pytest_tests/pytest_fixture_param_test.py", "original_string": "def test_example_file_failing(fs):\n    \"\"\"Test fails because EXAMPLE_FILE is cached in the module\n    and not patched.\"\"\"\n    fs.create_file(example.EXAMPLE_FILE, contents='stuff here')\n    check_that_example_file_is_in_fake_fs()\n", "docstring": "Test fails because EXAMPLE_FILE is cached in the module"}
{"repo": "pyfakefs-master/pyfakefs/pytest_tests/pytest_fixture_param_test.py", "original_string": "def test_example_file_passing_using_parametrized_fixture(fs):\n    \"\"\"Test passes if using a fixture that reloads the module containing\n    EXAMPLE_FILE\"\"\"\n    fs.create_file(example.EXAMPLE_FILE, contents='stuff here')\n    check_that_example_file_is_in_fake_fs()\n", "docstring": "Test passes if using a fixture that reloads the module containing"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_test.py", "original_string": "    def test_set_contents_to_dir_raises(self):\n        # Regression test for #276\n        self.filesystem.is_windows_fs = True\n        self.assert_raises_os_error(\n            errno.EISDIR, self.fake_dir.set_contents, 'a')\n        self.filesystem.is_windows_fs = False\n        self.assert_raises_os_error(\n            errno.EISDIR, self.fake_dir.set_contents, 'a')\n", "docstring": "Regression test for #276"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_test.py", "original_string": "    def test_not_exists_subpath_named_like_file_contents(self):\n        # Regression test for #219\n        file_path = \"/foo/bar\"\n        self.filesystem.create_file(file_path, contents='baz')\n        self.assertFalse(self.filesystem.exists(file_path + \"/baz\"))\n", "docstring": "Regression test for #219"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_test.py", "original_string": "    def check_abspath_bytes(self, is_windows):\n        \"\"\"abspath should return a consistent representation of a file.\"\"\"\n        self.filesystem.is_windows_fs = is_windows\n        filename = b'foo'\n        abspath = b'!' + filename\n        self.filesystem.create_file(abspath)\n        self.assertEqual(abspath, self.path.abspath(abspath))\n        self.assertEqual(abspath, self.path.abspath(filename))\n        self.assertEqual(abspath, self.path.abspath(b'..!' + filename))\n", "docstring": "abspath should return a consistent representation of a file.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_test.py", "original_string": "    def test_getsize_dir_empty(self):\n        # For directories, only require that the size is non-negative.\n        dir_path = 'foo!bar'\n        self.filesystem.create_dir(dir_path)\n        size = self.path.getsize(dir_path)\n        self.assertFalse(int(size) < 0,\n                         'expected non-negative size; actual: %s' % size)\n", "docstring": "For directories, only require that the size is non-negative."}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_test.py", "original_string": "    def test_is_link_case_sensitive(self):\n        # Regression test for #306\n        self.filesystem.is_case_sensitive = False\n        self.filesystem.create_dir('foo')\n        self.filesystem.create_symlink('foo!bar', 'foo')\n        self.assertTrue(self.path.islink('foo!Bar'))\n", "docstring": "Regression test for #306"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_test.py", "original_string": "    def test_slashes_are_not_collapsed(self):\n        \"\"\"Tests that '/' is not treated specially if the\n        path separator is '|'.\n", "docstring": "Tests that '/' is not treated specially if the"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_test.py", "original_string": "    def test_slashes_do_not_split(self):\n        \"\"\"Tests that '/' is not treated specially if the\n        path separator is '|'.\"\"\"\n        self.assertEqual(('', 'a/b'), self.filesystem.splitpath('a/b'))\n", "docstring": "Tests that '/' is not treated specially if the"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_test.py", "original_string": "    def test_normalize_case_for_lazily_added_empty_file(self):\n        # regression test for specific issue with added empty real files\n        filesystem = fake_filesystem.FakeFilesystem()\n        real_dir_path = os.path.split(\n            os.path.dirname(os.path.abspath(__file__)))[0]\n        filesystem.add_real_directory(real_dir_path)\n        initPyPath = os.path.join(real_dir_path, '__init__.py')\n        self.assertEqual(initPyPath,\n                         filesystem._original_path(initPyPath.upper()))\n", "docstring": "regression test for specific issue with added empty real files"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_test.py", "original_string": "    def setUp(self):\n        # use the real path separator to work with the real file system\n        self.filesystem = fake_filesystem.FakeFilesystem()\n        self.fake_open = fake_filesystem.FakeFileOpen(self.filesystem)\n        self.pyfakefs_path = os.path.split(\n            os.path.dirname(os.path.abspath(__file__)))[0]\n        self.root_path = os.path.split(self.pyfakefs_path)[0]\n", "docstring": "use the real path separator to work with the real file system"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_test.py", "original_string": "    def test_write_to_real_file(self):\n        # regression test for #470\n        real_file_path = os.path.abspath(__file__)\n        self.filesystem.add_real_file(real_file_path, read_only=False)\n        with self.fake_open(real_file_path, 'w') as f:\n            f.write('foo')\n        with self.fake_open(real_file_path, 'rb') as f:\n            self.assertEqual(b'foo', f.read())\n", "docstring": "regression test for #470"}
{"repo": "pyfakefs-master/pyfakefs/tests/dynamic_patch_test.py", "original_string": "    def setUp(self):\n        \"\"\"Set up the fake file system\"\"\"\n        self.setUpPyfakefs()\n", "docstring": "Set up the fake file system\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/example.py", "original_string": "def create_file(path):\n    \"\"\"Create the specified file and add some content to it.  Use the `open()`\n    built in function.\n    For example, the following file operations occur in the fake file system.\n    In the real file system, we would not even have permission\n    to write `/test`:\n    >>> os.path.isdir('/test')\n    False\n    >>> os.mkdir('/test')\n    >>> os.path.isdir('/test')\n    True\n    >>> os.path.exists('/test/file.txt')\n    False\n    >>> create_file('/test/file.txt')\n    >>> os.path.exists('/test/file.txt')\n    True\n    >>> with open('/test/file.txt') as f:\n    ...     f.readlines()\n    [\"This is test file '/test/file.txt'.\\\\n\", \\\n", "docstring": "Create the specified file and add some content to it.  Use the `open()`"}
{"repo": "pyfakefs-master/pyfakefs/tests/example.py", "original_string": "def delete_file(path):\n    \"\"\"Delete the specified file.\n    For example:\n    >>> os.mkdir('/test')\n    >>> os.path.exists('/test/file.txt')\n    False\n    >>> create_file('/test/file.txt')\n    >>> os.path.exists('/test/file.txt')\n    True\n    >>> delete_file('/test/file.txt')\n    >>> os.path.exists('/test/file.txt')\n    False\n    \"\"\"\n    os.remove(path)\n", "docstring": "Delete the specified file."}
{"repo": "pyfakefs-master/pyfakefs/tests/example.py", "original_string": "def scan_dir(path):\n    \"\"\"Return a list of directory entries for the given path.\"\"\"\n    if has_scandir:\n        return list(scandir.scandir(path))\n    return list(os.scandir(path))\n", "docstring": "Return a list of directory entries for the given path.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/mox3_stubout_test.py", "original_string": "    def test_stubout_submodule_with_smart_set(self):\n        # this one does not work with Set\n        non_existing_path = 'non_existing_path'\n        self.assertFalse(\n            mox3_stubout_example.check_if_exists(non_existing_path))\n        self.stubber.smart_set(os, 'path', ExistingPath)\n        self.assertTrue(\n            mox3_stubout_example.check_if_exists(non_existing_path))\n        self.stubber.smart_unset_all()\n        self.assertFalse(\n            mox3_stubout_example.check_if_exists(non_existing_path))\n", "docstring": "this one does not work with Set"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_unittest_test.py", "original_string": "    def setUp(self):\n        \"\"\"Set up the fake file system\"\"\"\n        self.setUpPyfakefs()\n", "docstring": "Set up the fake file system\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_unittest_test.py", "original_string": "    def test_open(self):\n        \"\"\"Fake `open()` function is bound\"\"\"\n        self.assertFalse(os.path.exists('/fake_file.txt'))\n        with open('/fake_file.txt', 'w') as f:\n            f.write(\"This test file was created using the open() function.\\n\")\n        self.assertTrue(self.fs.exists('/fake_file.txt'))\n        with open('/fake_file.txt') as f:\n            content = f.read()\n        self.assertEqual(content, 'This test file was created using the '\n                                  'open() function.\\n')\n", "docstring": "Fake `open()` function is bound\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_unittest_test.py", "original_string": "    def test_os(self):\n        \"\"\"Fake os module is bound\"\"\"\n        self.assertFalse(self.fs.exists('/test/dir1/dir2'))\n        os.makedirs('/test/dir1/dir2')\n        self.assertTrue(self.fs.exists('/test/dir1/dir2'))\n", "docstring": "Fake os module is bound\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_unittest_test.py", "original_string": "    def test_shutil(self):\n        \"\"\"Fake shutil module is bound\"\"\"\n        self.fs.create_dir('/test/dir1/dir2a')\n        self.fs.create_dir('/test/dir1/dir2b')\n        self.assertTrue(self.fs.exists('/test/dir1/dir2b'))\n        self.assertTrue(self.fs.exists('/test/dir1/dir2a'))\n        shutil.rmtree('/test/dir1')\n        self.assertFalse(self.fs.exists('/test/dir1'))\n", "docstring": "Fake shutil module is bound\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_unittest_test.py", "original_string": "    def test_attributes(self):\n        \"\"\"Attributes of module under test are not patched\"\"\"\n        self.assertEqual(module_with_attributes.os, 'os attribute value')\n        self.assertEqual(module_with_attributes.path, 'path attribute value')\n        self.assertEqual(module_with_attributes.pathlib,\n                         'pathlib attribute value')\n        self.assertEqual(module_with_attributes.shutil,\n                         'shutil attribute value')\n        self.assertEqual(module_with_attributes.io, 'io attribute value')\n", "docstring": "Attributes of module under test are not patched\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_unittest_test.py", "original_string": "    def setUp(self):\n        \"\"\"Set up the fake file system\"\"\"\n        self.setUpPyfakefs(\n            modules_to_reload=[pyfakefs.tests.import_as_example])\n", "docstring": "Set up the fake file system\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_unittest_test.py", "original_string": "    def __getattr__(self, name):\n        \"\"\"Forwards any non-faked calls to the standard module.\"\"\"\n        return getattr(self._orig_module, name)\n", "docstring": "Forwards any non-faked calls to the standard module.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_unittest_test.py", "original_string": "    def setUp(self):\n        \"\"\"Set up the fake file system\"\"\"\n        self.setUpPyfakefs(\n            modules_to_patch={\n                'pyfakefs.tests.import_as_example': FakeExampleModule})\n", "docstring": "Set up the fake file system\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_unittest_test.py", "original_string": "    def test_b(self):\n        # used to fail because 'bar' could not be found\n        shutil.make_archive('archive', 'zip', root_dir='foo')\n", "docstring": "used to fail because 'bar' could not be found"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_unittest_test.py", "original_string": "    def test_file_copied_again(self):\n        # used to fail because 'test2' could not be found\n        self.assertTrue(os.path.isfile('./test2/subdir/1.txt'))\n        copy_tree(\"./test2/\", \"./test/\")\n        remove_tree(\"./test2/\")\n        self.assertTrue(os.path.isfile('./test/subdir/1.txt'))\n        self.assertFalse(os.path.isdir('./test2/'))\n", "docstring": "used to fail because 'test2' could not be found"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_unittest_test.py", "original_string": "    def test_cwd(self, fs):\n        \"\"\"Make sure fake file system is used for os in pathlib\"\"\"\n        self.assertEqual(os.path.sep, str(pathlib.Path.cwd()))\n        dot_abs = pathlib.Path(\".\").absolute()\n        self.assertEqual(os.path.sep, str(dot_abs))\n        self.assertTrue(dot_abs.exists())\n", "docstring": "Make sure fake file system is used for os in pathlib\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_unittest_test.py", "original_string": "    def test_no_deprecation_warning(self):\n        \"\"\"Ensures that deprecation warnings are suppressed during module\n        lookup, see #542.\n        \"\"\"\n        from pyfakefs.tests.fixtures.deprecated_property import \\\n            DeprecationTest  # noqa: F401\n        with warnings.catch_warnings(record=True) as w:\n            warnings.simplefilter(\"error\", DeprecationWarning)\n            self.setUpPyfakefs()\n            self.assertEqual(0, len(w))\n", "docstring": "Ensures that deprecation warnings are suppressed during module"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_chdir_fails_non_exist(self):\n        \"\"\"chdir should raise OSError if the target does not exist.\"\"\"\n        directory = self.make_path('no', 'such', 'directory')\n        self.assert_raises_os_error(errno.ENOENT, self.os.chdir, directory)\n", "docstring": "chdir should raise OSError if the target does not exist.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_consecutive_chdir(self):\n        \"\"\"Consecutive relative chdir calls should work.\"\"\"\n        dir1 = self.make_path('foo')\n        dir2 = 'bar'\n        full_dirname = self.os.path.join(dir1, dir2)\n        self.create_dir(full_dirname)\n        self.os.chdir(dir1)\n        self.os.chdir(dir2)\n        # use real path to handle symlink /var to /private/var in MacOs\n        self.assertEqual(os.path.realpath(self.os.getcwd()),\n                         os.path.realpath(full_dirname))\n", "docstring": "Consecutive relative chdir calls should work.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_get_cwd(self):\n        # skipping real fs test - can't test root dir\n        self.skip_real_fs()\n        dirname = self.make_path('foo', 'bar')\n        self.create_dir(dirname)\n        self.assertEqual(self.os.getcwd(), self.os.path.sep)\n        self.os.chdir(dirname)\n        self.assertEqual(self.os.getcwd(), dirname)\n", "docstring": "skipping real fs test - can't test root dir"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_stat_no_follow_symlinks_windows(self):\n        \"\"\"Test that stat with follow_symlinks=False behaves like lstat.\"\"\"\n        self.check_windows_only()\n        self.skip_if_symlink_not_supported()\n        directory = self.make_path('xyzzy')\n        base_name = 'plugh'\n        file_contents = 'frobozz'\n        # Just make sure we didn't accidentally make our test data meaningless.\n        self.assertNotEqual(len(base_name), len(file_contents))\n        file_path = self.os.path.join(directory, base_name)\n        link_path = self.os.path.join(directory, 'link')\n        self.create_file(file_path, contents=file_contents)\n        self.create_symlink(link_path, base_name)\n        self.assertEqual(len(file_contents),\n                         self.os.stat(file_path, follow_symlinks=False)[\n                             stat.ST_SIZE])\n        self.assertEqual(0,\n                         self.os.stat(link_path, follow_symlinks=False)[\n                             stat.ST_SIZE])\n", "docstring": "Test that stat with follow_symlinks=False behaves like lstat.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_stat_with_current_dir(self):\n        # regression test for #516\n        stat_result = self.os.stat('.')\n        lstat_result = self.os.lstat('.')\n        self.assertEqual(stat_result, lstat_result)\n", "docstring": "regression test for #516"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_mkdir_with_trailing_sep(self):\n        # regression test for #367\n        dir_path = self.make_path('foo')\n        self.os.mkdir(dir_path + self.os.sep + self.os.sep)\n        self.assertTrue(self.os.path.exists(dir_path))\n", "docstring": "regression test for #367"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_readlink_ending_with_sep_posix(self):\n        # regression test for #359\n        self.check_posix_only()\n        link_path = self.make_path('foo')\n        self.os.symlink(self.base_path, link_path)\n        self.assert_raises_os_error(errno.EINVAL,\n                                    self.os.readlink, link_path + self.os.sep)\n", "docstring": "regression test for #359"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_lstat_symlink_with_trailing_sep_macos(self):\n        # regression test for #366\n        self.check_macos_only()\n        self.skip_if_symlink_not_supported()\n        link_path = self.make_path('foo')\n        self.os.symlink(self.base_path, link_path)\n        # used to raise\n        self.assertTrue(self.os.lstat(link_path + self.os.sep).st_mode)\n", "docstring": "regression test for #366"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def check_remove_link_ending_with_sep(self, error_nr):\n        # regression test for #360\n        link_path = self.make_path('foo')\n        self.os.symlink(self.base_path, link_path)\n        self.assert_raises_os_error(error_nr,\n                                    self.os.remove, link_path + self.os.sep)\n", "docstring": "regression test for #360"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def check_remove_with_trailing_separator(self, error_nr):\n        # regression test for #377\n        file_path = self.make_path('foo')\n        self.create_file(file_path)\n        self.assert_raises_os_error(error_nr, self.os.remove,\n                                    file_path + self.os.sep)\n", "docstring": "regression test for #377"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_circular_readlink_with_trailing_separator_macos(self):\n        # Regression test for #372\n        self.check_macos_only()\n        file_path = self.make_path('foo')\n        self.os.symlink(file_path, file_path)\n        self.os.readlink(file_path + self.os.sep)\n", "docstring": "Regression test for #372"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_remove_dir_with_drive(self):\n        # regression test for issue #337\n        self.check_windows_only()\n        self.skip_real_fs()\n        dir_path = self.os.path.join('C:', 'test')\n        self.filesystem.create_dir(dir_path)\n        self.assert_raises_os_error(errno.EACCES, self.os.remove, dir_path)\n", "docstring": "regression test for issue #337"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rename_case_with_symlink_mac(self):\n        # Regression test for #322\n        self.check_macos_only()\n        self.check_rename_case_with_symlink(['b', 'beta'])\n", "docstring": "Regression test for #322"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_replace_existing_directory_should_raise_under_windows(self):\n        \"\"\"Renaming to an existing directory raises OSError under Windows.\"\"\"\n        self.check_windows_only()\n        old_path = self.make_path('foo', 'bar')\n        new_path = self.make_path('foo', 'baz')\n        self.create_dir(old_path)\n        self.create_dir(new_path)\n        self.assert_raises_os_error(errno.EACCES, self.os.replace, old_path,\n                                    new_path)\n", "docstring": "Renaming to an existing directory raises OSError under Windows.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rename_to_another_device_should_raise(self):\n        \"\"\"Renaming to another filesystem device raises OSError.\"\"\"\n        self.skip_real_fs()\n        self.filesystem.add_mount_point('/mount')\n        old_path = '/foo/bar'\n        new_path = '/mount/bar'\n        self.filesystem.create_file(old_path)\n        self.assert_raises_os_error(errno.EXDEV, self.os.rename, old_path,\n                                    new_path)\n", "docstring": "Renaming to another filesystem device raises OSError.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rename_to_existent_file_windows(self):\n        \"\"\"Renaming a file to a used name raises OSError under Windows.\"\"\"\n        self.check_windows_only()\n        directory = self.make_path('xyzzy')\n        old_file_path = self.os.path.join(directory, 'plugh_old')\n        new_file_path = self.os.path.join(directory, 'plugh_new')\n        self.create_file(old_file_path, contents='test contents 1')\n        self.create_file(new_file_path, contents='test contents 2')\n        self.assertTrue(self.os.path.exists(old_file_path))\n        self.assertTrue(self.os.path.exists(new_file_path))\n        self.assert_raises_os_error(\n            errno.EEXIST, self.os.rename, old_file_path, new_file_path)\n", "docstring": "Renaming a file to a used name raises OSError under Windows.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rename_to_nonexistent_dir(self):\n        \"\"\"Can rename a file to a name in a nonexistent dir.\"\"\"\n        directory = self.make_path('xyzzy')\n        old_file_path = self.os.path.join(directory, 'plugh_old')\n        new_file_path = self.os.path.join(\n            directory, 'no_such_path', 'plugh_new')\n        self.create_file(old_file_path, contents='test contents')\n        self.assertTrue(self.os.path.exists(old_file_path))\n        self.assertFalse(self.os.path.exists(new_file_path))\n        self.assert_raises_os_error(\n            errno.ENOENT, self.os.rename, old_file_path, new_file_path)\n        self.assertTrue(self.os.path.exists(old_file_path))\n        self.assertFalse(self.os.path.exists(new_file_path))\n        self.check_contents(old_file_path, 'test contents')\n", "docstring": "Can rename a file to a name in a nonexistent dir.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rename_empty_dir(self):\n        \"\"\"Test a rename of an empty directory.\"\"\"\n        directory = self.make_path('xyzzy')\n        before_dir = self.os.path.join(directory, 'empty')\n        after_dir = self.os.path.join(directory, 'unused')\n        self.create_dir(before_dir)\n        self.assertTrue(\n            self.os.path.exists(self.os.path.join(before_dir, '.')))\n        self.assertFalse(self.os.path.exists(after_dir))\n        self.os.rename(before_dir, after_dir)\n        self.assertFalse(self.os.path.exists(before_dir))\n        self.assertTrue(self.os.path.exists(self.os.path.join(after_dir, '.')))\n", "docstring": "Test a rename of an empty directory.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_append_mode_tell_macos(self):\n        # Regression test for #300\n        self.check_macos_only()\n        self.check_append_mode_tell_after_truncate(7)\n", "docstring": "Regression test for #300"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_tell_after_seekback_in_append_mode(self):\n        # Regression test for #414\n        file_path = self.make_path('foo')\n        with self.open(file_path, 'a') as f:\n            f.write('aa')\n            f.seek(1)\n            self.assertEqual(1, f.tell())\n", "docstring": "Regression test for #414"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rename_preserves_stat(self):\n        \"\"\"Test if rename preserves mtime.\"\"\"\n        self.check_posix_only()\n        self.skip_real_fs()\n        directory = self.make_path('xyzzy')\n        old_file_path = self.os.path.join(directory, 'plugh_old')\n        new_file_path = self.os.path.join(directory, 'plugh_new')\n        self.create_file(old_file_path)\n        old_file = self.filesystem.get_object(old_file_path)\n        old_file.st_mtime = old_file.st_mtime - 3600\n        self.os.chown(old_file_path, 200, 200)\n        self.os.chmod(old_file_path, 0o222)\n        self.create_file(new_file_path)\n        new_file = self.filesystem.get_object(new_file_path)\n        self.assertNotEqual(new_file.st_mtime, old_file.st_mtime)\n        self.os.rename(old_file_path, new_file_path)\n        new_file = self.filesystem.get_object(\n            new_file_path, check_read_perm=False)\n        self.assertEqual(new_file.st_mtime, old_file.st_mtime)\n        self.assertEqual(new_file.st_mode, old_file.st_mode)\n        self.assertEqual(new_file.st_uid, old_file.st_uid)\n        self.assertEqual(new_file.st_gid, old_file.st_gid)\n", "docstring": "Test if rename preserves mtime.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rmdir(self):\n        \"\"\"Can remove a directory.\"\"\"\n        directory = self.make_path('xyzzy')\n        sub_dir = self.make_path('xyzzy', 'abccd')\n        other_dir = self.make_path('xyzzy', 'cdeed')\n        self.create_dir(directory)\n        self.assertTrue(self.os.path.exists(directory))\n        self.os.rmdir(directory)\n        self.assertFalse(self.os.path.exists(directory))\n        self.create_dir(sub_dir)\n        self.create_dir(other_dir)\n        self.os.chdir(sub_dir)\n        self.os.rmdir('../cdeed')\n        self.assertFalse(self.os.path.exists(other_dir))\n        self.os.chdir('..')\n        self.os.rmdir('abccd')\n        self.assertFalse(self.os.path.exists(sub_dir))\n", "docstring": "Can remove a directory.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def check_rmdir_raises_if_not_directory(self, error_nr):\n        \"\"\"Raises an exception if the target is not a directory.\"\"\"\n        directory = self.make_path('xyzzy')\n        file_path = self.os.path.join(directory, 'plugh')\n        self.create_file(file_path)\n        self.assertTrue(self.os.path.exists(file_path))\n        self.assert_raises_os_error(errno.ENOTDIR, self.os.rmdir, file_path)\n        self.assert_raises_os_error(error_nr, self.os.rmdir, '.')\n", "docstring": "Raises an exception if the target is not a directory.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_removedirs(self):\n        # no exception raised\n        self.skip_real_fs()\n        data = ['test1', ('test1', 'test2'), ('test1', 'extra'),\n                ('test1', 'test2', 'test3')]\n        for directory in data:\n            self.create_dir(self.make_path(directory))\n            self.assertTrue(self.os.path.exists(self.make_path(directory)))\n        self.assert_raises_os_error(errno.ENOTEMPTY, self.remove_dirs_check,\n                                    self.make_path(data[0]))\n        self.assert_raises_os_error(errno.ENOTEMPTY, self.remove_dirs_check,\n                                    self.make_path(data[1]))\n        self.assertTrue(self.remove_dirs_check(self.make_path(data[3])))\n        self.assertTrue(self.os.path.exists(self.make_path(data[0])))\n        self.assertFalse(self.os.path.exists(self.make_path(data[1])))\n        self.assertTrue(self.os.path.exists(self.make_path(data[2])))\n        # Should raise because '/test1/extra' is all that is left, and\n        # removedirs('/test1/extra') will eventually try to rmdir('/').\n        self.assert_raises_os_error(errno.EBUSY, self.remove_dirs_check,\n                                    self.make_path(data[2]))\n        # However, it will still delete '/test1') in the process.\n        self.assertFalse(self.os.path.exists(self.make_path(data[0])))\n        self.create_dir(self.make_path('test1', 'test2'))\n        # Add this to the root directory to avoid raising an exception.\n        self.filesystem.create_dir(self.make_path('test3'))\n        self.assertTrue(\n            self.remove_dirs_check(self.make_path('test1', 'test2')))\n        self.assertFalse(self.os.path.exists(self.make_path('test1', 'test2')))\n        self.assertFalse(self.os.path.exists(self.make_path('test1')))\n", "docstring": "no exception raised"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_removedirs_raises_if_cascade_removing_root(self):\n        \"\"\"Raises exception if asked to remove '/' as part of a\n        larger operation.\n        All of other directories should still be removed, though.\n        \"\"\"\n        self.skip_real_fs()\n        directory = self.make_path('foo', 'bar')\n        self.create_dir(directory)\n        self.assertTrue(self.os.path.exists(directory))\n        self.assert_raises_os_error(errno.EBUSY, self.os.removedirs, directory)\n        head, unused_tail = self.os.path.split(directory)\n        while self.os.path.splitdrive(head)[1] != self.os.path.sep:\n            self.assertFalse(self.os.path.exists(directory))\n            head, unused_tail = self.os.path.split(head)\n", "docstring": "Raises exception if asked to remove '/' as part of a"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_mkdir(self):\n        \"\"\"mkdir can create a relative directory.\"\"\"\n        self.skip_real_fs()\n        directory = 'xyzzy'\n        self.assertFalse(self.filesystem.exists(directory))\n        self.os.mkdir(directory)\n        self.assertTrue(self.filesystem.exists('/%s' % directory))\n        self.os.chdir(directory)\n        self.os.mkdir(directory)\n        self.assertTrue(\n            self.filesystem.exists('/%s/%s' % (directory, directory)))\n        self.os.chdir(directory)\n        self.os.mkdir('../abccb')\n        self.assertTrue(self.os.path.exists('/%s/abccb' % directory))\n", "docstring": "mkdir can create a relative directory.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_mkdir_raises_if_empty_directory_name(self):\n        \"\"\"mkdir raises exeption if creating directory named ''.\"\"\"\n        directory = ''\n        self.assert_raises_os_error(errno.ENOENT, self.os.mkdir, directory)\n", "docstring": "mkdir raises exeption if creating directory named ''.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_mkdir_raises_if_directory_exists(self):\n        \"\"\"mkdir raises exception if directory already exists.\"\"\"\n        directory = self.make_path('xyzzy')\n        self.create_dir(directory)\n        self.assertTrue(self.os.path.exists(directory))\n        self.assert_raises_os_error(errno.EEXIST, self.os.mkdir, directory)\n", "docstring": "mkdir raises exception if directory already exists.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def check_mkdir_raises_if_parent_is_file(self, error_type):\n        \"\"\"mkdir raises exception if name already exists as a file.\"\"\"\n        directory = self.make_path('xyzzy')\n        file_path = self.os.path.join(directory, 'plugh')\n        self.create_file(file_path)\n        self.assert_raises_os_error(error_type, self.os.mkdir,\n                                    self.os.path.join(file_path, 'ff'))\n", "docstring": "mkdir raises exception if name already exists as a file.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_mkdir_raises_with_slash_dot_windows(self):\n        \"\"\"mkdir raises exception if mkdir foo/. (trailing /.).\"\"\"\n        self.check_windows_only()\n        self.assert_raises_os_error(errno.EACCES,\n                                    self.os.mkdir, self.os.sep + '.')\n        directory = self.make_path('xyzzy', '.')\n        self.os.mkdir(directory)\n        self.create_dir(self.make_path('xyzzy'))\n        self.assert_raises_os_error(errno.EEXIST, self.os.mkdir, directory)\n", "docstring": "mkdir raises exception if mkdir foo/. (trailing /.).\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_mkdir_raises_with_double_dots_windows(self):\n        \"\"\"mkdir raises exception if mkdir foo/foo2/../foo3.\"\"\"\n        self.check_windows_only()\n        self.assert_raises_os_error(errno.EACCES,\n                                    self.os.mkdir, self.os.sep + '..')\n        directory = self.make_path(\n            'xyzzy', 'dir1', 'dir2', '..', '..', 'dir3')\n        self.assert_raises_os_error(errno.ENOENT, self.os.mkdir, directory)\n        self.create_dir(self.make_path('xyzzy'))\n        self.os.mkdir(directory)\n        self.assertTrue(self.os.path.exists(directory))\n        directory = self.make_path('xyzzy', 'dir1', '..')\n        self.assert_raises_os_error(errno.EEXIST, self.os.mkdir, directory)\n", "docstring": "mkdir raises exception if mkdir foo/foo2/../foo3.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def check_makedirs_raises_if_parent_is_file(self, error_type):\n        \"\"\"makedirs raises exception if a parent component exists as a file.\"\"\"\n        file_path = self.make_path('xyzzy')\n        directory = self.os.path.join(file_path, 'plugh')\n        self.create_file(file_path)\n        self.assertTrue(self.os.path.exists(file_path))\n        self.assert_raises_os_error(error_type, self.os.makedirs, directory)\n", "docstring": "makedirs raises exception if a parent component exists as a file.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_makedirs_raises_if_access_denied(self):\n        \"\"\"makedirs raises exception if access denied.\"\"\"\n        self.check_posix_only()\n        directory = self.make_path('a')\n        self.os.mkdir(directory)\n        # Change directory permissions to be read only.\n        self.os.chmod(directory, 0o400)\n        directory = self.make_path('a', 'b')\n        if not is_root():\n            with self.assertRaises(Exception):\n                self.os.makedirs(directory)\n        else:\n            self.os.makedirs(directory)\n            self.assertTrue(self.os.path.exists(directory))\n", "docstring": "makedirs raises exception if access denied.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_access600(self):\n        # set up\n        self.check_posix_only()\n        path = self.make_path('some_file')\n        self.createTestFile(path)\n        self.os.chmod(path, 0o600)\n        self.assert_mode_equal(0o600, self.os.stat(path).st_mode)\n        # actual tests\n        self.assertTrue(self.os.access(path, self.os.F_OK))\n        self.assertTrue(self.os.access(path, self.os.R_OK))\n        self.assertTrue(self.os.access(path, self.os.W_OK))\n        self.assertFalse(self.os.access(path, self.os.X_OK))\n        self.assertFalse(self.os.access(path, self.rwx))\n        self.assertTrue(self.os.access(path, self.rw))\n", "docstring": "set up"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_chmod_dir(self):\n        # set up\n        self.check_posix_only()\n        self.skip_real_fs()\n        path = self.make_path('some_dir')\n        self.createTestDirectory(path)\n        # actual tests\n        self.os.chmod(path, 0o1434)\n        st = self.os.stat(path)\n        self.assert_mode_equal(0o1434, st.st_mode)\n        self.assertFalse(st.st_mode & stat.S_IFREG)\n        self.assertTrue(st.st_mode & stat.S_IFDIR)\n", "docstring": "set up"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_chown_existing_file(self):\n        # set up\n        self.skip_real_fs()\n        file_path = self.make_path('some_file')\n        self.create_file(file_path)\n        # first set it make sure it's set\n        self.os.chown(file_path, 100, 101)\n        st = self.os.stat(file_path)\n        self.assertEqual(st[stat.ST_UID], 100)\n        self.assertEqual(st[stat.ST_GID], 101)\n        # we can make sure it changed\n        self.os.chown(file_path, 200, 201)\n        st = self.os.stat(file_path)\n        self.assertEqual(st[stat.ST_UID], 200)\n        self.assertEqual(st[stat.ST_GID], 201)\n        # setting a value to -1 leaves it unchanged\n        self.os.chown(file_path, -1, -1)\n        st = self.os.stat(file_path)\n        self.assertEqual(st[stat.ST_UID], 200)\n        self.assertEqual(st[stat.ST_GID], 201)\n", "docstring": "set up"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_chown_bad_arguments(self):\n        \"\"\"os.chown() with bad args (Issue #30)\"\"\"\n        self.check_posix_only()\n        file_path = self.make_path('some_file')\n        self.create_file(file_path)\n        self.assertRaises(TypeError, self.os.chown, file_path, 'username', -1)\n        self.assertRaises(TypeError, self.os.chown, file_path, -1, 'groupname')\n", "docstring": "os.chown() with bad args (Issue #30)\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_classify_directory_contents(self):\n        \"\"\"Directory classification should work correctly.\"\"\"\n        root_directory = self.make_path('foo')\n        test_directories = ['bar1', 'baz2']\n        test_files = ['baz1', 'bar2', 'baz3']\n        self.create_dir(root_directory)\n        for directory in test_directories:\n            directory = self.os.path.join(root_directory, directory)\n            self.create_dir(directory)\n        for test_file in test_files:\n            test_file = self.os.path.join(root_directory, test_file)\n            self.create_file(test_file)\n        test_directories.sort()\n        test_files.sort()\n        generator = self.os.walk(root_directory)\n        root, dirs, files = next(generator)\n        dirs.sort()\n        files.sort()\n        self.assertEqual(root_directory, root)\n        self.assertEqual(test_directories, dirs)\n        self.assertEqual(test_files, files)\n", "docstring": "Directory classification should work correctly.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rename_symlink_with_trailing_sep_macos(self):\n        # Regression test for #391\n        self.check_macos_only()\n        path = self.make_path('foo')\n        self.os.symlink(self.base_path, path)\n        self.os.rename(path + self.os.sep, self.base_path)\n", "docstring": "Regression test for #391"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rename_symlink_to_other_case(self):\n        # Regression test for #389\n        self.skip_if_symlink_not_supported()\n        link_path = self.make_path('foo')\n        self.os.symlink(self.base_path, link_path)\n        link_to_link_path = self.make_path('BAR')\n        self.os.symlink(link_path, link_to_link_path)\n        new_link_to_link_path = self.os.path.join(link_path, 'bar')\n        self.os.rename(link_to_link_path, new_link_to_link_path)\n        self.assertEqual(['bar', 'foo'],\n                         sorted(self.os.listdir(new_link_to_link_path)))\n", "docstring": "Regression test for #389"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def check_open_broken_symlink_to_path_with_trailing_sep(self, error):\n        # Regression tests for #397\n        self.skip_if_symlink_not_supported()\n        target_path = self.make_path('target') + self.os.sep\n        link_path = self.make_path('link')\n        self.os.symlink(target_path, link_path)\n        self.assert_raises_os_error(error, self.open, link_path, 'a')\n        self.assert_raises_os_error(error, self.open, link_path, 'w')\n", "docstring": "Regression tests for #397"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def check_link_path_ending_with_sep(self, error):\n        # Regression tests for #399\n        self.skip_if_symlink_not_supported()\n        file_path = self.make_path('foo')\n        link_path = self.make_path('link')\n        with self.open(file_path, 'w'):\n            self.assert_raises_os_error(\n                error, self.os.link, file_path + self.os.sep, link_path)\n", "docstring": "Regression tests for #399"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_readlink_circular_link_with_trailing_sep_macos(self):\n        # Regression test for #392\n        self.check_macos_only()\n        path1 = self.make_path('foo')\n        path0 = self.make_path('bar')\n        self.os.symlink(path0, path1)\n        self.os.symlink(path1, path0)\n        self.assertEqual(path0, self.os.readlink(path0 + self.os.sep))\n", "docstring": "Regression test for #392"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_link_bogus(self):\n        # trying to create a link from a non-existent file should fail\n        self.skip_if_symlink_not_supported()\n        self.assert_raises_os_error(errno.ENOENT,\n                                    self.os.link, '/nonexistent_source',\n                                    '/link_dest')\n", "docstring": "trying to create a link from a non-existent file should fail"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_mkdir_umask_applied(self):\n        \"\"\"mkdir creates a directory with umask applied.\"\"\"\n        self.check_posix_only()\n        self.os.umask(0o22)\n        dir1 = self.make_path('dir1')\n        self.os.mkdir(dir1)\n        self.assert_mode_equal(0o755, self.os.stat(dir1).st_mode)\n        self.os.umask(0o67)\n        dir2 = self.make_path('dir2')\n        self.os.mkdir(dir2)\n        self.assert_mode_equal(0o710, self.os.stat(dir2).st_mode)\n", "docstring": "mkdir creates a directory with umask applied.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_mknod_umask_applied(self):\n        \"\"\"mkdir creates a device with umask applied.\"\"\"\n        # skipping MacOs due to mknod permission issues\n        self.check_linux_only()\n        self.os.umask(0o22)\n        node1 = self.make_path('nod1')\n        self.os.mknod(node1, stat.S_IFREG | 0o666)\n        self.assert_mode_equal(0o644, self.os.stat(node1).st_mode)\n        self.os.umask(0o27)\n        node2 = self.make_path('nod2')\n        self.os.mknod(node2, stat.S_IFREG | 0o666)\n        self.assert_mode_equal(0o640, self.os.stat(node2).st_mode)\n", "docstring": "mkdir creates a device with umask applied.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_open_existing_pipe(self):\n        # create some regular files to ensure that real and fake fd\n        # are out of sync (see #581)\n        fds = []\n        for i in range(5):\n            path = self.make_path('file' + str(i))\n            fds.append(self.os.open(path, os.O_CREAT))\n        file_path = self.make_path('file.txt')\n        self.create_file(file_path)\n        with self.open(file_path):\n            read_fd, write_fd = self.os.pipe()\n            with self.open(write_fd, 'wb') as f:\n                self.assertEqual(4, f.write(b'test'))\n            with self.open(read_fd, 'rb') as f:\n                self.assertEqual(b'test', f.read(4))\n        for fd in fds:\n            self.os.close(fd)\n", "docstring": "create some regular files to ensure that real and fake fd"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_stat_no_follow_symlinks_posix(self):\n        \"\"\"Test that stat with follow_symlinks=False behaves like lstat.\"\"\"\n        self.check_posix_only()\n        directory = self.make_path('xyzzy')\n        base_name = 'plugh'\n        file_contents = 'frobozz'\n        # Just make sure we didn't accidentally make our test data meaningless.\n        self.assertNotEqual(len(base_name), len(file_contents))\n        file_path = self.os.path.join(directory, base_name)\n        link_path = self.os.path.join(directory, 'link')\n        self.create_file(file_path, contents=file_contents)\n        self.create_symlink(link_path, base_name)\n        self.assertEqual(len(file_contents), self.os.stat(\n            file_path.upper(), follow_symlinks=False)[stat.ST_SIZE])\n        self.assertEqual(len(base_name), self.os.stat(\n            link_path.upper(), follow_symlinks=False)[stat.ST_SIZE])\n", "docstring": "Test that stat with follow_symlinks=False behaves like lstat.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rename_symlink_with_changed_case(self):\n        # Regression test for #313\n        self.skip_if_symlink_not_supported()\n        link_path = self.make_path('link')\n        self.os.symlink(self.base_path, link_path)\n        link_path = self.os.path.join(link_path, 'link')\n        link_path_upper = self.make_path('link', 'LINK')\n        self.os.rename(link_path_upper, link_path)\n", "docstring": "Regression test for #313"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rename_symlink_to_other_case_does_nothing_in_mac_os(self):\n        # Regression test for #318\n        self.check_macos_only()\n        path0 = self.make_path(\"beta\")\n        self.os.symlink(self.base_path, path0)\n        path0 = self.make_path(\"beta\", \"Beta\")\n        path1 = self.make_path(\"Beta\")\n        self.os.rename(path0, path1)\n        self.assertEqual(['beta'], sorted(self.os.listdir(path0)))\n", "docstring": "Regression test for #318"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_stat_with_mixed_case(self):\n        # Regression test for #310\n        self.skip_if_symlink_not_supported()\n        base_path = self.make_path('foo')\n        path = self.os.path.join(base_path, 'bar')\n        self.create_dir(path)\n        path = self.os.path.join(path, 'Bar')\n        self.os.symlink(base_path, path)\n        path = self.os.path.join(path, 'Bar')\n        # used to raise\n        self.os.stat(path)\n", "docstring": "Regression test for #310"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_replace_existing_directory_should_raise_under_windows(self):\n        \"\"\"Renaming to an existing directory raises OSError under Windows.\"\"\"\n        self.check_windows_only()\n        old_path = self.make_path('foo', 'bar')\n        new_path = self.make_path('foo', 'baz')\n        self.create_dir(old_path)\n        self.create_dir(new_path)\n        self.assert_raises_os_error(errno.EACCES, self.os.replace, old_path,\n                                    new_path.upper())\n", "docstring": "Renaming to an existing directory raises OSError under Windows.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rename_to_existent_file_windows(self):\n        \"\"\"Renaming a file to a used name raises OSError under Windows.\"\"\"\n        self.check_windows_only()\n        directory = self.make_path('xyzzy')\n        old_file_path = self.os.path.join(directory, 'plugh_old')\n        new_file_path = self.os.path.join(directory, 'plugh_new')\n        self.create_file(old_file_path, contents='test contents 1')\n        self.create_file(new_file_path, contents='test contents 2')\n        self.assertTrue(self.os.path.exists(old_file_path))\n        self.assertTrue(self.os.path.exists(new_file_path))\n        self.assert_raises_os_error(errno.EEXIST, self.os.rename,\n                                    old_file_path.upper(),\n                                    new_file_path.upper())\n", "docstring": "Renaming a file to a used name raises OSError under Windows.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rename_to_nonexistent_dir(self):\n        \"\"\"Can rename a file to a name in a nonexistent dir.\"\"\"\n        directory = self.make_path('xyzzy')\n        old_file_path = self.os.path.join(directory, 'plugh_old')\n        new_file_path = self.os.path.join(\n            directory, 'no_such_path', 'plugh_new')\n        self.create_file(old_file_path, contents='test contents')\n        self.assertTrue(self.os.path.exists(old_file_path))\n        self.assertFalse(self.os.path.exists(new_file_path))\n        self.assert_raises_os_error(errno.ENOENT, self.os.rename,\n                                    old_file_path.upper(),\n                                    new_file_path.upper())\n        self.assertTrue(self.os.path.exists(old_file_path))\n        self.assertFalse(self.os.path.exists(new_file_path))\n        self.check_contents(old_file_path, 'test contents')\n", "docstring": "Can rename a file to a name in a nonexistent dir.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rename_dir(self):\n        \"\"\"Test a rename of a directory.\"\"\"\n        directory = self.make_path('xyzzy')\n        before_dir = self.os.path.join(directory, 'before')\n        before_file = self.os.path.join(directory, 'before', 'file')\n        after_dir = self.os.path.join(directory, 'after')\n        after_file = self.os.path.join(directory, 'after', 'file')\n        self.create_dir(before_dir)\n        self.create_file(before_file, contents='payload')\n        self.assertTrue(self.os.path.exists(before_dir.upper()))\n        self.assertTrue(self.os.path.exists(before_file.upper()))\n        self.assertFalse(self.os.path.exists(after_dir.upper()))\n        self.assertFalse(self.os.path.exists(after_file.upper()))\n        self.os.rename(before_dir.upper(), after_dir)\n        self.assertFalse(self.os.path.exists(before_dir.upper()))\n        self.assertFalse(self.os.path.exists(before_file.upper()))\n        self.assertTrue(self.os.path.exists(after_dir.upper()))\n        self.assertTrue(self.os.path.exists(after_file.upper()))\n        self.check_contents(after_file, 'payload')\n", "docstring": "Test a rename of a directory.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_rmdir(self):\n        \"\"\"Can remove a directory.\"\"\"\n        directory = self.make_path('xyzzy')\n        sub_dir = self.make_path('xyzzy', 'abccd')\n        other_dir = self.make_path('xyzzy', 'cdeed')\n        self.create_dir(directory)\n        self.assertTrue(self.os.path.exists(directory))\n        self.os.rmdir(directory)\n        self.assertFalse(self.os.path.exists(directory))\n        self.create_dir(sub_dir)\n        self.create_dir(other_dir)\n        self.os.chdir(sub_dir)\n        self.os.rmdir('../CDEED')\n        self.assertFalse(self.os.path.exists(other_dir))\n        self.os.chdir('..')\n        self.os.rmdir('AbcCd')\n        self.assertFalse(self.os.path.exists(sub_dir))\n", "docstring": "Can remove a directory.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_mkdir_raises_if_file_exists(self):\n        \"\"\"mkdir raises exception if name already exists as a file.\"\"\"\n        directory = self.make_path('xyzzy')\n        file_path = self.os.path.join(directory, 'plugh')\n        self.create_file(file_path)\n        self.assertTrue(self.os.path.exists(file_path))\n        self.assert_raises_os_error(errno.EEXIST,\n                                    self.os.mkdir, file_path.upper())\n", "docstring": "mkdir raises exception if name already exists as a file.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def check_mkdir_raises_if_parent_is_file(self, error_type):\n        \"\"\"mkdir raises exception if name already exists as a file.\"\"\"\n        directory = self.make_path('xyzzy')\n        file_path = self.os.path.join(directory, 'plugh')\n        self.create_file(file_path)\n        self.assert_raises_os_error(error_type, self.os.mkdir,\n                                    self.os.path.join(file_path.upper(),\n                                                      'ff'))\n", "docstring": "mkdir raises exception if name already exists as a file.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def check_makedirs_raises_if_parent_is_file(self, error_type):\n        \"\"\"makedirs raises exception if a parent component exists as a file.\"\"\"\n        file_path = self.make_path('xyzzy')\n        directory = self.os.path.join(file_path, 'plugh')\n        self.create_file(file_path)\n        self.assertTrue(self.os.path.exists(file_path))\n        self.assert_raises_os_error(error_type, self.os.makedirs,\n                                    directory.upper())\n", "docstring": "makedirs raises exception if a parent component exists as a file.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_makedirs_exist_ok(self):\n        \"\"\"makedirs uses the exist_ok argument\"\"\"\n        directory = self.make_path('xyzzy', 'foo')\n        self.create_dir(directory)\n        self.assertTrue(self.os.path.exists(directory))\n        self.assert_raises_os_error(errno.EEXIST, self.os.makedirs,\n                                    directory.upper())\n        self.os.makedirs(directory.upper(), exist_ok=True)\n        self.assertTrue(self.os.path.exists(directory))\n", "docstring": "makedirs uses the exist_ok argument\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_link_is_broken_symlink(self):\n        # Regression test for #311\n        self.skip_if_symlink_not_supported()\n        self.check_case_insensitive_fs()\n        file_path = self.make_path('baz')\n        self.create_file(file_path)\n        path_lower = self.make_path('foo')\n        self.os.symlink(path_lower, path_lower)\n        path_upper = self.make_path('Foo')\n        self.assert_raises_os_error(errno.EEXIST,\n                                    self.os.link, file_path, path_upper)\n", "docstring": "Regression test for #311"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_utime_sets_current_time_if_args_is_none_with_floats(self):\n        # we set os.stat_float_times() to False, so atime/ctime/mtime\n        # are converted as ints (seconds since epoch)\n        stat_float_times = fake_filesystem.FakeOsModule.stat_float_times()\n        fake_filesystem.FakeOsModule.stat_float_times(False)\n        try:\n            with self.mock_time(start=200.9124):\n                path = '/some_file'\n                self.createTestFile(path)\n                st = self.os.stat(path)\n                # 200 is the current time established above\n                # (if converted to int)\n                self.assertEqual(200, st.st_atime)\n                self.assertTrue(isinstance(st.st_atime, int))\n                self.assertEqual(220, st.st_mtime)\n                self.assertTrue(isinstance(st.st_mtime, int))\n                self.assertEqual(200912400000, st.st_atime_ns)\n                self.assertEqual(220912400000, st.st_mtime_ns)\n                self.assertEqual(220, st.st_mtime)\n                self.assertEqual(240, st.st_ctime)\n                # actual tests\n                self.os.utime(path, times=None)\n                st = self.os.stat(path)\n                self.assertEqual(260, st.st_atime)\n                self.assertTrue(isinstance(st.st_atime, int))\n                self.assertEqual(260, st.st_mtime)\n                self.assertTrue(isinstance(st.st_mtime, int))\n                self.assertEqual(260912400000, st.st_atime_ns)\n                self.assertEqual(260912400000, st.st_mtime_ns)\n        finally:\n            fake_filesystem.FakeOsModule.stat_float_times(stat_float_times)\n", "docstring": "we set os.stat_float_times() to False, so atime/ctime/mtime"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_utime_sets_specified_time(self):\n        # set up\n        path = self.make_path('some_file')\n        self.createTestFile(path)\n        self.os.stat(path)\n        # actual tests\n        self.os.utime(path, times=(1, 2))\n        st = self.os.stat(path)\n        self.assertEqual(1, st.st_atime)\n        self.assertEqual(2, st.st_mtime)\n", "docstring": "set up"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_utime_sets_specified_time_in_ns(self):\n        # set up\n        path = self.make_path('some_file')\n        self.createTestFile(path)\n        self.os.stat(path)\n        # actual tests\n        self.os.utime(path, ns=(200000000, 400000000))\n        st = self.os.stat(path)\n        self.assertEqual(0.2, st.st_atime)\n        self.assertEqual(0.4, st.st_mtime)\n", "docstring": "set up"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_write_from_different_fds_with_append(self):\n        # Regression test for #268\n        file_path = self.make_path('baz')\n        fd0 = self.os.open(file_path, os.O_CREAT | os.O_WRONLY | os.O_TRUNC)\n        fd1 = self.os.open(file_path, os.O_WRONLY | os.O_APPEND)\n        self.os.write(fd0, b'aaa')\n        self.os.write(fd1, b'bbb')\n        self.assertEqual(6, self.os.path.getsize(file_path))\n        self.check_contents(file_path, b'aaabbb')\n        self.os.close(fd1)\n        self.os.close(fd0)\n", "docstring": "Regression test for #268"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_read_after_closing_write_descriptor(self):\n        # Regression test for #271\n        file_path = self.make_path('baz')\n        fd0 = self.os.open(file_path, os.O_CREAT | os.O_WRONLY | os.O_TRUNC)\n        fd1 = self.os.open(file_path, os.O_CREAT | os.O_WRONLY | os.O_TRUNC)\n        fd2 = self.os.open(file_path, os.O_CREAT)\n        self.os.write(fd1, b'abc')\n        self.os.close(fd0)\n        self.assertEqual(b'abc', self.os.read(fd2, 3))\n        self.os.close(fd2)\n        self.os.close(fd1)\n", "docstring": "Regression test for #271"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def StoreErrno(self, os_error):\n        \"\"\"Store the last errno we saw.\"\"\"\n        self.last_errno = os_error.errno\n", "docstring": "Store the last errno we saw.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_walk_top_down(self):\n        \"\"\"Walk down ordering is correct.\"\"\"\n        base_dir = self.make_path('foo')\n        self.create_file(self.os.path.join(base_dir, '1.txt'))\n        self.create_file(self.os.path.join(base_dir, 'bar1', '2.txt'))\n        self.create_file(self.os.path.join(base_dir, 'bar1', 'baz', '3.txt'))\n        self.create_file(self.os.path.join(base_dir, 'bar2', '4.txt'))\n        expected = [\n            (base_dir, ['bar1', 'bar2'], ['1.txt']),\n            (self.os.path.join(base_dir, 'bar1'), ['baz'], ['2.txt']),\n            (self.os.path.join(base_dir, 'bar1', 'baz'), [], ['3.txt']),\n            (self.os.path.join(base_dir, 'bar2'), [], ['4.txt']),\n        ]\n        self.assertWalkResults(expected, base_dir)\n", "docstring": "Walk down ordering is correct.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_walk_raises_if_non_existent(self):\n        \"\"\"Raises an exception when attempting to walk\n         non-existent directory.\"\"\"\n        directory = self.make_path('foo', 'bar')\n        self.assertEqual(False, self.os.path.exists(directory))\n        generator = self.os.walk(directory)\n        self.assertRaises(StopIteration, next, generator)\n", "docstring": "Raises an exception when attempting to walk"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_walk_calls_on_error_if_non_existent(self):\n        \"\"\"Calls onerror with correct errno when walking\n        non-existent directory.\"\"\"\n        self.ResetErrno()\n        directory = self.make_path('foo', 'bar')\n        self.assertEqual(False, self.os.path.exists(directory))\n        # Calling os.walk on a non-existent directory should trigger\n        # a call to the onerror method.\n        # We do not actually care what, if anything, is returned.\n        for _ in self.os.walk(directory, onerror=self.StoreErrno):\n            pass\n        self.assertTrue(self.GetErrno() in (errno.ENOTDIR, errno.ENOENT))\n", "docstring": "Calls onerror with correct errno when walking"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_walk_skips_removed_directories(self):\n        \"\"\"Caller can modify list of directories to visit while walking.\"\"\"\n        root = self.make_path('foo')\n        visit = 'visit'\n        no_visit = 'no_visit'\n        self.create_file(self.os.path.join(root, 'bar'))\n        self.create_file(self.os.path.join(root, visit, '1.txt'))\n        self.create_file(self.os.path.join(root, visit, '2.txt'))\n        self.create_file(self.os.path.join(root, no_visit, '3.txt'))\n        self.create_file(self.os.path.join(root, no_visit, '4.txt'))\n        generator = self.os.walk(self.make_path('foo'))\n        root_contents = next(generator)\n        root_contents[1].remove(no_visit)\n        visited_visit_directory = False\n        for root, _dirs, _files in iter(generator):\n            self.assertEqual(False, root.endswith(self.os.path.sep + no_visit))\n            if root.endswith(self.os.path.sep + visit):\n                visited_visit_directory = True\n        self.assertEqual(True, visited_visit_directory)\n", "docstring": "Caller can modify list of directories to visit while walking.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_base_dirpath(self):\n        # regression test for #512\n        file_path = self.make_path('foo', 'bar', 'baz')\n        self.create_file(file_path)\n        variants = [\n            self.make_path('foo', 'bar'),\n            self.make_path('foo', '..', 'foo', 'bar'),\n            self.make_path('foo', '..', 'foo', 'bar') +\n            self.os.path.sep * 3,\n            self.make_path('foo') + self.os.path.sep * 3 + 'bar'\n        ]\n        for base_dir in variants:\n            for dirpath, dirnames, filenames in self.os.walk(base_dir):\n                self.assertEqual(dirpath, base_dir)\n        file_path = self.make_path('foo', 'bar', 'dir', 'baz')\n        self.create_file(file_path)\n        for base_dir in variants:\n            for dirpath, dirnames, filenames in self.os.walk(base_dir):\n                self.assertTrue(dirpath.startswith(base_dir))\n", "docstring": "regression test for #512"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_file_size_truncation(self):\n        \"\"\"test that file size gets updated via open().\"\"\"\n        file_dir = 'xyzzy'\n        file_path = 'xyzzy/truncation'\n        content = 'AAA content.'\n        # pre-create file with content\n        self.os.mkdir(file_dir)\n        fh = self.open(file_path, 'w')\n        fh.write(content)\n        fh.close()\n        self.assertEqual(len(content), self.os.stat(file_path)[stat.ST_SIZE])\n        self.assertEqual(content,\n                         self.filesystem.get_object(file_path).contents)\n        # test file truncation\n        fh = self.open(file_path, 'w')\n        self.assertEqual(0, self.os.stat(file_path)[stat.ST_SIZE])\n        self.assertEqual('', self.filesystem.get_object(file_path).contents)\n        fh.close()\n", "docstring": "test that file size gets updated via open().\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def do_scandir(self):\n        \"\"\"Hook to override how scandir is called.\"\"\"\n        return self.scandir(self.directory)\n", "docstring": "Hook to override how scandir is called.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_path_links_not_resolved(self):\n        # regression test for #350\n        self.skip_if_symlink_not_supported()\n        dir_path = self.make_path('A', 'B', 'C')\n        self.os.makedirs(self.os.path.join(dir_path, 'D'))\n        link_path = self.make_path('A', 'C')\n        self.os.symlink(dir_path, link_path)\n        self.assertEqual([self.os.path.join(link_path, 'D')],\n                         [f.path for f in self.scandir(link_path)])\n", "docstring": "regression test for #350"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def test_scandir_stat_nlink(self):\n        # regression test for #350\n        stat_nlink = self.os.stat(self.file_path).st_nlink\n        self.assertEqual(1, stat_nlink)\n        dir_iter = self.scandir(self.directory)\n        for item in dir_iter:\n            if item.path == self.file_path:\n                scandir_stat_nlink = item.stat().st_nlink\n                if self.is_windows_fs:\n                    self.assertEqual(0, scandir_stat_nlink)\n                else:\n                    self.assertEqual(1, scandir_stat_nlink)\n                self.assertEqual(1, self.os.stat(self.file_path).st_nlink)\n", "docstring": "regression test for #350"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_os_test.py", "original_string": "    def scandir_path(self):\n        # When scandir is called with a relative path, that relative path is\n        # used in the path attribute of the DirEntry objects.\n        return self.os.path.relpath(self.directory)\n", "docstring": "When scandir is called with a relative path, that relative path is"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_open_no_parent_dir(self):\n        \"\"\"Expect raise when opening a file in a missing directory.\"\"\"\n        file_path = self.make_path('foo', 'bar.txt')\n        self.assert_raises_os_error(errno.ENOENT, self.open, file_path, 'w')\n", "docstring": "Expect raise when opening a file in a missing directory.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_open_with_wplus(self):\n        # set up\n        file_path = self.make_path('wplus_file')\n        self.create_file(file_path, contents='old contents')\n        self.assertTrue(self.os.path.exists(file_path))\n        with self.open(file_path, 'r') as fake_file:\n            self.assertEqual('old contents', fake_file.read())\n        # actual tests\n        with self.open(file_path, 'w+') as fake_file:\n            fake_file.write('new contents')\n            fake_file.seek(0)\n            self.assertTrue('new contents', fake_file.read())\n", "docstring": "set up"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_append_with_aplus_read_with_loop(self):\n        # set up\n        file_path = self.make_path('aplus_file')\n        self.create_file(file_path, contents='old contents')\n        self.assertTrue(self.os.path.exists(file_path))\n        with self.open(file_path, 'r') as fake_file:\n            self.assertEqual('old contents', fake_file.read())\n        # actual tests\n        with self.open(file_path, 'a+') as fake_file:\n            fake_file.seek(0)\n            fake_file.write('new contents')\n            fake_file.seek(0)\n            for line in fake_file:\n                self.assertEqual('old contentsnew contents', line)\n", "docstring": "set up"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_read_with_rplus(self):\n        # set up\n        file_path = self.make_path('rplus_file')\n        self.create_file(file_path, contents='old contents here')\n        self.assertTrue(self.os.path.exists(file_path))\n        with self.open(file_path, 'r') as fake_file:\n            self.assertEqual('old contents here', fake_file.read())\n        # actual tests\n        with self.open(file_path, 'r+') as fake_file:\n            self.assertEqual('old contents here', fake_file.read())\n            fake_file.seek(0)\n            fake_file.write('new contents')\n            fake_file.seek(0)\n            self.assertEqual('new contents here', fake_file.read())\n", "docstring": "set up"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_open_flags700(self):\n        # set up\n        self.check_posix_only()\n        file_path = self.make_path('target_file')\n        self.create_with_permission(file_path, 0o700)\n        # actual tests\n        self.open(file_path, 'r').close()\n        self.open(file_path, 'w').close()\n        self.open(file_path, 'w+').close()\n        with self.assertRaises(ValueError):\n            self.open(file_path, 'INV')\n", "docstring": "set up"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_open_flags200(self):\n        # set up\n        self.check_posix_only()\n        file_path = self.make_path('target_file')\n        self.create_with_permission(file_path, 0o200)\n        # actual tests\n        self.open(file_path, 'w').close()\n        if not is_root():\n            with self.assertRaises(OSError):\n                self.open(file_path, 'r')\n            with self.assertRaises(OSError):\n                self.open(file_path, 'w+')\n        else:\n            self.open(file_path, 'r').close()\n            self.open(file_path, 'w+').close()\n", "docstring": "set up"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_follow_intra_path_link_write(self):\n        # Test a link in the middle of of a file path.\n        self.skip_if_symlink_not_supported()\n        link_path = self.os.path.join(\n            self.base_path, 'foo', 'build', 'local_machine', 'output', '1')\n        target = self.make_path('tmp', 'output', '1')\n        self.create_dir(self.make_path('tmp', 'output'))\n        self.create_symlink(self.os.path.join(\n            self.base_path, 'foo', 'build', 'local_machine'),\n            self.make_path('tmp'))\n        self.assertFalse(self.os.path.exists(link_path))\n        self.assertFalse(self.os.path.exists(target))\n        target_contents = 'real baz contents'\n        with self.open(link_path, 'w') as fh:\n            fh.write(target_contents)\n        with self.open(target, 'r') as fh:\n            got_contents = fh.read()\n        self.assertEqual(target_contents, got_contents)\n", "docstring": "Test a link in the middle of of a file path."}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def check_open_with_trailing_sep(self, error_nr):\n        # regression test for #362\n        path = self.make_path('foo') + self.os.path.sep\n        self.assert_raises_os_error(error_nr, self.open, path, 'w')\n", "docstring": "regression test for #362"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_update_other_instances_of_same_file_on_flush(self):\n        # Regression test for #302\n        file_path = self.make_path('baz')\n        with self.open(file_path, 'w') as f0:\n            with self.open(file_path, 'w') as f1:\n                f0.write('test')\n                f0.truncate()\n                f1.flush()\n                self.assertEqual(4, self.os.path.getsize(file_path))\n", "docstring": "Regression test for #302"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_st_size_after_truncate(self):\n        # Regression test for #412\n        file_path = self.make_path('foo')\n        with self.open(file_path, 'a') as f:\n            f.write('a')\n            f.truncate()\n            f.write('b')\n            f.truncate()\n            self.assertEqual(2, self.os.stat(file_path).st_size)\n", "docstring": "Regression test for #412"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_accessing_closed_file_raises(self):\n        # Regression test for #275, #280\n        if self.is_pypy:\n            raise unittest.SkipTest('Different exceptions with PyPy')\n        file_path = self.make_path('foo')\n        self.create_file(file_path, contents=b'test')\n        fake_file = self.open(file_path, 'r')\n        fake_file.close()\n        with self.assertRaises(ValueError):\n            fake_file.read(1)\n        with self.assertRaises(ValueError):\n            fake_file.write('a')\n        with self.assertRaises(ValueError):\n            fake_file.readline()\n        with self.assertRaises(ValueError):\n            fake_file.truncate()\n        with self.assertRaises(ValueError):\n            fake_file.tell()\n        with self.assertRaises(ValueError):\n            fake_file.seek(1)\n        with self.assertRaises(ValueError):\n            fake_file.flush()\n", "docstring": "Regression test for #275, #280"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_tell_flushes_under_mac_os(self):\n        # Regression test for #288\n        self.check_macos_only()\n        file_path = self.make_path('foo')\n        with self.open(file_path, 'w') as f0:\n            f0.write('test')\n            self.assertEqual(4, f0.tell())\n            self.assertEqual(4, self.os.path.getsize(file_path))\n", "docstring": "Regression test for #288"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_read_flushes_under_posix(self):\n        # Regression test for #278\n        self.check_posix_only()\n        file_path = self.make_path('foo')\n        with self.open(file_path, 'a+') as f0:\n            f0.write('test')\n            self.assertEqual('', f0.read())\n            self.assertEqual(4, self.os.path.getsize(file_path))\n", "docstring": "Regression test for #278"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_seek_flushes(self):\n        # Regression test for #290\n        file_path = self.make_path('foo')\n        with self.open(file_path, 'w') as f0:\n            f0.write('test')\n            self.assertEqual(0, self.os.path.getsize(file_path))\n            f0.seek(3)\n            self.assertEqual(4, self.os.path.getsize(file_path))\n", "docstring": "Regression test for #290"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def check_seek_outside_and_truncate_sets_size(self, mode):\n        # Regression test for #294 and #296\n        file_path = self.make_path('baz')\n        with self.open(file_path, mode) as f0:\n            f0.seek(1)\n            f0.truncate()\n            self.assertEqual(1, f0.tell())\n            self.assertEqual(1, self.os.path.getsize(file_path))\n            f0.seek(1)\n            self.assertEqual(1, self.os.path.getsize(file_path))\n        self.assertEqual(1, self.os.path.getsize(file_path))\n", "docstring": "Regression test for #294 and #296"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_seek_outside_and_truncate_sets_size_in_append_mode(self):\n        # Regression test for #295\n        self.check_seek_outside_and_truncate_sets_size('a')\n", "docstring": "Regression test for #295"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_closing_closed_file_does_nothing(self):\n        # Regression test for #299\n        file_path = self.make_path('baz')\n        f0 = self.open(file_path, 'w')\n        f0.close()\n        with self.open(file_path) as f1:\n            # would close f1 if not handled\n            f0.close()\n            self.assertEqual('', f1.read())\n", "docstring": "Regression test for #299"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_truncate_flushes_zeros(self):\n        # Regression test for #301\n        file_path = self.make_path('baz')\n        with self.open(file_path, 'w') as f0:\n            with self.open(file_path) as f1:\n                f0.seek(1)\n                f0.truncate()\n                self.assertEqual('\\0', f1.read())\n", "docstring": "Regression test for #301"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_utf16_text(self):\n        # regression test for #574\n        file_path = self.make_path('foo')\n        with self.open(file_path, \"w\", encoding='utf-16') as f:\n            assert f.write(\"1\") == 1\n        with self.open(file_path, \"a\", encoding='utf-16') as f:\n            assert f.write(\"2\") == 1\n        with self.open(file_path, \"r\", encoding='utf-16') as f:\n            text = f.read()\n            assert text == \"12\"\n", "docstring": "regression test for #574"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_failed_flush_does_not_truncate_file(self):\n        # regression test for #548\n        self.skip_real_fs()  # cannot set fs size in real fs\n        self.filesystem.set_disk_usage(100)\n        self.os.makedirs(\"foo\")\n        file_path = self.os.path.join('foo', 'bar.txt')\n        with self.open(file_path, 'wb') as f:\n            f.write(b'a' * 50)\n            f.flush()\n            with self.open(file_path, \"rb\") as r:\n                x = r.read()\n                self.assertTrue(x.startswith(b'a' * 50))\n            with self.assertRaises(OSError):\n                f.write(b'b' * 200)\n                f.flush()\n            with self.open(file_path, \"rb\") as r:\n                x = r.read()\n                self.assertTrue(x.startswith(b'a' * 50))\n            f.truncate(50)\n", "docstring": "regression test for #548"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_read_text(self):\n        \"\"\"Test that text mode flag is ignored\"\"\"\n        self.check_windows_only()\n        with self.open_file('r') as f:\n            self.assertEqual(self.converted_contents, f.read())\n        with self.open_file('rt') as f:\n            self.assertEqual(self.converted_contents, f.read())\n", "docstring": "Test that text mode flag is ignored\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_open_test.py", "original_string": "    def test_read_link_to_link(self):\n        # Write into the final link target and read back from a file which will\n        # point to that.\n        self.skip_if_symlink_not_supported()\n        link_path = self.make_path('foo', 'bar')\n        self.create_symlink(link_path, 'link')\n        self.create_symlink(self.make_path('foo', 'link'), 'baz')\n        self.write_to_file(self.make_path('foo', 'baz'))\n        fh = self.open(link_path, 'r')\n        self.assertEqual('x', fh.read())\n", "docstring": "Write into the final link target and read back from a file which will"}
{"repo": "pyfakefs-master/pyfakefs/tests/example_test.py", "original_string": "def load_tests(loader, tests, ignore):\n    \"\"\"Load the pyfakefs/example.py doctest tests into unittest.\"\"\"\n    return fake_filesystem_unittest.load_doctests(\n        loader, tests, ignore, example)\n", "docstring": "Load the pyfakefs/example.py doctest tests into unittest.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/example_test.py", "original_string": "    def setUp(self):\n        \"\"\"Invoke the :py:class:`pyfakefs.fake_filesystem_unittest.TestCase`\n        `self.setUp()` method.  This defines:\n        * Attribute `self.fs`, an instance of\n          :py:class:`pyfakefs.fake_filesystem.FakeFilesystem`. This is useful\n          for creating test files.\n        * Attribute `self.stubs`, an instance of\n          :py:class:`pyfakefs.mox3_stubout.StubOutForTesting`. Use this if\n          you need to define additional stubs.\n        \"\"\"\n        # This is before setUpPyfakefs(), so still using the real file system\n        self.filepath = os.path.realpath(__file__)\n        with io.open(self.filepath, 'rb') as f:\n            self.real_contents = f.read()\n        self.setUpPyfakefs()\n", "docstring": "Invoke the :py:class:`pyfakefs.fake_filesystem_unittest.TestCase`"}
{"repo": "pyfakefs-master/pyfakefs/tests/example_test.py", "original_string": "    def test_create_file(self):\n        \"\"\"Test example.create_file() which uses `open()` and `file.write()`.\n        \"\"\"\n        self.assertFalse(os.path.isdir('/test'))\n        os.mkdir('/test')\n        self.assertTrue(os.path.isdir('/test'))\n        self.assertFalse(os.path.exists('/test/file.txt'))\n        example.create_file('/test/file.txt')\n        self.assertTrue(os.path.exists('/test/file.txt'))\n", "docstring": "Test example.create_file() which uses `open()` and `file.write()`."}
{"repo": "pyfakefs-master/pyfakefs/tests/example_test.py", "original_string": "    def test_file_exists(self):\n        \"\"\"Test example.path_exists() which uses `os.path.exists()`.\"\"\"\n        self.assertFalse(example.path_exists('/test/empty.txt'))\n        self.fs.create_file('/test/empty.txt')\n        self.assertTrue(example.path_exists('/test/empty.txt'))\n", "docstring": "Test example.path_exists() which uses `os.path.exists()`.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/example_test.py", "original_string": "    def test_rm_tree(self):\n        \"\"\"Test example.rm_tree() using `shutil.rmtree()`.\"\"\"\n        self.fs.create_dir('/test/dir1/dir2a')\n        # os.mkdirs() works, too.\n        os.makedirs('/test/dir1/dir2b')\n        self.assertTrue(os.path.isdir('/test/dir1/dir2b'))\n        self.assertTrue(os.path.isdir('/test/dir1/dir2a'))\n        example.rm_tree('/test/dir1')\n        self.assertFalse(os.path.exists('/test/dir1'))\n", "docstring": "Test example.rm_tree() using `shutil.rmtree()`.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/example_test.py", "original_string": "    def test_scandir_scandir(self):\n        \"\"\"Test example.scandir() which uses `scandir.scandir()`.\n        The scandir module has been replaced with the fake_scandir module so\n        the fake filesystem path entries are returned instead of\n        `scandir.DirEntry` objects.\n        \"\"\"\n        self.fs.create_file('/test/text.txt')\n        self.fs.create_dir('/test/dir')\n        entries = sorted(example.scan_dir('/test'), key=lambda e: e.name)\n        self.assertEqual(2, len(entries))\n        self.assertEqual('text.txt', entries[1].name)\n        self.assertTrue(entries[0].is_dir())\n        self.assertTrue(entries[1].is_file())\n", "docstring": "Test example.scandir() which uses `scandir.scandir()`."}
{"repo": "pyfakefs-master/pyfakefs/tests/import_as_example.py", "original_string": "def check_if_exists1(filepath):\n    # test patching module imported under other name\n    return my_os.path.exists(filepath)\n", "docstring": "test patching module imported under other name"}
{"repo": "pyfakefs-master/pyfakefs/tests/import_as_example.py", "original_string": "def check_if_exists3(filepath):\n    # tests patching Path imported from pathlib\n    return Path(filepath).exists()\n", "docstring": "tests patching Path imported from pathlib"}
{"repo": "pyfakefs-master/pyfakefs/tests/import_as_example.py", "original_string": "def check_if_exists5(filepath):\n    # tests patching `exists` imported from os.path\n    return exists(filepath)\n", "docstring": "tests patching `exists` imported from os.path"}
{"repo": "pyfakefs-master/pyfakefs/tests/import_as_example.py", "original_string": "def check_if_exists7(filepath):\n    # tests patching pathlib\n    return pathlib.Path(filepath).exists()\n", "docstring": "tests patching pathlib"}
{"repo": "pyfakefs-master/pyfakefs/tests/import_as_example.py", "original_string": "def file_stat2(filepath):\n    # tests patching `stat` imported from os as other name\n    return my_stat(filepath)\n", "docstring": "tests patching `stat` imported from os as other name"}
{"repo": "pyfakefs-master/pyfakefs/tests/import_as_example.py", "original_string": "def exists_this_file():\n    \"\"\"Returns True in real fs only\"\"\"\n    return exists(__file__)\n", "docstring": "Returns True in real fs only\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/import_as_example.py", "original_string": "def return_this_file_path():\n    \"\"\"Works only in real fs\"\"\"\n    return Path(__file__)\n", "docstring": "Works only in real fs\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_stat_time_test.py", "original_string": "    def setUp(self):\n        super(TestFakeModeW, self).setUp()\n        self.mode = 'w'\n", "docstring": "super(TestFakeModeW, self).setUp()"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_stat_time_test.py", "original_string": "    def test_open_write_flush_close(self):\n        self.check_open_write_flush_close_w_mode()\n", "docstring": "self.check_open_write_flush_close_w_mode()"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_stat_time_test.py", "original_string": "    def use_real_fs(self):\n        return True\n", "docstring": "return True"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_tempfile_test.py", "original_string": "    def test_mkstemp_dir(self):\n        \"\"\"test tempfile.mkstemp(dir=).\"\"\"\n        # expect fail: /dir does not exist\n        with self.assertRaises(OSError):\n            tempfile.mkstemp(dir='/dir')\n        # expect pass: /dir exists\n        self.fs.create_dir('/dir')\n        next_fd = len(self.fs.open_files)\n        temporary = tempfile.mkstemp(dir='/dir')\n        self.assertEqual(2, len(temporary))\n        self.assertEqual(next_fd, temporary[0])\n        self.assertTrue(temporary[1].startswith(\n            os.path.join(os.sep, 'dir', 'tmp')))\n        self.assertTrue(self.fs.exists(temporary[1]))\n        mode = 0o666 if self.fs.is_windows_fs else 0o600\n        self.assertEqual(self.fs.get_object(temporary[1]).st_mode,\n                         stat.S_IFREG | mode)\n", "docstring": "test tempfile.mkstemp(dir=).\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/test_utils.py", "original_string": "    def path_separator(self):\n        \"\"\"Can be overwritten to use a specific separator in the\n        fake filesystem.\"\"\"\n        if self.use_real_fs():\n            return os.path.sep\n        return '/'\n", "docstring": "Can be overwritten to use a specific separator in the"}
{"repo": "pyfakefs-master/pyfakefs/tests/test_utils.py", "original_string": "    def check_linux_only(self):\n        \"\"\"If called at test start, the real FS test is executed only under\n        Linux, and the fake filesystem test emulates a Linux system.\n        \"\"\"\n        if self.use_real_fs():\n            if TestCase.is_macos or TestCase.is_windows:\n                raise unittest.SkipTest(\n                    'Testing Linux specific functionality')\n        else:\n            self.set_windows_fs(False)\n            self.filesystem.is_macos = False\n", "docstring": "If called at test start, the real FS test is executed only under"}
{"repo": "pyfakefs-master/pyfakefs/tests/test_utils.py", "original_string": "    def check_linux_and_windows(self):\n        \"\"\"If called at test start, the real FS test is executed only under\n        Linux and Windows, and the fake filesystem test emulates a Linux\n        system under MacOS.\n        \"\"\"\n        if self.use_real_fs():\n            if TestCase.is_macos:\n                raise unittest.SkipTest(\n                    'Testing non-MacOs functionality')\n        else:\n            self.filesystem.is_macos = False\n", "docstring": "If called at test start, the real FS test is executed only under"}
{"repo": "pyfakefs-master/pyfakefs/tests/test_utils.py", "original_string": "    def check_case_sensitive_fs(self):\n        \"\"\"If called at test start, the real FS test is executed only in a\n        case-sensitive FS (e.g. under Linux), and the fake file system test\n        emulates a case-sensitive FS under the running OS.\n        \"\"\"\n        if self.use_real_fs():\n            if TestCase.is_macos or TestCase.is_windows:\n                raise unittest.SkipTest(\n                    'Testing case sensitive specific functionality')\n        else:\n            self.filesystem.is_case_sensitive = True\n", "docstring": "If called at test start, the real FS test is executed only in a"}
{"repo": "pyfakefs-master/pyfakefs/tests/test_utils.py", "original_string": "    def skip_real_fs(self):\n        \"\"\"If called at test start, no real FS test is executed.\"\"\"\n        if self.use_real_fs():\n            raise unittest.SkipTest('Only tests fake FS')\n", "docstring": "If called at test start, no real FS test is executed.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/test_utils.py", "original_string": "    def symlink_can_be_tested(self, force_real_fs=False):\n        \"\"\"Used to check if symlinks and hard links can be tested under\n        Windows. All tests are skipped under Windows for Python versions\n        not supporting links, and real tests are skipped if running without\n        administrator rights.\n        \"\"\"\n        if (not TestCase.is_windows or\n                (not force_real_fs and not self.use_real_fs())):\n            return True\n        if TestCase.symlinks_can_be_tested is None:\n            if force_real_fs:\n                self.base_path = tempfile.mkdtemp()\n            link_path = self.make_path('link')\n            try:\n                self.os.symlink(self.base_path, link_path)\n                TestCase.symlinks_can_be_tested = True\n                self.os.remove(link_path)\n            except (OSError, NotImplementedError):\n                TestCase.symlinks_can_be_tested = False\n            if force_real_fs:\n                self.base_path = None\n        return TestCase.symlinks_can_be_tested\n", "docstring": "Used to check if symlinks and hard links can be tested under"}
{"repo": "pyfakefs-master/pyfakefs/tests/test_utils.py", "original_string": "    def make_path(self, *args):\n        \"\"\"Create a path with the given component(s). A base path is prepended\n        to the path which represents a temporary directory in the real FS,\n        and a fixed path in the fake filesystem.\n        Always use to compose absolute paths for tests also running in the\n        real FS.\n        \"\"\"\n        if isinstance(args[0], (list, tuple)):\n            path = self.base_path\n            for arg in args[0]:\n                path = self.os.path.join(path, to_string(arg))\n            return path\n        args = [to_string(arg) for arg in args]\n        return self.os.path.join(self.base_path, *args)\n", "docstring": "Create a path with the given component(s). A base path is prepended"}
{"repo": "pyfakefs-master/pyfakefs/tests/test_utils.py", "original_string": "    def create_file(self, file_path, contents=None, encoding=None, perm=0o666):\n        \"\"\"Create the given file at `file_path` with optional contents,\n        including subdirectories. `file_path` shall be composed using\n        `make_path()`.\n        \"\"\"\n        self.create_dir(self.os.path.dirname(file_path))\n        mode = ('wb' if encoding is not None or is_byte_string(contents)\n                else 'w')\n        if encoding is not None and contents is not None:\n            contents = contents.encode(encoding)\n        with self.open(file_path, mode) as f:\n            if contents is not None:\n                f.write(contents)\n        self.os.chmod(file_path, perm)\n", "docstring": "Create the given file at `file_path` with optional contents,"}
{"repo": "pyfakefs-master/pyfakefs/tests/test_utils.py", "original_string": "    def check_contents(self, file_path, contents):\n        \"\"\"Compare `contents` with the contents of the file at `file_path`.\n        Asserts equality.\n        \"\"\"\n        mode = 'rb' if is_byte_string(contents) else 'r'\n        with self.open(file_path, mode) as f:\n            self.assertEqual(contents, f.read())\n", "docstring": "Compare `contents` with the contents of the file at `file_path`."}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_pathlib_test.py", "original_string": "    def test_initialization_type(self):\n        \"\"\"Make sure tests for class type will work\"\"\"\n        path = self.path('/test')\n        if is_windows:\n            self.assertTrue(isinstance(path, self.pathlib.WindowsPath))\n            self.assertTrue(isinstance(path, self.pathlib.PureWindowsPath))\n            self.assertTrue(self.pathlib.PurePosixPath())\n            # in fake fs, we allow to use the other OS implementation\n            if self.use_real_fs():\n                with self.assertRaises(NotImplementedError):\n                    self.pathlib.PosixPath()\n            else:\n                self.assertTrue(self.pathlib.PosixPath())\n        else:\n            self.assertTrue(isinstance(path, self.pathlib.PosixPath))\n            self.assertTrue(isinstance(path, self.pathlib.PurePosixPath))\n            self.assertTrue(self.pathlib.PureWindowsPath())\n            if self.use_real_fs():\n                with self.assertRaises(NotImplementedError):\n                    self.pathlib.WindowsPath()\n            else:\n                self.assertTrue(self.pathlib.WindowsPath())\n", "docstring": "Make sure tests for class type will work\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_pathlib_test.py", "original_string": "    def test_init_collapse(self):\n        \"\"\"Tests for collapsing path during initialization.\n        Taken from pathlib.PurePath documentation.\n        \"\"\"\n        self.assertEqual(self.path('foo//bar'), self.path('foo/bar'))\n        self.assertEqual(self.path('foo/./bar'), self.path('foo/bar'))\n        self.assertNotEqual(self.path('foo/../bar'), self.path('foo/bar'))\n        self.assertEqual(self.path('/etc', '/usr', 'lib64'),\n                         self.path('/usr/lib64'))\n", "docstring": "Tests for collapsing path during initialization."}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_pathlib_test.py", "original_string": "    def test_init_with_segments(self):\n        \"\"\"Basic initialization tests - taken from pathlib.Path\n        documentation\"\"\"\n        self.assertEqual(self.path('c:/', 'foo', 'bar', 'baz'),\n                         self.path('c:/foo/bar/baz'))\n        self.assertEqual(self.path(), self.path('.'))\n        self.assertEqual(self.path(self.path('foo'), self.path('bar')),\n                         self.path('foo/bar'))\n        self.assertEqual(self.path('c:/Users') / 'john' / 'data',\n                         self.path('c:/Users/john/data'))\n", "docstring": "Basic initialization tests - taken from pathlib.Path"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_vs_real_test.py", "original_string": "def sep(path):\n    \"\"\"Converts slashes in the path to the architecture's path seperator.\"\"\"\n    if isinstance(path, str):\n        return path.replace('/', os.sep)\n    return path\n", "docstring": "Converts slashes in the path to the architecture's path seperator.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_vs_real_test.py", "original_string": "    def _paths(self, path):\n        \"\"\"For a given path, return paths in the real and fake filesystems.\"\"\"\n        if not path:\n            return None, None\n        return (os.path.join(self.real_base, path),\n                os.path.join(self.fake_base, path))\n", "docstring": "For a given path, return paths in the real and fake filesystems.\n"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_vs_real_test.py", "original_string": "    def setUp(self):\n        # Base paths in the real and test file systems. We keep them different\n        # so that missing features in the fake don't fall through to the base\n        # operations and magically succeed.\n        tsname = 'fakefs.%s' % time.time()\n        self.cwd = os.getcwd()\n        # Fully expand the base_path - required on OS X.\n        self.real_base = os.path.realpath(\n            os.path.join(tempfile.gettempdir(), tsname))\n        os.chdir(tempfile.gettempdir())\n        if os.path.isdir(self.real_base):\n            shutil.rmtree(self.real_base)\n        os.mkdir(self.real_base)\n        self.fake_base = self._FAKE_FS_BASE\n        # Make sure we can write to the physical testing temp directory.\n        self.assertTrue(os.access(self.real_base, os.W_OK))\n        self.fake_filesystem = fake_filesystem.FakeFilesystem()\n        self.fake_filesystem.create_dir(self.fake_base)\n        self.fake_os = fake_filesystem.FakeOsModule(self.fake_filesystem)\n        self.fake_open = fake_filesystem.FakeFileOpen(self.fake_filesystem)\n        self._created_files = []\n        os.chdir(self.real_base)\n        self.fake_os.chdir(self.fake_base)\n", "docstring": "Base paths in the real and test file systems. We keep them different"}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_vs_real_test.py", "original_string": "    def test_isabs(self):\n        # We do not have to create any files for isabs.\n        self.assertOsPathMethodBehaviorMatches('isabs', None)\n        self.assertOsPathMethodBehaviorMatches('isabs', '')\n        self.assertOsPathMethodBehaviorMatches('isabs', '/')\n        self.assertOsPathMethodBehaviorMatches('isabs', '/a')\n        self.assertOsPathMethodBehaviorMatches('isabs', 'a')\n", "docstring": "We do not have to create any files for isabs."}
{"repo": "pyfakefs-master/pyfakefs/tests/fake_filesystem_vs_real_test.py", "original_string": "    def test_sym_link_to_parent(self):\n        # Soft links on HFS+ / OS X behave differently.\n        if os.uname()[0] != 'Darwin':\n            self._create_test_file('d', 'a')\n            self._create_test_file('d', 'a/b')\n            self._create_test_file('l', 'a/b/c', '..')\n            self.assertAllOsBehaviorsMatch('a/b/c')\n", "docstring": "Soft links on HFS+ / OS X behave differently."}
{"repo": "eventlet-master/examples/producer_consumer.py", "original_string": "def fetch(url, outq):\n    \"\"\"Fetch a url and push any urls found into a queue.\"\"\"\n    print(\"fetching\", url)\n    data = ''\n    with eventlet.Timeout(5, False):\n        data = urllib2.urlopen(url).read().decode()\n    for url_match in url_regex.finditer(data):\n        new_url = url_match.group(0)\n        outq.put(new_url)\n", "docstring": "Fetch a url and push any urls found into a queue.\n"}
{"repo": "eventlet-master/examples/websocket.py", "original_string": "def handle(ws):\n    \"\"\"  This is the websocket handler function.  Note that we\n    can dispatch based on path in here, too.\"\"\"\n    if ws.path == '/echo':\n        while True:\n            m = ws.wait()\n            if m is None:\n                break\n            ws.send(m)\n    elif ws.path == '/data':\n        for i in six.moves.range(10000):\n            ws.send(\"0 %s %s\\n\" % (i, random.random()))\n            eventlet.sleep(0.1)\n", "docstring": "This is the websocket handler function.  Note that we"}
{"repo": "eventlet-master/examples/recursive_crawler.py", "original_string": "def fetch(url, seen, pool):\n    \"\"\"Fetch a url, stick any found urls into the seen set, and\n    dispatch any new ones to the pool.\"\"\"\n    print(\"fetching\", url)\n    data = ''\n    with eventlet.Timeout(5, False):\n        data = urlopen(url).read().decode()\n    for url_match in url_regex.finditer(data):\n        new_url = url_match.group(0)\n        # only send requests to eventlet.net so as not to destroy the internet\n        if new_url not in seen and 'eventlet.net' in new_url:\n            seen.add(new_url)\n            # while this seems stack-recursive, it's actually not:\n            # spawned greenthreads start their own stacks\n            pool.spawn_n(fetch, new_url, seen, pool)\n", "docstring": "Fetch a url, stick any found urls into the seen set, and"}
{"repo": "eventlet-master/eventlet/corolocal.py", "original_string": "def get_ident():\n    \"\"\" Returns ``id()`` of current greenlet.  Useful for debugging.\"\"\"\n    return id(greenthread.getcurrent())\n", "docstring": "Returns ``id()`` of current greenlet.  Useful for debugging.\n"}
{"repo": "eventlet-master/eventlet/pools.py", "original_string": "    def __init__(self, min_size=0, max_size=4, order_as_stack=False, create=None):\n        \"\"\"*order_as_stack* governs the ordering of the items in the free pool.\n        If ``False`` (the default), the free items collection (of items that\n        were created and were put back in the pool) acts as a round-robin,\n        giving each item approximately equal utilization.  If ``True``, the\n        free pool acts as a FILO stack, which preferentially re-uses items that\n        have most recently been used.\n        \"\"\"\n        self.min_size = min_size\n        self.max_size = max_size\n        self.order_as_stack = order_as_stack\n        self.current_size = 0\n        self.channel = queue.LightQueue(0)\n        self.free_items = collections.deque()\n        if create is not None:\n            self.create = create\n        for x in range(min_size):\n            self.current_size += 1\n            self.free_items.append(self.create())\n", "docstring": "*order_as_stack* governs the ordering of the items in the free pool."}
{"repo": "eventlet-master/eventlet/pools.py", "original_string": "    def item(self):\n        \"\"\" Get an object out of the pool, for use with with statement.\n        >>> from eventlet import pools\n        >>> pool = pools.TokenPool(max_size=4)\n        >>> with pool.item() as obj:\n        ...     print(\"got token\")\n        ...\n        got token\n        >>> pool.free()\n        4\n        \"\"\"\n        obj = self.get()\n        try:\n            yield obj\n        finally:\n            self.put(obj)\n", "docstring": "Get an object out of the pool, for use with with statement."}
{"repo": "eventlet-master/eventlet/pools.py", "original_string": "    def resize(self, new_size):\n        \"\"\"Resize the pool to *new_size*.\n        Adjusting this number does not affect existing items checked out of\n        the pool, nor on any greenthreads who are waiting for an item to free\n        up.  Some indeterminate number of :meth:`get`/:meth:`put`\n        cycles will be necessary before the new maximum size truly matches\n        the actual operation of the pool.\n        \"\"\"\n        self.max_size = new_size\n", "docstring": "Resize the pool to *new_size*."}
{"repo": "eventlet-master/eventlet/pools.py", "original_string": "    def waiting(self):\n        \"\"\"Return the number of routines waiting for a pool item.\n        \"\"\"\n        return max(0, self.channel.getting() - self.channel.putting())\n", "docstring": "Return the number of routines waiting for a pool item."}
{"repo": "eventlet-master/eventlet/greenthread.py", "original_string": "def sleep(seconds=0):\n    \"\"\"Yield control to another eligible coroutine until at least *seconds* have\n    elapsed.\n    *seconds* may be specified as an integer, or a float if fractional seconds\n    are desired. Calling :func:`~greenthread.sleep` with *seconds* of 0 is the\n    canonical way of expressing a cooperative yield. For example, if one is\n    looping over a large list performing an expensive calculation without\n    calling any socket methods, it's a good idea to call ``sleep(0)``\n    occasionally; otherwise nothing else will run.\n    \"\"\"\n    hub = hubs.get_hub()\n    current = getcurrent()\n    assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'\n    timer = hub.schedule_call_global(seconds, current.switch)\n    try:\n        hub.switch()\n    finally:\n        timer.cancel()\n", "docstring": "Yield control to another eligible coroutine until at least *seconds* have"}
{"repo": "eventlet-master/eventlet/greenthread.py", "original_string": "def spawn_n(func, *args, **kwargs):\n    \"\"\"Same as :func:`spawn`, but returns a ``greenlet`` object from\n    which it is not possible to retrieve either a return value or\n    whether it raised any exceptions.  This is faster than\n    :func:`spawn`; it is fastest if there are no keyword arguments.\n    If an exception is raised in the function, spawn_n prints a stack\n    trace; the print can be disabled by calling\n    :func:`eventlet.debug.hub_exceptions` with False.\n    \"\"\"\n    return _spawn_n(0, func, args, kwargs)[1]\n", "docstring": "Same as :func:`spawn`, but returns a ``greenlet`` object from"}
{"repo": "eventlet-master/eventlet/greenthread.py", "original_string": "def spawn_after_local(seconds, func, *args, **kwargs):\n    \"\"\"Spawns *func* after *seconds* have elapsed.  The function will NOT be\n    called if the current greenthread has exited.\n    *seconds* may be specified as an integer, or a float if fractional seconds\n    are desired. The *func* will be called with the given *args* and\n    keyword arguments *kwargs*, and will be executed within its own greenthread.\n    The return value of :func:`spawn_after` is a :class:`GreenThread` object,\n    which can be used to retrieve the results of the call.\n    To cancel the spawn and prevent *func* from being called,\n    call :meth:`GreenThread.cancel` on the return value. This will not abort the\n    function if it's already started running.  If terminating *func* regardless\n    of whether it's started or not is the desired behavior, call\n    :meth:`GreenThread.kill`.\n    \"\"\"\n    hub = hubs.get_hub()\n    g = GreenThread(hub.greenlet)\n    hub.schedule_call_local(seconds, g.switch, func, args, kwargs)\n    return g\n", "docstring": "Spawns *func* after *seconds* have elapsed.  The function will NOT be"}
{"repo": "eventlet-master/eventlet/greenthread.py", "original_string": "    def link(self, func, *curried_args, **curried_kwargs):\n        \"\"\" Set up a function to be called with the results of the GreenThread.\n        The function must have the following signature::\n            def func(gt, [curried args/kwargs]):\n        When the GreenThread finishes its run, it calls *func* with itself\n        and with the `curried arguments <http://en.wikipedia.org/wiki/Currying>`_ supplied\n        at link-time.  If the function wants to retrieve the result of the GreenThread,\n        it should call wait() on its first argument.\n        Note that *func* is called within execution context of\n        the GreenThread, so it is possible to interfere with other linked\n        functions by doing things like switching explicitly to another\n        greenthread.\n        \"\"\"\n        if self._exit_funcs is None:\n            self._exit_funcs = deque()\n        self._exit_funcs.append((func, curried_args, curried_kwargs))\n        if self._exit_event.ready():\n            self._resolve_links()\n", "docstring": "Set up a function to be called with the results of the GreenThread."}
{"repo": "eventlet-master/eventlet/greenthread.py", "original_string": "    def kill(self, *throw_args):\n        \"\"\"Kills the greenthread using :func:`kill`.  After being killed\n        all calls to :meth:`wait` will raise *throw_args* (which default\n        to :class:`greenlet.GreenletExit`).\"\"\"\n        return kill(self, *throw_args)\n", "docstring": "Kills the greenthread using :func:`kill`.  After being killed"}
{"repo": "eventlet-master/eventlet/greenthread.py", "original_string": "def cancel(g, *throw_args):\n    \"\"\"Like :func:`kill`, but only terminates the greenthread if it hasn't\n    already started execution.  If the grenthread has already started\n    execution, :func:`cancel` has no effect.\"\"\"\n    if not g:\n        kill(g, *throw_args)\n", "docstring": "Like :func:`kill`, but only terminates the greenthread if it hasn't"}
{"repo": "eventlet-master/eventlet/greenpool.py", "original_string": "    def running(self):\n        \"\"\" Returns the number of greenthreads that are currently executing\n        functions in the GreenPool.\"\"\"\n        return len(self.coroutines_running)\n", "docstring": "Returns the number of greenthreads that are currently executing"}
{"repo": "eventlet-master/eventlet/greenpool.py", "original_string": "    def spawn(self, function, *args, **kwargs):\n        \"\"\"Run the *function* with its arguments in its own green thread.\n        Returns the :class:`GreenThread <eventlet.GreenThread>`\n        object that is running the function, which can be used to retrieve the\n        results.\n        If the pool is currently at capacity, ``spawn`` will block until one of\n        the running greenthreads completes its task and frees up a slot.\n        This function is reentrant; *function* can call ``spawn`` on the same\n        pool without risk of deadlocking the whole thing.\n        \"\"\"\n        # if reentering an empty pool, don't try to wait on a coroutine freeing\n        # itself -- instead, just execute in the current coroutine\n        current = eventlet.getcurrent()\n        if self.sem.locked() and current in self.coroutines_running:\n            # a bit hacky to use the GT without switching to it\n            gt = eventlet.greenthread.GreenThread(current)\n            gt.main(function, args, kwargs)\n            return gt\n        else:\n            self.sem.acquire()\n            gt = eventlet.spawn(function, *args, **kwargs)\n            if not self.coroutines_running:\n                self.no_coros_running = eventlet.Event()\n            self.coroutines_running.add(gt)\n            gt.link(self._spawn_done)\n        return gt\n", "docstring": "Run the *function* with its arguments in its own green thread."}
{"repo": "eventlet-master/eventlet/greenpool.py", "original_string": "    def spawn_n(self, function, *args, **kwargs):\n        \"\"\"Create a greenthread to run the *function*, the same as\n        :meth:`spawn`.  The difference is that :meth:`spawn_n` returns\n        None; the results of *function* are not retrievable.\n        \"\"\"\n        # if reentering an empty pool, don't try to wait on a coroutine freeing\n        # itself -- instead, just execute in the current coroutine\n        current = eventlet.getcurrent()\n        if self.sem.locked() and current in self.coroutines_running:\n            self._spawn_n_impl(function, args, kwargs, None)\n        else:\n            self.sem.acquire()\n            g = eventlet.spawn_n(\n                self._spawn_n_impl,\n                function, args, kwargs, True)\n            if not self.coroutines_running:\n                self.no_coros_running = eventlet.Event()\n            self.coroutines_running.add(g)\n", "docstring": "Create a greenthread to run the *function*, the same as"}
{"repo": "eventlet-master/eventlet/greenpool.py", "original_string": "    def imap(self, function, *iterables):\n        \"\"\"This is the same as :func:`itertools.imap`, and has the same\n        concurrency and memory behavior as :meth:`starmap`.\n        It's quite convenient for, e.g., farming out jobs from a file::\n           def worker(line):\n               return do_something(line)\n           pool = GreenPool()\n           for result in pool.imap(worker, open(\"filename\", 'r')):\n               print(result)\n        \"\"\"\n        return self.starmap(function, six.moves.zip(*iterables))\n", "docstring": "This is the same as :func:`itertools.imap`, and has the same"}
{"repo": "eventlet-master/eventlet/websocket.py", "original_string": "    def _parse_messages(self):\n        \"\"\" Parses for messages in the buffer *buf*.  It is assumed that\n        the buffer contains the start character for a message, but that it\n        may contain only part of the rest of the message.\n        Returns an array of messages, and the buffer remainder that\n        didn't contain any full messages.\"\"\"\n        msgs = []\n        end_idx = 0\n        buf = self._buf\n        while buf:\n            frame_type = six.indexbytes(buf, 0)\n            if frame_type == 0:\n                # Normal message.\n                end_idx = buf.find(b\"\\xFF\")\n                if end_idx == -1:  # pragma NO COVER\n                    break\n                msgs.append(buf[1:end_idx].decode('utf-8', 'replace'))\n                buf = buf[end_idx + 1:]\n            elif frame_type == 255:\n                # Closing handshake.\n                assert six.indexbytes(buf, 1) == 0, \"Unexpected closing handshake: %r\" % buf\n                self.websocket_closed = True\n                break\n            else:\n                raise ValueError(\"Don't understand how to parse this type of message: %r\" % buf)\n        self._buf = buf\n        return msgs\n", "docstring": "Parses for messages in the buffer *buf*.  It is assumed that"}
{"repo": "eventlet-master/eventlet/websocket.py", "original_string": "    def wait(self):\n        \"\"\"Waits for and deserializes messages.\n        Returns a single message; the oldest not yet processed. If the client\n        has already closed the connection, returns None.  This is different\n        from normal socket behavior because the empty string is a valid\n        websocket message.\"\"\"\n        while not self._msgs:\n            # Websocket might be closed already.\n            if self.websocket_closed:\n                return None\n            # no parsed messages, must mean buf needs more data\n            delta = self.socket.recv(8096)\n            if delta == b'':\n                return None\n            self._buf += delta\n            msgs = self._parse_messages()\n            self._msgs.extend(msgs)\n        return self._msgs.popleft()\n", "docstring": "Waits for and deserializes messages."}
{"repo": "eventlet-master/eventlet/websocket.py", "original_string": "    def close(self):\n        \"\"\"Forcibly close the websocket; generally it is preferable to\n        return from the handler method.\"\"\"\n        try:\n            self._send_closing_frame(True)\n            self.socket.shutdown(True)\n        except SocketError as e:\n            if e.errno != errno.ENOTCONN:\n                self.log.write('{ctx} socket shutdown error: {e}'.format(ctx=self.log_context, e=e))\n        finally:\n            self.socket.close()\n", "docstring": "Forcibly close the websocket; generally it is preferable to"}
{"repo": "eventlet-master/eventlet/websocket.py", "original_string": "    def __init__(self, status, message):\n        super(FailedConnectionError, self).__init__(status, message)\n        self.message = message\n        self.status = status\n", "docstring": "super(FailedConnectionError, self).__init__(status, message)"}
{"repo": "eventlet-master/eventlet/patcher.py", "original_string": "    def restore(self):\n        \"\"\"Restores the modules that the saver knows about into\n        sys.modules.\n        \"\"\"\n        try:\n            for modname, mod in six.iteritems(self._saved):\n                if mod is not None:\n                    sys.modules[modname] = mod\n                else:\n                    try:\n                        del sys.modules[modname]\n                    except KeyError:\n                        pass\n        finally:\n            imp.release_lock()\n", "docstring": "Restores the modules that the saver knows about into"}
{"repo": "eventlet-master/eventlet/patcher.py", "original_string": "def import_patched(module_name, *additional_modules, **kw_additional_modules):\n    \"\"\"Imports a module in a way that ensures that the module uses \"green\"\n    versions of the standard library modules, so that everything works\n    nonblockingly.\n    The only required argument is the name of the module to be imported.\n    \"\"\"\n    return inject(\n        module_name,\n        None,\n        *additional_modules + tuple(kw_additional_modules.items()))\n", "docstring": "Imports a module in a way that ensures that the module uses \"green\""}
{"repo": "eventlet-master/eventlet/patcher.py", "original_string": "def _original_patch_function(func, *module_names):\n    \"\"\"Kind of the contrapositive of patch_function: decorates a\n    function such that when it's called, sys.modules is populated only\n    with the unpatched versions of the specified modules.  Unlike\n    patch_function, only the names of the modules need be supplied,\n    and there are no defaults.  This is a gross hack; tell your kids not\n    to import inside function bodies!\"\"\"\n    def patched(*args, **kw):\n        saver = SysModulesSaver(module_names)\n        for name in module_names:\n            sys.modules[name] = original(name)\n        try:\n            return func(*args, **kw)\n        finally:\n            saver.restore()\n    return patched\n", "docstring": "Kind of the contrapositive of patch_function: decorates a"}
{"repo": "eventlet-master/eventlet/patcher.py", "original_string": "def _green_existing_locks():\n    \"\"\"Make locks created before monkey-patching safe.\n    RLocks rely on a Lock and on Python 2, if an unpatched Lock blocks, it\n    blocks the native thread. We need to replace these with green Locks.\n    This was originally noticed in the stdlib logging module.\"\"\"\n    import gc\n    import threading\n    import eventlet.green.thread\n    lock_type = type(threading.Lock())\n    rlock_type = type(threading.RLock())\n    if hasattr(threading, '_PyRLock'):\n        # this happens on CPython3 and PyPy >= 7.0.0: \"py3-style\" rlocks, they\n        # are implemented natively in C and RPython respectively\n        py3_style = True\n        pyrlock_type = type(threading._PyRLock())\n    else:\n        # this happens on CPython2.7 and PyPy < 7.0.0: \"py2-style\" rlocks,\n        # they are implemented in pure-python\n        py3_style = False\n        pyrlock_type = None\n    # We're monkey-patching so there can't be any greenlets yet, ergo our thread\n    # ID is the only valid owner possible.\n    tid = eventlet.green.thread.get_ident()\n    for obj in gc.get_objects():\n        if isinstance(obj, rlock_type):\n            if not py3_style and isinstance(obj._RLock__block, lock_type):\n                _fix_py2_rlock(obj, tid)\n            elif py3_style and not isinstance(obj, pyrlock_type):\n                _fix_py3_rlock(obj)\n", "docstring": "Make locks created before monkey-patching safe."}
{"repo": "eventlet-master/eventlet/semaphore.py", "original_string": "    def locked(self):\n        \"\"\"Returns true if a call to acquire would block.\n        \"\"\"\n        return self.counter <= 0\n", "docstring": "Returns true if a call to acquire would block."}
{"repo": "eventlet-master/eventlet/semaphore.py", "original_string": "    def acquire(self, blocking=True, timeout=None):\n        \"\"\"Acquire a semaphore.\n        When invoked without arguments: if the internal counter is larger than\n        zero on entry, decrement it by one and return immediately. If it is zero\n        on entry, block, waiting until some other thread has called release() to\n        make it larger than zero. This is done with proper interlocking so that\n        if multiple acquire() calls are blocked, release() will wake exactly one\n        of them up. The implementation may pick one at random, so the order in\n        which blocked threads are awakened should not be relied on. There is no\n        return value in this case.\n        When invoked with blocking set to true, do the same thing as when called\n        without arguments, and return true.\n        When invoked with blocking set to false, do not block. If a call without\n        an argument would block, return false immediately; otherwise, do the\n        same thing as when called without arguments, and return true.\n        Timeout value must be strictly positive.\n        \"\"\"\n        if timeout == -1:\n            timeout = None\n        if timeout is not None and timeout < 0:\n            raise ValueError(\"timeout value must be strictly positive\")\n        if not blocking:\n            if timeout is not None:\n                raise ValueError(\"can't specify timeout for non-blocking acquire\")\n            timeout = 0\n        if not blocking and self.locked():\n            return False\n        current_thread = eventlet.getcurrent()\n        if self.counter <= 0 or self._waiters:\n            if current_thread not in self._waiters:\n                self._waiters.append(current_thread)\n            try:\n                if timeout is not None:\n                    ok = False\n                    with eventlet.Timeout(timeout, False):\n                        while self.counter <= 0:\n                            hubs.get_hub().switch()\n                        ok = True\n                    if not ok:\n                        return False\n                else:\n                    # If someone else is already in this wait loop, give them\n                    # a chance to get out.\n                    while True:\n                        hubs.get_hub().switch()\n                        if self.counter > 0:\n                            break\n            finally:\n                try:\n                    self._waiters.remove(current_thread)\n                except ValueError:\n                    # Fine if its already been dropped.\n                    pass\n        self.counter -= 1\n        return True\n", "docstring": "Acquire a semaphore."}
{"repo": "eventlet-master/eventlet/semaphore.py", "original_string": "    def release(self, blocking=True):\n        \"\"\"Release a semaphore, incrementing the internal counter by one. When\n        it was zero on entry and another thread is waiting for it to become\n        larger than zero again, wake up that thread.\n        The *blocking* argument is for consistency with CappedSemaphore and is\n        ignored\n        \"\"\"\n        self.counter += 1\n        if self._waiters:\n            hubs.get_hub().schedule_call_global(0, self._do_acquire)\n        return True\n", "docstring": "Release a semaphore, incrementing the internal counter by one. When"}
{"repo": "eventlet-master/eventlet/semaphore.py", "original_string": "    def balance(self):\n        \"\"\"An integer value that represents how many new calls to\n        :meth:`acquire` or :meth:`release` would be needed to get the counter to\n        0.  If it is positive, then its value is the number of acquires that can\n        happen before the next acquire would block.  If it is negative, it is\n        the negative of the number of releases that would be required in order\n        to make the counter 0 again (one more release would push the counter to\n        1 and unblock acquirers).  It takes into account how many greenthreads\n        are currently blocking in :meth:`acquire`.\n        \"\"\"\n        # positive means there are free items\n        # zero means there are no free items but nobody has requested one\n        # negative means there are requests for items, but no items\n        return self.counter - len(self._waiters)\n", "docstring": "An integer value that represents how many new calls to"}
{"repo": "eventlet-master/eventlet/semaphore.py", "original_string": "    def bounded(self):\n        \"\"\"Returns true if a call to release would block.\n        \"\"\"\n        return self.upper_bound.locked()\n", "docstring": "Returns true if a call to release would block."}
{"repo": "eventlet-master/eventlet/queue.py", "original_string": "    def waiting(self):\n        return self.greenlet is not None\n", "docstring": "return self.greenlet is not None"}
{"repo": "eventlet-master/eventlet/queue.py", "original_string": "    def throw(self, *throw_args):\n        \"\"\"Make greenlet calling wait() wake up (if there is a wait()).\n        Can only be called from Hub's greenlet.\n        \"\"\"\n        assert getcurrent() is get_hub(\n        ).greenlet, \"Can only use Waiter.switch method from the mainloop\"\n        if self.greenlet is not None:\n            try:\n                self.greenlet.throw(*throw_args)\n            except Exception:\n                traceback.print_exc()\n", "docstring": "Make greenlet calling wait() wake up (if there is a wait())."}
{"repo": "eventlet-master/eventlet/queue.py", "original_string": "    def wait(self):\n        \"\"\"Wait until switch() or throw() is called.\n        \"\"\"\n        assert self.greenlet is None, 'This Waiter is already used by %r' % (self.greenlet, )\n        self.greenlet = getcurrent()\n        try:\n            return get_hub().switch()\n        finally:\n            self.greenlet = None\n", "docstring": "Wait until switch() or throw() is called."}
{"repo": "eventlet-master/eventlet/queue.py", "original_string": "    def qsize(self):\n        \"\"\"Return the size of the queue.\"\"\"\n        return len(self.queue)\n", "docstring": "Return the size of the queue.\n"}
{"repo": "eventlet-master/eventlet/queue.py", "original_string": "    def putting(self):\n        \"\"\"Returns the number of greenthreads that are blocked waiting to put\n        items into the queue.\"\"\"\n        return len(self.putters)\n", "docstring": "Returns the number of greenthreads that are blocked waiting to put"}
{"repo": "eventlet-master/eventlet/queue.py", "original_string": "    def empty(self):\n        \"\"\"Return ``True`` if the queue is empty, ``False`` otherwise.\"\"\"\n        return not self.qsize()\n", "docstring": "Return ``True`` if the queue is empty, ``False`` otherwise.\n"}
{"repo": "eventlet-master/eventlet/queue.py", "original_string": "    def put(self, item, block=True, timeout=None):\n        \"\"\"Put an item into the queue.\n        If optional arg *block* is true and *timeout* is ``None`` (the default),\n        block if necessary until a free slot is available. If *timeout* is\n        a positive number, it blocks at most *timeout* seconds and raises\n        the :class:`Full` exception if no free slot was available within that time.\n        Otherwise (*block* is false), put an item on the queue if a free slot\n        is immediately available, else raise the :class:`Full` exception (*timeout*\n        is ignored in that case).\n        \"\"\"\n        if self.maxsize is None or self.qsize() < self.maxsize:\n            # there's a free slot, put an item right away\n            self._put(item)\n            if self.getters:\n                self._schedule_unlock()\n        elif not block and get_hub().greenlet is getcurrent():\n            # we're in the mainloop, so we cannot wait; we can switch() to other greenlets though\n            # find a getter and deliver an item to it\n            while self.getters:\n                getter = self.getters.pop()\n                if getter:\n                    self._put(item)\n                    item = self._get()\n                    getter.switch(item)\n                    return\n            raise Full\n        elif block:\n            waiter = ItemWaiter(item, block)\n            self.putters.add(waiter)\n            timeout = Timeout(timeout, Full)\n            try:\n                if self.getters:\n                    self._schedule_unlock()\n                result = waiter.wait()\n                assert result is waiter, \"Invalid switch into Queue.put: %r\" % (result, )\n                if waiter.item is not _NONE:\n                    self._put(item)\n            finally:\n                timeout.cancel()\n                self.putters.discard(waiter)\n        elif self.getters:\n            waiter = ItemWaiter(item, block)\n            self.putters.add(waiter)\n            self._schedule_unlock()\n            result = waiter.wait()\n            assert result is waiter, \"Invalid switch into Queue.put: %r\" % (result, )\n            if waiter.item is not _NONE:\n                raise Full\n        else:\n            raise Full\n", "docstring": "Put an item into the queue."}
{"repo": "eventlet-master/eventlet/queue.py", "original_string": "    def get(self, block=True, timeout=None):\n        \"\"\"Remove and return an item from the queue.\n        If optional args *block* is true and *timeout* is ``None`` (the default),\n        block if necessary until an item is available. If *timeout* is a positive number,\n        it blocks at most *timeout* seconds and raises the :class:`Empty` exception\n        if no item was available within that time. Otherwise (*block* is false), return\n        an item if one is immediately available, else raise the :class:`Empty` exception\n        (*timeout* is ignored in that case).\n        \"\"\"\n        if self.qsize():\n            if self.putters:\n                self._schedule_unlock()\n            return self._get()\n        elif not block and get_hub().greenlet is getcurrent():\n            # special case to make get_nowait() runnable in the mainloop greenlet\n            # there are no items in the queue; try to fix the situation by unlocking putters\n            while self.putters:\n                putter = self.putters.pop()\n                if putter:\n                    putter.switch(putter)\n                    if self.qsize():\n                        return self._get()\n            raise Empty\n        elif block:\n            waiter = Waiter()\n            timeout = Timeout(timeout, Empty)\n            try:\n                self.getters.add(waiter)\n                if self.putters:\n                    self._schedule_unlock()\n                try:\n                    return waiter.wait()\n                except:\n                    self._schedule_unlock()\n                    raise\n            finally:\n                self.getters.discard(waiter)\n                timeout.cancel()\n        else:\n            raise Empty\n", "docstring": "Remove and return an item from the queue."}
{"repo": "eventlet-master/eventlet/queue.py", "original_string": "    def task_done(self):\n        '''Indicate that a formerly enqueued task is complete. Used by queue consumer threads.\n        For each :meth:`get <Queue.get>` used to fetch a task, a subsequent call to\n        :meth:`task_done` tells the queue that the processing on the task is complete.\n        If a :meth:`join` is currently blocking, it will resume when all items have been processed\n        (meaning that a :meth:`task_done` call was received for every item that had been\n        :meth:`put <Queue.put>` into the queue).\n        Raises a :exc:`ValueError` if called more times than there were items placed in the queue.\n        '''\n        if self.unfinished_tasks <= 0:\n            raise ValueError('task_done() called too many times')\n        self.unfinished_tasks -= 1\n        if self.unfinished_tasks == 0:\n            self._cond.send(None)\n", "docstring": "Indicate that a formerly enqueued task is complete. Used by queue consumer threads."}
{"repo": "eventlet-master/eventlet/event.py", "original_string": "    def reset(self):\n        # this is kind of a misfeature and doesn't work perfectly well,\n        # it's better to create a new event rather than reset an old one\n        # removing documentation so that we don't get new use cases for it\n        assert self._result is not NOT_USED, 'Trying to re-reset() a fresh event.'\n        self._result = NOT_USED\n        self._exc = None\n", "docstring": "this is kind of a misfeature and doesn't work perfectly well,"}
{"repo": "eventlet-master/eventlet/event.py", "original_string": "    def wait(self, timeout=None):\n        \"\"\"Wait until another coroutine calls :meth:`send`.\n        Returns the value the other coroutine passed to :meth:`send`.\n        >>> import eventlet\n        >>> evt = eventlet.Event()\n        >>> def wait_on():\n        ...    retval = evt.wait()\n        ...    print(\"waited for {0}\".format(retval))\n        >>> _ = eventlet.spawn(wait_on)\n        >>> evt.send('result')\n        >>> eventlet.sleep(0)\n        waited for result\n        Returns immediately if the event has already occurred.\n        >>> evt.wait()\n        'result'\n        When the timeout argument is present and not None, it should be a floating point number\n        specifying a timeout for the operation in seconds (or fractions thereof).\n        \"\"\"\n        current = greenlet.getcurrent()\n        if self._result is NOT_USED:\n            hub = hubs.get_hub()\n            self._waiters.add(current)\n            timer = None\n            if timeout is not None:\n                timer = hub.schedule_call_local(timeout, self._do_send, None, None, current)\n            try:\n                result = hub.switch()\n                if timer is not None:\n                    timer.cancel()\n                return result\n            finally:\n                self._waiters.discard(current)\n        if self._exc is not None:\n            current.throw(*self._exc)\n        return self._result\n", "docstring": "Wait until another coroutine calls :meth:`send`."}
{"repo": "eventlet-master/eventlet/wsgi.py", "original_string": "def format_date_time(timestamp):\n    \"\"\"Formats a unix timestamp into an HTTP standard string.\"\"\"\n    year, month, day, hh, mm, ss, wd, _y, _z = time.gmtime(timestamp)\n    return \"%s, %02d %3s %4d %02d:%02d:%02d GMT\" % (\n        _weekdayname[wd], day, _monthname[month], year, hh, mm, ss\n    )\n", "docstring": "Formats a unix timestamp into an HTTP standard string.\n"}
{"repo": "eventlet-master/eventlet/db_pool.py", "original_string": "    def _expire_old_connections(self, now):\n        \"\"\"Iterates through the open connections contained in the pool, closing\n        ones that have remained idle for longer than max_idle seconds, or have\n        been in existence for longer than max_age seconds.\n        *now* is the current time, as returned by time.time().\n        \"\"\"\n        original_count = len(self.free_items)\n        expired = [\n            conn\n            for last_used, created_at, conn in self.free_items\n            if self._is_expired(now, last_used, created_at)]\n        new_free = [\n            (last_used, created_at, conn)\n            for last_used, created_at, conn in self.free_items\n            if not self._is_expired(now, last_used, created_at)]\n        self.free_items.clear()\n        self.free_items.extend(new_free)\n        # adjust the current size counter to account for expired\n        # connections\n        self.current_size -= original_count - len(self.free_items)\n        for conn in expired:\n            self._safe_close(conn, quiet=True)\n", "docstring": "Iterates through the open connections contained in the pool, closing"}
{"repo": "eventlet-master/eventlet/db_pool.py", "original_string": "    def _unwrap_connection(self, conn):\n        \"\"\"If the connection was wrapped by a subclass of\n        BaseConnectionWrapper and is still functional (as determined\n        by the __nonzero__, or __bool__ in python3, method), returns\n        the unwrapped connection.  If anything goes wrong with this\n        process, returns None.\n        \"\"\"\n        base = None\n        try:\n            if conn:\n                base = conn._base\n                conn._destroy()\n            else:\n                base = None\n        except AttributeError:\n            pass\n        return base\n", "docstring": "If the connection was wrapped by a subclass of"}
{"repo": "eventlet-master/eventlet/dagpool.py", "original_string": "    def __init__(self, key, exc):\n        # initialize base class with a reasonable string message\n        msg = \"PropagateError({0}): {1}: {2}\" \\\n              .format(key, exc.__class__.__name__, exc)\n        super(PropagateError, self).__init__(msg)\n        self.msg = msg\n        # Unless we set args, this is unpickleable:\n        # https://bugs.python.org/issue1692335\n        self.args = (key, exc)\n        self.key = key\n        self.exc = exc\n", "docstring": "initialize base class with a reasonable string message"}
{"repo": "eventlet-master/eventlet/dagpool.py", "original_string": "    def _value_or_raise(value):\n        # Most methods attempting to deliver PropagateError should raise that\n        # instead of simply returning it.\n        if isinstance(value, PropagateError):\n            raise value\n        return value\n", "docstring": "Most methods attempting to deliver PropagateError should raise that"}
{"repo": "eventlet-master/eventlet/tpool.py", "original_string": "    def __init__(self, obj, autowrap=(), autowrap_names=()):\n        self._obj = obj\n        self._autowrap = autowrap\n        self._autowrap_names = autowrap_names\n", "docstring": "self._obj = obj"}
{"repo": "eventlet-master/eventlet/coros.py", "original_string": "    def dec(self, by=1):\n        \"\"\"Decrement our counter. If this transitions the counter from nonzero\n        to zero, a current or subsequent wait() call need no longer wait.\n        \"\"\"\n        assert by > 0\n        self.counter -= by\n        if self.counter <= 0:\n            # Don't leave self.counter < 0, that will screw things up in\n            # future calls.\n            self.counter = 0\n            # Transitioning from nonzero to 0 means wait() need no longer wait.\n            self.event.send()\n", "docstring": "Decrement our counter. If this transitions the counter from nonzero"}
{"repo": "eventlet-master/eventlet/debug.py", "original_string": "def spew(trace_names=None, show_values=False):\n    \"\"\"Install a trace hook which writes incredibly detailed logs\n    about what code is being executed to stdout.\n    \"\"\"\n    sys.settrace(Spew(trace_names, show_values))\n", "docstring": "Install a trace hook which writes incredibly detailed logs"}
{"repo": "eventlet-master/eventlet/debug.py", "original_string": "def format_hub_listeners():\n    \"\"\" Returns a formatted string of the current listeners on the current\n    hub.  This can be useful in determining what's going on in the event system,\n    especially when used in conjunction with :func:`hub_listener_stacks`.\n    \"\"\"\n    from eventlet import hubs\n    hub = hubs.get_hub()\n    result = ['READERS:']\n    for l in hub.get_readers():\n        result.append(repr(l))\n    result.append('WRITERS:')\n    for l in hub.get_writers():\n        result.append(repr(l))\n    return os.linesep.join(result)\n", "docstring": "Returns a formatted string of the current listeners on the current"}
{"repo": "eventlet-master/eventlet/debug.py", "original_string": "def hub_listener_stacks(state=False):\n    \"\"\"Toggles whether or not the hub records the stack when clients register\n    listeners on file descriptors.  This can be useful when trying to figure\n    out what the hub is up to at any given moment.  To inspect the stacks\n    of the current listeners, call :func:`format_hub_listeners` at critical\n    junctures in the application logic.\n    \"\"\"\n    from eventlet import hubs\n    hubs.get_hub().set_debug_listeners(state)\n", "docstring": "Toggles whether or not the hub records the stack when clients register"}
{"repo": "eventlet-master/eventlet/debug.py", "original_string": "def hub_prevent_multiple_readers(state=True):\n    \"\"\"Toggle prevention of multiple greenlets reading from a socket\n    When multiple greenlets read from the same socket it is often hard\n    to predict which greenlet will receive what data.  To achieve\n    resource sharing consider using ``eventlet.pools.Pool`` instead.\n    But if you really know what you are doing you can change the state\n    to ``False`` to stop the hub from protecting against this mistake.\n    \"\"\"\n    from eventlet.hubs import hub\n    hub.g_prevent_multiple_readers = state\n", "docstring": "Toggle prevention of multiple greenlets reading from a socket"}
{"repo": "eventlet-master/eventlet/debug.py", "original_string": "def tpool_exceptions(state=False):\n    \"\"\"Toggles whether tpool itself prints exceptions that are raised from\n    functions that are executed in it, in addition to raising them like\n    it normally does.\"\"\"\n    from eventlet import tpool\n    tpool.QUIET = not state\n", "docstring": "Toggles whether tpool itself prints exceptions that are raised from"}
{"repo": "eventlet-master/eventlet/backdoor.py", "original_string": "    def finalize(self):\n        # restore the state of the socket\n        self.desc = None\n        if len(self.hostport) >= 2:\n            host = self.hostport[0]\n            port = self.hostport[1]\n            print(\"backdoor closed to %s:%s\" % (host, port,))\n        else:\n            print('backdoor closed')\n", "docstring": "restore the state of the socket"}
{"repo": "eventlet-master/eventlet/backdoor.py", "original_string": "def backdoor(conn_info, locals=None):\n    \"\"\"Sets up an interactive console on a socket with a single connected\n    client.  This does not block the caller, as it spawns a new greenlet to\n    handle the console.  This is meant to be called from within an accept loop\n    (such as backdoor_server).\n    \"\"\"\n    conn, addr = conn_info\n    if conn.family == socket.AF_INET:\n        host, port = addr\n        print(\"backdoor to %s:%s\" % (host, port))\n    elif conn.family == socket.AF_INET6:\n        host, port, _, _ = addr\n        print(\"backdoor to %s:%s\" % (host, port))\n    else:\n        print('backdoor opened')\n    fl = conn.makefile(\"rw\")\n    console = SocketConsole(fl, addr, locals)\n    hub = hubs.get_hub()\n    hub.schedule_call_global(0, console.switch)\n", "docstring": "Sets up an interactive console on a socket with a single connected"}
{"repo": "eventlet-master/eventlet/timeout.py", "original_string": "    def pending(self):\n        \"\"\"True if the timeout is scheduled to be raised.\"\"\"\n        if self.timer is not None:\n            return self.timer.pending\n        else:\n            return False\n", "docstring": "True if the timeout is scheduled to be raised.\n"}
{"repo": "eventlet-master/eventlet/timeout.py", "original_string": "def wrap_is_timeout(base):\n    '''Adds `.is_timeout=True` attribute to objects returned by `base()`.\n    When `base` is class, attribute is added as read-only property. Returns `base`.\n    Otherwise, it returns a function that sets attribute on result of `base()` call.\n    Wrappers make best effort to be transparent.\n    '''\n    if inspect.isclass(base):\n        base.is_timeout = property(lambda _: True)\n        return base\n    @functools.wraps(base)\n    def fun(*args, **kwargs):\n        ex = base(*args, **kwargs)\n        ex.is_timeout = True\n        return ex\n    return fun\n", "docstring": "Adds `.is_timeout=True` attribute to objects returned by `base()`."}
{"repo": "eventlet-master/eventlet/convenience.py", "original_string": "def connect(addr, family=socket.AF_INET, bind=None):\n    \"\"\"Convenience function for opening client sockets.\n    :param addr: Address of the server to connect to.  For TCP sockets, this is a (host, port) tuple.\n    :param family: Socket family, optional.  See :mod:`socket` documentation for available families.\n    :param bind: Local address to bind to, optional.\n    :return: The connected green socket object.\n    \"\"\"\n    sock = socket.socket(family, socket.SOCK_STREAM)\n    if bind is not None:\n        sock.bind(bind)\n    sock.connect(addr)\n    return sock\n", "docstring": "Convenience function for opening client sockets."}
{"repo": "eventlet-master/eventlet/convenience.py", "original_string": "def listen(addr, family=socket.AF_INET, backlog=50, reuse_addr=True, reuse_port=None):\n    \"\"\"Convenience function for opening server sockets.  This\n    socket can be used in :func:`~eventlet.serve` or a custom ``accept()`` loop.\n    Sets SO_REUSEADDR on the socket to save on annoyance.\n    :param addr: Address to listen on.  For TCP sockets, this is a (host, port)  tuple.\n    :param family: Socket family, optional.  See :mod:`socket` documentation for available families.\n    :param backlog:\n        The maximum number of queued connections. Should be at least 1; the maximum\n        value is system-dependent.\n    :return: The listening green socket object.\n    \"\"\"\n    sock = socket.socket(family, socket.SOCK_STREAM)\n    if reuse_addr and sys.platform[:3] != 'win':\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    if family in (socket.AF_INET, socket.AF_INET6) and addr[1] == 0:\n        if reuse_port:\n            warnings.warn(\n                '''listen on random port (0) with SO_REUSEPORT is dangerous.\n                Double check your intent.\n                Example problem: https://github.com/eventlet/eventlet/issues/411''',\n                ReuseRandomPortWarning, stacklevel=3)\n    elif reuse_port is None:\n        reuse_port = True\n    if reuse_port and hasattr(socket, 'SO_REUSEPORT'):\n        # NOTE(zhengwei): linux kernel >= 3.9\n        try:\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n        # OSError is enough on Python 3+\n        except (OSError, socket.error) as ex:\n            if support.get_errno(ex) in (22, 92):\n                # A famous platform defines unsupported socket option.\n                # https://github.com/eventlet/eventlet/issues/380\n                # https://github.com/eventlet/eventlet/issues/418\n                warnings.warn(\n                    '''socket.SO_REUSEPORT is defined but not supported.\n                    On Windows: known bug, wontfix.\n                    On other systems: please comment in the issue linked below.\n                    More information: https://github.com/eventlet/eventlet/issues/380''',\n                    ReusePortUnavailableWarning, stacklevel=3)\n    sock.bind(addr)\n    sock.listen(backlog)\n    return sock\n", "docstring": "Convenience function for opening server sockets.  This"}
{"repo": "eventlet-master/eventlet/convenience.py", "original_string": "def wrap_ssl(sock, *a, **kw):\n    \"\"\"Convenience function for converting a regular socket into an\n    SSL socket.  Has the same interface as :func:`ssl.wrap_socket`,\n    but can also use PyOpenSSL. Though, note that it ignores the\n    `cert_reqs`, `ssl_version`, `ca_certs`, `do_handshake_on_connect`,\n    and `suppress_ragged_eofs` arguments when using PyOpenSSL.\n    The preferred idiom is to call wrap_ssl directly on the creation\n    method, e.g., ``wrap_ssl(connect(addr))`` or\n    ``wrap_ssl(listen(addr), server_side=True)``. This way there is\n    no \"naked\" socket sitting around to accidentally corrupt the SSL\n    session.\n    :return Green SSL object.\n    \"\"\"\n    return wrap_ssl_impl(sock, *a, **kw)\n", "docstring": "Convenience function for converting a regular socket into an"}
{"repo": "eventlet-master/eventlet/green/profile.py", "original_string": "    def trace_dispatch_return_extend_back(self, frame, t):\n        \"\"\"A hack function to override error checking in parent class.  It\n        allows invalid returns (where frames weren't preveiously entered into\n        the profiler) which can happen for all the tasklets that suddenly start\n        to get monitored. This means that the time will eventually be attributed\n        to a call high in the chain, when there is a tasklet switch\n        \"\"\"\n        if isinstance(self.cur[-2], Profile.fake_frame):\n            return False\n            self.trace_dispatch_call(frame, 0)\n        return self.trace_dispatch_return(frame, t)\n", "docstring": "A hack function to override error checking in parent class.  It"}
{"repo": "eventlet-master/eventlet/green/profile.py", "original_string": "    def SwitchTasklet(self, t0, t1, t):\n        # tally the time spent in the old tasklet\n        pt, it, et, fn, frame, rcur = self.cur\n        cur = (pt, it + t, et, fn, frame, rcur)\n        # we are switching to a new tasklet, store the old\n        self.sleeping[t0] = cur, self.timings\n        self.current_tasklet = t1\n        # find the new one\n        try:\n            self.cur, self.timings = self.sleeping.pop(t1)\n        except KeyError:\n            self.cur, self.timings = None, {}\n            self.simulate_call(\"profiler\")\n            self.simulate_call(\"new_tasklet\")\n", "docstring": "tally the time spent in the old tasklet"}
{"repo": "eventlet-master/eventlet/green/profile.py", "original_string": "def run(statement, filename=None, sort=-1):\n    \"\"\"Run statement under profiler optionally saving results in filename\n    This function takes a single argument that can be passed to the\n    \"exec\" statement, and an optional file name.  In all cases this\n    routine attempts to \"exec\" its first argument and gather profiling\n    statistics from the execution. If no file name is present, then this\n    function automatically prints a simple profiling report, sorted by the\n    standard name string (file/line/function-name) that is presented in\n    each line.\n    \"\"\"\n    prof = Profile()\n    try:\n        prof = prof.run(statement)\n    except SystemExit:\n        pass\n    if filename is not None:\n        prof.dump_stats(filename)\n    else:\n        return prof.print_stats(sort)\n", "docstring": "Run statement under profiler optionally saving results in filename"}
{"repo": "eventlet-master/eventlet/green/os.py", "original_string": "def fdopen(fd, *args, **kw):\n    \"\"\"fdopen(fd [, mode='r' [, bufsize]]) -> file_object\n    Return an open file object connected to a file descriptor.\"\"\"\n    if not isinstance(fd, int):\n        raise TypeError('fd should be int, not %r' % fd)\n    try:\n        return greenio.GreenPipe(fd, *args, **kw)\n    except IOError as e:\n        raise OSError(*e.args)\n", "docstring": "fdopen(fd [, mode='r' [, bufsize]]) -> file_object"}
{"repo": "eventlet-master/eventlet/green/os.py", "original_string": "def read(fd, n):\n    \"\"\"read(fd, buffersize) -> string\n    Read a file descriptor.\"\"\"\n    while True:\n        try:\n            return __original_read__(fd, n)\n        except (OSError, IOError) as e:\n            if get_errno(e) != errno.EAGAIN:\n                raise\n        except socket.error as e:\n            if get_errno(e) == errno.EPIPE:\n                return ''\n            raise\n        try:\n            hubs.trampoline(fd, read=True)\n        except hubs.IOClosed:\n            return ''\n", "docstring": "read(fd, buffersize) -> string"}
{"repo": "eventlet-master/eventlet/green/os.py", "original_string": "def write(fd, st):\n    \"\"\"write(fd, string) -> byteswritten\n    Write a string to a file descriptor.\n    \"\"\"\n    while True:\n        try:\n            return __original_write__(fd, st)\n        except (OSError, IOError) as e:\n            if get_errno(e) != errno.EAGAIN:\n                raise\n        except socket.error as e:\n            if get_errno(e) != errno.EPIPE:\n                raise\n        hubs.trampoline(fd, write=True)\n", "docstring": "write(fd, string) -> byteswritten"}
{"repo": "eventlet-master/eventlet/green/os.py", "original_string": "def waitpid(pid, options):\n    \"\"\"waitpid(...)\n    waitpid(pid, options) -> (pid, status)\n    Wait for completion of a given child process.\"\"\"\n    if options & os_orig.WNOHANG != 0:\n        return __original_waitpid__(pid, options)\n    else:\n        new_options = options | os_orig.WNOHANG\n        while True:\n            rpid, status = __original_waitpid__(pid, new_options)\n            if rpid and status >= 0:\n                return rpid, status\n            greenthread.sleep(0.01)\n", "docstring": "waitpid(...)"}
{"repo": "eventlet-master/eventlet/green/zmq.py", "original_string": "    def socket(self, socket_type):\n        \"\"\"Overridden method to ensure that the green version of socket is used\n        Behaves the same as :meth:`zmq.Context.socket`, but ensures\n        that a :class:`Socket` with all of its send and recv methods set to be\n        non-blocking is returned\n        \"\"\"\n        if self.closed:\n            raise ZMQError(ENOTSUP)\n        return Socket(self, socket_type)\n", "docstring": "Overridden method to ensure that the green version of socket is used"}
{"repo": "eventlet-master/eventlet/green/zmq.py", "original_string": "    def send(self, msg, flags=0, copy=True, track=False):\n        \"\"\"A send method that's safe to use when multiple greenthreads\n        are calling send, send_multipart, recv and recv_multipart on\n        the same socket.\n        \"\"\"\n        if flags & NOBLOCK:\n            result = _Socket_send(self, msg, flags, copy, track)\n            # Instead of calling both wake methods, could call\n            # self.getsockopt(EVENTS) which would trigger wakeups if\n            # needed.\n            self._eventlet_send_event.wake()\n            self._eventlet_recv_event.wake()\n            return result\n        # TODO: pyzmq will copy the message buffer and create Message\n        # objects under some circumstances. We could do that work here\n        # once to avoid doing it every time the send is retried.\n        flags |= NOBLOCK\n        with self._eventlet_send_lock:\n            while True:\n                try:\n                    return _Socket_send(self, msg, flags, copy, track)\n                except ZMQError as e:\n                    if e.errno == EAGAIN:\n                        self._eventlet_send_event.block()\n                    else:\n                        raise\n                finally:\n                    # The call to send processes 0mq events and may\n                    # make the socket ready to recv. Wake the next\n                    # receiver. (Could check EVENTS for POLLIN here)\n                    self._eventlet_recv_event.wake()\n", "docstring": "A send method that's safe to use when multiple greenthreads"}
{"repo": "eventlet-master/eventlet/green/zmq.py", "original_string": "    def send_multipart(self, msg_parts, flags=0, copy=True, track=False):\n        \"\"\"A send_multipart method that's safe to use when multiple\n        greenthreads are calling send, send_multipart, recv and\n        recv_multipart on the same socket.\n        \"\"\"\n        if flags & NOBLOCK:\n            return _Socket_send_multipart(self, msg_parts, flags, copy, track)\n        # acquire lock here so the subsequent calls to send for the\n        # message parts after the first don't block\n        with self._eventlet_send_lock:\n            return _Socket_send_multipart(self, msg_parts, flags, copy, track)\n", "docstring": "A send_multipart method that's safe to use when multiple"}
{"repo": "eventlet-master/eventlet/green/zmq.py", "original_string": "    def send_string(self, u, flags=0, copy=True, encoding='utf-8'):\n        \"\"\"A send_string method that's safe to use when multiple\n        greenthreads are calling send, send_string, recv and\n        recv_string on the same socket.\n        \"\"\"\n        if flags & NOBLOCK:\n            return _Socket_send_string(self, u, flags, copy, encoding)\n        # acquire lock here so the subsequent calls to send for the\n        # message parts after the first don't block\n        with self._eventlet_send_lock:\n            return _Socket_send_string(self, u, flags, copy, encoding)\n", "docstring": "A send_string method that's safe to use when multiple"}
{"repo": "eventlet-master/eventlet/green/zmq.py", "original_string": "    def send_pyobj(self, obj, flags=0, protocol=2):\n        \"\"\"A send_pyobj method that's safe to use when multiple\n        greenthreads are calling send, send_pyobj, recv and\n        recv_pyobj on the same socket.\n        \"\"\"\n        if flags & NOBLOCK:\n            return _Socket_send_pyobj(self, obj, flags, protocol)\n        # acquire lock here so the subsequent calls to send for the\n        # message parts after the first don't block\n        with self._eventlet_send_lock:\n            return _Socket_send_pyobj(self, obj, flags, protocol)\n", "docstring": "A send_pyobj method that's safe to use when multiple"}
{"repo": "eventlet-master/eventlet/green/zmq.py", "original_string": "    def send_json(self, obj, flags=0, **kwargs):\n        \"\"\"A send_json method that's safe to use when multiple\n        greenthreads are calling send, send_json, recv and\n        recv_json on the same socket.\n        \"\"\"\n        if flags & NOBLOCK:\n            return _Socket_send_json(self, obj, flags, **kwargs)\n        # acquire lock here so the subsequent calls to send for the\n        # message parts after the first don't block\n        with self._eventlet_send_lock:\n            return _Socket_send_json(self, obj, flags, **kwargs)\n", "docstring": "A send_json method that's safe to use when multiple"}
{"repo": "eventlet-master/eventlet/green/zmq.py", "original_string": "    def recv(self, flags=0, copy=True, track=False):\n        \"\"\"A recv method that's safe to use when multiple greenthreads\n        are calling send, send_multipart, recv and recv_multipart on\n        the same socket.\n        \"\"\"\n        if flags & NOBLOCK:\n            msg = _Socket_recv(self, flags, copy, track)\n            # Instead of calling both wake methods, could call\n            # self.getsockopt(EVENTS) which would trigger wakeups if\n            # needed.\n            self._eventlet_send_event.wake()\n            self._eventlet_recv_event.wake()\n            return msg\n        deadline = None\n        if hasattr(__zmq__, 'RCVTIMEO'):\n            sock_timeout = self.getsockopt(__zmq__.RCVTIMEO)\n            if sock_timeout == -1:\n                pass\n            elif sock_timeout > 0:\n                deadline = self._eventlet_clock() + sock_timeout / 1000.0\n            else:\n                raise ValueError(sock_timeout)\n        flags |= NOBLOCK\n        with self._eventlet_recv_lock:\n            while True:\n                try:\n                    return _Socket_recv(self, flags, copy, track)\n                except ZMQError as e:\n                    if e.errno == EAGAIN:\n                        # zmq in its wisdom decided to reuse EAGAIN for timeouts\n                        if deadline is not None and self._eventlet_clock() > deadline:\n                            e.is_timeout = True\n                            raise\n                        self._eventlet_recv_event.block(deadline=deadline)\n                    else:\n                        raise\n                finally:\n                    # The call to recv processes 0mq events and may\n                    # make the socket ready to send. Wake the next\n                    # receiver. (Could check EVENTS for POLLOUT here)\n                    self._eventlet_send_event.wake()\n", "docstring": "A recv method that's safe to use when multiple greenthreads"}
{"repo": "eventlet-master/eventlet/green/zmq.py", "original_string": "    def recv_multipart(self, flags=0, copy=True, track=False):\n        \"\"\"A recv_multipart method that's safe to use when multiple\n        greenthreads are calling send, send_multipart, recv and\n        recv_multipart on the same socket.\n        \"\"\"\n        if flags & NOBLOCK:\n            return _Socket_recv_multipart(self, flags, copy, track)\n        # acquire lock here so the subsequent calls to recv for the\n        # message parts after the first don't block\n        with self._eventlet_recv_lock:\n            return _Socket_recv_multipart(self, flags, copy, track)\n", "docstring": "A recv_multipart method that's safe to use when multiple"}
{"repo": "eventlet-master/eventlet/green/zmq.py", "original_string": "    def recv_string(self, flags=0, encoding='utf-8'):\n        \"\"\"A recv_string method that's safe to use when multiple\n        greenthreads are calling send, send_string, recv and\n        recv_string on the same socket.\n        \"\"\"\n        if flags & NOBLOCK:\n            return _Socket_recv_string(self, flags, encoding)\n        # acquire lock here so the subsequent calls to recv for the\n        # message parts after the first don't block\n        with self._eventlet_recv_lock:\n            return _Socket_recv_string(self, flags, encoding)\n", "docstring": "A recv_string method that's safe to use when multiple"}
{"repo": "eventlet-master/eventlet/green/zmq.py", "original_string": "    def recv_json(self, flags=0, **kwargs):\n        \"\"\"A recv_json method that's safe to use when multiple\n        greenthreads are calling send, send_json, recv and\n        recv_json on the same socket.\n        \"\"\"\n        if flags & NOBLOCK:\n            return _Socket_recv_json(self, flags, **kwargs)\n        # acquire lock here so the subsequent calls to recv for the\n        # message parts after the first don't block\n        with self._eventlet_recv_lock:\n            return _Socket_recv_json(self, flags, **kwargs)\n", "docstring": "A recv_json method that's safe to use when multiple"}
{"repo": "eventlet-master/eventlet/green/threading.py", "original_string": "def _fixup_thread(t):\n    # Some third-party packages (lockfile) will try to patch the\n    # threading.Thread class with a get_name attribute if it doesn't\n    # exist. Since we might return Thread objects from the original\n    # threading package that won't get patched, let's make sure each\n    # individual object gets patched too our patched threading.Thread\n    # class has been patched. This is why monkey patching can be bad...\n    global __threading\n    if not __threading:\n        __threading = __import__('threading')\n    if (hasattr(__threading.Thread, 'get_name') and\n            not hasattr(t, 'get_name')):\n        t.get_name = t.getName\n    return t\n", "docstring": "Some third-party packages (lockfile) will try to patch the"}
{"repo": "eventlet-master/eventlet/green/thread.py", "original_string": "    def _set_sentinel():\n        # TODO this is a dummy code, reimplementing this may be needed:\n        # https://hg.python.org/cpython/file/b5e9bc4352e1/Modules/_threadmodule.c#l1203\n        return allocate_lock()\n", "docstring": "TODO this is a dummy code, reimplementing this may be needed:"}
{"repo": "eventlet-master/eventlet/green/select.py", "original_string": "def get_fileno(obj):\n    # The purpose of this function is to exactly replicate\n    # the behavior of the select module when confronted with\n    # abnormal filenos; the details are extensively tested in\n    # the stdlib test/test_select.py.\n    try:\n        f = obj.fileno\n    except AttributeError:\n        if not isinstance(obj, six.integer_types):\n            raise TypeError(\"Expected int or long, got %s\" % type(obj))\n        return obj\n    else:\n        rv = f()\n        if not isinstance(rv, six.integer_types):\n            raise TypeError(\"Expected int or long, got %s\" % type(rv))\n        return rv\n", "docstring": "The purpose of this function is to exactly replicate"}
{"repo": "eventlet-master/eventlet/green/ssl.py", "original_string": "    def read(self, *args, **kwargs):\n        \"\"\"Read up to LEN bytes and return them.\n        Return zero-length string on EOF.\"\"\"\n        try:\n            return self._call_trampolining(\n                super(GreenSSLSocket, self).read, *args, **kwargs)\n        except IOClosed:\n            return b''\n", "docstring": "Read up to LEN bytes and return them."}
{"repo": "eventlet-master/eventlet/green/ssl.py", "original_string": "    def sendto(self, data, addr, flags=0):\n        # *NOTE: gross, copied code from ssl.py becase it's not factored well enough to be used as-is\n        if self._sslobj:\n            raise ValueError(\"sendto not allowed on instances of %s\" %\n                             self.__class__)\n        else:\n            trampoline(self, write=True, timeout_exc=timeout_exc('timed out'))\n            return socket.sendto(self, data, addr, flags)\n", "docstring": "*NOTE: gross, copied code from ssl.py becase it's not factored well enough to be used as-is"}
{"repo": "eventlet-master/eventlet/green/ssl.py", "original_string": "    def do_handshake(self):\n        \"\"\"Perform a TLS/SSL handshake.\"\"\"\n        return self._call_trampolining(\n            super(GreenSSLSocket, self).do_handshake)\n", "docstring": "Perform a TLS/SSL handshake.\n"}
{"repo": "eventlet-master/eventlet/green/ssl.py", "original_string": "    def connect(self, addr):\n        \"\"\"Connects to remote ADDR, and then wraps the connection in\n        an SSL channel.\"\"\"\n        # *NOTE: grrrrr copied this code from ssl.py because of the reference\n        # to socket.connect which we don't want to call directly\n        if self._sslobj:\n            raise ValueError(\"attempt to connect already-connected SSLSocket!\")\n        self._socket_connect(addr)\n        server_side = False\n        try:\n            sslwrap = _ssl.sslwrap\n        except AttributeError:\n            # sslwrap was removed in 3.x and later in 2.7.9\n            if six.PY2:\n                sslobj = self._context._wrap_socket(self._sock, server_side, ssl_sock=self)\n            else:\n                context = self.context if PY33 else self._context\n                sslobj = context._wrap_socket(self, server_side, server_hostname=self.server_hostname)\n        else:\n            sslobj = sslwrap(self._sock, server_side, self.keyfile, self.certfile,\n                             self.cert_reqs, self.ssl_version,\n                             self.ca_certs, *self.ciphers)\n        try:\n            # This is added in Python 3.5, http://bugs.python.org/issue21965\n            SSLObject\n        except NameError:\n            self._sslobj = sslobj\n        else:\n            if _is_under_py_3_7:\n                self._sslobj = SSLObject(sslobj, owner=self)\n            else:\n                self._sslobj = sslobj\n        if self.do_handshake_on_connect:\n            self.do_handshake()\n", "docstring": "Connects to remote ADDR, and then wraps the connection in"}
{"repo": "eventlet-master/eventlet/green/ssl.py", "original_string": "    def sslwrap_simple(sock, keyfile=None, certfile=None):\n        \"\"\"A replacement for the old socket.ssl function.  Designed\n        for compatibility with Python 2.5 and earlier.  Will disappear in\n        Python 3.0.\"\"\"\n        ssl_sock = GreenSSLSocket(sock, keyfile=keyfile, certfile=certfile,\n                                  server_side=False,\n                                  cert_reqs=CERT_NONE,\n                                  ssl_version=PROTOCOL_SSLv23,\n                                  ca_certs=None)\n        return ssl_sock\n", "docstring": "A replacement for the old socket.ssl function.  Designed"}
{"repo": "eventlet-master/eventlet/green/ssl.py", "original_string": "        def green_create_default_context(*a, **kw):\n            # We can't just monkey-patch on the green version of `wrap_socket`\n            # on to SSLContext instances, but SSLContext.create_default_context\n            # does a bunch of work. Rather than re-implementing it all, just\n            # switch out the __class__ to get our `wrap_socket` implementation\n            context = _original_create_default_context(*a, **kw)\n            context.__class__ = GreenSSLContext\n            return context\n", "docstring": "We can't just monkey-patch on the green version of `wrap_socket`"}
{"repo": "eventlet-master/eventlet/green/subprocess.py", "original_string": "    def wait(self, timeout=None, check_interval=0.01):\n        # Instead of a blocking OS call, this version of wait() uses logic\n        # borrowed from the eventlet 0.2 processes.Process.wait() method.\n        if timeout is not None:\n            endtime = time.time() + timeout\n        try:\n            while True:\n                status = self.poll()\n                if status is not None:\n                    return status\n                if timeout is not None and time.time() > endtime:\n                    raise TimeoutExpired(self.args, timeout)\n                eventlet.sleep(check_interval)\n        except OSError as e:\n            if e.errno == errno.ECHILD:\n                # no child process, this happens if the child process\n                # already died and has been cleaned up\n                return -1\n            else:\n                raise\n", "docstring": "Instead of a blocking OS call, this version of wait() uses logic"}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def server_bind(self):\n        \"\"\"Override server_bind to store the server name.\"\"\"\n        socketserver.TCPServer.server_bind(self)\n        host, port = self.server_address[:2]\n        self.server_name = socket.getfqdn(host)\n        self.server_port = port\n", "docstring": "Override server_bind to store the server name.\n"}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def handle_one_request(self):\n        \"\"\"Handle a single HTTP request.\n        You normally don't need to override this method; see the class\n        __doc__ string for information on how to handle specific HTTP\n        commands such as GET and POST.\n        \"\"\"\n        try:\n            self.raw_requestline = self.rfile.readline(65537)\n            if len(self.raw_requestline) > 65536:\n                self.requestline = ''\n                self.request_version = ''\n                self.command = ''\n                self.send_error(HTTPStatus.REQUEST_URI_TOO_LONG)\n                return\n            if not self.raw_requestline:\n                self.close_connection = True\n                return\n            if not self.parse_request():\n                # An error code has been sent, just exit\n                return\n            mname = 'do_' + self.command\n            if not hasattr(self, mname):\n                self.send_error(\n                    HTTPStatus.NOT_IMPLEMENTED,\n                    \"Unsupported method (%r)\" % self.command)\n                return\n            method = getattr(self, mname)\n            method()\n            self.wfile.flush() #actually send the response if not already done.\n        except socket.timeout as e:\n            #a read or a write timed out.  Discard this connection\n            self.log_error(\"Request timed out: %r\", e)\n            self.close_connection = True\n            return\n", "docstring": "Handle a single HTTP request."}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def send_error(self, code, message=None, explain=None):\n        \"\"\"Send and log an error reply.\n        Arguments are\n        * code:    an HTTP error code\n                   3 digits\n        * message: a simple optional 1 line reason phrase.\n                   *( HTAB / SP / VCHAR / %x80-FF )\n                   defaults to short entry matching the response code\n        * explain: a detailed message defaults to the long entry\n                   matching the response code.\n        This sends an error response (so it must be called before any\n        output has been generated), logs the error, and finally sends\n        a piece of HTML explaining the error to the user.\n        \"\"\"\n        try:\n            shortmsg, longmsg = self.responses[code]\n        except KeyError:\n            shortmsg, longmsg = '???', '???'\n        if message is None:\n            message = shortmsg\n        if explain is None:\n            explain = longmsg\n        self.log_error(\"code %d, message %s\", code, message)\n        self.send_response(code, message)\n        self.send_header('Connection', 'close')\n        # Message body is omitted for cases described in:\n        #  - RFC7230: 3.3. 1xx, 204(No Content), 304(Not Modified)\n        #  - RFC7231: 6.3.6. 205(Reset Content)\n        body = None\n        if (code >= 200 and\n            code not in (HTTPStatus.NO_CONTENT,\n                         HTTPStatus.RESET_CONTENT,\n                         HTTPStatus.NOT_MODIFIED)):\n            # HTML encode to prevent Cross Site Scripting attacks\n            # (see bug #1100201)\n            content = (self.error_message_format % {\n                'code': code,\n                'message': html.escape(message, quote=False),\n                'explain': html.escape(explain, quote=False)\n            })\n            body = content.encode('UTF-8', 'replace')\n            self.send_header(\"Content-Type\", self.error_content_type)\n            self.send_header('Content-Length', int(len(body)))\n        self.end_headers()\n        if self.command != 'HEAD' and body:\n            self.wfile.write(body)\n", "docstring": "Send and log an error reply."}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def send_response_only(self, code, message=None):\n        \"\"\"Send the response header only.\"\"\"\n        if self.request_version != 'HTTP/0.9':\n            if message is None:\n                if code in self.responses:\n                    message = self.responses[code][0]\n                else:\n                    message = ''\n            if not hasattr(self, '_headers_buffer'):\n                self._headers_buffer = []\n            self._headers_buffer.append((\"%s %d %s\\r\\n\" %\n                    (self.protocol_version, code, message)).encode(\n                        'latin-1', 'strict'))\n", "docstring": "Send the response header only.\n"}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def end_headers(self):\n        \"\"\"Send the blank line ending the MIME headers.\"\"\"\n        if self.request_version != 'HTTP/0.9':\n            self._headers_buffer.append(b\"\\r\\n\")\n            self.flush_headers()\n", "docstring": "Send the blank line ending the MIME headers.\n"}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def log_request(self, code='-', size='-'):\n        \"\"\"Log an accepted request.\n        This is called by send_response().\n        \"\"\"\n        if isinstance(code, HTTPStatus):\n            code = code.value\n        self.log_message('\"%s\" %s %s',\n                         self.requestline, str(code), str(size))\n", "docstring": "Log an accepted request."}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def log_message(self, format, *args):\n        \"\"\"Log an arbitrary message.\n        This is used by all other logging functions.  Override\n        it if you have specific logging wishes.\n        The first argument, FORMAT, is a format string for the\n        message to be logged.  If the format string contains\n        any % escapes requiring parameters, they should be\n        specified as subsequent arguments (it's just like\n        printf!).\n        The client ip and current date/time are prefixed to\n        every message.\n        \"\"\"\n        sys.stderr.write(\"%s - - [%s] %s\\n\" %\n                         (self.address_string(),\n                          self.log_date_time_string(),\n                          format%args))\n", "docstring": "Log an arbitrary message."}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def date_time_string(self, timestamp=None):\n        \"\"\"Return the current date and time formatted for a message header.\"\"\"\n        if timestamp is None:\n            timestamp = time.time()\n        return email.utils.formatdate(timestamp, usegmt=True)\n", "docstring": "Return the current date and time formatted for a message header.\n"}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def address_string(self):\n        \"\"\"Return the client address.\"\"\"\n        return self.client_address[0]\n", "docstring": "Return the client address.\n"}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def do_GET(self):\n        \"\"\"Serve a GET request.\"\"\"\n        f = self.send_head()\n        if f:\n            try:\n                self.copyfile(f, self.wfile)\n            finally:\n                f.close()\n", "docstring": "Serve a GET request.\n"}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def send_head(self):\n        \"\"\"Common code for GET and HEAD commands.\n        This sends the response code and MIME headers.\n        Return value is either a file object (which has to be copied\n        to the outputfile by the caller unless the command was HEAD,\n        and must be closed by the caller under all circumstances), or\n        None, in which case the caller has nothing further to do.\n        \"\"\"\n        path = self.translate_path(self.path)\n        f = None\n        if os.path.isdir(path):\n            parts = urllib.parse.urlsplit(self.path)\n            if not parts.path.endswith('/'):\n                # redirect browser - doing basically what apache does\n                self.send_response(HTTPStatus.MOVED_PERMANENTLY)\n                new_parts = (parts[0], parts[1], parts[2] + '/',\n                             parts[3], parts[4])\n                new_url = urllib.parse.urlunsplit(new_parts)\n                self.send_header(\"Location\", new_url)\n                self.end_headers()\n                return None\n            for index in \"index.html\", \"index.htm\":\n                index = os.path.join(path, index)\n                if os.path.exists(index):\n                    path = index\n                    break\n            else:\n                return self.list_directory(path)\n        ctype = self.guess_type(path)\n        try:\n            f = open(path, 'rb')\n        except OSError:\n            self.send_error(HTTPStatus.NOT_FOUND, \"File not found\")\n            return None\n        try:\n            self.send_response(HTTPStatus.OK)\n            self.send_header(\"Content-type\", ctype)\n            fs = os.fstat(f.fileno())\n            self.send_header(\"Content-Length\", str(fs[6]))\n            self.send_header(\"Last-Modified\", self.date_time_string(fs.st_mtime))\n            self.end_headers()\n            return f\n        except:\n            f.close()\n            raise\n", "docstring": "Common code for GET and HEAD commands."}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def translate_path(self, path):\n        \"\"\"Translate a /-separated PATH to the local filename syntax.\n        Components that mean special things to the local file system\n        (e.g. drive or directory names) are ignored.  (XXX They should\n        probably be diagnosed.)\n        \"\"\"\n        # abandon query parameters\n        path = path.split('?',1)[0]\n        path = path.split('#',1)[0]\n        # Don't forget explicit trailing slash when normalizing. Issue17324\n        trailing_slash = path.rstrip().endswith('/')\n        try:\n            path = urllib.parse.unquote(path, errors='surrogatepass')\n        except UnicodeDecodeError:\n            path = urllib.parse.unquote(path)\n        path = posixpath.normpath(path)\n        words = path.split('/')\n        words = filter(None, words)\n        path = os.getcwd()\n        for word in words:\n            if os.path.dirname(word) or word in (os.curdir, os.pardir):\n                # Ignore components that are not a simple file/directory name\n                continue\n            path = os.path.join(path, word)\n        if trailing_slash:\n            path += '/'\n        return path\n", "docstring": "Translate a /-separated PATH to the local filename syntax."}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def guess_type(self, path):\n        \"\"\"Guess the type of a file.\n        Argument is a PATH (a filename).\n        Return value is a string of the form type/subtype,\n        usable for a MIME Content-type header.\n        The default implementation looks the file's extension\n        up in the table self.extensions_map, using application/octet-stream\n        as a default; however it would be permissible (if\n        slow) to look inside the data to make a better guess.\n        \"\"\"\n        base, ext = posixpath.splitext(path)\n        if ext in self.extensions_map:\n            return self.extensions_map[ext]\n        ext = ext.lower()\n        if ext in self.extensions_map:\n            return self.extensions_map[ext]\n        else:\n            return self.extensions_map['']\n", "docstring": "Guess the type of a file."}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "def nobody_uid():\n    \"\"\"Internal routine to get nobody's uid\"\"\"\n    global nobody\n    if nobody:\n        return nobody\n    try:\n        import pwd\n    except ImportError:\n        return -1\n    try:\n        nobody = pwd.getpwnam('nobody')[2]\n    except KeyError:\n        nobody = 1 + max(x[2] for x in pwd.getpwall())\n    return nobody\n", "docstring": "Internal routine to get nobody's uid\n"}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def do_POST(self):\n        \"\"\"Serve a POST request.\n        This is only implemented for CGI scripts.\n        \"\"\"\n        if self.is_cgi():\n            self.run_cgi()\n        else:\n            self.send_error(\n                HTTPStatus.NOT_IMPLEMENTED,\n                \"Can only POST to CGI scripts\")\n", "docstring": "Serve a POST request."}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def is_cgi(self):\n        \"\"\"Test whether self.path corresponds to a CGI script.\n        Returns True and updates the cgi_info attribute to the tuple\n        (dir, rest) if self.path requires running a CGI script.\n        Returns False otherwise.\n        If any exception is raised, the caller should assume that\n        self.path was rejected as invalid and act accordingly.\n        The default implementation tests whether the normalized url\n        path begins with one of the strings in self.cgi_directories\n        (and the next character is a '/' or the end of the string).\n        \"\"\"\n        collapsed_path = _url_collapse_path(self.path)\n        dir_sep = collapsed_path.find('/', 1)\n        head, tail = collapsed_path[:dir_sep], collapsed_path[dir_sep+1:]\n        if head in self.cgi_directories:\n            self.cgi_info = head, tail\n            return True\n        return False\n", "docstring": "Test whether self.path corresponds to a CGI script."}
{"repo": "eventlet-master/eventlet/green/http/server.py", "original_string": "    def is_executable(self, path):\n        \"\"\"Test whether argument path is an executable file.\"\"\"\n        return executable(path)\n", "docstring": "Test whether argument path is an executable file.\n"}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "def _encode(data, name='data'):\n    \"\"\"Call data.encode(\"latin-1\") but show a better error message.\"\"\"\n    try:\n        return data.encode(\"latin-1\")\n    except UnicodeEncodeError as err:\n        raise UnicodeEncodeError(\n            err.encoding,\n            err.object,\n            err.start,\n            err.end,\n            \"%s (%.20r) is not valid Latin-1. Use %s.encode('utf-8') \"\n            \"if you want to send it encoded in UTF-8.\" %\n            (name.title(), data[err.start:err.end], name)) from None\n", "docstring": "Call data.encode(\"latin-1\") but show a better error message.\n"}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def getallmatchingheaders(self, name):\n        \"\"\"Find all header lines matching a given header name.\n        Look through the list of headers and find all lines matching a given\n        header name (and their continuation lines).  A list of the lines is\n        returned, without interpretation.  If the header does not occur, an\n        empty list is returned.  If the header occurs multiple times, all\n        occurrences are returned.  Case is not important in the header name.\n        \"\"\"\n        name = name.lower() + ':'\n        n = len(name)\n        lst = []\n        hit = 0\n        for line in self.keys():\n            if line[:n].lower() == name:\n                hit = 1\n            elif not line[:1].isspace():\n                hit = 0\n            if hit:\n                lst.append(line)\n        return lst\n", "docstring": "Find all header lines matching a given header name."}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def __init__(self, sock, debuglevel=0, method=None, url=None):\n        # If the response includes a content-length header, we need to\n        # make sure that the client doesn't read more than the\n        # specified number of bytes.  If it does, it will block until\n        # the server times out and closes the connection.  This will\n        # happen if a self.fp.read() is done (without a size) whether\n        # self.fp is buffered or not.  So, no self.fp.read() by\n        # clients unless they know what they are doing.\n        self.fp = sock.makefile(\"rb\")\n        self.debuglevel = debuglevel\n        self._method = method\n        # The HTTPResponse object is returned via urllib.  The clients\n        # of http and urllib expect different attributes for the\n        # headers.  headers is used here and supports urllib.  msg is\n        # provided as a backwards compatibility layer for http\n        # clients.\n        self.headers = self.msg = None\n        # from the Status-Line of the response\n        self.version = _UNKNOWN # HTTP-Version\n        self.status = _UNKNOWN  # Status-Code\n        self.reason = _UNKNOWN  # Reason-Phrase\n        self.chunked = _UNKNOWN         # is \"chunked\" being used?\n        self.chunk_left = _UNKNOWN      # bytes left to read in current chunk\n        self.length = _UNKNOWN          # number of bytes left in response\n        self.will_close = _UNKNOWN      # conn will close at end of response\n", "docstring": "If the response includes a content-length header, we need to"}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def isclosed(self):\n        \"\"\"True if the connection is closed.\"\"\"\n        # NOTE: it is possible that we will not ever call self.close(). This\n        #       case occurs when will_close is TRUE, length is None, and we\n        #       read up to the last byte, but NOT past it.\n        #\n        # IMPLIES: if will_close is FALSE, then self.close() will ALWAYS be\n        #          called, meaning self.isclosed() is meaningful.\n        return self.fp is None\n", "docstring": "True if the connection is closed.\n"}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def readinto(self, b):\n        \"\"\"Read up to len(b) bytes into bytearray b and return the number\n        of bytes read.\n        \"\"\"\n        if self.fp is None:\n            return 0\n        if self._method == \"HEAD\":\n            self._close_conn()\n            return 0\n        if self.chunked:\n            return self._readinto_chunked(b)\n        if self.length is not None:\n            if len(b) > self.length:\n                # clip the read to the \"end of response\"\n                b = memoryview(b)[0:self.length]\n        # we do not use _safe_read() here because this may be a .will_close\n        # connection, and the user is reading more bytes than will be provided\n        # (for example, reading in 1k chunks)\n        n = self.fp.readinto(b)\n        if not n and b:\n            # Ideally, we would raise IncompleteRead if the content-length\n            # wasn't satisfied, but it might break compatibility.\n            self._close_conn()\n        elif self.length is not None:\n            self.length -= n\n            if not self.length:\n                self._close_conn()\n        return n\n", "docstring": "Read up to len(b) bytes into bytearray b and return the number"}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def _read_and_discard_trailer(self):\n        # read and discard trailer up to the CRLF terminator\n        ### note: we shouldn't have any trailers!\n        while True:\n            line = self.fp.readline(_MAXLINE + 1)\n            if len(line) > _MAXLINE:\n                raise LineTooLong(\"trailer line\")\n            if not line:\n                # a vanishingly small number of sites EOF without\n                # sending the trailer\n                break\n            if line in (b'\\r\\n', b'\\n', b''):\n                break\n", "docstring": "read and discard trailer up to the CRLF terminator"}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def _safe_read(self, amt):\n        \"\"\"Read the number of bytes requested, compensating for partial reads.\n        Normally, we have a blocking socket, but a read() can be interrupted\n        by a signal (resulting in a partial read).\n        Note that we cannot distinguish between EOF and an interrupt when zero\n        bytes have been read. IncompleteRead() will be raised in this\n        situation.\n        This function should be used when <amt> bytes \"should\" be present for\n        reading. If the bytes are truly not available (due to EOF), then the\n        IncompleteRead exception can be used to detect the problem.\n        \"\"\"\n        s = []\n        while amt > 0:\n            chunk = self.fp.read(min(amt, MAXAMOUNT))\n            if not chunk:\n                raise IncompleteRead(b''.join(s), amt)\n            s.append(chunk)\n            amt -= len(chunk)\n        return b\"\".join(s)\n", "docstring": "Read the number of bytes requested, compensating for partial reads."}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def read1(self, n=-1):\n        \"\"\"Read with at most one underlying system call.  If at least one\n        byte is buffered, return that instead.\n        \"\"\"\n        if self.fp is None or self._method == \"HEAD\":\n            return b\"\"\n        if self.chunked:\n            return self._read1_chunked(n)\n        if self.length is not None and (n < 0 or n > self.length):\n            n = self.length\n        try:\n            result = self.fp.read1(n)\n        except ValueError:\n            if n >= 0:\n                raise\n            # some implementations, like BufferedReader, don't support -1\n            # Read an arbitrarily selected largeish chunk.\n            result = self.fp.read1(16*1024)\n        if not result and n:\n            self._close_conn()\n        elif self.length is not None:\n            self.length -= len(result)\n        return result\n", "docstring": "Read with at most one underlying system call.  If at least one"}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def _peek_chunked(self, n):\n        # Strictly speaking, _get_chunk_left() may cause more than one read,\n        # but that is ok, since that is to satisfy the chunked protocol.\n        try:\n            chunk_left = self._get_chunk_left()\n        except IncompleteRead:\n            return b'' # peek doesn't worry about protocol\n        if chunk_left is None:\n            return b'' # eof\n        # peek is allowed to return more than requested.  Just request the\n        # entire chunk, and truncate what we get.\n        return self.fp.peek(chunk_left)[:chunk_left]\n", "docstring": "Strictly speaking, _get_chunk_left() may cause more than one read,"}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def getheader(self, name, default=None):\n        '''Returns the value of the header matching *name*.\n        If there are multiple matching headers, the values are\n        combined into a single string separated by commas and spaces.\n        If no matching header is found, returns *default* or None if\n        the *default* is not specified.\n        If the headers are unknown, raises http.client.ResponseNotReady.\n        '''\n        if self.headers is None:\n            raise ResponseNotReady()\n        headers = self.headers.get_all(name) or default\n        if isinstance(headers, str) or not hasattr(headers, '__iter__'):\n            return headers\n        else:\n            return ', '.join(headers)\n", "docstring": "Returns the value of the header matching *name*."}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def info(self):\n        '''Returns an instance of the class mimetools.Message containing\n        meta-information associated with the URL.\n        When the method is HTTP, these headers are those returned by\n        the server at the head of the retrieved HTML page (including\n        Content-Length and Content-Type).\n        When the method is FTP, a Content-Length header will be\n        present if (as is now usual) the server passed back a file\n        length in response to the FTP retrieval request. A\n        Content-Type header will be present if the MIME type can be\n        guessed.\n        When the method is local-file, returned headers will include\n        a Date representing the file's last-modified time, a\n        Content-Length giving file size, and a Content-Type\n        containing a guess at the file's type. See also the\n        description of the mimetools module.\n        '''\n        return self.headers\n", "docstring": "Returns an instance of the class mimetools.Message containing"}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def getcode(self):\n        '''Return the HTTP status code that was sent with the response,\n        or None if the URL is not an HTTP URL.\n        '''\n        return self.status\n", "docstring": "Return the HTTP status code that was sent with the response,"}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def _is_textIO(stream):\n        \"\"\"Test whether a file-like object is a text or a binary stream.\n        \"\"\"\n        return isinstance(stream, io.TextIOBase)\n", "docstring": "Test whether a file-like object is a text or a binary stream."}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def _get_content_length(body, method):\n        \"\"\"Get the content-length based on the body.\n        If the body is None, we set Content-Length: 0 for methods that expect\n        a body (RFC 7230, Section 3.3.2). We also set the Content-Length for\n        any method if the body is a str or bytes-like object and not a file.\n        \"\"\"\n        if body is None:\n            # do an explicit check for not None here to distinguish\n            # between unset and set but empty\n            if method.upper() in _METHODS_EXPECTING_BODY:\n                return 0\n            else:\n                return None\n        if hasattr(body, 'read'):\n            # file-like object.\n            return None\n        try:\n            # does it implement the buffer protocol (bytes, bytearray, array)?\n            mv = memoryview(body)\n            return mv.nbytes\n        except TypeError:\n            pass\n        if isinstance(body, str):\n            return len(body)\n        return None\n", "docstring": "Get the content-length based on the body."}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def set_tunnel(self, host, port=None, headers=None):\n        \"\"\"Set up host and port for HTTP CONNECT tunnelling.\n        In a connection that uses HTTP CONNECT tunneling, the host passed to the\n        constructor is used as a proxy server that relays all communication to\n        the endpoint passed to `set_tunnel`. This done by sending an HTTP\n        CONNECT request to the proxy server when the connection is established.\n        This method must be called before the HTML connection has been\n        established.\n        The headers argument should be a mapping of extra HTTP headers to send\n        with the CONNECT request.\n        \"\"\"\n        if self.sock:\n            raise RuntimeError(\"Can't set up tunnel for established connection\")\n        self._tunnel_host, self._tunnel_port = self._get_hostport(host, port)\n        if headers:\n            self._tunnel_headers = headers\n        else:\n            self._tunnel_headers.clear()\n", "docstring": "Set up host and port for HTTP CONNECT tunnelling."}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        self.sock = self._create_connection(\n            (self.host,self.port), self.timeout, self.source_address)\n        self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n        if self._tunnel_host:\n            self._tunnel()\n", "docstring": "Connect to the host and port specified in __init__.\n"}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n        if self.sock is None:\n            if self.auto_open:\n                self.connect()\n            else:\n                raise NotConnected()\n        if self.debuglevel > 0:\n            print(\"send:\", repr(data))\n        blocksize = 8192\n        if hasattr(data, \"read\") :\n            if self.debuglevel > 0:\n                print(\"sendIng a read()able\")\n            encode = False\n            try:\n                mode = data.mode\n            except AttributeError:\n                # io.BytesIO and other file-like objects don't have a `mode`\n                # attribute.\n                pass\n            else:\n                if \"b\" not in mode:\n                    encode = True\n                    if self.debuglevel > 0:\n                        print(\"encoding file using iso-8859-1\")\n            while 1:\n                datablock = data.read(blocksize)\n                if not datablock:\n                    break\n                if encode:\n                    datablock = datablock.encode(\"iso-8859-1\")\n                self.sock.sendall(datablock)\n            return\n        try:\n            self.sock.sendall(data)\n        except TypeError:\n            if isinstance(data, collections.Iterable):\n                for d in data:\n                    self.sock.sendall(d)\n            else:\n                raise TypeError(\"data should be a bytes-like object \"\n                                \"or an iterable, got %r\" % type(data))\n", "docstring": "Send `data' to the server."}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def endheaders(self, message_body=None, **kwds):\n        \"\"\"Indicate that the last header line has been sent to the server.\n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.\n        \"\"\"\n        encode_chunked = kwds.pop('encode_chunked', False)\n        if kwds:\n            # mimic interpreter error for unrecognized keyword\n            raise TypeError(\"endheaders() got an unexpected keyword argument '{0}'\"\n                            .format(kwds.popitem()[0]))\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n        self._send_output(message_body, encode_chunked=encode_chunked)\n", "docstring": "Indicate that the last header line has been sent to the server."}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def _set_content_length(self, body, method):\n        # Set the content-length based on the body. If the body is \"empty\", we\n        # set Content-Length: 0 for methods that expect a body (RFC 7230,\n        # Section 3.3.2). If the body is set for other methods, we set the\n        # header provided we can figure out what the length is.\n        thelen = None\n        method_expects_body = method.upper() in _METHODS_EXPECTING_BODY\n        if body is None and method_expects_body:\n            thelen = '0'\n        elif body is not None:\n            try:\n                thelen = str(len(body))\n            except TypeError:\n                # If this is a file-like object, try to\n                # fstat its file descriptor\n                try:\n                    thelen = str(os.fstat(body.fileno()).st_size)\n                except (AttributeError, OSError):\n                    # Don't send a length if this failed\n                    if self.debuglevel > 0: print(\"Cannot stat!!\")\n        if thelen is not None:\n            self.putheader('Content-Length', thelen)\n", "docstring": "Set the content-length based on the body. If the body is \"empty\", we"}
{"repo": "eventlet-master/eventlet/green/http/client.py", "original_string": "    def getresponse(self):\n        \"\"\"Get the response from the server.\n        If the HTTPConnection is in the correct state, returns an\n        instance of HTTPResponse or of whatever object is returned by\n        the response_class variable.\n        If a request has not been sent or if a previous response has\n        not be handled, ResponseNotReady is raised.  If the HTTP\n        response indicates that the connection should be closed, then\n        it will be closed before the response is returned.  When the\n        connection is closed, the underlying socket is closed.\n        \"\"\"\n        # if a prior response has been completed, then forget about it.\n        if self.__response and self.__response.isclosed():\n            self.__response = None\n        # if a prior response exists, then it must be completed (otherwise, we\n        # cannot read this response's header to determine the connection-close\n        # behavior)\n        #\n        # note: if a prior response existed, but was connection-close, then the\n        # socket and response were made independent of this HTTPConnection\n        # object since a new request requires that we open a whole new\n        # connection\n        #\n        # this means the prior response had one of two states:\n        #   1) will_close: this connection was reset and the prior socket and\n        #                  response operate independently\n        #   2) persistent: the response was retained and we await its\n        #                  isclosed() status to become true.\n        #\n        if self.__state != _CS_REQ_SENT or self.__response:\n            raise ResponseNotReady(self.__state)\n        if self.debuglevel > 0:\n            response = self.response_class(self.sock, self.debuglevel,\n                                           method=self._method)\n        else:\n            response = self.response_class(self.sock, method=self._method)\n        try:\n            try:\n                response.begin()\n            except ConnectionError:\n                self.close()\n                raise\n            assert response.will_close != _UNKNOWN\n            self.__state = _CS_IDLE\n            if response.will_close:\n                # this effectively passes the connection to the response\n                self.close()\n            else:\n                # remember this, so we can tell when it is complete\n                self.__response = response\n            return response\n        except:\n            response.close()\n            raise\n", "docstring": "Get the response from the server."}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "def _warn_unhandled_exception():\n    # There are a few catch-all except: statements in this module, for\n    # catching input that's bad in unexpected ways.  Warn if any\n    # exceptions are caught there.\n    import io, warnings, traceback\n    f = io.StringIO()\n    traceback.print_exc(None, f)\n    msg = f.getvalue()\n    warnings.warn(\"http.cookiejar bug!\\n%s\" % msg, stacklevel=2)\n", "docstring": "There are a few catch-all except: statements in this module, for"}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "def time2isoz(t=None):\n    \"\"\"Return a string representing time in seconds since epoch, t.\n    If the function is called without an argument, it will use the current\n    time.\n    The format of the returned string is like \"YYYY-MM-DD hh:mm:ssZ\",\n    representing Universal Time (UTC, aka GMT).  An example of this format is:\n    1994-11-24 08:49:37Z\n    \"\"\"\n    if t is None:\n        dt = datetime.datetime.utcnow()\n    else:\n        dt = datetime.datetime.utcfromtimestamp(t)\n    return \"%04d-%02d-%02d %02d:%02d:%02dZ\" % (\n        dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)\n", "docstring": "Return a string representing time in seconds since epoch, t."}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "def http2time(text):\n    \"\"\"Returns time in seconds since epoch of time represented by a string.\n    Return value is an integer.\n    None is returned if the format of str is unrecognized, the time is outside\n    the representable range, or the timezone string is not recognized.  If the\n    string contains no timezone, UTC is assumed.\n    The timezone in the string may be numerical (like \"-0800\" or \"+0100\") or a\n    string timezone (like \"UTC\", \"GMT\", \"BST\" or \"EST\").  Currently, only the\n    timezone strings equivalent to UTC (zero offset) are known to the function.\n    The function loosely parses the following formats:\n    Wed, 09 Feb 1994 22:23:32 GMT       -- HTTP format\n    Tuesday, 08-Feb-94 14:15:29 GMT     -- old rfc850 HTTP format\n    Tuesday, 08-Feb-1994 14:15:29 GMT   -- broken rfc850 HTTP format\n    09 Feb 1994 22:23:32 GMT            -- HTTP format (no weekday)\n    08-Feb-94 14:15:29 GMT              -- rfc850 format (no weekday)\n    08-Feb-1994 14:15:29 GMT            -- broken rfc850 format (no weekday)\n    The parser ignores leading and trailing whitespace.  The time may be\n    absent.\n    If the year is given with only 2 digits, the function will select the\n    century that makes the year closest to the current date.\n    \"\"\"\n    # fast exit for strictly conforming string\n    m = STRICT_DATE_RE.search(text)\n    if m:\n        g = m.groups()\n        mon = MONTHS_LOWER.index(g[1].lower()) + 1\n        tt = (int(g[2]), mon, int(g[0]),\n              int(g[3]), int(g[4]), float(g[5]))\n        return _timegm(tt)\n    # No, we need some messy parsing...\n    # clean up\n    text = text.lstrip()\n    text = WEEKDAY_RE.sub(\"\", text, 1)  # Useless weekday\n    # tz is time zone specifier string\n    day, mon, yr, hr, min, sec, tz = [None]*7\n    # loose regexp parse\n    m = LOOSE_HTTP_DATE_RE.search(text)\n    if m is not None:\n        day, mon, yr, hr, min, sec, tz = m.groups()\n    else:\n        return None  # bad format\n    return _str2time(day, mon, yr, hr, min, sec, tz)\n", "docstring": "Returns time in seconds since epoch of time represented by a string."}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "def unmatched(match):\n    \"\"\"Return unmatched part of re.Match object.\"\"\"\n    start, end = match.span(0)\n    return match.string[:start]+match.string[end:]\n", "docstring": "Return unmatched part of re.Match object.\n"}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "def join_header_words(lists):\n    \"\"\"Do the inverse (almost) of the conversion done by split_header_words.\n    Takes a list of lists of (key, value) pairs and produces a single header\n    value.  Attribute values are quoted if needed.\n    >>> join_header_words([[(\"text/plain\", None), (\"charset\", \"iso-8859-1\")]])\n    'text/plain; charset=\"iso-8859-1\"'\n    >>> join_header_words([[(\"text/plain\", None)], [(\"charset\", \"iso-8859-1\")]])\n    'text/plain, charset=\"iso-8859-1\"'\n    \"\"\"\n    headers = []\n    for pairs in lists:\n        attr = []\n        for k, v in pairs:\n            if v is not None:\n                if not re.search(r\"^\\w+$\", v):\n                    v = HEADER_JOIN_ESCAPE_RE.sub(r\"\\\\\\1\", v)  # escape \" and \\\n                    v = '\"%s\"' % v\n                k = \"%s=%s\" % (k, v)\n            attr.append(k)\n        if attr: headers.append(\"; \".join(attr))\n    return \", \".join(headers)\n", "docstring": "Do the inverse (almost) of the conversion done by split_header_words."}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "def parse_ns_headers(ns_headers):\n    \"\"\"Ad-hoc parser for Netscape protocol cookie-attributes.\n    The old Netscape cookie format for Set-Cookie can for instance contain\n    an unquoted \",\" in the expires field, so we have to use this ad-hoc\n    parser instead of split_header_words.\n    XXX This may not make the best possible effort to parse all the crap\n    that Netscape Cookie headers contain.  Ronald Tschalar's HTTPClient\n    parser is probably better, so could do worse than following that if\n    this ever gives any trouble.\n    Currently, this is also used for parsing RFC 2109 cookies.\n    \"\"\"\n    known_attrs = (\"expires\", \"domain\", \"path\", \"secure\",\n                   # RFC 2109 attrs (may turn up in Netscape cookies, too)\n                   \"version\", \"port\", \"max-age\")\n    result = []\n    for ns_header in ns_headers:\n        pairs = []\n        version_set = False\n        # XXX: The following does not strictly adhere to RFCs in that empty\n        # names and values are legal (the former will only appear once and will\n        # be overwritten if multiple occurrences are present). This is\n        # mostly to deal with backwards compatibility.\n        for ii, param in enumerate(ns_header.split(';')):\n            param = param.strip()\n            key, sep, val = param.partition('=')\n            key = key.strip()\n            if not key:\n                if ii == 0:\n                    break\n                else:\n                    continue\n            # allow for a distinction between present and empty and missing\n            # altogether\n            val = val.strip() if sep else None\n            if ii != 0:\n                lc = key.lower()\n                if lc in known_attrs:\n                    key = lc\n                if key == \"version\":\n                    # This is an RFC 2109 cookie.\n                    if val is not None:\n                        val = strip_quotes(val)\n                    version_set = True\n                elif key == \"expires\":\n                    # convert expires date to seconds since epoch\n                    if val is not None:\n                        val = http2time(strip_quotes(val))  # None if invalid\n            pairs.append((key, val))\n        if pairs:\n            if not version_set:\n                pairs.append((\"version\", \"0\"))\n            result.append(pairs)\n    return result\n", "docstring": "Ad-hoc parser for Netscape protocol cookie-attributes."}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "def is_HDN(text):\n    \"\"\"Return True if text is a host domain name.\"\"\"\n    # XXX\n    # This may well be wrong.  Which RFC is HDN defined in, if any (for\n    #  the purposes of RFC 2965)?\n    # For the current implementation, what about IPv6?  Remember to look\n    #  at other uses of IPV4_RE also, if change this.\n    if IPV4_RE.search(text):\n        return False\n    if text == \"\":\n        return False\n    if text[0] == \".\" or text[-1] == \".\":\n        return False\n    return True\n", "docstring": "Return True if text is a host domain name.\n"}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "def liberal_is_HDN(text):\n    \"\"\"Return True if text is a sort-of-like a host domain name.\n    For accepting/blocking domains.\n    \"\"\"\n    if IPV4_RE.search(text):\n        return False\n    return True\n", "docstring": "Return True if text is a sort-of-like a host domain name."}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "def request_host(request):\n    \"\"\"Return request-host, as defined by RFC 2965.\n    Variation from RFC: returned value is lowercased, for convenient\n    comparison.\n    \"\"\"\n    url = request.get_full_url()\n    host = urllib.parse.urlparse(url)[1]\n    if host == \"\":\n        host = request.get_header(\"Host\", \"\")\n    # remove port, if present\n    host = cut_port_re.sub(\"\", host, 1)\n    return host.lower()\n", "docstring": "Return request-host, as defined by RFC 2965."}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "def request_path(request):\n    \"\"\"Path component of request-URI, as defined by RFC 2965.\"\"\"\n    url = request.get_full_url()\n    parts = urllib.parse.urlsplit(url)\n    path = escape_path(parts.path)\n    if not path.startswith(\"/\"):\n        # fix bad RFC 2396 absoluteURI\n        path = \"/\" + path\n    return path\n", "docstring": "Path component of request-URI, as defined by RFC 2965.\n"}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "def reach(h):\n    \"\"\"Return reach of host h, as defined by RFC 2965, section 1.\n    The reach R of a host name H is defined as follows:\n       *  If\n          -  H is the host domain name of a host; and,\n          -  H has the form A.B; and\n          -  A has no embedded (that is, interior) dots; and\n          -  B has at least one embedded dot, or B is the string \"local\".\n             then the reach of H is .B.\n       *  Otherwise, the reach of H is H.\n    >>> reach(\"www.acme.com\")\n    '.acme.com'\n    >>> reach(\"acme.com\")\n    'acme.com'\n    >>> reach(\"acme.local\")\n    '.local'\n    \"\"\"\n    i = h.find(\".\")\n    if i >= 0:\n        #a = h[:i]  # this line is only here to show what a is\n        b = h[i+1:]\n        i = b.find(\".\")\n        if is_HDN(h) and (i >= 0 or b == \"local\"):\n            return \".\"+b\n    return h\n", "docstring": "Return reach of host h, as defined by RFC 2965, section 1."}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "    def set_ok(self, cookie, request):\n        \"\"\"Return true if (and only if) cookie should be accepted from server.\n        Currently, pre-expired cookies never get this far -- the CookieJar\n        class deletes such cookies itself.\n        \"\"\"\n        raise NotImplementedError()\n", "docstring": "Return true if (and only if) cookie should be accepted from server."}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "    def domain_return_ok(self, domain, request):\n        \"\"\"Return false if cookies should not be returned, given cookie domain.\n        \"\"\"\n        return True\n", "docstring": "Return false if cookies should not be returned, given cookie domain."}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "    def set_blocked_domains(self, blocked_domains):\n        \"\"\"Set the sequence of blocked domains.\"\"\"\n        self._blocked_domains = tuple(blocked_domains)\n", "docstring": "Set the sequence of blocked domains.\n"}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "    def allowed_domains(self):\n        \"\"\"Return None, or the sequence of allowed domains (as a tuple).\"\"\"\n        return self._allowed_domains\n", "docstring": "Return None, or the sequence of allowed domains (as a tuple).\n"}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "    def set_ok_name(self, cookie, request):\n        # Try and stop servers setting V0 cookies designed to hack other\n        # servers that know both V0 and V1 protocols.\n        if (cookie.version == 0 and self.strict_ns_set_initial_dollar and\n            cookie.name.startswith(\"$\")):\n            _debug(\"   illegal name (starts with '$'): '%s'\", cookie.name)\n            return False\n        return True\n", "docstring": "Try and stop servers setting V0 cookies designed to hack other"}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "    def return_ok_verifiability(self, cookie, request):\n        if request.unverifiable and is_third_party(request):\n            if cookie.version > 0 and self.strict_rfc2965_unverifiable:\n                _debug(\"   third-party RFC 2965 cookie during unverifiable \"\n                       \"transaction\")\n                return False\n            elif cookie.version == 0 and self.strict_ns_unverifiable:\n                _debug(\"   third-party Netscape cookie during unverifiable \"\n                       \"transaction\")\n                return False\n        return True\n", "docstring": "if request.unverifiable and is_third_party(request):"}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "def deepvalues(mapping):\n    \"\"\"Iterates over nested mapping, depth-first, in sorted order by key.\"\"\"\n    values = vals_sorted_by_key(mapping)\n    for obj in values:\n        mapping = False\n        try:\n            obj.items\n        except AttributeError:\n            pass\n        else:\n            mapping = True\n            yield from deepvalues(obj)\n        if not mapping:\n            yield obj\n", "docstring": "Iterates over nested mapping, depth-first, in sorted order by key.\n"}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "    def _cookie_attrs(self, cookies):\n        \"\"\"Return a list of cookie-attributes to be returned to server.\n        like ['foo=\"bar\"; $Path=\"/\"', ...]\n        The $Version attribute is also added when appropriate (currently only\n        once per request).\n        \"\"\"\n        # add cookies in order of most specific (ie. longest) path first\n        cookies.sort(key=lambda a: len(a.path), reverse=True)\n        version_set = False\n        attrs = []\n        for cookie in cookies:\n            # set version of Cookie header\n            # XXX\n            # What should it be if multiple matching Set-Cookie headers have\n            #  different versions themselves?\n            # Answer: there is no answer; was supposed to be settled by\n            #  RFC 2965 errata, but that may never appear...\n            version = cookie.version\n            if not version_set:\n                version_set = True\n                if version > 0:\n                    attrs.append(\"$Version=%s\" % version)\n            # quote cookie value if necessary\n            # (not for Netscape protocol, which already has any quotes\n            #  intact, due to the poorly-specified Netscape Cookie: syntax)\n            if ((cookie.value is not None) and\n                self.non_word_re.search(cookie.value) and version > 0):\n                value = self.quote_re.sub(r\"\\\\\\1\", cookie.value)\n            else:\n                value = cookie.value\n            # add cookie-attributes to be returned in Cookie header\n            if cookie.value is None:\n                attrs.append(cookie.name)\n            else:\n                attrs.append(\"%s=%s\" % (cookie.name, value))\n            if version > 0:\n                if cookie.path_specified:\n                    attrs.append('$Path=\"%s\"' % cookie.path)\n                if cookie.domain.startswith(\".\"):\n                    domain = cookie.domain\n                    if (not cookie.domain_initial_dot and\n                        domain.startswith(\".\")):\n                        domain = domain[1:]\n                    attrs.append('$Domain=\"%s\"' % domain)\n                if cookie.port is not None:\n                    p = \"$Port\"\n                    if cookie.port_specified:\n                        p = p + ('=\"%s\"' % cookie.port)\n                    attrs.append(p)\n        return attrs\n", "docstring": "Return a list of cookie-attributes to be returned to server."}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "    def make_cookies(self, response, request):\n        \"\"\"Return sequence of Cookie objects extracted from response object.\"\"\"\n        # get cookie-attributes for RFC 2965 and Netscape protocols\n        headers = response.info()\n        rfc2965_hdrs = headers.get_all(\"Set-Cookie2\", [])\n        ns_hdrs = headers.get_all(\"Set-Cookie\", [])\n        rfc2965 = self._policy.rfc2965\n        netscape = self._policy.netscape\n        if ((not rfc2965_hdrs and not ns_hdrs) or\n            (not ns_hdrs and not rfc2965) or\n            (not rfc2965_hdrs and not netscape) or\n            (not netscape and not rfc2965)):\n            return []  # no relevant cookie headers: quick exit\n        try:\n            cookies = self._cookies_from_attrs_set(\n                split_header_words(rfc2965_hdrs), request)\n        except Exception:\n            _warn_unhandled_exception()\n            cookies = []\n        if ns_hdrs and netscape:\n            try:\n                # RFC 2109 and Netscape cookies\n                ns_cookies = self._cookies_from_attrs_set(\n                    parse_ns_headers(ns_hdrs), request)\n            except Exception:\n                _warn_unhandled_exception()\n                ns_cookies = []\n            self._process_rfc2109_cookies(ns_cookies)\n            # Look for Netscape cookies (from Set-Cookie headers) that match\n            # corresponding RFC 2965 cookies (from Set-Cookie2 headers).\n            # For each match, keep the RFC 2965 cookie and ignore the Netscape\n            # cookie (RFC 2965 section 9.1).  Actually, RFC 2109 cookies are\n            # bundled in with the Netscape cookies for this purpose, which is\n            # reasonable behaviour.\n            if rfc2965:\n                lookup = {}\n                for cookie in cookies:\n                    lookup[(cookie.domain, cookie.path, cookie.name)] = None\n                def no_matching_rfc2965(ns_cookie, lookup=lookup):\n                    key = ns_cookie.domain, ns_cookie.path, ns_cookie.name\n                    return key not in lookup\n                ns_cookies = filter(no_matching_rfc2965, ns_cookies)\n            if ns_cookies:\n                cookies.extend(ns_cookies)\n        return cookies\n", "docstring": "Return sequence of Cookie objects extracted from response object.\n"}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "    def set_cookie(self, cookie):\n        \"\"\"Set a cookie, without checking whether or not it should be set.\"\"\"\n        c = self._cookies\n        self._cookies_lock.acquire()\n        try:\n            if cookie.domain not in c: c[cookie.domain] = {}\n            c2 = c[cookie.domain]\n            if cookie.path not in c2: c2[cookie.path] = {}\n            c3 = c2[cookie.path]\n            c3[cookie.name] = cookie\n        finally:\n            self._cookies_lock.release()\n", "docstring": "Set a cookie, without checking whether or not it should be set.\n"}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "    def clear(self, domain=None, path=None, name=None):\n        \"\"\"Clear some cookies.\n        Invoking this method without arguments will clear all cookies.  If\n        given a single argument, only cookies belonging to that domain will be\n        removed.  If given two arguments, cookies belonging to the specified\n        path within that domain are removed.  If given three arguments, then\n        the cookie with the specified name, path and domain is removed.\n        Raises KeyError if no matching cookie exists.\n        \"\"\"\n        if name is not None:\n            if (domain is None) or (path is None):\n                raise ValueError(\n                    \"domain and path must be given to remove a cookie by name\")\n            del self._cookies[domain][path][name]\n        elif path is not None:\n            if domain is None:\n                raise ValueError(\n                    \"domain must be given to remove cookies by path\")\n            del self._cookies[domain][path]\n        elif domain is not None:\n            del self._cookies[domain]\n        else:\n            self._cookies = {}\n", "docstring": "Clear some cookies."}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "    def clear_expired_cookies(self):\n        \"\"\"Discard all expired cookies.\n        You probably don't need to call this method: expired cookies are never\n        sent back to the server (provided you're using DefaultCookiePolicy),\n        this method is called by CookieJar itself every so often, and the\n        .save() method won't save expired cookies anyway (unless you ask\n        otherwise by passing a true ignore_expires argument).\n        \"\"\"\n        self._cookies_lock.acquire()\n        try:\n            now = time.time()\n            for cookie in self:\n                if cookie.is_expired(now):\n                    self.clear(cookie.domain, cookie.path, cookie.name)\n        finally:\n            self._cookies_lock.release()\n", "docstring": "Discard all expired cookies."}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "    def __len__(self):\n        \"\"\"Return number of contained cookies.\"\"\"\n        i = 0\n        for cookie in self: i = i + 1\n        return i\n", "docstring": "Return number of contained cookies.\n"}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "    def load(self, filename=None, ignore_discard=False, ignore_expires=False):\n        \"\"\"Load cookies from a file.\"\"\"\n        if filename is None:\n            if self.filename is not None: filename = self.filename\n            else: raise ValueError(MISSING_FILENAME_TEXT)\n        with open(filename) as f:\n            self._really_load(f, filename, ignore_discard, ignore_expires)\n", "docstring": "Load cookies from a file.\n"}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "def lwp_cookie_str(cookie):\n    \"\"\"Return string representation of Cookie in the LWP cookie file format.\n    Actually, the format is extended a bit -- see module docstring.\n    \"\"\"\n    h = [(cookie.name, cookie.value),\n         (\"path\", cookie.path),\n         (\"domain\", cookie.domain)]\n    if cookie.port is not None: h.append((\"port\", cookie.port))\n    if cookie.path_specified: h.append((\"path_spec\", None))\n    if cookie.port_specified: h.append((\"port_spec\", None))\n    if cookie.domain_initial_dot: h.append((\"domain_dot\", None))\n    if cookie.secure: h.append((\"secure\", None))\n    if cookie.expires: h.append((\"expires\",\n                               time2isoz(float(cookie.expires))))\n    if cookie.discard: h.append((\"discard\", None))\n    if cookie.comment: h.append((\"comment\", cookie.comment))\n    if cookie.comment_url: h.append((\"commenturl\", cookie.comment_url))\n    keys = sorted(cookie._rest.keys())\n    for k in keys:\n        h.append((k, str(cookie._rest[k])))\n    h.append((\"version\", str(cookie.version)))\n    return join_header_words([h])\n", "docstring": "Return string representation of Cookie in the LWP cookie file format."}
{"repo": "eventlet-master/eventlet/green/http/cookiejar.py", "original_string": "    def as_lwp_str(self, ignore_discard=True, ignore_expires=True):\n        \"\"\"Return cookies as a string of \"\\\\n\"-separated \"Set-Cookie3\" headers.\n        ignore_discard and ignore_expires: see docstring for FileCookieJar.save\n        \"\"\"\n        now = time.time()\n        r = []\n        for cookie in self:\n            if not ignore_discard and cookie.discard:\n                continue\n            if not ignore_expires and cookie.is_expired(now):\n                continue\n            r.append(\"Set-Cookie3: %s\" % lwp_cookie_str(cookie))\n        return \"\\n\".join(r+[\"\"])\n", "docstring": "Return cookies as a string of \"\\\\n\"-separated \"Set-Cookie3\" headers."}
{"repo": "eventlet-master/eventlet/green/http/cookies.py", "original_string": "def _unquote(str):\n    # If there aren't any doublequotes,\n    # then there can't be any special characters.  See RFC 2109.\n    if str is None or len(str) < 2:\n        return str\n    if str[0] != '\"' or str[-1] != '\"':\n        return str\n    # We have to assume that we must decode this string.\n    # Down to work.\n    # Remove the \"s\n    str = str[1:-1]\n    # Check for special sequences.  Examples:\n    #    \\012 --> \\n\n    #    \\\"   --> \"\n    #\n    i = 0\n    n = len(str)\n    res = []\n    while 0 <= i < n:\n        o_match = _OctalPatt.search(str, i)\n        q_match = _QuotePatt.search(str, i)\n        if not o_match and not q_match:              # Neither matched\n            res.append(str[i:])\n            break\n        # else:\n        j = k = -1\n        if o_match:\n            j = o_match.start(0)\n        if q_match:\n            k = q_match.start(0)\n        if q_match and (not o_match or k < j):     # QuotePatt matched\n            res.append(str[i:k])\n            res.append(str[k+1])\n            i = k + 2\n        else:                                      # OctalPatt matched\n            res.append(str[i:j])\n            res.append(chr(int(str[j+1:j+4], 8)))\n            i = j + 4\n    return _nulljoin(res)\n", "docstring": "If there aren't any doublequotes,"}
{"repo": "eventlet-master/eventlet/green/http/cookies.py", "original_string": "    def __init__(self):\n        # Set defaults\n        self._key = self._value = self._coded_value = None\n        # Set default attributes\n        for key in self._reserved:\n            dict.__setitem__(self, key, \"\")\n", "docstring": "Set defaults"}
{"repo": "eventlet-master/eventlet/green/http/cookies.py", "original_string": "    def OutputString(self, attrs=None):\n        # Build up our result\n        #\n        result = []\n        append = result.append\n        # First, the key=value pair\n        append(\"%s=%s\" % (self.key, self.coded_value))\n        # Now add any defined attributes\n        if attrs is None:\n            attrs = self._reserved\n        items = sorted(self.items())\n        for key, value in items:\n            if value == \"\":\n                continue\n            if key not in attrs:\n                continue\n            if key == \"expires\" and isinstance(value, int):\n                append(\"%s=%s\" % (self._reserved[key], _getdate(value)))\n            elif key == \"max-age\" and isinstance(value, int):\n                append(\"%s=%d\" % (self._reserved[key], value))\n            elif key in self._flags:\n                if value:\n                    append(str(self._reserved[key]))\n            else:\n                append(\"%s=%s\" % (self._reserved[key], value))\n        # Return the result\n        return _semispacejoin(result)\n", "docstring": "Build up our result"}
{"repo": "eventlet-master/eventlet/green/http/cookies.py", "original_string": "    def value_decode(self, val):\n        \"\"\"real_value, coded_value = value_decode(STRING)\n        Called prior to setting a cookie's value from the network\n        representation.  The VALUE is the value read from HTTP\n        header.\n        Override this function to modify the behavior of cookies.\n        \"\"\"\n        return val, val\n", "docstring": "real_value, coded_value = value_decode(STRING)"}
{"repo": "eventlet-master/eventlet/green/http/cookies.py", "original_string": "    def __setitem__(self, key, value):\n        \"\"\"Dictionary style assignment.\"\"\"\n        if isinstance(value, Morsel):\n            # allow assignment of constructed Morsels (e.g. for pickling)\n            dict.__setitem__(self, key, value)\n        else:\n            rval, cval = self.value_encode(value)\n            self.__set(key, rval, cval)\n", "docstring": "Dictionary style assignment.\n"}
{"repo": "eventlet-master/eventlet/green/http/cookies.py", "original_string": "    def load(self, rawdata):\n        \"\"\"Load cookies from a string (presumably HTTP_COOKIE) or\n        from a dictionary.  Loading cookies from a dictionary 'd'\n        is equivalent to calling:\n            map(Cookie.__setitem__, d.keys(), d.values())\n        \"\"\"\n        if isinstance(rawdata, str):\n            self.__parse_string(rawdata)\n        else:\n            # self.update() wouldn't call our custom __setitem__\n            for key, value in rawdata.items():\n                self[key] = value\n        return\n", "docstring": "Load cookies from a string (presumably HTTP_COOKIE) or"}
{"repo": "eventlet-master/eventlet/green/OpenSSL/SSL.py", "original_string": "    def read(self, size):\n        \"\"\"Works like a blocking call to SSL_read(), whose behavior is\n        described here:  http://www.openssl.org/docs/ssl/SSL_read.html\"\"\"\n        if self.act_non_blocking:\n            return self.fd.read(size)\n        while True:\n            try:\n                return self.fd.read(size)\n            except WantReadError:\n                trampoline(self.fd.fileno(),\n                           read=True,\n                           timeout=self.gettimeout(),\n                           timeout_exc=socket.timeout)\n            except WantWriteError:\n                trampoline(self.fd.fileno(),\n                           write=True,\n                           timeout=self.gettimeout(),\n                           timeout_exc=socket.timeout)\n            except SysCallError as e:\n                if get_errno(e) == -1 or get_errno(e) > 0:\n                    return ''\n", "docstring": "Works like a blocking call to SSL_read(), whose behavior is"}
{"repo": "eventlet-master/eventlet/green/OpenSSL/SSL.py", "original_string": "    def write(self, data):\n        \"\"\"Works like a blocking call to SSL_write(), whose behavior is\n        described here:  http://www.openssl.org/docs/ssl/SSL_write.html\"\"\"\n        if not data:\n            return 0  # calling SSL_write() with 0 bytes to be sent is undefined\n        if self.act_non_blocking:\n            return self.fd.write(data)\n        while True:\n            try:\n                return self.fd.write(data)\n            except WantReadError:\n                trampoline(self.fd.fileno(),\n                           read=True,\n                           timeout=self.gettimeout(),\n                           timeout_exc=socket.timeout)\n            except WantWriteError:\n                trampoline(self.fd.fileno(),\n                           write=True,\n                           timeout=self.gettimeout(),\n                           timeout_exc=socket.timeout)\n", "docstring": "Works like a blocking call to SSL_write(), whose behavior is"}
{"repo": "eventlet-master/eventlet/green/OpenSSL/SSL.py", "original_string": "    def sendall(self, data):\n        \"\"\"Send \"all\" data on the connection. This calls send() repeatedly until\n        all data is sent. If an error occurs, it's impossible to tell how much data\n        has been sent.\n        No return value.\"\"\"\n        tail = self.send(data)\n        while tail < len(data):\n            tail += self.send(data[tail:])\n", "docstring": "Send \"all\" data on the connection. This calls send() repeatedly until"}
{"repo": "eventlet-master/eventlet/hubs/selects.py", "original_string": "    def _remove_bad_fds(self):\n        \"\"\" Iterate through fds, removing the ones that are bad per the\n        operating system.\n        \"\"\"\n        all_fds = list(self.listeners[self.READ]) + list(self.listeners[self.WRITE])\n        for fd in all_fds:\n            try:\n                select.select([fd], [], [], 0)\n            except select.error as e:\n                if support.get_errno(e) in BAD_SOCK:\n                    self.remove_descriptor(fd)\n", "docstring": "Iterate through fds, removing the ones that are bad per the"}
{"repo": "eventlet-master/eventlet/hubs/pyevent.py", "original_string": "    def add(self, evtype, fileno, real_cb, real_tb, mac):\n        # this is stupid: pyevent won't call a callback unless it's a function,\n        # so we have to force it to be one here\n        if isinstance(real_cb, types.BuiltinMethodType):\n            def cb(_d):\n                real_cb(_d)\n        else:\n            cb = real_cb\n        if evtype is READ:\n            evt = event.read(fileno, cb, fileno)\n        elif evtype is WRITE:\n            evt = event.write(fileno, cb, fileno)\n        return super(Hub, self).add(evtype, fileno, evt, real_tb, mac)\n", "docstring": "this is stupid: pyevent won't call a callback unless it's a function,"}
{"repo": "eventlet-master/eventlet/hubs/hub.py", "original_string": "def closed_callback(fileno):\n    \"\"\" Used to de-fang a callback that may be triggered by a loop in BaseHub.wait\n    \"\"\"\n    # No-op.\n    pass\n", "docstring": "Used to de-fang a callback that may be triggered by a loop in BaseHub.wait"}
{"repo": "eventlet-master/eventlet/hubs/hub.py", "original_string": "    def __init__(self, evtype, fileno, cb, tb, mark_as_closed):\n        \"\"\" The following are required:\n        cb - the standard callback, which will switch into the\n            listening greenlet to indicate that the event waited upon\n            is ready\n        tb - a 'throwback'. This is typically greenlet.throw, used\n            to raise a signal into the target greenlet indicating that\n            an event was obsoleted by its underlying filehandle being\n            repurposed.\n        mark_as_closed - if any listener is obsoleted, this is called\n            (in the context of some other client greenlet) to alert\n            underlying filehandle-wrapping objects that they've been\n            closed.\n        \"\"\"\n        assert (evtype is READ or evtype is WRITE)\n        self.evtype = evtype\n        self.fileno = fileno\n        self.cb = cb\n        self.tb = tb\n        self.mark_as_closed = mark_as_closed\n        self.spent = False\n        self.greenlet = greenlet.getcurrent()\n", "docstring": "The following are required:"}
{"repo": "eventlet-master/eventlet/hubs/hub.py", "original_string": "    def _obsolete(self, fileno):\n        \"\"\" We've received an indication that 'fileno' has been obsoleted.\n            Any current listeners must be defanged, and notifications to\n            their greenlets queued up to send.\n        \"\"\"\n        found = False\n        for evtype, bucket in six.iteritems(self.secondaries):\n            if fileno in bucket:\n                for listener in bucket[fileno]:\n                    found = True\n                    self.closed.append(listener)\n                    listener.defang()\n                del bucket[fileno]\n        # For the primary listeners, we actually need to call remove,\n        # which may modify the underlying OS polling objects.\n        for evtype, bucket in six.iteritems(self.listeners):\n            if fileno in bucket:\n                listener = bucket[fileno]\n                found = True\n                self.closed.append(listener)\n                self.remove(listener)\n                listener.defang()\n        return found\n", "docstring": "We've received an indication that 'fileno' has been obsoleted."}
{"repo": "eventlet-master/eventlet/hubs/hub.py", "original_string": "    def remove_descriptor(self, fileno):\n        \"\"\" Completely remove all listeners for this fileno.  For internal use\n        only.\"\"\"\n        # gather any listeners we have\n        listeners = []\n        listeners.append(self.listeners[READ].get(fileno, noop))\n        listeners.append(self.listeners[WRITE].get(fileno, noop))\n        listeners.extend(self.secondaries[READ].get(fileno, ()))\n        listeners.extend(self.secondaries[WRITE].get(fileno, ()))\n        for listener in listeners:\n            try:\n                # listener.cb may want to remove(listener)\n                listener.cb(fileno)\n            except Exception:\n                self.squelch_generic_exception(sys.exc_info())\n        # NOW this fileno is now dead to all\n        self.listeners[READ].pop(fileno, None)\n        self.listeners[WRITE].pop(fileno, None)\n        self.secondaries[READ].pop(fileno, None)\n        self.secondaries[WRITE].pop(fileno, None)\n", "docstring": "Completely remove all listeners for this fileno.  For internal use"}
{"repo": "eventlet-master/eventlet/hubs/hub.py", "original_string": "    def run(self, *a, **kw):\n        \"\"\"Run the runloop until abort is called.\n        \"\"\"\n        # accept and discard variable arguments because they will be\n        # supplied if other greenlets have run and exited before the\n        # hub's greenlet gets a chance to run\n        if self.running:\n            raise RuntimeError(\"Already running!\")\n        try:\n            self.running = True\n            self.stopping = False\n            while not self.stopping:\n                while self.closed:\n                    # We ditch all of these first.\n                    self.close_one()\n                self.prepare_timers()\n                if self.debug_blocking:\n                    self.block_detect_pre()\n                self.fire_timers(self.clock())\n                if self.debug_blocking:\n                    self.block_detect_post()\n                self.prepare_timers()\n                wakeup_when = self.sleep_until()\n                if wakeup_when is None:\n                    sleep_time = self.default_sleep()\n                else:\n                    sleep_time = wakeup_when - self.clock()\n                if sleep_time > 0:\n                    self.wait(sleep_time)\n                else:\n                    self.wait(0)\n            else:\n                self.timers_canceled = 0\n                del self.timers[:]\n                del self.next_timers[:]\n        finally:\n            self.running = False\n            self.stopping = False\n", "docstring": "Run the runloop until abort is called."}
{"repo": "eventlet-master/eventlet/hubs/hub.py", "original_string": "    def schedule_call_global(self, seconds, cb, *args, **kw):\n        \"\"\"Schedule a callable to be called after 'seconds' seconds have\n        elapsed. The timer will NOT be canceled if the current greenlet has\n        exited before the timer fires.\n            seconds: The number of seconds to wait.\n            cb: The callable to call after the given time.\n            *args: Arguments to pass to the callable when called.\n            **kw: Keyword arguments to pass to the callable when called.\n        \"\"\"\n        t = timer.Timer(seconds, cb, *args, **kw)\n        self.add_timer(t)\n        return t\n", "docstring": "Schedule a callable to be called after 'seconds' seconds have"}
{"repo": "eventlet-master/eventlet/hubs/__init__.py", "original_string": "def get_default_hub():\n    \"\"\"Select the default hub implementation based on what multiplexing\n    libraries are installed.  The order that the hubs are tried is:\n    * epoll\n    * kqueue\n    * poll\n    * select\n    It won't automatically select the pyevent hub, because it's not\n    python-thread-safe.\n    .. include:: ../doc/common.txt\n    .. note :: |internal|\n    \"\"\"\n    for mod in builtin_hub_modules:\n        if mod.is_available():\n            return mod\n    raise HubError('no built-in hubs are available: {}'.format(builtin_hub_modules))\n", "docstring": "Select the default hub implementation based on what multiplexing"}
{"repo": "eventlet-master/eventlet/hubs/__init__.py", "original_string": "def get_hub():\n    \"\"\"Get the current event hub singleton object.\n    .. note :: |internal|\n    \"\"\"\n    try:\n        hub = _threadlocal.hub\n    except AttributeError:\n        try:\n            _threadlocal.Hub\n        except AttributeError:\n            use_hub()\n        hub = _threadlocal.hub = _threadlocal.Hub()\n    return hub\n", "docstring": "Get the current event hub singleton object."}
{"repo": "eventlet-master/eventlet/hubs/timer.py", "original_string": "    def __init__(self, seconds, cb, *args, **kw):\n        \"\"\"Create a timer.\n            seconds: The minimum number of seconds to wait before calling\n            cb: The callback to call when the timer has expired\n            *args: The arguments to pass to cb\n            **kw: The keyword arguments to pass to cb\n        This timer will not be run unless it is scheduled in a runloop by\n        calling timer.schedule() or runloop.add_timer(timer).\n        \"\"\"\n        self.seconds = seconds\n        self.tpl = cb, args, kw\n        self.called = False\n        if _g_debug:\n            self.traceback = six.StringIO()\n            traceback.print_stack(file=self.traceback)\n", "docstring": "Create a timer."}
{"repo": "eventlet-master/eventlet/greenio/base.py", "original_string": "    def __init__(self, family=socket.AF_INET, *args, **kwargs):\n        should_set_nonblocking = kwargs.pop('set_nonblocking', True)\n        if isinstance(family, six.integer_types):\n            fd = _original_socket(family, *args, **kwargs)\n            # Notify the hub that this is a newly-opened socket.\n            notify_opened(fd.fileno())\n        else:\n            fd = family\n        # import timeout from other socket, if it was there\n        try:\n            self._timeout = fd.gettimeout() or socket.getdefaulttimeout()\n        except AttributeError:\n            self._timeout = socket.getdefaulttimeout()\n        # Filter fd.fileno() != -1 so that won't call set non-blocking on\n        # closed socket\n        if should_set_nonblocking and fd.fileno() != -1:\n            set_nonblocking(fd)\n        self.fd = fd\n        # when client calls setblocking(0) or settimeout(0) the socket must\n        # act non-blocking\n        self.act_non_blocking = False\n        # Copy some attributes from underlying real socket.\n        # This is the easiest way that i found to fix\n        # https://bitbucket.org/eventlet/eventlet/issue/136\n        # Only `getsockopt` is required to fix that issue, others\n        # are just premature optimization to save __getattr__ call.\n        self.bind = fd.bind\n        self.close = fd.close\n        self.fileno = fd.fileno\n        self.getsockname = fd.getsockname\n        self.getsockopt = fd.getsockopt\n        self.listen = fd.listen\n        self.setsockopt = fd.setsockopt\n        self.shutdown = fd.shutdown\n        self._closed = False\n", "docstring": "should_set_nonblocking = kwargs.pop('set_nonblocking', True)"}
{"repo": "eventlet-master/eventlet/greenio/base.py", "original_string": "    def __del__(self):\n        # This is in case self.close is not assigned yet (currently the constructor does it)\n        close = getattr(self, 'close', None)\n        if close is not None:\n            close()\n", "docstring": "This is in case self.close is not assigned yet (currently the constructor does it)"}
{"repo": "eventlet-master/eventlet/greenio/py3.py", "original_string": "    def _mark_as_closed(self):\n        \"\"\" Mark this socket as being closed \"\"\"\n        self._closed = True\n", "docstring": "Mark this socket as being closed \n"}
{"repo": "eventlet-master/eventlet/support/psycopg2_patcher.py", "original_string": "def make_psycopg_green():\n    \"\"\"Configure Psycopg to be used with eventlet in non-blocking way.\"\"\"\n    if not hasattr(extensions, 'set_wait_callback'):\n        raise ImportError(\n            \"support for coroutines not available in this Psycopg version (%s)\"\n            % psycopg2.__version__)\n    extensions.set_wait_callback(eventlet_wait_callback)\n", "docstring": "Configure Psycopg to be used with eventlet in non-blocking way.\n"}
{"repo": "eventlet-master/eventlet/support/greendns.py", "original_string": "def import_patched(module_name):\n    # Import cycle note: it's crucial to use _socket_nodns here because\n    # regular evenlet.green.socket imports *this* module and if we imported\n    # it back we'd end with an import cycle (socket -> greendns -> socket).\n    # We break this import cycle by providing a restricted socket module.\n    modules = {\n        'select': select,\n        'time': time,\n        'os': os,\n        'socket': _socket_nodns,\n        'ssl': ssl,\n    }\n    return patcher.import_patched(module_name, **modules)\n", "docstring": "Import cycle note: it's crucial to use _socket_nodns here because"}
{"repo": "eventlet-master/eventlet/support/greendns.py", "original_string": "def is_ipv4_addr(host):\n    \"\"\"Return True if host is a valid IPv4 address\"\"\"\n    if not isinstance(host, six.string_types):\n        return False\n    try:\n        dns.ipv4.inet_aton(host)\n    except dns.exception.SyntaxError:\n        return False\n    else:\n        return True\n", "docstring": "Return True if host is a valid IPv4 address\n"}
{"repo": "eventlet-master/eventlet/support/greendns.py", "original_string": "def is_ip_addr(host):\n    \"\"\"Return True if host is a valid IPv4 or IPv6 address\"\"\"\n    return is_ipv4_addr(host) or is_ipv6_addr(host)\n", "docstring": "Return True if host is a valid IPv4 or IPv6 address\n"}
{"repo": "eventlet-master/eventlet/support/greendns.py", "original_string": "    def __init__(self, qname, rdtype, rdclass, rrset, raise_on_no_answer=True):\n        \"\"\"Create a new answer\n        :qname: A dns.name.Name instance of the query name\n        :rdtype: The rdatatype of the query\n        :rdclass: The rdataclass of the query\n        :rrset: The dns.rrset.RRset with the response, must have ttl attribute\n        :raise_on_no_answer: Whether to raise dns.resolver.NoAnswer if no\n           answer.\n        \"\"\"\n        self.response = None\n        self.qname = qname\n        self.rdtype = rdtype\n        self.rdclass = rdclass\n        self.canonical_name = qname\n        if not rrset and raise_on_no_answer:\n            raise dns.resolver.NoAnswer()\n        self.rrset = rrset\n        self.expiration = (time.time() +\n                           rrset.ttl if hasattr(rrset, 'ttl') else 0)\n", "docstring": "Create a new answer"}
{"repo": "eventlet-master/eventlet/support/greendns.py", "original_string": "    def _load(self):\n        \"\"\"Load hosts file\n        This will unconditionally (re)load the data from the hosts\n        file.\n        \"\"\"\n        lines = self._readlines()\n        self._v4.clear()\n        self._v6.clear()\n        self._aliases.clear()\n        for line in lines:\n            parts = line.split()\n            if len(parts) < 2:\n                continue\n            ip = parts.pop(0)\n            if is_ipv4_addr(ip):\n                ipmap = self._v4\n            elif is_ipv6_addr(ip):\n                if ip.startswith('fe80'):\n                    # Do not use link-local addresses, OSX stores these here\n                    continue\n                ipmap = self._v6\n            else:\n                continue\n            cname = parts.pop(0).lower()\n            ipmap[cname] = ip\n            for alias in parts:\n                alias = alias.lower()\n                ipmap[alias] = ip\n                self._aliases[alias] = cname\n        self._last_load = time.time()\n", "docstring": "Load hosts file"}
{"repo": "eventlet-master/eventlet/support/greendns.py", "original_string": "    def getaliases(self, hostname):\n        \"\"\"Return a list of all the aliases of a given cname\"\"\"\n        # Due to the way store aliases this is a bit inefficient, this\n        # clearly was an afterthought.  But this is only used by\n        # gethostbyname_ex so it's probably fine.\n        aliases = []\n        if hostname in self._aliases:\n            cannon = self._aliases[hostname]\n        else:\n            cannon = hostname\n        aliases.append(cannon)\n        for alias, cname in six.iteritems(self._aliases):\n            if cannon == cname:\n                aliases.append(alias)\n        aliases.remove(hostname)\n        return aliases\n", "docstring": "Return a list of all the aliases of a given cname\n"}
{"repo": "eventlet-master/eventlet/support/greendns.py", "original_string": "    def __init__(self, hosts_resolver=None, filename='/etc/resolv.conf'):\n        \"\"\"Initialise the resolver proxy\n        :param hosts_resolver: An instance of HostsResolver to use.\n        :param filename: The filename containing the resolver\n           configuration.  The default value is correct for both UNIX\n           and Windows, on Windows it will result in the configuration\n           being read from the Windows registry.\n        \"\"\"\n        self._hosts = hosts_resolver\n        self._filename = filename\n        self.clear()\n", "docstring": "Initialise the resolver proxy"}
{"repo": "eventlet-master/eventlet/support/greendns.py", "original_string": "def getaliases(host):\n    \"\"\"Return a list of for aliases for the given hostname\n    This method does translate the dnspython exceptions into\n    socket.gaierror exceptions.  If no aliases are available an empty\n    list will be returned.\n    \"\"\"\n    try:\n        return resolver.getaliases(host)\n    except dns.exception.Timeout:\n        raise EAI_EAGAIN_ERROR\n    except dns.exception.DNSException:\n        raise EAI_NODATA_ERROR\n", "docstring": "Return a list of for aliases for the given hostname"}
{"repo": "eventlet-master/eventlet/support/greendns.py", "original_string": "def getaddrinfo(host, port, family=0, socktype=0, proto=0, flags=0):\n    \"\"\"Replacement for Python's socket.getaddrinfo\n    This does the A and AAAA lookups asynchronously after which it\n    calls the OS' getaddrinfo(3) using the AI_NUMERICHOST flag.  This\n    flag ensures getaddrinfo(3) does not use the network itself and\n    allows us to respect all the other arguments like the native OS.\n    \"\"\"\n    if isinstance(host, six.string_types):\n        host = host.encode('idna').decode('ascii')\n    if host is not None and not is_ip_addr(host):\n        qname, addrs = _getaddrinfo_lookup(host, family, flags)\n    else:\n        qname = host\n        addrs = [host]\n    aiflags = (flags | socket.AI_NUMERICHOST) & (0xffff ^ socket.AI_CANONNAME)\n    res = []\n    err = None\n    for addr in addrs:\n        try:\n            ai = socket.getaddrinfo(addr, port, family,\n                                    socktype, proto, aiflags)\n        except socket.error as e:\n            if flags & socket.AI_ADDRCONFIG:\n                err = e\n                continue\n            raise\n        res.extend(ai)\n    if not res:\n        if err:\n            raise err\n        raise socket.gaierror(socket.EAI_NONAME, 'No address found')\n    if flags & socket.AI_CANONNAME:\n        if not is_ip_addr(qname):\n            qname = resolve_cname(qname).encode('ascii').decode('idna')\n        ai = res[0]\n        res[0] = (ai[0], ai[1], ai[2], qname, ai[4])\n    return res\n", "docstring": "Replacement for Python's socket.getaddrinfo"}
{"repo": "eventlet-master/eventlet/support/greendns.py", "original_string": "def gethostbyname_ex(hostname):\n    \"\"\"Replacement for Python's socket.gethostbyname_ex\"\"\"\n    if is_ipv4_addr(hostname):\n        return (hostname, [], [hostname])\n    ans = resolve(hostname)\n    aliases = getaliases(hostname)\n    addrs = [rr.address for rr in ans.rrset]\n    qname = str(ans.qname)\n    if qname[-1] == '.':\n        qname = qname[:-1]\n    return (qname, aliases, addrs)\n", "docstring": "Replacement for Python's socket.gethostbyname_ex\n"}
{"repo": "eventlet-master/eventlet/support/greendns.py", "original_string": "def _net_read(sock, count, expiration):\n    \"\"\"coro friendly replacement for dns.query._net_read\n    Read the specified number of bytes from sock.  Keep trying until we\n    either get the desired amount, or we hit EOF.\n    A Timeout exception will be raised if the operation is not completed\n    by the expiration time.\n    \"\"\"\n    s = bytearray()\n    while count > 0:\n        try:\n            n = sock.recv(count)\n        except socket.timeout:\n            # Q: Do we also need to catch coro.CoroutineSocketWake and pass?\n            if expiration - time.time() <= 0.0:\n                raise dns.exception.Timeout\n            eventlet.sleep(0.01)\n            continue\n        if n == b'':\n            raise EOFError\n        count = count - len(n)\n        s += n\n    return s\n", "docstring": "coro friendly replacement for dns.query._net_read"}
{"repo": "eventlet-master/eventlet/support/__init__.py", "original_string": "def get_errno(exc):\n    \"\"\" Get the error code out of socket.error objects.\n    socket.error in <2.5 does not have errno attribute\n    socket.error in 3.x does not allow indexing access\n    e.args[0] works for all.\n    There are cases when args[0] is not errno.\n    i.e. http://bugs.python.org/issue6471\n    Maybe there are cases when errno is set, but it is not the first argument?\n    \"\"\"\n    try:\n        if exc.errno is not None:\n            return exc.errno\n    except AttributeError:\n        pass\n    try:\n        return exc.args[0]\n    except IndexError:\n        return None\n", "docstring": "Get the error code out of socket.error objects."}
{"repo": "eventlet-master/eventlet/support/__init__.py", "original_string": "    def clear_sys_exc_info():\n        \"\"\"No-op In py3k.\n        Exception information is not visible outside of except statements.\n        sys.exc_clear became obsolete and removed.\"\"\"\n        pass\n", "docstring": "No-op In py3k."}
{"repo": "eventlet-master/eventlet/zipkin/greenthread.py", "original_string": "def _patched__init(self, parent):\n    # parent thread saves current TraceData from tls to self\n    if api.is_tracing():\n        self.trace_data = api.get_trace_data()\n    __original_init__(self, parent)\n", "docstring": "parent thread saves current TraceData from tls to self"}
{"repo": "eventlet-master/eventlet/zipkin/client.py", "original_string": "    def _build_message(self, thrift_obj):\n        trans = TTransport.TMemoryBuffer()\n        protocol = TBinaryProtocol.TBinaryProtocolAccelerated(trans=trans)\n        thrift_obj.write(protocol)\n        return base64.b64encode(trans.getvalue())\n", "docstring": "trans = TTransport.TMemoryBuffer()"}
{"repo": "eventlet-master/eventlet/zipkin/api.py", "original_string": "def put_annotation(msg, endpoint=None):\n    \"\"\" This is annotation API.\n    You can add your own annotation from in your code.\n    Annotation is recorded with timestamp automatically.\n    e.g.) put_annotation('cache hit for %s' % request)\n    :param msg: String message\n    :param endpoint: host info\n    \"\"\"\n    if is_sample():\n        a = ZipkinDataBuilder.build_annotation(msg, endpoint)\n        trace_data = get_trace_data()\n        trace_data.add_annotation(a)\n", "docstring": "This is annotation API."}
{"repo": "eventlet-master/eventlet/zipkin/api.py", "original_string": "def is_tracing():\n    \"\"\" Return whether the current thread is tracking or not \"\"\"\n    return hasattr(_tls, 'trace_data')\n", "docstring": "Return whether the current thread is tracking or not \n"}
{"repo": "eventlet-master/eventlet/zipkin/api.py", "original_string": "    def add_binary_annotation(self, bannotation):\n        if bannotation.host is None:\n            bannotation.host = self.endpoint\n        if not self._done:\n            self.bannotations.append(bannotation)\n", "docstring": "if bannotation.host is None:"}
{"repo": "eventlet-master/benchmarks/__init__.py", "original_string": "    def format_result(self, name_pad_to=64):\n        # format compatible with golang.org/x/tools/cmd/benchcmp\n        return \"Benchmark_{b.name}{pad}\\t{b.iters}\\t{b.ns_per_op} ns/op\".format(\n            b=self, pad=' ' * (name_pad_to + 1 - len(self.name)))\n", "docstring": "format compatible with golang.org/x/tools/cmd/benchcmp"}
{"repo": "eventlet-master/benchmarks/__init__.py", "original_string": "def _run_timeit(func, number):\n    # common setup\n    gc.collect()\n    manager = getattr(func, '_benchmark_manager', None)\n    try:\n        # TODO collect allocations count, memory usage\n        # TODO collect custom MB/sec metric reported by benchmark\n        if manager is not None:\n            with manager(number) as ctx:\n                return timeit.Timer(lambda: func(ctx)).timeit(number=number)\n        else:\n            return timeit.Timer(func).timeit(number=number)\n    finally:\n        # common cleanup\n        eventlet.sleep(0.01)\n", "docstring": "common setup"}
{"repo": "eventlet-master/benchmarks/__init__.py", "original_string": "def collect(filter_fun):\n    # running `python benchmarks/__init__.py` or `python -m benchmarks`\n    # puts .../eventlet/benchmarks at top of sys.path, fix it to project root\n    if sys.path[0].endswith('/benchmarks'):\n        path = sys.path.pop(0)\n        correct = path.rsplit('/', 1)[0]\n        sys.path.insert(0, correct)\n    common_prefix = 'benchmark_'\n    result = []\n    # TODO step 1: put all toplevel benchmarking code under `if __name__ == '__main__'`\n    # TODO step 2: auto import benchmarks/*.py, remove whitelist below\n    # TODO step 3: convert existing benchmarks\n    for name in ('hub_timers', 'spawn'):\n        mod = importlib.import_module('benchmarks.' + name)\n        for name, obj in inspect.getmembers(mod):\n            if name.startswith(common_prefix) and inspect.isfunction(obj):\n                useful_name = name[len(common_prefix):]\n                if filter_fun(useful_name):\n                    result.append(Benchmark(name=useful_name, func=obj))\n    return result\n", "docstring": "running `python benchmarks/__init__.py` or `python -m benchmarks`"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "def _is_instance_mock(obj):\n    # can't use isinstance on Mock objects because they override __class__\n    # The base class for all mocks is NonCallableMock\n    return issubclass(type(obj), NonCallableMock)\n", "docstring": "can't use isinstance on Mock objects because they override __class__"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "def _is_list(obj):\n    # checks for list or tuples\n    # XXXX badly named!\n    return type(obj) in (list, tuple)\n", "docstring": "checks for list or tuples"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "def _set_signature(mock, original, instance=False):\n    # creates a function with signature (*args, **kwargs) that delegates to a\n    # mock. It still does signature checking by calling a lambda with the same\n    # signature as the original.\n    if not _callable(original):\n        return\n    skipfirst = isinstance(original, ClassTypes)\n    result = _getsignature(original, skipfirst, instance)\n    if result is None:\n        # was a C function (e.g. object().__init__ ) that can't be mocked\n        return\n    signature, func = result\n    src = \"lambda %s: None\" % signature\n    checksig = eval(src, {})\n    _copy_func_details(func, checksig)\n    name = original.__name__\n    if not _isidentifier(name):\n        name = 'funcopy'\n    context = {'_checksig_': checksig, 'mock': mock}\n    src = \"\"\"def %s(*args, **kwargs):\n    _checksig_(*args, **kwargs)\n    return mock(*args, **kwargs)\"\"\" % name\n    exec(src, context)\n    funcopy = context[name]\n    _setup_func(funcopy, mock)\n    return funcopy\n", "docstring": "creates a function with signature (*args, **kwargs) that delegates to a"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "    def __new__(cls, *args, **kw):\n        # every instance has its own class\n        # so we can create magic methods on the\n        # class without stomping on other mocks\n        new = type(cls.__name__, (cls,), {'__doc__': cls.__doc__})\n        instance = object.__new__(new)\n        return instance\n", "docstring": "every instance has its own class"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "    def _mock_add_spec(self, spec, spec_set):\n        _spec_class = None\n        if spec is not None and not _is_list(spec):\n            if isinstance(spec, ClassTypes):\n                _spec_class = spec\n            else:\n                _spec_class = _get_class(spec)\n            spec = dir(spec)\n        __dict__ = self.__dict__\n        __dict__['_spec_class'] = _spec_class\n        __dict__['_spec_set'] = spec_set\n        __dict__['_mock_methods'] = spec\n", "docstring": "_spec_class = None"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "    def __dir__(self):\n        \"\"\"Filter the output of `dir(mock)` to only useful members.\"\"\"\n        extras = self._mock_methods or []\n        from_type = dir(type(self))\n        from_dict = list(self.__dict__)\n        if FILTER_DIR:\n            from_type = [e for e in from_type if not e.startswith('_')]\n            from_dict = [e for e in from_dict if not e.startswith('_') or\n                         _is_magic(e)]\n        return sorted(set(extras + from_type + from_dict +\n                          list(self._mock_children)))\n", "docstring": "Filter the output of `dir(mock)` to only useful members.\n"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "    def assert_called_once_with(_mock_self, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and with the specified\n        arguments.\"\"\"\n        self = _mock_self\n        if not self.call_count == 1:\n            msg = (\"Expected to be called once. Called %s times.\" %\n                   self.call_count)\n            raise AssertionError(msg)\n        return self.assert_called_with(*args, **kwargs)\n", "docstring": "assert that the mock was called exactly once and with the specified"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "    def assert_any_call(self, *args, **kwargs):\n        \"\"\"assert the mock has been called with the specified arguments.\n        The assert passes if the mock has *ever* been called, unlike\n        `assert_called_with` and `assert_called_once_with` that only pass if\n        the call is the most recent one.\"\"\"\n        kall = call(*args, **kwargs)\n        if kall not in self.call_args_list:\n            expected_string = self._format_mock_call_signature(args, kwargs)\n            raise AssertionError(\n                '%s call not found' % expected_string\n            )\n", "docstring": "assert the mock has been called with the specified arguments."}
{"repo": "eventlet-master/tests/mock.py", "original_string": "    def __call__(_mock_self, *args, **kwargs):\n        # can't use self in-case a function / method we are mocking uses self\n        # in the signature\n        _mock_self._mock_check_sig(*args, **kwargs)\n        return _mock_self._mock_call(*args, **kwargs)\n", "docstring": "can't use self in-case a function / method we are mocking uses self"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "def _is_started(patcher):\n    # XXXX horrible\n    return hasattr(patcher, 'is_local')\n", "docstring": "XXXX horrible"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "        def patched(*args, **keywargs):\n            # don't use a with here (backwards compatibility with Python 2.4)\n            extra_args = []\n            entered_patchers = []\n            # can't use try...except...finally because of Python 2.4\n            # compatibility\n            exc_info = tuple()\n            try:\n                try:\n                    for patching in patched.patchings:\n                        arg = patching.__enter__()\n                        entered_patchers.append(patching)\n                        if patching.attribute_name is not None:\n                            keywargs.update(arg)\n                        elif patching.new is DEFAULT:\n                            extra_args.append(arg)\n                    args += tuple(extra_args)\n                    return func(*args, **keywargs)\n                except:\n                    if (patching not in entered_patchers and\n                            _is_started(patching)):\n                        # the patcher may have been started, but an exception\n                        # raised whilst entering one of its additional_patchers\n                        entered_patchers.append(patching)\n                    # Pass the exception to __exit__\n                    exc_info = sys.exc_info()\n                    # re-raise the exception\n                    raise\n            finally:\n                for patching in reversed(entered_patchers):\n                    patching.__exit__(*exc_info)\n", "docstring": "don't use a with here (backwards compatibility with Python 2.4)"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "    def __exit__(self, *exc_info):\n        \"\"\"Undo the patch.\"\"\"\n        if not _is_started(self):\n            raise RuntimeError('stop called on unstarted patcher')\n        if self.is_local and self.temp_original is not DEFAULT:\n            setattr(self.target, self.attribute, self.temp_original)\n        else:\n            delattr(self.target, self.attribute)\n            if not self.create and not hasattr(self.target, self.attribute):\n                # needed for proxy objects like django settings\n                setattr(self.target, self.attribute, self.temp_original)\n        del self.temp_original\n        del self.is_local\n        del self.target\n        for patcher in reversed(self.additional_patchers):\n            if _is_started(patcher):\n                patcher.__exit__(*exc_info)\n", "docstring": "Undo the patch.\n"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "    def stop(self):\n        \"\"\"Stop an active patch.\"\"\"\n        self._active_patches.discard(self)\n        return self.__exit__()\n", "docstring": "Stop an active patch.\n"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "    def __exit__(self, *args):\n        \"\"\"Unpatch the dict.\"\"\"\n        self._unpatch_dict()\n        return False\n", "docstring": "Unpatch the dict.\n"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "    def mock_add_spec(self, spec, spec_set=False):\n        \"\"\"Add a spec to a mock. `spec` can either be an object or a\n        list of strings. Only attributes on the `spec` can be fetched as\n        attributes from the mock.\n        If `spec_set` is True then only attributes on the spec can be set.\"\"\"\n        self._mock_add_spec(spec, spec_set)\n        self._mock_set_magics()\n", "docstring": "Add a spec to a mock. `spec` can either be an object or a"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "    def mock_add_spec(self, spec, spec_set=False):\n        \"\"\"Add a spec to a mock. `spec` can either be an object or a\n        list of strings. Only attributes on the `spec` can be fetched as\n        attributes from the mock.\n        If `spec_set` is True then only attributes on the spec can be set.\"\"\"\n        self._mock_add_spec(spec, spec_set)\n        self._mock_set_magics()\n", "docstring": "Add a spec to a mock. `spec` can either be an object or a"}
{"repo": "eventlet-master/tests/mock.py", "original_string": "    def _get_child_mock(self, **kwargs):\n        return MagicMock(**kwargs)\n", "docstring": "return MagicMock(**kwargs)"}
{"repo": "eventlet-master/tests/timeout_test.py", "original_string": "    def test_repr(self):\n        # just verify these don't crash\n        tm = eventlet.Timeout(1)\n        eventlet.sleep(0)\n        repr(tm)\n        str(tm)\n        tm.cancel()\n        tm = eventlet.Timeout(None, RuntimeError)\n        repr(tm)\n        str(tm)\n        tm = eventlet.Timeout(None, False)\n        repr(tm)\n        str(tm)\n", "docstring": "just verify these don't crash"}
{"repo": "eventlet-master/tests/timeout_test.py", "original_string": "        def longer_timeout():\n            # this should not catch the outer timeout's exception\n            return eventlet.with_timeout(DELAY * 10, eventlet.sleep, DELAY * 20, timeout_value='b')\n", "docstring": "this should not catch the outer timeout's exception"}
{"repo": "eventlet-master/tests/greenio_test.py", "original_string": "def bufsized(sock, size=1):\n    \"\"\" Resize both send and receive buffers on a socket.\n    Useful for testing trampoline.  Returns the socket.\n    >>> import socket\n    >>> sock = bufsized(socket.socket(socket.AF_INET, socket.SOCK_STREAM))\n    \"\"\"\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, size)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, size)\n    return sock\n", "docstring": "Resize both send and receive buffers on a socket."}
{"repo": "eventlet-master/tests/greenio_test.py", "original_string": "def min_buf_size():\n    \"\"\"Return the minimum buffer size that the platform supports.\"\"\"\n    test_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    test_sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 1)\n    return test_sock.getsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF)\n", "docstring": "Return the minimum buffer size that the platform supports.\n"}
{"repo": "eventlet-master/tests/greenio_test.py", "original_string": "        def server():\n            # accept the connection in another greenlet\n            sock, addr = listener.accept()\n            evt.wait()\n", "docstring": "accept the connection in another greenlet"}
{"repo": "eventlet-master/tests/greenio_test.py", "original_string": "        def server():\n            # accept the connection in another greenlet\n            sock, addr = listener.accept()\n            evt.wait()\n", "docstring": "accept the connection in another greenlet"}
{"repo": "eventlet-master/tests/greenio_test.py", "original_string": "        def accept_once(listener):\n            # delete/overwrite the original conn\n            # object, only keeping the file object around\n            # closing the file object should close everything\n            try:\n                conn, addr = listener.accept()\n                conn = conn.makefile('wb')\n                conn.write(b'hello\\n')\n                conn.close()\n                gc.collect()\n                self.assertWriteToClosedFileRaises(conn)\n            finally:\n                listener.close()\n", "docstring": "delete/overwrite the original conn"}
{"repo": "eventlet-master/tests/greenio_test.py", "original_string": "            def connect_once(listener):\n                # delete/overwrite the original conn\n                # object, only keeping the file object around\n                # closing the file object should close everything\n                client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                client.connect(('127.0.0.1', listener.getsockname()[1]))\n                client.close()\n", "docstring": "delete/overwrite the original conn"}
{"repo": "eventlet-master/tests/greenio_test.py", "original_string": "    def test_pip_read_until_end(self):\n        # similar to test_pip_read above but reading until eof\n        r, w = os.pipe()\n        r = greenio.GreenPipe(r, 'rb')\n        w = greenio.GreenPipe(w, 'wb')\n        w.write(b'c' * DEFAULT_BUFFER_SIZE * 2)\n        w.close()\n        buf = r.read()  # no chunk size specified; read until end\n        self.assertEqual(len(buf), 2 * DEFAULT_BUFFER_SIZE)\n        self.assertEqual(buf[:3], b'ccc')\n", "docstring": "similar to test_pip_read above but reading until eof"}
{"repo": "eventlet-master/tests/greenio_test.py", "original_string": "def test_socket_del_fails_gracefully_when_not_fully_initialized():\n    # Regression introduced in da87716714689894f23d0db7b003f26d97031e83, reported in:\n    # * GH #137 https://github.com/eventlet/eventlet/issues/137\n    # * https://bugs.launchpad.net/oslo.messaging/+bug/1369999\n    class SocketSubclass(socket.socket):\n        def __init__(self):\n            pass\n    with tests.capture_stderr() as err:\n        SocketSubclass()\n    assert err.getvalue() == ''\n", "docstring": "Regression introduced in da87716714689894f23d0db7b003f26d97031e83, reported in:"}
{"repo": "eventlet-master/tests/greenio_test.py", "original_string": "def test_partial_write_295():\n    # https://github.com/eventlet/eventlet/issues/295\n    # `socket.makefile('w').writelines()` must send all\n    # despite partial writes by underlying socket\n    listen_socket = eventlet.listen(('localhost', 0))\n    original_accept = listen_socket.accept\n    def talk(conn):\n        f = conn.makefile('wb')\n        line = b'*' * 2140\n        f.writelines([line] * 10000)\n        conn.close()\n    def accept():\n        connection, address = original_accept()\n        original_send = connection.send\n        def slow_send(b, *args):\n            b = b[:1031]\n            return original_send(b, *args)\n        connection.send = slow_send\n        eventlet.spawn(talk, connection)\n        return connection, address\n    listen_socket.accept = accept\n    eventlet.spawn(listen_socket.accept)\n    sock = eventlet.connect(listen_socket.getsockname())\n    with eventlet.Timeout(10):\n        bs = sock.makefile('rb').read()\n    assert len(bs) == 21400000\n    assert bs == (b'*' * 21400000)\n", "docstring": "https://github.com/eventlet/eventlet/issues/295"}
{"repo": "eventlet-master/tests/websocket_test.py", "original_string": "    def test_query_string(self):\n        # verify that the query string comes out the other side unscathed\n        connect = [\n            \"GET /echo?query_string HTTP/1.1\",\n            \"Upgrade: WebSocket\",\n            \"Connection: Upgrade\",\n            \"Host: %s:%s\" % self.server_addr,\n            \"Origin: http://%s:%s\" % self.server_addr,\n            \"Sec-WebSocket-Protocol: ws\",\n            \"Sec-WebSocket-Key1: 4 @1  46546xW%0l 1 5\",\n            \"Sec-WebSocket-Key2: 12998 5 Y3 1  .P00\",\n        ]\n        sock = eventlet.connect(self.server_addr)\n        sock.sendall(six.b('\\r\\n'.join(connect) + '\\r\\n\\r\\n^n:ds[4U'))\n        result = sock.recv(1024)\n        self.assertEqual(result, six.b('\\r\\n'.join([\n            'HTTP/1.1 101 WebSocket Protocol Handshake',\n            'Upgrade: WebSocket',\n            'Connection: Upgrade',\n            'Sec-WebSocket-Origin: http://%s:%s' % self.server_addr,\n            'Sec-WebSocket-Protocol: ws',\n            'Sec-WebSocket-Location: '\n            'ws://%s:%s/echo?query_string\\r\\n\\r\\n8jKS\\'y:G*Co,Wxa-' % self.server_addr,\n        ])))\n", "docstring": "verify that the query string comes out the other side unscathed"}
{"repo": "eventlet-master/tests/greendns_test.py", "original_string": "def _make_host_resolver():\n    \"\"\"Returns a HostResolver instance\n    The hosts file will be empty but accessible as a py.path.local\n    instance using the ``hosts`` attribute.\n    \"\"\"\n    hosts = tempfile.NamedTemporaryFile()\n    hr = greendns.HostsResolver(fname=hosts.name)\n    hr.hosts = hosts\n    hr._last_stat = 0\n    return hr\n", "docstring": "Returns a HostResolver instance"}
{"repo": "eventlet-master/tests/greendns_test.py", "original_string": "    def setUp(self):\n        # Store this so we can reuse it for each test\n        self.query = greendns.dns.message.Message()\n        self.query.flags = greendns.dns.flags.QR\n        self.query_wire = self.query.to_wire()\n        super(TestUdp, self).setUp()\n", "docstring": "Store this so we can reuse it for each test"}
{"repo": "eventlet-master/tests/greendns_test.py", "original_string": "    def _make_mock_resolver(self):\n        \"\"\"A mocked Resolver\"\"\"\n        base_resolver = _make_mock_base_resolver()\n        base_resolver.rr.address = '5.6.7.8'\n        return base_resolver()\n", "docstring": "A mocked Resolver\n"}
{"repo": "eventlet-master/tests/greendns_test.py", "original_string": "def _make_mock_resolve():\n    \"\"\"A stubbed out resolve function\n    This monkeypatches the greendns.resolve() function with a mock.\n    You must give it answers by calling .add().\n    \"\"\"\n    class MockAnswer(list):\n        pass\n    class MockResolve(object):\n        def __init__(self):\n            self.answers = {}\n        def __call__(self, name, family=socket.AF_INET, raises=True,\n                     _proxy=None, use_network=True):\n            qname = dns.name.from_text(name)\n            try:\n                rrset = self.answers[name][family]\n            except KeyError:\n                if raises:\n                    raise greendns.dns.resolver.NoAnswer()\n                rrset = dns.rrset.RRset(qname, 1, 1)\n            ans = MockAnswer()\n            ans.qname = qname\n            ans.rrset = rrset\n            ans.extend(rrset.items)\n            return ans\n        def add(self, name, addr):\n            \"\"\"Add an address to a name and family\"\"\"\n            try:\n                rdata = dns.rdtypes.IN.A.A(dns.rdataclass.IN,\n                                           dns.rdatatype.A, addr)\n                family = socket.AF_INET\n            except (socket.error, dns.exception.SyntaxError):\n                rdata = dns.rdtypes.IN.AAAA.AAAA(dns.rdataclass.IN,\n                                                 dns.rdatatype.AAAA, addr)\n                family = socket.AF_INET6\n            family_dict = self.answers.setdefault(name, {})\n            rrset = family_dict.get(family)\n            if not rrset:\n                family_dict[family] = rrset = dns.rrset.RRset(\n                    dns.name.from_text(name), rdata.rdclass, rdata.rdtype)\n            rrset.add(rdata)\n    resolve = MockResolve()\n    return resolve\n", "docstring": "A stubbed out resolve function"}
{"repo": "eventlet-master/tests/greendns_test.py", "original_string": "    def _make_mock_resolve_cname(self):\n        \"\"\"A stubbed out cname function\"\"\"\n        class ResolveCname(object):\n            qname = None\n            cname = 'cname.example.com'\n            def __call__(self, host):\n                self.qname = host\n                return self.cname\n        resolve_cname = ResolveCname()\n        return resolve_cname\n", "docstring": "A stubbed out cname function\n"}
{"repo": "eventlet-master/tests/greendns_test.py", "original_string": "    def test_AI_ADDRCONFIG_noaddr(self):\n        # If AI_ADDRCONFIG is used but there is no address we need to\n        # get an exception, not an empty list.\n        def getaddrinfo(addr, port, family, socktype, proto, aiflags):\n            raise socket.error(socket.EAI_ADDRFAMILY,\n                               'Address family for hostname not supported')\n        greendns.socket.getaddrinfo = getaddrinfo\n        greendns.resolve = _make_mock_resolve()\n        try:\n            greendns.getaddrinfo('::1', None, 0, 0, 0, socket.AI_ADDRCONFIG)\n        except socket.error as e:\n            assert e.errno == socket.EAI_ADDRFAMILY\n", "docstring": "If AI_ADDRCONFIG is used but there is no address we need to"}
{"repo": "eventlet-master/tests/greendns_test.py", "original_string": "    def test_raise_dns_tcp(self):\n        # https://github.com/eventlet/eventlet/issues/499\n        # None means we don't want the server to find the IP\n        with tests.dns_tcp_server(None) as dnsaddr:\n            resolver = Resolver()\n            resolver.nameservers = [dnsaddr[0]]\n            resolver.nameserver_ports[dnsaddr[0]] = dnsaddr[1]\n            with self.assertRaises(NoAnswer):\n                resolver.query('host.example.com', 'a', tcp=True)\n", "docstring": "https://github.com/eventlet/eventlet/issues/499"}
{"repo": "eventlet-master/tests/db_pool_test.py", "original_string": "    def test_clear_warmup(self):\n        \"\"\"Clear implicitly created connections (min_size > 0)\"\"\"\n        self.pool = self.create_pool(min_size=1)\n        self.pool.clear()\n        self.assertEqual(len(self.pool.free_items), 0)\n", "docstring": "Clear implicitly created connections (min_size > 0)\n"}
{"repo": "eventlet-master/tests/db_pool_test.py", "original_string": "    def test_raising_create(self):\n        # if the create() method raises an exception the pool should\n        # not lose any connections\n        self.pool = self.create_pool(max_size=1, module=RaisingDBModule())\n        self.assertRaises(RuntimeError, self.pool.get)\n        self.assertEqual(self.pool.free(), 1)\n", "docstring": "if the create() method raises an exception the pool should"}
{"repo": "eventlet-master/tests/ssl_test.py", "original_string": "    def setUp(self):\n        # disabling socket.ssl warnings because we're testing it here\n        warnings.filterwarnings(\n            action='ignore',\n            message='.*socket.ssl.*',\n            category=DeprecationWarning)\n        super(SSLTest, self).setUp()\n", "docstring": "disabling socket.ssl warnings because we're testing it here"}
{"repo": "eventlet-master/tests/greenpool_test.py", "original_string": "    def test_timer_cancel(self):\n        # this test verifies that local timers are not fired\n        # outside of the context of the spawn\n        timer_fired = []\n        def fire_timer():\n            timer_fired.append(True)\n        def some_work():\n            hubs.get_hub().schedule_call_local(0, fire_timer)\n        pool = eventlet.GreenPool(2)\n        worker = pool.spawn(some_work)\n        worker.wait()\n        eventlet.sleep(0)\n        eventlet.sleep(0)\n        self.assertEqual(timer_fired, [])\n", "docstring": "this test verifies that local timers are not fired"}
{"repo": "eventlet-master/tests/greenpool_test.py", "original_string": "    def test_pool_smash(self):\n        # The premise is that a coroutine in a Pool tries to get a token out\n        # of a token pool but times out before getting the token.  We verify\n        # that neither pool is adversely affected by this situation.\n        pool = eventlet.GreenPool(1)\n        tp = pools.TokenPool(max_size=1)\n        tp.get()  # empty out the pool\n        def do_receive(tp):\n            timer = eventlet.Timeout(0, RuntimeError())\n            try:\n                tp.get()\n                self.fail(\"Shouldn't have received anything from the pool\")\n            except RuntimeError:\n                return 'timed out'\n            else:\n                timer.cancel()\n        # the spawn makes the token pool expect that coroutine, but then\n        # immediately cuts bait\n        e1 = pool.spawn(do_receive, tp)\n        self.assertEqual(e1.wait(), 'timed out')\n        # the pool can get some random item back\n        def send_wakeup(tp):\n            tp.put('wakeup')\n        gt = eventlet.spawn(send_wakeup, tp)\n        # now we ask the pool to run something else, which should not\n        # be affected by the previous send at all\n        def resume():\n            return 'resumed'\n        e2 = pool.spawn(resume)\n        self.assertEqual(e2.wait(), 'resumed')\n        # we should be able to get out the thing we put in there, too\n        self.assertEqual(tp.get(), 'wakeup')\n        gt.wait()\n", "docstring": "The premise is that a coroutine in a Pool tries to get a token out"}
{"repo": "eventlet-master/tests/greenpool_test.py", "original_string": "    def spawn_order_check(self, concurrency):\n        # checks that piles are strictly ordered\n        p = eventlet.GreenPile(concurrency)\n        def makework(count, unique):\n            for i in six.moves.range(count):\n                token = (unique, i)\n                p.spawn(pressure, token)\n        iters = 1000\n        eventlet.spawn(makework, iters, 1)\n        eventlet.spawn(makework, iters, 2)\n        eventlet.spawn(makework, iters, 3)\n        p.spawn(pressure, (0, 0))\n        latest = [-1] * 4\n        received = 0\n        it = iter(p)\n        while True:\n            try:\n                i = six.next(it)\n            except StressException as exc:\n                i = exc.args[0]\n            except StopIteration:\n                break\n            received += 1\n            if received % 5 == 0:\n                eventlet.sleep(0.0001)\n            unique, order = i\n            assert latest[unique] < order\n            latest[unique] = order\n        for l in latest[1:]:\n            self.assertEqual(l, iters - 1)\n", "docstring": "checks that piles are strictly ordered"}
{"repo": "eventlet-master/tests/api_test.py", "original_string": "def check_hub():\n    # Clear through the descriptor queue\n    eventlet.sleep(0)\n    eventlet.sleep(0)\n    hub = hubs.get_hub()\n    for nm in 'get_readers', 'get_writers':\n        dct = getattr(hub, nm)()\n        assert not dct, \"hub.%s not empty: %s\" % (nm, dct)\n    hub.abort(wait=True)\n    assert not hub.running\n", "docstring": "Clear through the descriptor queue"}
{"repo": "eventlet-master/tests/greenthread_test.py", "original_string": "    def test_link_relinks(self):\n        # test that linking in a linked func doesn't cause infinite recursion.\n        called = []\n        def link_func(g):\n            g.link(link_func_pass)\n        def link_func_pass(g):\n            called.append(True)\n        gt = greenthread.spawn(passthru)\n        gt.link(link_func)\n        gt.wait()\n        self.assertEqual(called, [True])\n", "docstring": "test that linking in a linked func doesn't cause infinite recursion."}
{"repo": "eventlet-master/tests/timeout_test_with_statement.py", "original_string": "    def test_cancellation(self):\n        # Nothing happens if with-block finishes before the timeout expires\n        t = Timeout(DELAY * 2)\n        sleep(0)  # make it pending\n        assert t.pending, repr(t)\n        with t:\n            assert t.pending, repr(t)\n            sleep(DELAY)\n        # check if timer was actually cancelled\n        assert not t.pending, repr(t)\n        sleep(DELAY * 2)\n", "docstring": "Nothing happens if with-block finishes before the timeout expires"}
{"repo": "eventlet-master/tests/timeout_test_with_statement.py", "original_string": "    def test_raising_self_true(self):\n        # specifying True as the exception raises self as well\n        try:\n            with Timeout(DELAY, True) as t:\n                sleep(DELAY * 2)\n        except Timeout as ex:\n            assert ex is t, (ex, t)\n        else:\n            raise AssertionError('must raise Timeout')\n", "docstring": "specifying True as the exception raises self as well"}
{"repo": "eventlet-master/tests/timeout_test_with_statement.py", "original_string": "    def test_raising_exception_class(self):\n        # Providing classes instead of values should be possible too:\n        try:\n            with Timeout(DELAY, ValueError):\n                sleep(DELAY * 2)\n        except ValueError:\n            pass\n", "docstring": "Providing classes instead of values should be possible too:"}
{"repo": "eventlet-master/tests/timeout_test_with_statement.py", "original_string": "    def test_cancel_timer_inside_block(self):\n        # It's possible to cancel the timer inside the block:\n        with Timeout(DELAY) as timer:\n            timer.cancel()\n            sleep(DELAY * 2)\n", "docstring": "It's possible to cancel the timer inside the block:"}
{"repo": "eventlet-master/tests/timeout_test_with_statement.py", "original_string": "    def test_dummy_timer(self):\n        # passing None as seconds disables the timer\n        with Timeout(None):\n            sleep(DELAY)\n        sleep(DELAY)\n", "docstring": "passing None as seconds disables the timer"}
{"repo": "eventlet-master/tests/websocket_new_test.py", "original_string": "    def test_large_frame_size_compressed_13(self):\n        # Test fix for GHSA-9p9m-jm8w-94p2\n        extensions_string = 'permessage-deflate'\n        extensions = {'permessage-deflate': {\n            'client_no_context_takeover': False,\n            'server_no_context_takeover': False}}\n        sock = eventlet.connect(self.server_addr)\n        sock.sendall(six.b(self.connect % extensions_string))\n        sock.recv(1024)\n        ws = websocket.RFC6455WebSocket(sock, {}, client=True, extensions=extensions)\n        should_still_fit = b\"x\" * TEST_MAX_FRAME_LENGTH\n        one_too_much = should_still_fit + b\"x\"\n        # send just fitting frame twice to make sure they are fine independently\n        ws.send(should_still_fit)\n        assert ws.wait() == should_still_fit\n        ws.send(should_still_fit)\n        assert ws.wait() == should_still_fit\n        ws.send(one_too_much)\n        res = ws.wait()\n        assert res is None # socket closed\n        # TODO: The websocket currently sents compressed control frames, which contradicts RFC7692.\n        # Renable the following assert after that has been fixed.\n        # assert ws._remote_close_data == b\"\\x03\\xf1Incoming compressed frame is above length limit.\"\n        eventlet.sleep(0.01)\n", "docstring": "Test fix for GHSA-9p9m-jm8w-94p2"}
{"repo": "eventlet-master/tests/zmq_test.py", "original_string": "    def test_close_linger(self):\n        \"\"\"Socket.close() must support linger argument.\n        https://github.com/eventlet/eventlet/issues/9\n        \"\"\"\n        sock1, sock2, _ = self.create_bound_pair(zmq.PAIR, zmq.PAIR)\n        sock1.close(1)\n        sock2.close(linger=0)\n", "docstring": "Socket.close() must support linger argument."}
{"repo": "eventlet-master/tests/zmq_test.py", "original_string": "    def test_change_subscription(self):\n        # FIXME: Extensive testing showed this particular test is the root cause\n        # of sporadic failures on Travis.\n        pub, sub, port = self.create_bound_pair(zmq.PUB, zmq.SUB)\n        sub.setsockopt(zmq.SUBSCRIBE, b'test')\n        eventlet.sleep(0)\n        sub_ready = eventlet.Event()\n        sub_last = eventlet.Event()\n        sub_done = eventlet.Event()\n        def rx():\n            while sub.recv() != b'test BEGIN':\n                eventlet.sleep(0)\n            sub_ready.send()\n            count = 0\n            while True:\n                msg = sub.recv()\n                if msg == b'test BEGIN':\n                    # BEGIN may come many times\n                    continue\n                if msg == b'test LAST':\n                    sub.setsockopt(zmq.SUBSCRIBE, b'done')\n                    sub.setsockopt(zmq.UNSUBSCRIBE, b'test')\n                    eventlet.sleep(0)\n                    # In real application you should either sync\n                    # or tolerate loss of messages.\n                    sub_last.send()\n                if msg == b'done DONE':\n                    break\n                count += 1\n            sub_done.send(count)\n        def tx():\n            # Sync receiver ready to avoid loss of first packets\n            while not sub_ready.ready():\n                pub.send(b'test BEGIN')\n                eventlet.sleep(0.005)\n            for i in range(1, 101):\n                msg = 'test {0}'.format(i).encode()\n                if i != 50:\n                    pub.send(msg)\n                else:\n                    pub.send(b'test LAST')\n                    sub_last.wait()\n                # XXX: putting a real delay of 1ms here fixes sporadic failures on Travis\n                # just yield eventlet.sleep(0) doesn't cut it\n                eventlet.sleep(0.001)\n            pub.send(b'done DONE')\n        eventlet.spawn(rx)\n        eventlet.spawn(tx)\n        rx_count = sub_done.wait()\n        self.assertEqual(rx_count, 50)\n", "docstring": "FIXME: Extensive testing showed this particular test is the root cause"}
{"repo": "eventlet-master/tests/zmq_test.py", "original_string": "    def test_cpu_usage_after_bind(self):\n        \"\"\"zmq eats CPU after PUB socket .bind()\n        https://bitbucket.org/eventlet/eventlet/issue/128\n        According to the ZeroMQ documentation, the socket file descriptor\n        can be readable without any pending messages. So we need to ensure\n        that Eventlet wraps around ZeroMQ sockets do not create busy loops.\n        A naive way to test it is to measure resource usage. This will require\n        some tuning to set appropriate acceptable limits.\n        \"\"\"\n        sock = self.context.socket(zmq.PUB)\n        self.sockets.append(sock)\n        sock.bind_to_random_port(\"tcp://127.0.0.1\")\n        eventlet.sleep()\n        tests.check_idle_cpu_usage(0.2, 0.1)\n", "docstring": "zmq eats CPU after PUB socket .bind()"}
{"repo": "eventlet-master/tests/zmq_test.py", "original_string": "    def test_cpu_usage_after_pub_send_or_dealer_recv(self):\n        \"\"\"zmq eats CPU after PUB send or DEALER recv.\n        Same https://bitbucket.org/eventlet/eventlet/issue/128\n        \"\"\"\n        pub, sub, _port = self.create_bound_pair(zmq.PUB, zmq.SUB)\n        sub.setsockopt(zmq.SUBSCRIBE, b\"\")\n        eventlet.sleep()\n        pub.send(b'test_send')\n        tests.check_idle_cpu_usage(0.2, 0.1)\n        sender, receiver, _port = self.create_bound_pair(zmq.DEALER, zmq.DEALER)\n        eventlet.sleep()\n        sender.send(b'test_recv')\n        msg = receiver.recv()\n        self.assertEqual(msg, b'test_recv')\n        tests.check_idle_cpu_usage(0.2, 0.1)\n", "docstring": "zmq eats CPU after PUB send or DEALER recv."}
{"repo": "eventlet-master/tests/zmq_test.py", "original_string": "def test_recv_json_no_args():\n    # https://github.com/eventlet/eventlet/issues/376\n    with clean_pair(zmq.REQ, zmq.REP) as (s1, s2, _):\n        eventlet.spawn(s1.send_json, {})\n        s2.recv_json()\n", "docstring": "https://github.com/eventlet/eventlet/issues/376"}
{"repo": "eventlet-master/tests/convenience_test.py", "original_string": "    def test_exiting_server(self):\n        # tests that the server closes the client sock on handle() exit\n        def closer(sock, addr):\n            pass\n        l = eventlet.listen(('localhost', 0))\n        gt = eventlet.spawn(eventlet.serve, l, closer)\n        client = eventlet.connect(('localhost', l.getsockname()[1]))\n        client.sendall(b'a')\n        self.assertFalse(client.recv(100))\n        gt.kill()\n", "docstring": "tests that the server closes the client sock on handle() exit"}
{"repo": "eventlet-master/tests/convenience_test.py", "original_string": "    def test_excepting_server_already_closed(self):\n        # same as above but with explicit clsoe before crash\n        def crasher(sock, addr):\n            sock.recv(1024)\n            sock.close()\n            0 // 0\n        l = eventlet.listen(('localhost', 0))\n        gt = eventlet.spawn(eventlet.serve, l, crasher)\n        client = eventlet.connect(('localhost', l.getsockname()[1]))\n        client.sendall(b'a')\n        self.assertRaises(ZeroDivisionError, gt.wait)\n        self.assertFalse(client.recv(100))\n", "docstring": "same as above but with explicit clsoe before crash"}
{"repo": "eventlet-master/tests/wsgi_test.py", "original_string": "def chunked_fail_app(environ, start_response):\n    \"\"\"http://rhodesmill.org/brandon/2013/chunked-wsgi/\n    \"\"\"\n    headers = [('Content-Type', 'text/plain')]\n    start_response('200 OK', headers)\n    # We start streaming data just fine.\n    yield b\"The dwarves of yore made mighty spells,\"\n    yield b\"While hammers fell like ringing bells\"\n    # Then the back-end fails!\n    try:\n        1 / 0\n    except Exception:\n        start_response('500 Error', headers, sys.exc_info())\n        return\n    # So rest of the response data is not available.\n    yield b\"In places deep, where dark things sleep,\"\n    yield b\"In hollow halls beneath the fells.\"\n", "docstring": "http://rhodesmill.org/brandon/2013/chunked-wsgi/"}
{"repo": "eventlet-master/tests/wsgi_test.py", "original_string": "def send_expect_close(sock, buf):\n    # Some tests will induce behavior that causes the remote end to\n    # close the connection before all of the data has been written.\n    # With small kernel buffer sizes, this can cause an EPIPE error.\n    # Since the test expects an early close, this can be ignored.\n    try:\n        sock.sendall(buf)\n    except socket.error as exc:\n        if support.get_errno(exc) != errno.EPIPE:\n            raise\n", "docstring": "Some tests will induce behavior that causes the remote end to"}
{"repo": "eventlet-master/tests/wsgi_test.py", "original_string": "    def spawn_server(self, **kwargs):\n        \"\"\"Spawns a new wsgi server with the given arguments using\n        :meth:`spawn_thread`.\n        Sets `self.server_addr` to (host, port) tuple suitable for `socket.connect`.\n        \"\"\"\n        self.logfile = six.StringIO()\n        new_kwargs = dict(max_size=128,\n                          log=self.logfile,\n                          site=self.site)\n        new_kwargs.update(kwargs)\n        if 'sock' not in new_kwargs:\n            new_kwargs['sock'] = eventlet.listen(('localhost', 0))\n        self.server_addr = new_kwargs['sock'].getsockname()\n        self.spawn_thread(wsgi.server, **new_kwargs)\n", "docstring": "Spawns a new wsgi server with the given arguments using"}
{"repo": "eventlet-master/tests/wsgi_test.py", "original_string": "    def test_partial_writes_are_handled(self):\n        # https://github.com/eventlet/eventlet/issues/295\n        # Eventlet issue: \"Python 3: wsgi doesn't handle correctly partial\n        # write of socket send() when using writelines()\".\n        #\n        # The bug was caused by the default writelines() implementaiton\n        # (used by the wsgi module) which doesn't check if write()\n        # successfully completed sending *all* data therefore data could be\n        # lost and the client could be left hanging forever.\n        #\n        # Switching wsgi wfile to buffered mode fixes the issue.\n        #\n        # Related CPython issue: \"Raw I/O writelines() broken\",\n        # http://bugs.python.org/issue26292\n        #\n        # Custom accept() and send() in order to simulate a connection that\n        # only sends one byte at a time so that any code that doesn't handle\n        # partial writes correctly has to fail.\n        listen_socket = eventlet.listen(('localhost', 0))\n        original_accept = listen_socket.accept\n        def accept():\n            connection, address = original_accept()\n            original_send = connection.send\n            def send(b, *args):\n                b = b[:1]\n                return original_send(b, *args)\n            connection.send = send\n            return connection, address\n        listen_socket.accept = accept\n        def application(env, start_response):\n            # Sending content-length is important here so that the client knows\n            # exactly how many bytes does it need to wait for.\n            start_response('200 OK', [('Content-length', 3)])\n            yield 'asd'\n        self.spawn_server(sock=listen_socket)\n        self.site.application = application\n        sock = eventlet.connect(self.server_addr)\n        sock.sendall(b'GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n')\n        # This would previously hang forever\n        result = read_http(sock)\n        assert result.body == b'asd'\n", "docstring": "https://github.com/eventlet/eventlet/issues/295"}
{"repo": "eventlet-master/tests/wsgi_test.py", "original_string": "    def test_022_custom_pool(self):\n        # just test that it accepts the parameter for now\n        # TODO(waitall): test that it uses the pool and that you can waitall() to\n        # ensure that all clients finished\n        p = eventlet.GreenPool(5)\n        self.spawn_server(custom_pool=p)\n        # this stuff is copied from test_001_server, could be better factored\n        sock = eventlet.connect(self.server_addr)\n        sock.sendall(b'GET / HTTP/1.0\\r\\nHost: localhost\\r\\n\\r\\n')\n        result = recvall(sock)\n        assert result.startswith(b'HTTP'), result\n        assert result.endswith(b'hello world'), result\n", "docstring": "just test that it accepts the parameter for now"}
{"repo": "eventlet-master/tests/wsgi_test.py", "original_string": "    def test_error_in_chunked_closes_connection(self):\n        # From http://rhodesmill.org/brandon/2013/chunked-wsgi/\n        self.spawn_server(minimum_chunk_size=1)\n        self.site.application = chunked_fail_app\n        sock = eventlet.connect(self.server_addr)\n        sock.sendall(b'GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n')\n        result = read_http(sock)\n        self.assertEqual(result.status, 'HTTP/1.1 200 OK')\n        self.assertEqual(result.headers_lower.get('transfer-encoding'), 'chunked')\n        expected_body = (\n            b'27\\r\\nThe dwarves of yore made mighty spells,\\r\\n'\n            b'25\\r\\nWhile hammers fell like ringing bells\\r\\n')\n        self.assertEqual(result.body, expected_body)\n        # verify that socket is closed by server\n        self.assertEqual(sock.recv(1), b'')\n", "docstring": "From http://rhodesmill.org/brandon/2013/chunked-wsgi/"}
{"repo": "eventlet-master/tests/wsgi_test.py", "original_string": "    def test_032_wsgi_input_as_iterable(self):\n        # https://bitbucket.org/eventlet/eventlet/issue/150\n        # env['wsgi.input'] returns a single byte at a time\n        # when used as an iterator\n        g = [0]\n        def echo_by_iterating(env, start_response):\n            start_response('200 OK', [('Content-type', 'text/plain')])\n            for chunk in env['wsgi.input']:\n                g[0] += 1\n                yield chunk\n        self.site.application = echo_by_iterating\n        upload_data = b'123456789abcdef' * 100\n        request = (\n            'POST / HTTP/1.0\\r\\n'\n            'Host: localhost\\r\\n'\n            'Content-Length: %i\\r\\n\\r\\n%s'\n        ) % (len(upload_data), bytes_to_str(upload_data))\n        sock = eventlet.connect(self.server_addr)\n        sock.sendall(request.encode())\n        result = read_http(sock)\n        self.assertEqual(result.body, upload_data)\n        self.assertEqual(g[0], 1)\n", "docstring": "https://bitbucket.org/eventlet/eventlet/issue/150"}
{"repo": "eventlet-master/tests/wsgi_test.py", "original_string": "    def test_client_disconnect(self):\n        \"\"\"Issue #95 Server must handle disconnect from client in the middle of response\n        \"\"\"\n        def long_response(environ, start_response):\n            start_response('200 OK', [('Content-Length', '9876')])\n            yield b'a' * 9876\n        server_sock = eventlet.listen(('localhost', 0))\n        self.server_addr = server_sock.getsockname()\n        server = wsgi.Server(server_sock, server_sock.getsockname(), long_response,\n                             log=self.logfile)\n        def make_request():\n            sock = eventlet.connect(server_sock.getsockname())\n            sock.send(b'GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n')\n            sock.close()\n        request_thread = eventlet.spawn(make_request)\n        client_sock, addr = server_sock.accept()\n        # Next line must not raise IOError -32 Broken pipe\n        server.process_request([addr, client_sock, wsgi.STATE_IDLE])\n        request_thread.wait()\n        server_sock.close()\n", "docstring": "Issue #95 Server must handle disconnect from client in the middle of response"}
{"repo": "eventlet-master/tests/wsgi_test.py", "original_string": "    def test_disable_header_name_capitalization(self):\n        # Disable HTTP header name capitalization\n        #\n        # https://github.com/eventlet/eventlet/issues/80\n        random_case_header = ('eTAg', 'TAg-VAluE')\n        def wsgi_app(environ, start_response):\n            start_response('200 oK', [random_case_header])\n            return [b'']\n        self.spawn_server(site=wsgi_app, capitalize_response_headers=False)\n        sock = eventlet.connect(self.server_addr)\n        sock.sendall(b'GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n')\n        result = read_http(sock)\n        sock.close()\n        self.assertEqual(result.status, 'HTTP/1.1 200 oK')\n        self.assertEqual(result.headers_lower[random_case_header[0].lower()], random_case_header[1])\n        self.assertEqual(result.headers_original[random_case_header[0]], random_case_header[1])\n", "docstring": "Disable HTTP header name capitalization"}
{"repo": "eventlet-master/tests/hub_test.py", "original_string": "    def test_cancel_proportion(self):\n        # if fewer than half the pending timers are canceled, it should\n        # not clean them out\n        hub = hubs.get_hub()\n        uncanceled_timers = []\n        stimers = hub.get_timers_count()\n        scanceled = hub.timers_canceled\n        for i in six.moves.range(1000):\n            # 2/3rds of new timers are uncanceled\n            t = hubs.get_hub().schedule_call_global(60, noop)\n            t2 = hubs.get_hub().schedule_call_global(60, noop)\n            t3 = hubs.get_hub().schedule_call_global(60, noop)\n            eventlet.sleep()\n            self.assert_less_than_equal(hub.timers_canceled,\n                                        hub.get_timers_count() + 1)\n            t.cancel()\n            self.assert_less_than_equal(hub.timers_canceled,\n                                        hub.get_timers_count() + 1)\n            uncanceled_timers.append(t2)\n            uncanceled_timers.append(t3)\n        # 3000 new timers, plus a few extras\n        self.assert_less_than_equal(stimers + 3000,\n                                    stimers + hub.get_timers_count())\n        self.assertEqual(hub.timers_canceled, 1000)\n        for t in uncanceled_timers:\n            t.cancel()\n            self.assert_less_than_equal(hub.timers_canceled,\n                                        hub.get_timers_count())\n        eventlet.sleep()\n", "docstring": "if fewer than half the pending timers are canceled, it should"}
{"repo": "eventlet-master/tests/hub_test.py", "original_string": "    def test_sleep(self):\n        # even if there was an error in the mainloop, the hub should continue\n        # to work\n        start = time.time()\n        eventlet.sleep(DELAY)\n        delay = time.time() - start\n        assert delay >= DELAY * \\\n            0.9, 'sleep returned after %s seconds (was scheduled for %s)' % (\n                delay, DELAY)\n        def fail():\n            1 // 0\n        hubs.get_hub().schedule_call_global(0, fail)\n        start = time.time()\n        eventlet.sleep(DELAY)\n        delay = time.time() - start\n        assert delay >= DELAY * \\\n            0.9, 'sleep returned after %s seconds (was scheduled for %s)' % (\n                delay, DELAY)\n", "docstring": "even if there was an error in the mainloop, the hub should continue"}
{"repo": "eventlet-master/tests/hub_test.py", "original_string": "    def test_exceptionpreservation(self):\n        # events for controlling execution order\n        gt1event = eventlet.Event()\n        gt2event = eventlet.Event()\n        def test_gt1():\n            try:\n                raise KeyError()\n            except KeyError:\n                gt1event.send('exception')\n                gt2event.wait()\n                assert sys.exc_info()[0] is KeyError\n                gt1event.send('test passed')\n        def test_gt2():\n            gt1event.wait()\n            gt1event.reset()\n            assert sys.exc_info()[0] is None\n            try:\n                raise ValueError()\n            except ValueError:\n                gt2event.send('exception')\n                gt1event.wait()\n                assert sys.exc_info()[0] is ValueError\n        g1 = eventlet.spawn(test_gt1)\n        g2 = eventlet.spawn(test_gt2)\n        try:\n            g1.wait()\n            g2.wait()\n        finally:\n            g1.kill()\n            g2.kill()\n", "docstring": "events for controlling execution order"}
{"repo": "eventlet-master/tests/hub_test.py", "original_string": "    def test_kill(self):\n        \"\"\" Checks that killing a process after the hub runloop dies does\n        not immediately return to hub greenlet's parent and schedule a\n        redundant timer. \"\"\"\n        hub = hubs.get_hub()\n        def dummyproc():\n            hub.switch()\n        g = eventlet.spawn(dummyproc)\n        eventlet.sleep(0)  # let dummyproc run\n        assert hub.greenlet.parent == eventlet.greenthread.getcurrent()\n        self.assertRaises(KeyboardInterrupt, hub.greenlet.throw,\n                          KeyboardInterrupt())\n        # kill dummyproc, this schedules a timer to return execution to\n        # this greenlet before throwing an exception in dummyproc.\n        # it is from this timer that execution should be returned to this\n        # greenlet, and not by propogating of the terminating greenlet.\n        g.kill()\n        with eventlet.Timeout(0.5, self.CustomException()):\n            # we now switch to the hub, there should be no existing timers\n            # that switch back to this greenlet and so this hub.switch()\n            # call should block indefinitely.\n            self.assertRaises(self.CustomException, hub.switch)\n", "docstring": "Checks that killing a process after the hub runloop dies does"}
{"repo": "eventlet-master/tests/test__socket_errors.py", "original_string": "    def test_connection_refused(self):\n        # open and close a dummy server to find an unused port\n        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        server.bind(('127.0.0.1', 0))\n        server.listen(1)\n        port = server.getsockname()[1]\n        server.close()\n        del server\n        s = socket.socket()\n        try:\n            s.connect(('127.0.0.1', port))\n            self.fail(\"Shouldn't have connected\")\n        except socket.error as ex:\n            code, text = ex.args\n            assert code == errno.ECONNREFUSED, 'Expected ECONNREFUSED, got {0} ({1})'.format(code, text)\n            assert 'refused' in text.lower(), (code, text)\n", "docstring": "open and close a dummy server to find an unused port"}
{"repo": "eventlet-master/tests/test__socket_errors.py", "original_string": "    def test_timeout(self, socket=socket):\n        \"\"\" Test that the socket timeout exception works correctly. \"\"\"\n        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        server.bind(('127.0.0.1', 0))\n        server.listen(1)\n        port = server.getsockname()[1]\n        s = socket.socket()\n        s.connect(('127.0.0.1', port))\n        cs, addr = server.accept()\n        cs.settimeout(1)\n        try:\n            try:\n                cs.recv(1024)\n                self.fail(\"Should have timed out\")\n            except socket.timeout as ex:\n                assert hasattr(ex, 'args')\n                assert len(ex.args) == 1\n                assert ex.args[0] == 'timed out'\n        finally:\n            s.close()\n            cs.close()\n            server.close()\n", "docstring": "Test that the socket timeout exception works correctly. \n"}
{"repo": "eventlet-master/tests/__init__.py", "original_string": "def skip_if(condition):\n    \"\"\" Decorator that skips a test if the *condition* evaluates True.\n    *condition* can be a boolean or a callable that accepts one argument.\n    The callable will be called with the function to be decorated, and\n    should return True to skip the test.\n    \"\"\"\n    def skipped_wrapper(func):\n        @functools.wraps(func)\n        def wrapped(*a, **kw):\n            if isinstance(condition, bool):\n                result = condition\n            else:\n                result = condition(func)\n            if result:\n                raise SkipTest()\n            else:\n                return func(*a, **kw)\n        return wrapped\n    return skipped_wrapper\n", "docstring": "Decorator that skips a test if the *condition* evaluates True."}
{"repo": "eventlet-master/tests/__init__.py", "original_string": "def skip_on_windows(func):\n    \"\"\" Decorator that skips a test on Windows.\"\"\"\n    return skip_if(sys.platform.startswith('win'))(func)\n", "docstring": "Decorator that skips a test on Windows.\n"}
{"repo": "eventlet-master/tests/__init__.py", "original_string": "def skip_if_CRLock_exist(func):\n    \"\"\" Decorator that skips a test if the `_thread.RLock` class exists \"\"\"\n    try:\n        from _thread import RLock\n        return skipped(func)\n    except ImportError:\n        return func\n", "docstring": "Decorator that skips a test if the `_thread.RLock` class exists \n"}
{"repo": "eventlet-master/tests/__init__.py", "original_string": "    def set_alarm(self, new_timeout):\n        \"\"\"Call this in the beginning of your test if you expect busy loops.\n        Only has effect during one test.\n        `new_timeout` must be int.\n        \"\"\"\n        def sig_alarm_handler(sig, frame):\n            # Could arm previous alarm but test is failed anyway\n            # seems to be no point in restoring previous state.\n            raise TestIsTakingTooLong(new_timeout)\n        self.previous_alarm = (\n            signal.signal(signal.SIGALRM, sig_alarm_handler),\n            signal.alarm(new_timeout),\n        )\n", "docstring": "Call this in the beginning of your test if you expect busy loops."}
{"repo": "eventlet-master/tests/__init__.py", "original_string": "def get_database_auth():\n    \"\"\"Retrieves a dict of connection parameters for connecting to test databases.\n    Authentication parameters are highly-machine specific, so\n    get_database_auth gets its information from either environment\n    variables or a config file.  The environment variable is\n    \"EVENTLET_DB_TEST_AUTH\" and it should contain a json object.  If\n    this environment variable is present, it's used and config files\n    are ignored.  If it's not present, it looks in the local directory\n    (tests) and in the user's home directory for a file named\n    \".test_dbauth\", which contains a json map of parameters to the\n    connect function.\n    \"\"\"\n    retval = {\n        'MySQLdb': {'host': 'localhost', 'user': 'root', 'passwd': ''},\n        'psycopg2': {'user': 'test'},\n    }\n    if 'EVENTLET_DB_TEST_AUTH' in os.environ:\n        return json.loads(os.environ.get('EVENTLET_DB_TEST_AUTH'))\n    files = [os.path.join(os.path.dirname(__file__), '.test_dbauth'),\n             os.path.join(os.path.expanduser('~'), '.test_dbauth')]\n    for f in files:\n        try:\n            auth_utf8 = json.load(open(f))\n            # Have to convert unicode objects to str objects because\n            # mysqldb is dumb. Using a doubly-nested list comprehension\n            # because we know that the structure is a two-level dict.\n            return dict(\n                [(str(modname), dict(\n                    [(str(k), str(v)) for k, v in connectargs.items()]))\n                 for modname, connectargs in auth_utf8.items()])\n        except IOError:\n            pass\n    return retval\n", "docstring": "Retrieves a dict of connection parameters for connecting to test databases."}
{"repo": "eventlet-master/tests/test__greenness.py", "original_string": "    def serve():\n        # increment the request_count before handling the request because\n        # the send() for the response blocks (or at least appeared to be)\n        httpd.request_count += 1\n        httpd.handle_request()\n", "docstring": "increment the request_count before handling the request because"}
{"repo": "eventlet-master/tests/mysqldb_test.py", "original_string": "def mysql_requirement(_f):\n    \"\"\"We want to skip tests if using pyevent, MySQLdb is not installed, or if\n    there is no database running on the localhost that the auth file grants\n    us access to.\n    This errs on the side of skipping tests if everything is not right, but\n    it's better than a million tests failing when you don't care about mysql\n    support.\"\"\"\n    if using_pyevent(_f):\n        return False\n    if MySQLdb is False:\n        print(\"Skipping mysql tests, MySQLdb not importable\")\n        return False\n    try:\n        auth = get_database_auth()['MySQLdb'].copy()\n        MySQLdb.connect(**auth)\n        return True\n    except MySQLdb.OperationalError:\n        print(\"Skipping mysql tests, error when connecting:\")\n        traceback.print_exc()\n        return False\n", "docstring": "We want to skip tests if using pyevent, MySQLdb is not installed, or if"}
{"repo": "eventlet-master/tests/subprocess_test.py", "original_string": "def test_subprocess_wait():\n    # https://bitbucket.org/eventlet/eventlet/issue/89\n    # In Python 3.3 subprocess.Popen.wait() method acquired `timeout`\n    # argument.\n    # RHEL backported it to their Python 2.6 package.\n    cmd = [sys.executable, \"-c\", \"import time; time.sleep(0.5)\"]\n    p = subprocess.Popen(cmd)\n    ok = False\n    t1 = time.time()\n    try:\n        p.wait(timeout=0.1)\n    except subprocess.TimeoutExpired as e:\n        str(e)  # make sure it doesn't throw\n        assert e.cmd == cmd\n        assert e.timeout == 0.1\n        ok = True\n    tdiff = time.time() - t1\n    assert ok, 'did not raise subprocess.TimeoutExpired'\n    assert 0.1 <= tdiff <= 0.2, 'did not stop within allowed time'\n", "docstring": "https://bitbucket.org/eventlet/eventlet/issue/89"}
{"repo": "eventlet-master/tests/subprocess_test.py", "original_string": "def test_patched_communicate_290():\n    # https://github.com/eventlet/eventlet/issues/290\n    # Certain order of import and monkey_patch breaks subprocess communicate()\n    # with AttributeError module `select` has no `poll` on Linux\n    # unpatched methods are removed for safety reasons in commit f63165c0e3\n    tests.run_isolated('subprocess_patched_communicate.py')\n", "docstring": "https://github.com/eventlet/eventlet/issues/290"}
{"repo": "eventlet-master/tests/socket_test.py", "original_string": "def test_recv_into_type():\n    # make sure `_recv_loop` returns the correct value when `recv_meth` is of\n    # foo_into type (fills a buffer and returns number of bytes, not the data)\n    # Using threads like `test_recv_type` above.\n    threading = eventlet.patcher.original('threading')\n    addr = []\n    def server():\n        sock = eventlet.listen(('127.0.0.1', 0))\n        addr[:] = sock.getsockname()\n        eventlet.sleep(0.2)\n    server_thread = threading.Thread(target=server)\n    server_thread.start()\n    eventlet.sleep(0.1)\n    sock = eventlet.connect(tuple(addr))\n    buf = array.array('B', b' ')\n    res = sock.recv_into(buf, 1)\n    assert isinstance(res, int)\n", "docstring": "make sure `_recv_loop` returns the correct value when `recv_meth` is of"}
{"repo": "eventlet-master/tests/socket_test.py", "original_string": "def test_socket_api_family():\n    # It was named family_or_realsock\n    # https://github.com/eventlet/eventlet/issues/319\n    socket.socket(family=socket.AF_INET)\n", "docstring": "It was named family_or_realsock"}
{"repo": "eventlet-master/tests/pools_test.py", "original_string": "    def test_abstract(self):\n        # Going for 100% coverage here\n        # A Pool cannot be used without overriding create()\n        pool = pools.Pool()\n        self.assertRaises(NotImplementedError, pool.get)\n", "docstring": "Going for 100% coverage here"}
{"repo": "eventlet-master/tests/dagpool_test.py", "original_string": "def assert_raises(exc):\n    \"\"\"exc is an exception class\"\"\"\n    try:\n        yield\n    except exc:\n        pass\n    else:\n        raise AssertionError(\"failed to raise expected exception {0}\"\n                             .format(exc.__class__.__name__))\n", "docstring": "exc is an exception class\n"}
{"repo": "eventlet-master/tests/dagpool_test.py", "original_string": "    def __init__(self):\n        self.sequence = [set()]\n", "docstring": "self.sequence = [set()]"}
{"repo": "eventlet-master/tests/dagpool_test.py", "original_string": "def test_wait_each_all():\n    # set up a simple linear dependency chain\n    deps = dict(b=\"a\", c=\"b\", d=\"c\", e=\"d\")\n    capture = Capture()\n    pool = DAGPool([(\"a\", \"a\")])\n    # capture a different Event for each key\n    events = dict((key, eventlet.event.Event()) for key in six.iterkeys(deps))\n    # can't use spawn_many() because we need a different event for each\n    for key, dep in six.iteritems(deps):\n        pool.spawn(key, dep, observe, capture, events[key])\n    keys = \"abcde\"                      # this specific order\n    each = iter(pool.wait_each())\n    for pos in range(len(keys)):\n        # next value from wait_each()\n        k, v = next(each)\n        assert_equals(k, keys[pos])\n        # advance every pool greenlet as far as it can go\n        spin()\n        # everything from keys[:pos+1] should have a value by now\n        for k in keys[:pos + 1]:\n            assert pool.get(k, _notthere) is not _notthere, \\\n                \"greenlet {0} did not yet produce a value\".format(k)\n        # everything from keys[pos+1:] should not yet\n        for k in keys[pos + 1:]:\n            assert pool.get(k, _notthere) is _notthere, \\\n                \"wait_each() delayed value for {0}\".format(keys[pos])\n        # let next greenthread complete\n        if pos < len(keys) - 1:\n            k = keys[pos + 1]\n            events[k].send(k)\n", "docstring": "set up a simple linear dependency chain"}
{"repo": "eventlet-master/tests/manual/greenio_memtest.py", "original_string": "def _VmB(VmKey):\n    '''Private.\n    '''\n    global _proc_status, _scale\n    # get pseudo file  /proc/<pid>/status\n    try:\n        t = open(_proc_status)\n        v = t.read()\n        t.close()\n    except:\n        return 0.0  # non-Linux?\n    # get VmKey line e.g. 'VmRSS:  9999  kB\\n ...'\n    i = v.index(VmKey)\n    v = v[i:].split(None, 3)  # whitespace\n    if len(v) < 3:\n        return 0.0  # invalid format?\n    # convert Vm value to bytes\n    return float(v[1]) * _scale[v[2]]\n", "docstring": "Private."}
{"repo": "eventlet-master/tests/manual/greenio_memtest.py", "original_string": "def resident(since=0.0):\n    '''Return resident memory usage in bytes.\n    '''\n    return _VmB('VmRSS:') - since\n", "docstring": "Return resident memory usage in bytes."}
{"repo": "eventlet-master/tests/stdlib/test_asyncore.py", "original_string": "def new_closeall_check(self, usedefault):\n    # Check that close_all() closes everything in a given map\n    l = []\n    testmap = {}\n    for i in range(10):\n        c = dummychannel()\n        l.append(c)\n        self.assertEqual(c.socket.closed, False)\n        testmap[i] = c\n    if usedefault:\n        # the only change we make is to not assign to asyncore.socket_map\n        # because doing so fails to assign to the real asyncore's socket_map\n        # and thus the test fails\n        socketmap = asyncore.socket_map.copy()\n        try:\n            asyncore.socket_map.clear()\n            asyncore.socket_map.update(testmap)\n            asyncore.close_all()\n        finally:\n            testmap = asyncore.socket_map.copy()\n            asyncore.socket_map.clear()\n            asyncore.socket_map.update(socketmap)\n    else:\n        asyncore.close_all(testmap)\n    self.assertEqual(len(testmap), 0)\n    for c in l:\n        self.assertEqual(c.socket.closed, True)\n", "docstring": "Check that close_all() closes everything in a given map"}
{"repo": "compose-master/compose/parallel.py", "original_string": "def parallel_execute(objects, func, get_name, msg, get_deps=None, limit=None, fail_check=None):\n    \"\"\"Runs func on objects in parallel while ensuring that func is\n    ran on object only after it is ran on all its dependencies.\n    get_deps called on object must return a collection with its dependencies.\n    get_name called on object must return its name.\n    fail_check is an additional failure check for cases that should display as a failure\n        in the CLI logs, but don't raise an exception (such as attempting to start 0 containers)\n    \"\"\"\n    objects = list(objects)\n    stream = sys.stderr\n    writer = ParallelStreamWriter.get_or_assign_instance(ParallelStreamWriter(stream))\n    for obj in objects:\n        writer.add_object(msg, get_name(obj))\n    for obj in objects:\n        writer.write_initial(msg, get_name(obj))\n    events = parallel_execute_iter(objects, func, get_deps, limit)\n    errors = {}\n    results = []\n    error_to_reraise = parallel_execute_watch(\n        events, writer, errors, results, msg, get_name, fail_check\n    )\n    for obj_name, error in errors.items():\n        stream.write(\"\\nERROR: for {}  {}\\n\".format(obj_name, error))\n    if error_to_reraise:\n        raise error_to_reraise\n    return results, errors\n", "docstring": "Runs func on objects in parallel while ensuring that func is"}
{"repo": "compose-master/compose/parallel.py", "original_string": "    def get_instance(cls):\n        return cls.instance\n", "docstring": "return cls.instance"}
{"repo": "compose-master/compose/service.py", "original_string": "    def get_container(self, number=1):\n        \"\"\"Return a :class:`compose.container.Container` for this service. The\n        container must be active, and match `number`.\n        \"\"\"\n        for container in self.containers(labels=['{}={}'.format(LABEL_CONTAINER_NUMBER, number)]):\n            return container\n        raise ValueError(\"No container found for {}_{}\".format(self.name, number))\n", "docstring": "Return a :class:`compose.container.Container` for this service. The"}
{"repo": "compose-master/compose/service.py", "original_string": "    def _fetch_containers(self, **fetch_options):\n        # Account for containers that might have been removed since we fetched\n        # the list.\n        def soft_inspect(container):\n            try:\n                return Container.from_id(self.client, container['Id'])\n            except NotFound:\n                return None\n        return filter(None, [\n            soft_inspect(container)\n            for container in self.client.containers(**fetch_options)\n        ])\n", "docstring": "Account for containers that might have been removed since we fetched"}
{"repo": "compose-master/compose/service.py", "original_string": "    def is_completed_successfully(self):\n        \"\"\" Check that all containers for this service has completed successfully\n            Returns false if at least one container does not exited and\n            raises CompletedUnsuccessfully exception if at least one container\n            exited with non-zero exit code.\n        \"\"\"\n        result = True\n        for ctnr in self.containers(stopped=True):\n            ctnr.inspect()\n            if ctnr.get('State.Status') != 'exited':\n                result = False\n            elif ctnr.exit_code != 0:\n                raise CompletedUnsuccessfully(ctnr.short_id, ctnr.exit_code)\n        return result\n", "docstring": "Check that all containers for this service has completed successfully"}
{"repo": "compose-master/compose/service.py", "original_string": "def parse_repository_tag(repo_path):\n    \"\"\"Splits image identification into base image path, tag/digest\n    and it's separator.\n    Example:\n    >>> parse_repository_tag('user/repo@sha256:digest')\n    ('user/repo', 'sha256:digest', '@')\n    >>> parse_repository_tag('user/repo:v1')\n    ('user/repo', 'v1', ':')\n    \"\"\"\n    tag_separator = \":\"\n    digest_separator = \"@\"\n    if digest_separator in repo_path:\n        repo, tag = repo_path.rsplit(digest_separator, 1)\n        return repo, tag, digest_separator\n    repo, tag = repo_path, \"\"\n    if tag_separator in repo_path:\n        repo, tag = repo_path.rsplit(tag_separator, 1)\n        if \"/\" in tag:\n            repo, tag = repo_path, \"\"\n    return repo, tag, tag_separator\n", "docstring": "Splits image identification into base image path, tag/digest"}
{"repo": "compose-master/compose/service.py", "original_string": "def warn_on_masked_volume(volumes_option, container_volumes, service):\n    container_volumes = {\n        volume.internal: volume.external\n        for volume in container_volumes}\n    for volume in volumes_option:\n        if (\n                volume.external and\n                volume.internal in container_volumes and\n                container_volumes.get(volume.internal) != volume.external\n        ):\n            log.warning((\n                \"Service \\\"{service}\\\" is using volume \\\"{volume}\\\" from the \"\n                \"previous container. Host mapping \\\"{host_path}\\\" has no effect. \"\n                \"Remove the existing containers (with `docker-compose rm {service}`) \"\n                \"to use the host volume mapping.\"\n            ).format(\n                service=service,\n                volume=volume.internal,\n                host_path=volume.external))\n", "docstring": "container_volumes = {"}
{"repo": "compose-master/compose/service.py", "original_string": "def build_container_labels(label_options, service_labels, number, config_hash, slug):\n    labels = dict(label_options or {})\n    labels.update(label.split('=', 1) for label in service_labels)\n    if number is not None:\n        labels[LABEL_CONTAINER_NUMBER] = str(number)\n    if slug is not None:\n        labels[LABEL_SLUG] = slug\n    labels[LABEL_VERSION] = __version__\n    if config_hash:\n        log.debug(\"Added config hash: %s\" % config_hash)\n        labels[LABEL_CONFIG_HASH] = config_hash\n    return labels\n", "docstring": "labels = dict(label_options or {})"}
{"repo": "compose-master/compose/utils.py", "original_string": "def stream_as_text(stream):\n    \"\"\"Given a stream of bytes or text, if any of the items in the stream\n    are bytes convert them to text.\n    This function can be removed once docker-py returns text streams instead\n    of byte streams.\n    \"\"\"\n    for data in stream:\n        if not isinstance(data, str):\n            data = data.decode('utf-8', 'replace')\n        yield data\n", "docstring": "Given a stream of bytes or text, if any of the items in the stream"}
{"repo": "compose-master/compose/utils.py", "original_string": "def split_buffer(stream, splitter=None, decoder=lambda a: a):\n    \"\"\"Given a generator which yields strings and a splitter function,\n    joins all input, splits on the separator and yields each chunk.\n    Unlike string.split(), each chunk includes the trailing\n    separator, except for the last one if none was found on the end\n    of the input.\n    \"\"\"\n    splitter = splitter or line_splitter\n    buffered = ''\n    for data in stream_as_text(stream):\n        buffered += data\n        while True:\n            buffer_split = splitter(buffered)\n            if buffer_split is None:\n                break\n            item, buffered = buffer_split\n            yield item\n    if buffered:\n        try:\n            yield decoder(buffered)\n        except Exception as e:\n            log.error(\n                'Compose tried decoding the following data chunk, but failed:'\n                '\\n%s' % repr(buffered)\n            )\n            raise StreamParseError(e)\n", "docstring": "Given a generator which yields strings and a splitter function,"}
{"repo": "compose-master/compose/utils.py", "original_string": "def json_stream(stream):\n    \"\"\"Given a stream of text, return a stream of json objects.\n    This handles streams which are inconsistently buffered (some entries may\n    be newline delimited, and others are not).\n    \"\"\"\n    return split_buffer(stream, json_splitter, json_decoder.decode)\n", "docstring": "Given a stream of text, return a stream of json objects."}
{"repo": "compose-master/compose/project.py", "original_string": "    def get_services_without_duplicate(self, service_names=None, include_deps=False):\n        services = self.get_services(service_names, include_deps)\n        for service in services:\n            service.remove_duplicate_containers()\n        return services\n", "docstring": "services = self.get_services(service_names, include_deps)"}
{"repo": "compose-master/compose/project.py", "original_string": "    def _legacy_event_processor(self, service_names):\n        # Only for v1 files or when Compose is forced to use an older API version\n        def build_container_event(event, container):\n            time = datetime.datetime.fromtimestamp(event['time'])\n            time = time.replace(\n                microsecond=microseconds_from_time_nano(event['timeNano'])\n            )\n            return {\n                'time': time,\n                'type': 'container',\n                'action': event['status'],\n                'id': container.id,\n                'service': container.service,\n                'attributes': {\n                    'name': container.name,\n                    'image': event['from'],\n                },\n                'container': container,\n            }\n        service_names = set(service_names or self.service_names)\n        for event in self.client.events(\n            filters={'label': self.labels()},\n            decode=True\n        ):\n            # This is a guard against some events broadcasted by swarm that\n            # don't have a status field.\n            # See https://github.com/docker/compose/issues/3316\n            if 'status' not in event:\n                continue\n            try:\n                # this can fail if the container has been removed or if the event\n                # refers to an image\n                container = Container.from_id(self.client, event['id'])\n            except APIError:\n                continue\n            if container.service not in service_names:\n                continue\n            yield build_container_event(event, container)\n", "docstring": "Only for v1 files or when Compose is forced to use an older API version"}
{"repo": "compose-master/compose/container.py", "original_string": "    def from_id(cls, client, id):\n        return cls(client, client.inspect_container(id), has_been_inspected=True)\n", "docstring": "return cls(client, client.inspect_container(id), has_been_inspected=True)"}
{"repo": "compose-master/compose/container.py", "original_string": "    def human_readable_health_status(self):\n        \"\"\" Generate UP status string with up time and health\n        \"\"\"\n        status_string = 'Up'\n        container_status = self.get('State.Health.Status')\n        if container_status == 'starting':\n            status_string += ' (health: starting)'\n        elif container_status is not None:\n            status_string += ' (%s)' % container_status\n        return status_string\n", "docstring": "Generate UP status string with up time and health"}
{"repo": "compose-master/compose/container.py", "original_string": "    def get(self, key):\n        \"\"\"Return a value from the container or None if the value is not set.\n        :param key: a string using dotted notation for nested dictionary\n                    lookups\n        \"\"\"\n        self.inspect_if_not_inspected()\n        def get_value(dictionary, key):\n            return (dictionary or {}).get(key)\n        return reduce(get_value, key.split('.'), self.dictionary)\n", "docstring": "Return a value from the container or None if the value is not set."}
{"repo": "compose-master/compose/container.py", "original_string": "    def rename_to_tmp_name(self):\n        \"\"\"Rename the container to a hopefully unique temporary container name\n        by prepending the short id.\n        \"\"\"\n        if not self.name.startswith(self.short_id):\n            self.client.rename(\n                self.id, '{}_{}'.format(self.short_id, self.name)\n            )\n", "docstring": "Rename the container to a hopefully unique temporary container name"}
{"repo": "compose-master/compose/container.py", "original_string": "    def reset_image(self, img_id):\n        \"\"\" If this container's image has been removed, temporarily replace the old image ID\n            with `img_id`.\n        \"\"\"\n        if not self.image_exists():\n            self.dictionary['Image'] = img_id\n", "docstring": "If this container's image has been removed, temporarily replace the old image ID"}
{"repo": "compose-master/compose/timeparse.py", "original_string": "def timeparse(sval):\n    \"\"\"Parse a time expression, returning it as a number of seconds.  If\n    possible, the return value will be an `int`; if this is not\n    possible, the return will be a `float`.  Returns `None` if a time\n    expression cannot be parsed from the given string.\n    Arguments:\n    - `sval`: the string value to parse\n    >>> timeparse('1m24s')\n    84\n    >>> timeparse('1.2 minutes')\n    72\n    >>> timeparse('1.2 seconds')\n    1.2\n    \"\"\"\n    match = re.match(r'\\s*' + TIMEFORMAT + r'\\s*$', sval, re.I)\n    if not match or not match.group(0).strip():\n        return\n    mdict = match.groupdict()\n    return sum(\n        MULTIPLIERS[k] * cast(v) for (k, v) in mdict.items() if v is not None)\n", "docstring": "Parse a time expression, returning it as a number of seconds.  If"}
{"repo": "compose-master/compose/cli/log_printer.py", "original_string": "def build_log_presenters(service_names, monochrome, keep_prefix=True):\n    \"\"\"Return an iterable of functions.\n    Each function can be used to format the logs output of a container.\n    \"\"\"\n    prefix_width = max_name_width(service_names)\n    def no_color(text):\n        return text\n    for color_func in cycle([no_color] if monochrome else colors.rainbow()):\n        yield LogPresenter(prefix_width, color_func, keep_prefix)\n", "docstring": "Return an iterable of functions."}
{"repo": "compose-master/compose/cli/log_printer.py", "original_string": "def build_log_generator(container, log_args):\n    # if the container doesn't have a log_stream we need to attach to container\n    # before log printer starts running\n    if container.log_stream is None:\n        stream = container.logs(stdout=True, stderr=True, stream=True, **log_args)\n    else:\n        stream = container.log_stream\n    return split_buffer(stream)\n", "docstring": "if the container doesn't have a log_stream we need to attach to container"}
{"repo": "compose-master/compose/cli/signals.py", "original_string": "def set_signal_handler_to_hang_up():\n    # on Windows a ValueError will be raised if trying to set signal handler for SIGHUP\n    if not IS_WINDOWS_PLATFORM:\n        signal.signal(signal.SIGHUP, hang_up)\n", "docstring": "on Windows a ValueError will be raised if trying to set signal handler for SIGHUP"}
{"repo": "compose-master/compose/cli/utils.py", "original_string": "def is_ubuntu():\n    return platform.system() == 'Linux' and distro.linux_distribution()[0] == 'Ubuntu'\n", "docstring": "return platform.system() == 'Linux' and distro.linux_distribution()[0] == 'Ubuntu'"}
{"repo": "compose-master/compose/cli/main.py", "original_string": "        def format_event(event):\n            attributes = [\"%s=%s\" % item for item in event['attributes'].items()]\n            return (\"{time} {type} {action} {id} ({attrs})\").format(\n                attrs=\", \".join(sorted(attributes)),\n                **event)\n", "docstring": "attributes = [\"%s=%s\" % item for item in event['attributes'].items()]"}
{"repo": "compose-master/compose/cli/main.py", "original_string": "def compute_exit_code(exit_value_from, attached_containers, cascade_starter, all_containers):\n    exit_code = 0\n    for e in all_containers:\n        if (not e.is_running and cascade_starter == e.name):\n            if not e.exit_code == 0:\n                exit_code = e.exit_code\n                break\n    return exit_code\n", "docstring": "exit_code = 0"}
{"repo": "compose-master/compose/config/config.py", "original_string": "def resolve_environment(service_dict, environment=None, interpolate=True):\n    \"\"\"Unpack any environment variables from an env_file, if set.\n    Interpolate environment values if set.\n    \"\"\"\n    env = {}\n    for env_file in service_dict.get('env_file', []):\n        env.update(env_vars_from_file(env_file, interpolate))\n    env.update(parse_environment(service_dict.get('environment')))\n    return dict(resolve_env_var(k, v, environment) for k, v in env.items())\n", "docstring": "Unpack any environment variables from an env_file, if set."}
{"repo": "compose-master/compose/config/interpolation.py", "original_string": "    def substitute(self, mapping):\n        # Helper function for .sub()\n        def convert(mo):\n            named = mo.group('named') or mo.group('braced')\n            braced = mo.group('braced')\n            if braced is not None:\n                sep = mo.group('sep')\n                if sep:\n                    return self.process_braced_group(braced, sep, mapping)\n            if named is not None:\n                val = mapping[named]\n                if isinstance(val, bytes):\n                    val = val.decode('utf-8')\n                return '{}'.format(val)\n            if mo.group('escaped') is not None:\n                return self.delimiter\n            if mo.group('invalid') is not None:\n                self._invalid(mo)\n            raise ValueError('Unrecognized named group in pattern',\n                             self.pattern)\n        return self.pattern.sub(convert, self.template)\n", "docstring": "Helper function for .sub()"}
{"repo": "compose-master/compose/config/types.py", "original_string": "def normpath(path, win_host=False):\n    \"\"\" Custom path normalizer that handles Compose-specific edge cases like\n        UNIX paths on Windows hosts and vice-versa. \"\"\"\n    sysnorm = ntpath.normpath if win_host else os.path.normpath\n    # If a path looks like a UNIX absolute path on Windows, it probably is;\n    # we'll need to revert the backslashes to forward slashes after normalization\n    flip_slashes = path.startswith('/') and IS_WINDOWS_PLATFORM\n    path = sysnorm(path)\n    if flip_slashes:\n        path = path.replace('\\\\', '/')\n    return path\n", "docstring": "Custom path normalizer that handles Compose-specific edge cases like"}
{"repo": "compose-master/compose/config/types.py", "original_string": "    def _parse_win32(cls, volume_config, normalize):\n        # relative paths in windows expand to include the drive, eg C:\\\n        # so we join the first 2 parts back together to count as one\n        mode = 'rw'\n        def separate_next_section(volume_config):\n            drive, tail = splitdrive(volume_config)\n            parts = tail.split(':', 1)\n            if drive:\n                parts[0] = drive + parts[0]\n            return parts\n        parts = separate_next_section(volume_config)\n        if len(parts) == 1:\n            internal = parts[0]\n            external = None\n        else:\n            external = parts[0]\n            parts = separate_next_section(parts[1])\n            external = normpath(external, True)\n            internal = parts[0]\n            if len(parts) > 1:\n                if ':' in parts[1]:\n                    raise ConfigurationError(\n                        \"Volume %s has incorrect format, should be \"\n                        \"external:internal[:mode]\" % volume_config\n                    )\n                mode = parts[1]\n        if normalize:\n            external = normalize_path_for_engine(external) if external else None\n        result = cls(external, internal, mode)\n        result.win32 = True\n        return result\n", "docstring": "relative paths in windows expand to include the drive, eg C:\\"}
{"repo": "compose-master/compose/config/types.py", "original_string": "    def parse(cls, volume_config, normalize=False, win_host=False):\n        \"\"\"Parse a volume_config path and split it into external:internal[:mode]\n        parts to be returned as a valid VolumeSpec.\n        \"\"\"\n        if IS_WINDOWS_PLATFORM or win_host:\n            return cls._parse_win32(volume_config, normalize)\n        else:\n            return cls._parse_unix(volume_config)\n", "docstring": "Parse a volume_config path and split it into external:internal[:mode]"}
{"repo": "compose-master/compose/config/serialize.py", "original_string": "def serialize_string(dumper, data):\n    \"\"\" Ensure boolean-like strings are quoted in the output \"\"\"\n    representer = dumper.represent_str\n    if isinstance(data, bytes):\n        data = data.decode('utf-8')\n    if data.lower() in ('y', 'n', 'yes', 'no', 'on', 'off', 'true', 'false'):\n        # Empirically only y/n appears to be an issue, but this might change\n        # depending on which PyYaml version is being used. Err on safe side.\n        return dumper.represent_scalar('tag:yaml.org,2002:str', data, style='\"')\n    return representer(data)\n", "docstring": "Ensure boolean-like strings are quoted in the output \n"}
{"repo": "compose-master/compose/config/validation.py", "original_string": "def validate_pid_mode(service_config, service_names):\n    pid_mode = service_config.config.get('pid')\n    if not pid_mode:\n        return\n    dependency = get_service_name_from_network_mode(pid_mode)\n    if not dependency:\n        return\n    if dependency not in service_names:\n        raise ConfigurationError(\n            \"Service '{s.name}' uses the PID namespace of service '{dep}' which \"\n            \"is undefined.\".format(s=service_config, dep=dependency)\n        )\n", "docstring": "pid_mode = service_config.config.get('pid')"}
{"repo": "compose-master/compose/config/validation.py", "original_string": "def _parse_valid_types_from_validator(validator):\n    \"\"\"A validator value can be either an array of valid types or a string of\n    a valid type. Parse the valid types and prefix with the correct article.\n    \"\"\"\n    if not isinstance(validator, list):\n        return anglicize_json_type(validator)\n    if len(validator) == 1:\n        return anglicize_json_type(validator[0])\n    return \"{}, or {}\".format(\n        \", \".join([anglicize_json_type(validator[0])] + validator[1:-1]),\n        anglicize_json_type(validator[-1]))\n", "docstring": "A validator value can be either an array of valid types or a string of"}
{"repo": "compose-master/compose/config/validation.py", "original_string": "def validate_service_constraints(config, service_name, config_file):\n    def handler(errors):\n        return process_service_constraint_errors(\n            errors, service_name, config_file.version)\n    schema = load_jsonschema(config_file.version)\n    validator = Draft4Validator(schema['definitions']['constraints']['service'])\n    handle_errors(validator.iter_errors(config), handler, None)\n", "docstring": "def handler(errors):"}
{"repo": "compose-master/script/test/versions.py", "original_string": "    def order(self):\n        \"\"\"Return a representation that allows this object to be sorted\n        correctly with the default comparator.\n        \"\"\"\n        # non-GA releases should appear before GA releases\n        # Order: tp -> beta -> rc -> GA\n        if self.stage:\n            for st in STAGES:\n                if st in self.stage:\n                    stage = (STAGES.index(st), self.stage)\n                    break\n        else:\n            stage = (len(STAGES),)\n        return (int(self.major), int(self.minor), int(self.patch)) + stage\n", "docstring": "Return a representation that allows this object to be sorted"}
{"repo": "compose-master/script/test/versions.py", "original_string": "def group_versions(versions):\n    \"\"\"Group versions by `major.minor` releases.\n    Example:\n        >>> group_versions([\n                Version(1, 0, 0),\n                Version(2, 0, 0, 'rc1'),\n                Version(2, 0, 0),\n                Version(2, 1, 0),\n            ])\n        [\n            [Version(1, 0, 0)],\n            [Version(2, 0, 0), Version(2, 0, 0, 'rc1')],\n            [Version(2, 1, 0)],\n        ]\n    \"\"\"\n    return list(\n        list(releases)\n        for _, releases\n        in itertools.groupby(versions, operator.attrgetter('major_minor'))\n    )\n", "docstring": "Group versions by `major.minor` releases."}
{"repo": "compose-master/script/test/versions.py", "original_string": "def get_default(versions):\n    \"\"\"Return a :class:`Version` for the latest GA version.\"\"\"\n    for version in versions:\n        if not version.stage:\n            return version\n", "docstring": "Return a :class:`Version` for the latest GA version.\n"}
{"repo": "compose-master/script/test/versions.py", "original_string": "def get_github_releases(projects):\n    \"\"\"Query the Github API for a list of version tags and return them in\n    sorted order.\n    See https://developer.github.com/v3/repos/#list-tags\n    \"\"\"\n    versions = []\n    for project in projects:\n        url = '{}/{}/tags'.format(GITHUB_API, project)\n        response = requests.get(url)\n        response.raise_for_status()\n        versions.extend(get_versions(response.json()))\n    return sorted(versions, reverse=True, key=operator.attrgetter('order'))\n", "docstring": "Query the Github API for a list of version tags and return them in"}
{"repo": "compose-master/tests/acceptance/cli_test.py", "original_string": "    def project(self):\n        # Hack: allow project to be overridden\n        if not hasattr(self, '_project'):\n            self._project = get_project(self.base_dir, override_dir=self.override_dir)\n        return self._project\n", "docstring": "Hack: allow project to be overridden"}
{"repo": "compose-master/tests/acceptance/cli_test.py", "original_string": "    def execute(self, container, cmd):\n        # Remove once Hijack and CloseNotifier sign a peace treaty\n        self.client.close()\n        exc = self.client.exec_create(container.id, cmd)\n        self.client.exec_start(exc)\n        return self.client.exec_inspect(exc)['ExitCode']\n", "docstring": "Remove once Hijack and CloseNotifier sign a peace treaty"}
{"repo": "compose-master/tests/acceptance/cli_test.py", "original_string": "    def test_build_no_cache_pull(self):\n        # Make sure we have the latest busybox already\n        pull_busybox(self.client)\n        self.base_dir = 'tests/fixtures/simple-dockerfile'\n        self.dispatch(['build', 'simple'])\n        result = self.dispatch(['build', '--no-cache', '--pull', 'simple'])\n        assert BUILD_CACHE_TEXT not in result.stdout\n        assert BUILD_PULL_TEXT in result.stdout\n", "docstring": "Make sure we have the latest busybox already"}
{"repo": "compose-master/tests/acceptance/cli_test.py", "original_string": "    def test_run_service_without_map_ports(self):\n        # create one off container\n        self.base_dir = 'tests/fixtures/ports-composefile'\n        self.dispatch(['run', '-d', 'simple'])\n        container = self.project.get_service('simple').containers(one_off=OneOffFilter.only)[0]\n        # get port information\n        port_random = container.get_local_port(3000)\n        port_assigned = container.get_local_port(3001)\n        # close all one off containers we just created\n        container.stop()\n        # check the ports\n        assert port_random is None\n        assert port_assigned is None\n", "docstring": "create one off container"}
{"repo": "compose-master/tests/acceptance/cli_test.py", "original_string": "    def test_run_service_with_explicitly_mapped_ports(self):\n        # create one off container\n        self.base_dir = 'tests/fixtures/ports-composefile'\n        self.dispatch(['run', '-d', '-p', '30000:3000', '--publish', '30001:3001', 'simple'])\n        container = self.project.get_service('simple').containers(one_off=OneOffFilter.only)[0]\n        # get port information\n        port_short = container.get_local_port(3000)\n        port_full = container.get_local_port(3001)\n        # close all one off containers we just created\n        container.stop()\n        # check the ports\n        assert port_short.endswith(':30000')\n        assert port_full.endswith(':30001')\n", "docstring": "create one off container"}
{"repo": "compose-master/tests/acceptance/cli_test.py", "original_string": "    def test_run_with_expose_ports(self):\n        # create one off container\n        self.base_dir = 'tests/fixtures/expose-composefile'\n        self.dispatch(['run', '-d', '--service-ports', 'simple'])\n        container = self.project.get_service('simple').containers(one_off=OneOffFilter.only)[0]\n        ports = container.ports\n        assert len(ports) == 9\n        # exposed ports are not mapped to host ports\n        assert ports['3000/tcp'] is None\n        assert ports['3001/tcp'] is None\n        assert ports['3001/udp'] is None\n        assert ports['3002/tcp'] is None\n        assert ports['3003/tcp'] is None\n        assert ports['3004/tcp'] is None\n        assert ports['3005/tcp'] is None\n        assert ports['3006/udp'] is None\n        assert ports['3007/udp'] is None\n        # close all one off containers we just created\n        container.stop()\n", "docstring": "create one off container"}
{"repo": "compose-master/tests/unit/cli/log_printer_test.py", "original_string": "    def test_item_is_stop_with_cascade_stop(self):\n        \"\"\"Return the name of the container that caused the cascade_stop\"\"\"\n        queue = Queue()\n        for item in QueueItem.stop('foobar-1'), QueueItem.new('a'), QueueItem.new('b'):\n            queue.put(item)\n        generator = consume_queue(queue, True)\n        assert next(generator) == 'foobar-1'\n", "docstring": "Return the name of the container that caused the cascade_stop\n"}
{"repo": "compose-master/tests/unit/config/config_test.py", "original_string": "def make_service_dict(name, service_dict, working_dir='.', filename=None):\n    \"\"\"Test helper function to construct a ServiceExtendsResolver\n    \"\"\"\n    resolver = config.ServiceExtendsResolver(\n        config.ServiceConfig(\n            working_dir=working_dir,\n            filename=filename,\n            name=name,\n            config=service_dict),\n        config.ConfigFile(filename=filename, config={}),\n        environment=Environment.from_env_file(working_dir)\n    )\n    return config.process_service(resolver.run())\n", "docstring": "Test helper function to construct a ServiceExtendsResolver"}
{"repo": "compose-master/tests/unit/config/config_test.py", "original_string": "    def test_config_build_configuration_v2(self):\n        # service.dockerfile is invalid in v2\n        with pytest.raises(ConfigurationError):\n            config.load(\n                build_config_details(\n                    {\n                        'version': '2',\n                        'services': {\n                            'web': {\n                                'build': '.',\n                                'dockerfile': 'Dockerfile-alt'\n                            }\n                        }\n                    },\n                    'tests/fixtures/extends',\n                    'filename.yml'\n                )\n            )\n        service = config.load(\n            build_config_details({\n                'version': '2',\n                'services': {\n                    'web': {\n                        'build': '.'\n                    }\n                }\n            }, 'tests/fixtures/extends', 'filename.yml')\n        ).services[0]\n        assert 'context' in service['build']\n        service = config.load(\n            build_config_details(\n                {\n                    'version': '2',\n                    'services': {\n                        'web': {\n                            'build': {\n                                'context': '.',\n                                'dockerfile': 'Dockerfile-alt'\n                            }\n                        }\n                    }\n                },\n                'tests/fixtures/extends',\n                'filename.yml'\n            )\n        ).services\n        assert 'context' in service[0]['build']\n        assert service[0]['build']['dockerfile'] == 'Dockerfile-alt'\n", "docstring": "service.dockerfile is invalid in v2"}
{"repo": "compose-master/tests/unit/config/config_test.py", "original_string": "    def test_config_invalid_expose_format_validation(self):\n        # Valid port mappings ARE NOT valid 'expose' entries\n        for invalid_expose in self.INVALID_PORT_MAPPINGS + self.VALID_PORT_MAPPINGS:\n            with pytest.raises(ConfigurationError) as exc:\n                self.check_config({'expose': invalid_expose})\n            assert \"should be of the format\" in exc.value.msg\n", "docstring": "Valid port mappings ARE NOT valid 'expose' entries"}
{"repo": "compose-master/tests/unit/config/config_test.py", "original_string": "    def test_memswap_can_be_a_string(self):\n        service_dict = config.load(\n            build_config_details(\n                {'foo': {'image': 'busybox', 'mem_limit': \"1G\", 'memswap_limit': \"512M\"}},\n                'tests/fixtures/extends',\n                'common.yml'\n            )\n        ).services\n        assert service_dict[0]['memswap_limit'] == \"512M\"\n", "docstring": "service_dict = config.load("}
{"repo": "compose-master/tests/integration/metrics_test.py", "original_string": "    def test_metrics_help(cls):\n        # root `docker-compose` command is considered as a `--help`\n        dispatch(cls.base_dir, [], env=MetricsTest.test_env)\n        assert cls.get_content() == \\\n               b'{\"command\": \"compose --help\", \"context\": \"moby\", ' \\\n               b'\"source\": \"docker-compose\", \"status\": \"success\"}'\n        dispatch(cls.base_dir, ['help', 'run'], env=MetricsTest.test_env)\n        assert cls.get_content() == \\\n               b'{\"command\": \"compose help\", \"context\": \"moby\", ' \\\n               b'\"source\": \"docker-compose\", \"status\": \"success\"}'\n        dispatch(cls.base_dir, ['--help'], env=MetricsTest.test_env)\n        assert cls.get_content() == \\\n               b'{\"command\": \"compose --help\", \"context\": \"moby\", ' \\\n               b'\"source\": \"docker-compose\", \"status\": \"success\"}'\n        dispatch(cls.base_dir, ['run', '--help'], env=MetricsTest.test_env)\n        assert cls.get_content() == \\\n               b'{\"command\": \"compose --help run\", \"context\": \"moby\", ' \\\n               b'\"source\": \"docker-compose\", \"status\": \"success\"}'\n        dispatch(cls.base_dir, ['up', '--help', 'extra_args'], env=MetricsTest.test_env)\n        assert cls.get_content() == \\\n               b'{\"command\": \"compose --help up\", \"context\": \"moby\", ' \\\n               b'\"source\": \"docker-compose\", \"status\": \"success\"}'\n", "docstring": "root `docker-compose` command is considered as a `--help`"}
{"repo": "compose-master/tests/integration/project_test.py", "original_string": "    def test_initialize_volumes_external_volumes(self):\n        # Use composetest_ prefix so it gets garbage-collected in tearDown()\n        vol_name = 'composetest_{:x}'.format(random.getrandbits(32))\n        full_vol_name = 'composetest_{}'.format(vol_name)\n        self.client.create_volume(vol_name)\n        config_data = build_config(\n            services=[{\n                'name': 'web',\n                'image': BUSYBOX_IMAGE_WITH_TAG,\n                'command': 'top'\n            }],\n            volumes={\n                vol_name: {'external': True, 'name': vol_name}\n            },\n        )\n        project = Project.from_config(\n            name='composetest',\n            config_data=config_data, client=self.client\n        )\n        project.volumes.initialize()\n        with pytest.raises(NotFound):\n            self.client.inspect_volume(full_vol_name)\n", "docstring": "Use composetest_ prefix so it gets garbage-collected in tearDown()"}
{"repo": "compose-master/tests/integration/service_test.py", "original_string": "    def test_create_container_with_legacy_tmpfs_mount(self):\n        # Ensure tmpfs mounts are converted to tmpfs entries if API version < 1.30\n        # Needed to support long syntax in the 3.2 format\n        client = docker_client({}, version='1.25')\n        container_path = '/container-tmpfs'\n        service = Service('db', client=client, volumes=[\n            MountSpec(type='tmpfs', target=container_path)\n        ], image=BUSYBOX_IMAGE_WITH_TAG, command=['top'], project='composetest')\n        container = service.create_container()\n        service.start_container(container)\n        mount = container.get_mount(container_path)\n        assert mount is None\n        assert container_path in container.get('HostConfig.Tmpfs')\n", "docstring": "Ensure tmpfs mounts are converted to tmpfs entries if API version < 1.30"}
{"repo": "compose-master/tests/integration/service_test.py", "original_string": "    def test_recreate_preserves_volume_with_trailing_slash(self):\n        \"\"\"When the Compose file specifies a trailing slash in the container path, make\n        sure we copy the volume over when recreating.\n        \"\"\"\n        service = self.create_service('data', volumes=[VolumeSpec.parse('/data/')])\n        old_container = create_and_start_container(service)\n        volume_path = old_container.get_mount('/data')['Source']\n        new_container = service.recreate_container(old_container)\n        assert new_container.get_mount('/data')['Source'] == volume_path\n", "docstring": "When the Compose file specifies a trailing slash in the container path, make"}
{"repo": "compose-master/tests/integration/service_test.py", "original_string": "    def test_execute_convergence_plan_recreate(self):\n        service = self.create_service(\n            'db',\n            environment={'FOO': '1'},\n            volumes=[VolumeSpec.parse('/etc')],\n            entrypoint=['top'],\n            command=['-d', '1']\n        )\n        old_container = service.create_container()\n        assert old_container.get('Config.Entrypoint') == ['top']\n        assert old_container.get('Config.Cmd') == ['-d', '1']\n        assert 'FOO=1' in old_container.get('Config.Env')\n        assert old_container.name.startswith('composetest_db_')\n        service.start_container(old_container)\n        old_container.inspect()  # reload volume data\n        volume_path = old_container.get_mount('/etc')['Source']\n        num_containers_before = len(self.client.containers(all=True))\n        service.options['environment']['FOO'] = '2'\n        new_container, = service.execute_convergence_plan(\n            ConvergencePlan('recreate', [old_container]))\n        assert new_container.get('Config.Entrypoint') == ['top']\n        assert new_container.get('Config.Cmd') == ['-d', '1']\n        assert 'FOO=2' in new_container.get('Config.Env')\n        assert new_container.name.startswith('composetest_db_')\n        assert new_container.get_mount('/etc')['Source'] == volume_path\n        if not is_cluster(self.client):\n            assert (\n                'affinity:container==%s' % old_container.id in\n                new_container.get('Config.Env')\n            )\n        else:\n            # In Swarm, the env marker is consumed and the container should be deployed\n            # on the same node.\n            assert old_container.get('Node.Name') == new_container.get('Node.Name')\n        assert len(self.client.containers(all=True)) == num_containers_before\n        assert old_container.id != new_container.id\n        with pytest.raises(APIError):\n            self.client.inspect_container(old_container.id)\n", "docstring": "service = self.create_service("}
{"repo": "compose-master/tests/integration/service_test.py", "original_string": "    def test_scale_with_api_error(self):\n        \"\"\"Test that when scaling if the API returns an error, that error is handled\n        and the remaining threads continue.\n        \"\"\"\n        service = self.create_service('web')\n        next_number = service._next_container_number()\n        service.create_container(number=next_number, quiet=True)\n        with mock.patch(\n            'compose.container.Container.create',\n            side_effect=APIError(\n                message=\"testing\",\n                response={},\n                explanation=\"Boom\")):\n            with mock.patch('sys.stderr', new_callable=StringIO) as mock_stderr:\n                with pytest.raises(OperationFailedError):\n                    service.scale(3)\n        assert len(service.containers()) == 1\n        assert service.containers()[0].is_running\n        assert \"ERROR: for composetest_web_\" in mock_stderr.getvalue()\n        assert \"Cannot create container for service web: Boom\" in mock_stderr.getvalue()\n", "docstring": "Test that when scaling if the API returns an error, that error is handled"}
{"repo": "compose-master/tests/integration/service_test.py", "original_string": "    def test_scale_with_custom_container_name_outputs_warning(self, mock_log):\n        \"\"\"Test that calling scale on a service that has a custom container name\n        results in warning output.\n        \"\"\"\n        service = self.create_service('app', container_name='custom-container')\n        assert service.custom_container_name == 'custom-container'\n        with pytest.raises(OperationFailedError):\n            service.scale(3)\n        captured_output = mock_log.warning.call_args[0][0]\n        assert len(service.containers()) == 1\n        assert \"Remove the custom name to scale the service.\" in captured_output\n", "docstring": "Test that calling scale on a service that has a custom container name"}
{"repo": "compose-master/tests/integration/service_test.py", "original_string": "    def test_scale_with_immediate_exit(self):\n        service = self.create_service('web', image='busybox', command='true')\n        service.scale(2)\n        assert len(service.containers(stopped=True)) == 2\n", "docstring": "service = self.create_service('web', image='busybox', command='true')"}
{"repo": "malsub-master/malsub/core/serv.py", "original_string": "    def __add__(self, other):\n        # insert sort here\n        # return ServiceList(self.list + [other])\n        return ServiceList(sorted(self.list + [other]))\n", "docstring": "insert sort here"}
{"repo": "malsub-master/malsub/core/serv.py", "original_string": "    def __repr__(self):\n        # return repr(self.list)\n        return self.list\n", "docstring": "return repr(self.list)"}
{"repo": "malsub-master/malsub/core/web.py", "original_string": "def parse_domainl(*dom):\n    # doml = []\n    # for d in dom:\n    # \tif regex.isdomain(d):\n    # \t\tdoml += [d]\n    # return doml\n    return [d for d in dom if regex.isdomain(d)]\n", "docstring": "doml = []"}
{"repo": "malsub-master/malsub/core/file.py", "original_string": "    def __init__(self, file):\n        # test for compression\n        self.name = path.basename(file)\n        self.pname = file\n        self.fdl = []\n        # try except ... for \"stat\"\n        self.len = stat(file).st_size\n        self.md5 = md5(file)\n        self.sha256 = sha256(file)\n        # self.type = [pe, pdf, apk, ...]\n", "docstring": "test for compression"}
{"repo": "malsub-master/malsub/core/file.py", "original_string": "def new(*files):\n    # return [File(f) for f in rw.filterff(*files)]\n    # filel = []\n    # for f in files:\n    # \tif tryf(f):\n    # \t\tfilel += [File(f)]\n    # return filel\n    return [File(f) for f in files if isfile(f)]\n", "docstring": "return [File(f) for f in rw.filterff(*files)]"}
{"repo": "malsub-master/malsub/service/malwr.py", "original_string": "    def submit_file(self, file: File):\n        # HTTP 405 Method Not Allowed\n        self.api_subf.data = {**self.get_apikey(), \"shared\": \"yes\"}\n        self.api_subf.file = {\"file\": (file.name, file.fd())}\n        data, _ = request(self.api_subf)\n        data = frmt.jsontree(data)\n        return out.pformat(data)\n", "docstring": "HTTP 405 Method Not Allowed"}
{"repo": "malsub-master/malsub/service/base.py", "original_string": "    def set_apikey(cls, apikey: dict):\n        # cls.__apikey = APIKey(**apikey)\n        # if not (regex.ishex(cls.__apikey.key) and len(cls.__apikey.key) == cls.api_keyl):\n        # \tout.error(f\"class {cls} has an invalid API key \\\"{apikey}\\\"\")\n        cls.__apikey = APIKey(**apikey)\n", "docstring": "cls.__apikey = APIKey(**apikey)"}
{"repo": "malsub-master/malsub/service/maltracker.py", "original_string": "    def report_url(self, url: str):\n        # URL report works with hash values\n        # use 'report_file'\n        # or... compute the hash value of the URL here\n        # and make the request\n        pass\n", "docstring": "URL report works with hash values"}
{"repo": "malsub-master/malsub/service/openphish.py", "original_string": "    def download_file(self, hash: Hash):\n        # self.api_dowf.fulluri = self.api_dowf.url + \"/feed.txt\"\n        data, filename = request(self.api_dowf)\n        rw.writef(\"openphish-community.txt\", data)\n        return \"downloaded \\\"openphish-community.txt\\\"\"\n", "docstring": "self.api_dowf.fulluri = self.api_dowf.url + \"/feed.txt\""}
{"repo": "malsub-master/malsub/common/out.py", "original_string": "def pformat(obj):\n    return __pp.pformat(obj)\n", "docstring": "return __pp.pformat(obj)"}
{"repo": "malsub-master/malsub/common/out.py", "original_string": "    def wrap(obj):\n        # if type(obj.__repr__()) is str:\n        if isinstance(obj.__repr__(), str):\n            return obj\n        else:\n            return wrap(obj.__repr__())\n", "docstring": "if type(obj.__repr__()) is str:"}
{"repo": "mayhem-master/part-4/mayhem_7.py", "original_string": "def publish_sync(queue):\n    \"\"\"Simulates an external publisher of messages.\n    Args:\n        queue (queue.Queue): Queue to publish messages to.\n        n (int): Number of messages to publish.\n    \"\"\"\n    choices = string.ascii_lowercase + string.digits\n    curr_thread = threading.current_thread()\n    THREADS.add(curr_thread.ident)\n    while True:\n        msg_id = str(uuid.uuid4())\n        host_id = \"\".join(random.choices(choices, k=4))\n        instance_name = f\"cattle-{host_id}\"\n        msg = PubSubMessage(message_id=msg_id, instance_name=instance_name)\n        # publish an item\n        queue.put(msg)\n        logging.info(f\"Published {msg}\")\n        # simulate randomness of publishing messages\n        time.sleep(random.random())\n", "docstring": "Simulates an external publisher of messages."}
{"repo": "mayhem-master/part-4/mayhem_7.py", "original_string": "def handle_results(results, msg):\n    \"\"\"Handle exception results for a given message.\"\"\"\n    for result in results:\n        if isinstance(result, RestartFailed):\n            logging.error(f\"Retrying for failure to restart: {msg.hostname}\")\n        elif isinstance(result, Exception):\n            logging.error(f\"Handling general error: {result}\")\n", "docstring": "Handle exception results for a given message.\n"}
{"repo": "mayhem-master/part-4/mayhem_7.py", "original_string": "def handle_exception(executor, loop, context):\n    # context[\"message\"] will always be there; but context[\"exception\"] may not\n    msg = context.get(\"exception\", context[\"message\"])\n    logging.error(f\"Caught exception: {msg}\")\n    logging.info(\"Shutting down...\")\n    asyncio.create_task(shutdown(loop, executor))\n", "docstring": "context[\"message\"] will always be there; but context[\"exception\"] may not"}
{"repo": "mayhem-master/part-4/mayhem_6.py", "original_string": "def publish_sync(queue):\n    \"\"\"Simulates an external publisher of messages.\n    Args:\n        queue (queue.Queue): Queue to publish messages to.\n        n (int): Number of messages to publish.\n    \"\"\"\n    choices = string.ascii_lowercase + string.digits\n    curr_thread = threading.current_thread()\n    THREADS.add(curr_thread.ident)\n    while True:\n        msg_id = str(uuid.uuid4())\n        host_id = \"\".join(random.choices(choices, k=4))\n        instance_name = f\"cattle-{host_id}\"\n        msg = PubSubMessage(message_id=msg_id, instance_name=instance_name)\n        # publish an item\n        queue.put(msg)\n        logging.info(f\"Published {msg}\")\n        # simulate randomness of publishing messages\n        time.sleep(random.random())\n", "docstring": "Simulates an external publisher of messages."}
{"repo": "mayhem-master/part-4/mayhem_6.py", "original_string": "def handle_results(results, msg):\n    \"\"\"Handle exception results for a given message.\"\"\"\n    for result in results:\n        if isinstance(result, RestartFailed):\n            logging.error(f\"Retrying for failure to restart: {msg.hostname}\")\n        elif isinstance(result, Exception):\n            logging.error(f\"Handling general error: {result}\")\n", "docstring": "Handle exception results for a given message.\n"}
{"repo": "mayhem-master/part-4/mayhem_6.py", "original_string": "def handle_exception(executor, loop, context):\n    # context[\"message\"] will always be there; but context[\"exception\"] may not\n    msg = context.get(\"exception\", context[\"message\"])\n    logging.error(f\"Caught exception: {msg}\")\n    logging.info(\"Shutting down...\")\n    asyncio.create_task(shutdown(loop, executor))\n", "docstring": "context[\"message\"] will always be there; but context[\"exception\"] may not"}
{"repo": "mayhem-master/part-4/mayhem_9.py", "original_string": "def publish_sync(queue):\n    \"\"\"Simulates an external publisher of messages.\n    Args:\n        queue (queue.Queue): Queue to publish messages to.\n        n (int): Number of messages to publish.\n    \"\"\"\n    choices = string.ascii_lowercase + string.digits\n    curr_thread = threading.current_thread()\n    THREADS.add(curr_thread.ident)\n    while True:\n        msg_id = str(uuid.uuid4())\n        host_id = \"\".join(random.choices(choices, k=4))\n        instance_name = f\"cattle-{host_id}\"\n        msg = PubSubMessage(message_id=msg_id, instance_name=instance_name)\n        # publish an item\n        queue.put(msg)\n        logging.info(f\"Published {msg}\")\n        # simulate randomness of publishing messages\n        time.sleep(random.random())\n", "docstring": "Simulates an external publisher of messages."}
{"repo": "mayhem-master/part-4/mayhem_9.py", "original_string": "def handle_results(results, msg):\n    \"\"\"Handle exception results for a given message.\"\"\"\n    for result in results:\n        if isinstance(result, RestartFailed):\n            logging.error(f\"Retrying for failure to restart: {msg.hostname}\")\n        elif isinstance(result, Exception):\n            logging.error(f\"Handling general error: {result}\")\n", "docstring": "Handle exception results for a given message.\n"}
{"repo": "mayhem-master/part-4/mayhem_9.py", "original_string": "def handle_exception(executor, loop, context):\n    # context[\"message\"] will always be there; but context[\"exception\"] may not\n    msg = context.get(\"exception\", context[\"message\"])\n    logging.error(f\"Caught exception: {msg}\")\n    logging.info(\"Shutting down...\")\n    asyncio.create_task(shutdown(loop, executor))\n", "docstring": "context[\"message\"] will always be there; but context[\"exception\"] may not"}
{"repo": "mayhem-master/part-4/mayhem_8.py", "original_string": "def publish_sync(queue):\n    \"\"\"Simulates an external publisher of messages.\n    Args:\n        queue (queue.Queue): Queue to publish messages to.\n        n (int): Number of messages to publish.\n    \"\"\"\n    choices = string.ascii_lowercase + string.digits\n    curr_thread = threading.current_thread()\n    THREADS.add(curr_thread.ident)\n    while True:\n        msg_id = str(uuid.uuid4())\n        host_id = \"\".join(random.choices(choices, k=4))\n        instance_name = f\"cattle-{host_id}\"\n        msg = PubSubMessage(message_id=msg_id, instance_name=instance_name)\n        # publish an item\n        queue.put(msg)\n        logging.info(f\"Published {msg}\")\n        # simulate randomness of publishing messages\n        time.sleep(random.random())\n", "docstring": "Simulates an external publisher of messages."}
{"repo": "mayhem-master/part-4/mayhem_8.py", "original_string": "def handle_results(results, msg):\n    \"\"\"Handle exception results for a given message.\"\"\"\n    for result in results:\n        if isinstance(result, RestartFailed):\n            logging.error(f\"Retrying for failure to restart: {msg.hostname}\")\n        elif isinstance(result, Exception):\n            logging.error(f\"Handling general error: {result}\")\n", "docstring": "Handle exception results for a given message.\n"}
{"repo": "mayhem-master/part-4/mayhem_8.py", "original_string": "def handle_exception(executor, loop, context):\n    # context[\"message\"] will always be there; but context[\"exception\"] may not\n    msg = context.get(\"exception\", context[\"message\"])\n    logging.error(f\"Caught exception: {msg}\")\n    logging.info(\"Shutting down...\")\n    asyncio.create_task(shutdown(loop, executor))\n", "docstring": "context[\"message\"] will always be there; but context[\"exception\"] may not"}
{"repo": "mayhem-master/part-3/mayhem_4.py", "original_string": "def handle_results(results, msg):\n    \"\"\"Handle exception results for a given message.\"\"\"\n    for result in results:\n        if isinstance(result, RestartFailed):\n            logging.error(f\"Retrying for failure to restart: {msg.hostname}\")\n        elif isinstance(result, Exception):\n            logging.error(f\"Handling general error: {result}\")\n", "docstring": "Handle exception results for a given message.\n"}
{"repo": "mayhem-master/part-3/mayhem_4.py", "original_string": "def handle_exception(loop, context):\n    # context[\"message\"] will always be there; but context[\"exception\"] may not\n    msg = context.get(\"exception\", context[\"message\"])\n    logging.error(f\"Caught exception: {msg}\")\n    # Removing `shutdown` to illustrate \"deadlocking\" on an error'ed message\n    # where the deadline continues to extend waiting for `asyncio.gather` to\n    # return both tasks\n    #\n    # logging.info(\"Shutting down...\")\n    # asyncio.create_task(shutdown(loop))\n", "docstring": "context[\"message\"] will always be there; but context[\"exception\"] may not"}
{"repo": "mayhem-master/part-3/mayhem_2.py", "original_string": "def handle_exception(loop, context):\n    # context[\"message\"] will always be there; but context[\"exception\"] may not\n    msg = context.get(\"exception\", context[\"message\"])\n    logging.error(f\"Caught exception: {msg}\")\n    logging.info(\"Shutting down...\")\n    asyncio.create_task(shutdown(loop))\n", "docstring": "context[\"message\"] will always be there; but context[\"exception\"] may not"}
{"repo": "mayhem-master/part-3/mayhem_5.py", "original_string": "def handle_results(results, msg):\n    \"\"\"Handle exception results for a given message.\"\"\"\n    for result in results:\n        if isinstance(result, RestartFailed):\n            logging.error(f\"Retrying for failure to restart: {msg.hostname}\")\n        elif isinstance(result, Exception):\n            logging.error(f\"Handling general error: {result}\")\n", "docstring": "Handle exception results for a given message.\n"}
{"repo": "mayhem-master/part-3/mayhem_5.py", "original_string": "def handle_exception(loop, context):\n    # context[\"message\"] will always be there; but context[\"exception\"] may not\n    msg = context.get(\"exception\", context[\"message\"])\n    logging.error(f\"Caught exception: {msg}\")\n    logging.info(\"Shutting down...\")\n    asyncio.create_task(shutdown(loop))\n", "docstring": "context[\"message\"] will always be there; but context[\"exception\"] may not"}
{"repo": "mayhem-master/part-3/mayhem_3.py", "original_string": "def handle_results(results, msg):\n    \"\"\"Handle exception results for a given message.\"\"\"\n    for result in results:\n        if isinstance(result, RestartFailed):\n            logging.error(f\"Retrying for failure to restart: {msg.hostname}\")\n        elif isinstance(result, Exception):\n            logging.error(f\"Handling general error: {result}\")\n", "docstring": "Handle exception results for a given message.\n"}
{"repo": "mayhem-master/part-3/mayhem_3.py", "original_string": "def handle_exception(loop, context):\n    # context[\"message\"] will always be there; but context[\"exception\"] may not\n    msg = context.get(\"exception\", context[\"message\"])\n    logging.error(f\"Caught exception: {msg}\")\n    logging.info(\"Shutting down...\")\n    asyncio.create_task(shutdown(loop))\n", "docstring": "context[\"message\"] will always be there; but context[\"exception\"] may not"}
{"repo": "mayhem-master/part-1/mayhem_7.py", "original_string": "def cleanup(msg, fut):\n    \"\"\"Cleanup tasks related to completing work on a message.\n    Args:\n        msg (PubSubMessage): consumed event message that is done being\n            processed.\n        fut (asyncio.Future): future provided by the callback.\n    \"\"\"\n    # unhelpful simulation of i/o work\n    await asyncio.sleep(random.random())\n    msg.acked = True\n    logging.info(f\"Done. Acked {msg}\")\n", "docstring": "Cleanup tasks related to completing work on a message."}
{"repo": "mayhem-master/part-1/mayhem_1.py", "original_string": "def consume(queue):\n    \"\"\"Consumer client to simulate subscribing to a publisher.\n    Args:\n        queue (queue.Queue): Queue from which to consume messages.\n    \"\"\"\n    while True:\n        # wait for an item from the publisher\n        msg = queue.get()\n        # the publisher emits None to indicate that it is done\n        if msg is None:\n            break\n        # process the msg\n        logging.info(f\"Consumed {msg}\")\n        # simulate i/o operation using sleep\n        time.sleep(random.random())\n", "docstring": "Consumer client to simulate subscribing to a publisher."}
{"repo": "mayhem-master/part-5/test_mayhem_4.py", "original_string": "def create_mock_coro(mocker, monkeypatch):\n    \"\"\"Create a mock-coro pair.\n    The coro can be used to patch an async method while the mock can\n    be used to assert calls to the mocked out method.\n    \"\"\"\n    def _create_mock_coro_pair(to_patch=None):\n        mock = mocker.Mock()\n        async def _coro(*args, **kwargs):\n            return mock(*args, **kwargs)\n        if to_patch:\n            monkeypatch.setattr(to_patch, _coro)\n        return mock, _coro\n    return _create_mock_coro_pair\n", "docstring": "Create a mock-coro pair."}
{"repo": "mayhem-master/part-5/test_mayhem_full.py", "original_string": "def caplog(caplog):\n    \"\"\"Set global test logging levels.\"\"\"\n    caplog.set_level(logging.DEBUG)\n    return caplog\n", "docstring": "Set global test logging levels.\n"}
{"repo": "mayhem-master/part-5/test_mayhem_full.py", "original_string": "def create_mock_coro(mocker, monkeypatch):\n    \"\"\"Create a mock-coro pair.\n    The coro can be used to patch an async method while the mock can\n    be used to assert calls to the mocked out method.\n    \"\"\"\n    def _create_mock_coro_pair(to_patch=None):\n        mock = mocker.Mock()\n        async def _coro(*args, **kwargs):\n            return mock(*args, **kwargs)\n        if to_patch:\n            monkeypatch.setattr(to_patch, _coro)\n        return mock, _coro\n    return _create_mock_coro_pair\n", "docstring": "Create a mock-coro pair."}
{"repo": "mayhem-master/part-5/test_mayhem_5.py", "original_string": "def create_mock_coro(mocker, monkeypatch):\n    \"\"\"Create a mock-coro pair.\n    The coro can be used to patch an async method while the mock can\n    be used to assert calls to the mocked out method.\n    \"\"\"\n    def _create_mock_coro_pair(to_patch=None):\n        mock = mocker.Mock()\n        async def _coro(*args, **kwargs):\n            return mock(*args, **kwargs)\n        if to_patch:\n            monkeypatch.setattr(to_patch, _coro)\n        return mock, _coro\n    return _create_mock_coro_pair\n", "docstring": "Create a mock-coro pair."}
{"repo": "mayhem-master/part-5/test_mayhem_7.py", "original_string": "def create_mock_coro(mocker, monkeypatch):\n    \"\"\"Create a mock-coro pair.\n    The coro can be used to patch an async method while the mock can\n    be used to assert calls to the mocked out method.\n    \"\"\"\n    def _create_mock_coro_pair(to_patch=None):\n        mock = mocker.Mock()\n        async def _coro(*args, **kwargs):\n            return mock(*args, **kwargs)\n        if to_patch:\n            monkeypatch.setattr(to_patch, _coro)\n        return mock, _coro\n    return _create_mock_coro_pair\n", "docstring": "Create a mock-coro pair."}
{"repo": "mayhem-master/part-5/test_mayhem_6.py", "original_string": "def create_mock_coro(mocker, monkeypatch):\n    \"\"\"Create a mock-coro pair.\n    The coro can be used to patch an async method while the mock can\n    be used to assert calls to the mocked out method.\n    \"\"\"\n    def _create_mock_coro_pair(to_patch=None):\n        mock = mocker.Mock()\n        async def _coro(*args, **kwargs):\n            return mock(*args, **kwargs)\n        if to_patch:\n            monkeypatch.setattr(to_patch, _coro)\n        return mock, _coro\n    return _create_mock_coro_pair\n", "docstring": "Create a mock-coro pair."}
{"repo": "mayhem-master/part-5/test_mayhem_6.py", "original_string": "    def _send_signal():\n        # allow the loop to start and work a little bit...\n        time.sleep(0.1)\n        # ...then send a signal\n        os.kill(os.getpid(), signal.SIGTERM)\n", "docstring": "allow the loop to start and work a little bit..."}
{"repo": "mayhem-master/part-5/test_mayhem_3.py", "original_string": "def create_mock_coro(mocker, monkeypatch):\n    \"\"\"Create a mock-coro pair.\n    The coro can be used to patch an async method while the mock can\n    be used to assert calls to the mocked out method.\n    \"\"\"\n    def _create_mock_coro_pair(to_patch=None):\n        mock = mocker.Mock()\n        async def _coro(*args, **kwargs):\n            return mock(*args, **kwargs)\n        if to_patch:\n            monkeypatch.setattr(to_patch, _coro)\n        return mock, _coro\n    return _create_mock_coro_pair\n", "docstring": "Create a mock-coro pair."}
{"repo": "PySR-master/pysr/sr.py", "original_string": "def _set_paths(tempdir):\n    # System-independent paths\n    pkg_directory = Path(__file__).parents[1]\n    default_project_file = pkg_directory / \"Project.toml\"\n    tmpdir = Path(tempfile.mkdtemp(dir=tempdir))\n    hyperparam_filename = tmpdir / f\"hyperparams.jl\"\n    dataset_filename = tmpdir / f\"dataset.jl\"\n    runfile_filename = tmpdir / \"runfile.jl\"\n    X_filename = tmpdir / \"X.csv\"\n    y_filename = tmpdir / \"y.csv\"\n    weights_filename = tmpdir / \"weights.csv\"\n    return dict(\n        pkg_directory=pkg_directory,\n        default_project_file=default_project_file,\n        X_filename=X_filename,\n        dataset_filename=dataset_filename,\n        hyperparam_filename=hyperparam_filename,\n        runfile_filename=runfile_filename,\n        tmpdir=tmpdir,\n        weights_filename=weights_filename,\n        y_filename=y_filename,\n    )\n", "docstring": "System-independent paths"}
{"repo": "PySR-master/pysr/sr.py", "original_string": "def best_row(equations=None):\n    \"\"\"Return the best row of a hall of fame file using the score column.\n    By default this uses the last equation file.\n    \"\"\"\n    if equations is None:\n        equations = get_hof()\n    if isinstance(equations, list):\n        return [eq.iloc[np.argmax(eq[\"score\"])] for eq in equations]\n    return equations.iloc[np.argmax(equations[\"score\"])]\n", "docstring": "Return the best row of a hall of fame file using the score column."}
{"repo": "PySR-master/pysr/sr.py", "original_string": "def best(equations=None):\n    \"\"\"Return the equation with the best score, in sympy format.\n    By default this uses the last equation file.\n    \"\"\"\n    if equations is None:\n        equations = get_hof()\n    if isinstance(equations, list):\n        return [best_row(eq)[\"sympy_format\"].simplify() for eq in equations]\n    return best_row(equations)[\"sympy_format\"].simplify()\n", "docstring": "Return the equation with the best score, in sympy format."}
{"repo": "PySR-master/pysr/sr.py", "original_string": "def _escape_filename(filename):\n    \"\"\"Turns a file into a string representation with correctly escaped backslashes\"\"\"\n    str_repr = str(filename)\n    str_repr = str_repr.replace(\"\\\\\", \"\\\\\\\\\")\n    return str_repr\n", "docstring": "Turns a file into a string representation with correctly escaped backslashes\n"}
{"repo": "PySR-master/pysr/sr.py", "original_string": "def _yesno(question):\n    \"\"\"Simple Yes/No Function.\"\"\"\n    prompt = f\"{question} (y/n): \"\n    ans = input(prompt).strip().lower()\n    if ans not in [\"y\", \"n\"]:\n        print(f\"{ans} is invalid, please try again...\")\n        return _yesno(question)\n    if ans == \"y\":\n        return True\n    return False\n", "docstring": "Simple Yes/No Function.\n"}
{"repo": "PySR-master/pysr/feynman_problems.py", "original_string": "    def __repr__(self):\n        return str(self)\n", "docstring": "return str(self)"}
{"repo": "PySR-master/pysr/feynman_problems.py", "original_string": "def do_feynman_experiments(\n    first=100,\n    verbosity=0,\n    dp=500,\n    output_file_path=\"FeynmanExperiment.csv\",\n    data_dir=FEYNMAN_DATASET,\n", "docstring": "first=100,"}
{"repo": "PySR-master/benchmarks/hyperparamopt.py", "original_string": "def run_trial(args):\n    \"\"\"Evaluate the model loss using the hyperparams in args\n    :args: A dictionary containing all hyperparameters\n    :returns: Dict with status and loss from cross-validation\n    \"\"\"\n    print(\"Running on\", args)\n    args[\"niterations\"] = 100\n    args[\"npop\"] = 100\n    args[\"ncyclesperiteration\"] = 1000\n    args[\"topn\"] = 10\n    args[\"parsimony\"] = 0.0\n    args[\"useFrequency\"] = True\n    args[\"annealing\"] = True\n    if args[\"npop\"] < 20 or args[\"ncyclesperiteration\"] < 3:\n        print(\"Bad parameters\")\n        return {\"status\": \"ok\", \"loss\": np.inf}\n    args[\"weightDoNothing\"] = 1.0\n    ntrials = 3\n    with temp_seed(0):\n        X = np.random.randn(100, 10) * 3\n    eval_str = [\n        \"np.sign(X[:, 2])*np.abs(X[:, 2])**2.5 + 5*np.cos(X[:, 3]) - 5\",\n        \"np.exp(X[:, 0]/2) + 12.0 + np.log(np.abs(X[:, 0])*10 + 1)\",\n        \"(np.exp(X[:, 3]) + 3)/(np.abs(X[:, 1]) + np.cos(X[:, 0]) + 1.1)\",\n        \"X[:, 0] * np.sin(2*np.pi * (X[:, 1] * X[:, 2] - X[:, 3] / X[:, 4])) + 3.0\",\n    ]\n    print(\"Starting\", str(args))\n    try:\n        local_trials = []\n        for i in range(len(eval_str)):\n            print(f\"Starting test {i}\")\n            for j in range(ntrials):\n                print(f\"Starting trial {j}\")\n                y = eval(eval_str[i])\n                trial = pysr.pysr(\n                    X,\n                    y,\n                    procs=4,\n                    populations=20,\n                    binary_operators=[\"plus\", \"mult\", \"pow\", \"div\"],\n                    unary_operators=[\"cos\", \"exp\", \"sin\", \"logm\", \"abs\"],\n                    maxsize=25,\n                    constraints={\"pow\": (-1, 1)},\n                    **args,\n                )\n                if len(trial) == 0:\n                    raise ValueError\n                local_trials.append(\n                    np.min(trial[\"MSE\"]) ** 0.5 / np.std(eval(eval_str[i - 1]))\n                )\n                print(f\"Test {i} trial {j} with\", str(args), f\"got {local_trials[-1]}\")\n    except ValueError:\n        print(\"Broken\", str(args))\n        return {\"status\": \"ok\", \"loss\": np.inf}  # or 'fail' if nan loss\n    loss = np.average(local_trials)\n    print(f\"Finished with {loss}\", str(args))\n    return {\"status\": \"ok\", \"loss\": loss}  # or 'fail' if nan loss\n", "docstring": "Evaluate the model loss using the hyperparams in args"}
{"repo": "PySR-master/benchmarks/hyperparamopt.py", "original_string": "def merge_trials(trials1, trials2_slice):\n    \"\"\"Merge two hyperopt trials objects\n    :trials1: The primary trials object\n    :trials2_slice: A slice of the trials object to be merged,\n        obtained with, e.g., trials2.trials[:10]\n    :returns: The merged trials object\n    \"\"\"\n    max_tid = 0\n    if len(trials1.trials) > 0:\n        max_tid = max([trial[\"tid\"] for trial in trials1.trials])\n    for trial in trials2_slice:\n        tid = trial[\"tid\"] + max_tid + 1\n        local_hyperopt_trial = Trials().new_trial_docs(\n            tids=[None], specs=[None], results=[None], miscs=[None]\n        )\n        local_hyperopt_trial[0] = trial\n        local_hyperopt_trial[0][\"tid\"] = tid\n        local_hyperopt_trial[0][\"misc\"][\"tid\"] = tid\n        for key in local_hyperopt_trial[0][\"misc\"][\"idxs\"].keys():\n            local_hyperopt_trial[0][\"misc\"][\"idxs\"][key] = [tid]\n        trials1.insert_trial_docs(local_hyperopt_trial)\n        trials1.refresh()\n    return trials1\n", "docstring": "Merge two hyperopt trials objects"}
{"repo": "photohash-master/photohash/photohash.py", "original_string": "def hash_distance(left_hash, right_hash):\n    \"\"\"Compute the hamming distance between two hashes\"\"\"\n    if len(left_hash) != len(right_hash):\n        raise ValueError('Hamming distance requires two strings of equal length')\n    return sum(map(lambda x: 0 if x[0] == x[1] else 1, zip(left_hash, right_hash)))\n", "docstring": "Compute the hamming distance between two hashes\n"}
{"repo": "photohash-master/photohash/photohash.py", "original_string": "def average_hash(image_path, hash_size=8):\n    \"\"\" Compute the average hash of the given image. \"\"\"\n    with open(image_path, 'rb') as f:\n        # Open the image, resize it and convert it to black & white.\n        image = Image.open(f).resize((hash_size, hash_size), Image.ANTIALIAS).convert('L')\n        pixels = list(image.getdata())\n    avg = sum(pixels) / len(pixels)\n    # Compute the hash based on each pixels value compared to the average.\n    bits = \"\".join(map(lambda pixel: '1' if pixel > avg else '0', pixels))\n    hashformat = \"0{hashlength}x\".format(hashlength=hash_size ** 2 // 4)\n    return int(bits, 2).__format__(hashformat)\n", "docstring": "Compute the average hash of the given image. \n"}
{"repo": "photohash-master/photohash/tests/test_photohash.py", "original_string": "    def test_hash_distance(self):\n        \"\"\"hash_distance should know the hamming distance between two strings\"\"\"\n        self.assertEqual(hash_distance('roses', 'toned'), 3)\n        self.assertEqual(hash_distance('are', 'are'), 0)\n        self.assertEqual(hash_distance('read', 'daer'), 4)\n", "docstring": "hash_distance should know the hamming distance between two strings\n"}
{"repo": "photohash-master/photohash/tests/test_photohash.py", "original_string": "    def test_distance(self):\n        \"\"\"distance should know the distance between the average_hash of two test images\"\"\"\n        for i in range(len(self.photos)):\n            for j in range(i, len(self.photos)):\n                hamming_distance = hash_distance(\n                    self.photos[i]['average_hash'],\n                    self.photos[j]['average_hash']\n                )\n                self.assertEqual(\n                    hamming_distance,\n                    distance(self.photos[i]['path'], self.photos[j]['path'])\n                )\n", "docstring": "distance should know the distance between the average_hash of two test images\n"}
{"repo": "scikit-feature-master/skfeature/utility/entropy_estimators.py", "original_string": "def entropyfromprobs(probs, base=2):\n    # Turn a normalized list of probabilities of discrete outcomes into entropy (base 2)\n    return -sum(map(elog, probs))/log(base)\n", "docstring": "Turn a normalized list of probabilities of discrete outcomes into entropy (base 2)"}
{"repo": "scikit-feature-master/skfeature/utility/entropy_estimators.py", "original_string": "def micd(x, y, k=3, base=2, warning=True):\n    \"\"\" If x is continuous and y is discrete, compute mutual information\n    \"\"\"\n    overallentropy = entropy(x, k, base)\n    n = len(y)\n    word_dict = dict()\n    for sample in y:\n        word_dict[sample] = word_dict.get(sample, 0) + 1./n\n    yvals = list(set(word_dict.keys()))\n    mi = overallentropy\n    for yval in yvals:\n        xgiveny = [x[i] for i in range(n) if y[i] == yval]\n        if k <= len(xgiveny) - 1:\n            mi -= word_dict[yval]*entropy(xgiveny, k, base)\n        else:\n            if warning:\n                print(\"Warning, after conditioning, on y={0} insufficient data. Assuming maximal entropy in this case.\".format(yval))\n            mi -= word_dict[yval]*overallentropy\n    return mi  # units already applied\n", "docstring": "If x is continuous and y is discrete, compute mutual information"}
{"repo": "scikit-feature-master/skfeature/utility/entropy_estimators.py", "original_string": "def avgdigamma(points, dvec):\n    # This part finds number of neighbors in some radius in the marginal space\n    # returns expectation value of <psi(nx)>\n    N = len(points)\n    tree = ss.cKDTree(points)\n    avg = 0.\n    for i in range(N):\n        dist = dvec[i]\n        # subtlety, we don't include the boundary point,\n        # but we are implicitly adding 1 to kraskov def bc center point is included\n        num_points = len(tree.query_ball_point(points[i], dist-1e-15, p=float('inf')))\n        avg += digamma(num_points)/N\n    return avg\n", "docstring": "This part finds number of neighbors in some radius in the marginal space"}
{"repo": "scikit-feature-master/skfeature/example/test_MIM.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/colon.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 10    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the index of each feature on the training set\n        idx,_,_ = MIM.mim(X[train], y[train], n_selected_features=num_fea)\n        # obtain the dataset on the selected features\n        features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_CFS.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/colon.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 100    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the index of selected features on training set\n        idx = CFS.cfs(X[train], y[train])\n        # obtain the dataset on the selected features\n        selected_features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(selected_features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(selected_features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_ls_l21.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    Y = construct_label_matrix_pan(y)\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 100    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the feature weight matrix\n        Weight, obj, value_gamma = ls_l21.proximal_gradient_descent(X[train], Y[train], 0.1, verbose=False)\n        # sort the feature scores in an ascending order according to the feature scores\n        idx = feature_ranking(Weight)\n        # obtain the dataset on the selected features\n        selected_features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(selected_features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(selected_features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_ll_l21.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    Y = construct_label_matrix_pan(y)\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 100    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the feature weight matrix\n        Weight, obj, value_gamma = ll_l21.proximal_gradient_descent(X[train], Y[train], 0.1, verbose=False)\n        # sort the feature scores in an ascending order according to the feature scores\n        idx = feature_ranking(Weight)\n        # obtain the dataset on the selected features\n        selected_features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(selected_features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(selected_features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_MIFS.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/BASEHOCK.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 10    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the index of each feature on the training set\n        idx = MIFS.mifs(X[train], y[train], n_selected_features=num_fea)\n        # obtain the dataset on the selected features\n        features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        print acc\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_MCFS.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    # construct affinity matrix\n    kwargs = {\"metric\": \"euclidean\", \"neighborMode\": \"knn\", \"weightMode\": \"heatKernel\", \"k\": 5, 't': 1}\n    W = construct_W.construct_W(X, **kwargs)\n    num_fea = 100    # specify the number of selected features\n    num_cluster = 20    # specify the number of clusters, it is usually set as the number of classes in the ground truth\n    # obtain the feature weight matrix\n    Weight = MCFS.mcfs(X, n_selected_features=num_fea, W=W, n_clusters=20)\n    # sort the feature scores in an ascending order according to the feature scores\n    idx = MCFS.feature_ranking(Weight)\n    # obtain the dataset on the selected features\n    selected_features = X[:, idx[0:num_fea]]\n    # perform kmeans clustering based on the selected features and repeats 20 times\n    nmi_total = 0\n    acc_total = 0\n    for i in range(0, 20):\n        nmi, acc = unsupervised_evaluation.evaluation(X_selected=selected_features, n_clusters=num_cluster, y=y)\n        nmi_total += nmi\n        acc_total += acc\n    # output the average NMI and average ACC\n    print 'NMI:', float(nmi_total)/20\n    print 'ACC:', float(acc_total)/20\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_FCBF.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/colon.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 10    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the index of each feature on the training set\n        idx = FCBF.fcbf(X[train], y[train], n_selected_features=num_fea)\n        # obtain the dataset on the selected features\n        features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_CIFE.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/colon.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 10    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the index of each feature on the training set\n        idx,_,_ = CIFE.cife(X[train], y[train], n_selected_features=num_fea)\n        # obtain the dataset on the selected features\n        features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_alpha_investing.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    y = y.astype(float)\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the index of selected features\n        idx = alpha_investing.alpha_investing(X[train], y[train], 0.05, 0.05)\n        # obtain the dataset on the selected features\n        selected_features = X[:, idx]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(selected_features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(selected_features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_low_variance.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/BASEHOCK.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    p = 0.1    # specify the threshold p to be 0.1\n    num_cluster = 2    # specify the number of clusters to be 2\n    # perform feature selection and obtain the dataset on the selected features\n    selected_features = low_variance.low_variance_feature_selection(X, p*(1-p))\n    # perform kmeans clustering based on the selected features and repeats 20 times\n    nmi_total = 0\n    acc_total = 0\n    for i in range(0, 20):\n        nmi, acc = unsupervised_evaluation.evaluation(X_selected=selected_features, n_clusters=num_cluster, y=y)\n        nmi_total += nmi\n        acc_total += acc\n    # output the average NMI and average ACC\n    print 'NMI:', float(nmi_total)/20\n    print 'ACC:', float(acc_total)/20\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_fisher_score.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 100    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the score of each feature on the training set\n        score = fisher_score.fisher_score(X[train], y[train])\n        # rank features in descending order according to score\n        idx = fisher_score.feature_ranking(score)\n        # obtain the dataset on the selected features\n        selected_features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(selected_features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(selected_features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_SPEC.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    # specify the second ranking function which uses all except the 1st eigenvalue\n    kwargs = {'style': 0}\n    # obtain the scores of features\n    score = SPEC.spec(X, **kwargs)\n    # sort the feature scores in an descending order according to the feature scores\n    idx = SPEC.feature_ranking(score, **kwargs)\n    # perform evaluation on clustering task\n    num_fea = 100    # number of selected features\n    num_cluster = 20    # number of clusters, it is usually set as the number of classes in the ground truth\n    # obtain the dataset on the selected features\n    selected_features = X[:, idx[0:num_fea]]\n    # perform kmeans clustering based on the selected features and repeats 20 times\n    nmi_total = 0\n    acc_total = 0\n    for i in range(0, 20):\n        nmi, acc = unsupervised_evaluation.evaluation(X_selected=selected_features, n_clusters=num_cluster, y=y)\n        nmi_total += nmi\n        acc_total += acc\n    # output the average NMI and average ACC\n    print 'NMI:', float(nmi_total)/20\n    print 'ACC:', float(acc_total)/20\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_chi_square.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/BASEHOCK.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 100    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the chi-square score of each feature\n        score = chi_square.chi_square(X, y)\n        # rank features in descending order according to score\n        idx = chi_square.feature_ranking(score)\n        # obtain the dataset on the selected features\n        selected_features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(selected_features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(selected_features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_MRMR.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/colon.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 10    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the index of each feature on the training set\n        idx,_,_ = MRMR.mrmr(X[train], y[train], n_selected_features=num_fea)\n        # obtain the dataset on the selected features\n        features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_svm_forward.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the idx of selected features from the training set\n        idx = svm_forward.svm_forward(X[train], y[train], n_features)\n        # obtain the dataset on the selected features\n        X_selected = X[:, idx]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(X_selected[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(X_selected[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_reliefF.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 100    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the score of each feature on the training set\n        score = reliefF.reliefF(X[train], y[train])\n        # rank features in descending order according to score\n        idx = reliefF.feature_ranking(score)\n        # obtain the dataset on the selected features\n        selected_features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(selected_features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(selected_features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_decision_tree_backward.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the idx of selected features from the training set\n        idx = decision_tree_backward.decision_tree_backward(X[train], y[train], n_features)\n        # obtain the dataset on the selected features\n        X_selected = X[:, idx]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(X_selected[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(X_selected[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_lap_score.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    # construct affinity matrix\n    kwargs_W = {\"metric\": \"euclidean\", \"neighbor_mode\": \"knn\", \"weight_mode\": \"heat_kernel\", \"k\": 5, 't': 1}\n    W = construct_W.construct_W(X, **kwargs_W)\n    # obtain the scores of features\n    score = lap_score.lap_score(X, W=W)\n    # sort the feature scores in an ascending order according to the feature scores\n    idx = lap_score.feature_ranking(score)\n    # perform evaluation on clustering task\n    num_fea = 100    # number of selected features\n    num_cluster = 20    # number of clusters, it is usually set as the number of classes in the ground truth\n    # obtain the dataset on the selected features\n    selected_features = X[:, idx[0:num_fea]]\n    # perform kmeans clustering based on the selected features and repeats 20 times\n    nmi_total = 0\n    acc_total = 0\n    for i in range(0, 20):\n        nmi, acc = unsupervised_evaluation.evaluation(X_selected=selected_features, n_clusters=num_cluster, y=y)\n        nmi_total += nmi\n        acc_total += acc\n    # output the average NMI and average ACC\n    print 'NMI:', float(nmi_total)/20\n    print 'ACC:', float(acc_total)/20\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_t_score.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 100    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the t-score of each feature\n        score = t_score.t_score(X, y)\n        # rank features in descending order according to score\n        idx = t_score.feature_ranking(score)\n        # obtain the dataset on the selected features\n        selected_features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(selected_features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(selected_features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_CMIM.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/colon.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 10    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the index of each feature on the training set\n        idx,_,_ = CMIM.cmim(X[train], y[train], n_selected_features=num_fea)\n        # obtain the dataset on the selected features\n        features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_gini_index.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/colon.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 100    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the gini_index score of each feature\n        score = gini_index.gini_index(X[train], y[train])\n        # rank features in descending order according to score\n        idx = gini_index.feature_ranking(score)\n        # obtain the dataset on the selected features\n        selected_features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(selected_features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(selected_features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_ICAP.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/colon.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 10    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the index of each feature on the training set\n        idx,_,_ = ICAP.icap(X[train], y[train], n_selected_features=num_fea)\n        # obtain the dataset on the selected features\n        features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_f_score.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/colon.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 100    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the f-score of each feature\n        score = f_score.f_score(X, y)\n        # rank features in descending order according to score\n        idx = f_score.feature_ranking(score)\n        # obtain the dataset on the selected features\n        selected_features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(selected_features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(selected_features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_NDFS.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    # construct affinity matrix\n    kwargs = {\"metric\": \"euclidean\", \"neighborMode\": \"knn\", \"weightMode\": \"heatKernel\", \"k\": 5, 't': 1}\n    W = construct_W.construct_W(X, **kwargs)\n    # obtain the feature weight matrix\n    Weight = NDFS.ndfs(X, W=W, n_clusters=20)\n    # sort the feature scores in an ascending order according to the feature scores\n    idx = feature_ranking(Weight)\n    # perform evaluation on clustering task\n    num_fea = 100    # number of selected features\n    num_cluster = 20    # number of clusters, it is usually set as the number of classes in the ground truth\n    # obtain the dataset on the selected features\n    selected_features = X[:, idx[0:num_fea]]\n    # perform kmeans clustering based on the selected features and repeats 20 times\n    nmi_total = 0\n    acc_total = 0\n    for i in range(0, 20):\n        nmi, acc = unsupervised_evaluation.evaluation(X_selected=selected_features, n_clusters=num_cluster, y=y)\n        nmi_total += nmi\n        acc_total += acc\n    # output the average NMI and average ACC\n    print 'NMI:', float(nmi_total)/20\n    print 'ACC:', float(acc_total)/20\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_RFS.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    Y = construct_label_matrix(y)\n    n_samples, n_features = X.shape\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 100    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the feature weight matrix\n        Weight = RFS.rfs(X[train, :], Y[train, :], gamma=0.1)\n        # sort the feature scores in an ascending order according to the feature scores\n        idx = feature_ranking(Weight)\n        # obtain the dataset on the selected features\n        selected_features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(selected_features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(selected_features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        print acc\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_DISR.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/colon.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 10    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the index of each feature on the training set\n        idx,_,_ = DISR.disr(X[train], y[train], n_selected_features=num_fea)\n        # obtain the dataset on the selected features\n        features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_trace_ratio.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 100    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the index of selected features\n        idx, feature_score, subset_score = trace_ratio.trace_ratio(X[train], y[train], num_fea, style='fisher')\n        # obtain the dataset on the selected features\n        selected_features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(selected_features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(selected_features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_decision_tree_forward.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the idx of selected features from the training set\n        idx = decision_tree_forward.decision_tree_forward(X[train], y[train], n_features)\n        # obtain the dataset on the selected features\n        X_selected = X[:, idx]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(X_selected[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(X_selected[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_UDFS.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    # perform evaluation on clustering task\n    num_fea = 100    # number of selected features\n    num_cluster = 20    # number of clusters, it is usually set as the number of classes in the ground truth\n    # obtain the feature weight matrix\n    Weight = UDFS.udfs(X, gamma=0.1, n_clusters=num_cluster)\n    # sort the feature scores in an ascending order according to the feature scores\n    idx = feature_ranking(Weight)\n    # obtain the dataset on the selected features\n    selected_features = X[:, idx[0:num_fea]]\n    # perform kmeans clustering based on the selected features and repeats 20 times\n    nmi_total = 0\n    acc_total = 0\n    for i in range(0, 20):\n        nmi, acc = unsupervised_evaluation.evaluation(X_selected=selected_features, n_clusters=num_cluster, y=y)\n        nmi_total += nmi\n        acc_total += acc\n    # output the average NMI and average ACC\n    print 'NMI:', float(nmi_total)/20\n    print 'ACC:', float(acc_total)/20\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_svm_backward.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/COIL20.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the idx of selected features from the training set\n        idx = svm_backward.svm_backward(X[train], y[train], n_features)\n        # obtain the dataset on the selected features\n        X_selected = X[:, idx]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(X_selected[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(X_selected[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "scikit-feature-master/skfeature/example/test_JMI.py", "original_string": "def main():\n    # load data\n    mat = scipy.io.loadmat('../data/colon.mat')\n    X = mat['X']    # data\n    X = X.astype(float)\n    y = mat['Y']    # label\n    y = y[:, 0]\n    n_samples, n_features = X.shape    # number of samples and number of features\n    # split data into 10 folds\n    ss = cross_validation.KFold(n_samples, n_folds=10, shuffle=True)\n    # perform evaluation on classification task\n    num_fea = 10    # number of selected features\n    clf = svm.LinearSVC()    # linear SVM\n    correct = 0\n    for train, test in ss:\n        # obtain the index of each feature on the training set\n        idx,_,_ = JMI.jmi(X[train], y[train], n_selected_features=num_fea)\n        # obtain the dataset on the selected features\n        features = X[:, idx[0:num_fea]]\n        # train a classification model with the selected features on the training dataset\n        clf.fit(features[train], y[train])\n        # predict the class labels of test data\n        y_predict = clf.predict(features[test])\n        # obtain the classification accuracy on the test data\n        acc = accuracy_score(y[test], y_predict)\n        correct = correct + acc\n    # output the average classification accuracy over all 10 folds\n    print 'Accuracy:', float(correct)/10\n", "docstring": "load data"}
{"repo": "TikTok-Api-master/examples/demo_user_pager.py", "original_string": "def printPage(page):\n    \"\"\"Just prints out each post with timestamp and description\"\"\"\n    for post in page:\n        print(\"{}: {}\".format(datetime.fromtimestamp(post[\"createTime\"]), post[\"desc\"]))\n", "docstring": "Just prints out each post with timestamp and description\n"}
{"repo": "TikTok-Api-master/tests/test_user_pager.py", "original_string": "    def test_page_size(self):\n        \"\"\"Pages should be pretty close to the specified size\"\"\"\n        pager = api.get_user_pager(\"therock\", page_size=5)\n        page = pager.__next__()\n        assert abs(len(page) - 5) <= 2\n        page = pager.__next__()\n        assert abs(len(page) - 5) <= 2\n", "docstring": "Pages should be pretty close to the specified size\n"}
{"repo": "TikTok-Api-master/TikTokApi/tiktokuser.py", "original_string": "    def __init__(self, user_cookie, debug=False, proxy=None):\n        \"\"\"A TikTok User Class. Represents a single user that is logged in.\n        :param user_cookie: The cookies from a signed in session of TikTok.\n         Sign into TikTok.com and run document.cookie in the javascript console\n        and then copy the string and place it into this parameter.\n        \"\"\"\n        self.cookies = user_cookie\n        self.debug = debug\n        self.proxy = proxy\n", "docstring": "A TikTok User Class. Represents a single user that is logged in."}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def __init__(self, **kwargs):\n        \"\"\"The TikTokApi class. Used to interact with TikTok, use get_instance NOT this.\"\"\"\n        # Forces Singleton\n        if TikTokApi.__instance is None:\n            TikTokApi.__instance = self\n        else:\n            raise Exception(\"Only one TikTokApi object is allowed\")\n        logging.basicConfig(level=kwargs.get(\"logging_level\", logging.WARNING))\n        logging.info(\"Class initalized\")\n        # Some Instance Vars\n        self.executablePath = kwargs.get(\"executablePath\", None)\n        if kwargs.get(\"custom_device_id\") != None:\n            raise Exception(\"Please use custom_device_id instead of custom_device_id\")\n        self.custom_device_id = kwargs.get(\"custom_device_id\", None)\n        self.userAgent = (\n            \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) \"\n            \"AppleWebKit/537.36 (KHTML, like Gecko) \"\n            \"Chrome/86.0.4240.111 Safari/537.36\"\n        )\n        self.proxy = kwargs.get(\"proxy\", None)\n        self.custom_verifyFp = kwargs.get(\"custom_verifyFp\")\n        self.signer_url = kwargs.get(\"external_signer\", None)\n        self.request_delay = kwargs.get(\"request_delay\", None)\n        self.requests_extra_kwargs = kwargs.get(\"requests_extra_kwargs\", {})\n        if kwargs.get(\"use_test_endpoints\", False):\n            global BASE_URL\n            BASE_URL = \"https://t.tiktok.com/\"\n        if kwargs.get(\"use_selenium\", False):\n            from .browser_selenium import browser\n        else:\n            from .browser import browser\n        if kwargs.get(\"generate_static_device_id\", False):\n            self.custom_device_id = \"\".join(random.choice(string.digits) for num in range(19))\n        if self.signer_url is None:\n            self.browser = browser(**kwargs)\n            self.userAgent = self.browser.userAgent\n        try:\n            self.timezone_name = self.__format_new_params__(self.browser.timezone_name)\n            self.browser_language = self.__format_new_params__(\n                self.browser.browser_language\n            )\n            self.width = self.browser.width\n            self.height = self.browser.height\n            self.region = self.browser.region\n            self.language = self.browser.language\n        except Exception as e:\n            logging.exception(e)\n            logging.warning(\"An error ocurred while opening your browser but it was ignored.\")\n            logging.warning(\"Are you sure you ran python -m playwright install\")\n            self.timezone_name = \"\"\n            self.browser_language = \"\"\n            self.width = \"1920\"\n            self.height = \"1080\"\n            self.region = \"US\"\n            self.language = \"en\"\n", "docstring": "The TikTokApi class. Used to interact with TikTok, use get_instance NOT this.\n"}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def __del__(self):\n        \"\"\"A basic cleanup method, called automatically from the code\"\"\"\n        try:\n            self.browser.clean_up()\n        except Exception:\n            pass\n        try:\n            get_playwright().stop()\n        except Exception:\n            pass\n        TikTokApi.__instance = None\n", "docstring": "A basic cleanup method, called automatically from the code\n"}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def get_bytes(self, **kwargs) -> bytes:\n        \"\"\"Returns TikTok's response as bytes, similar to get_data\"\"\"\n        (\n            region,\n            language,\n            proxy,\n            maxCount,\n            device_id,\n        ) = self.__process_kwargs__(kwargs)\n        kwargs[\"custom_device_id\"] = device_id\n        if self.signer_url is None:\n            verify_fp, device_id, signature = self.browser.sign_url(**kwargs)\n            userAgent = self.browser.userAgent\n            referrer = self.browser.referrer\n        else:\n            verify_fp, device_id, signature, userAgent, referrer = self.external_signer(\n                kwargs[\"url\"], custom_device_id=kwargs.get(\"custom_device_id\", None)\n            )\n        query = {\"verifyFp\": verify_fp, \"_signature\": signature}\n        url = \"{}&{}\".format(kwargs[\"url\"], urlencode(query))\n        r = requests.get(\n            url,\n            headers={\n                \"Accept\": \"*/*\",\n                \"Accept-Encoding\": \"identity;q=1, *;q=0\",\n                \"Accept-Language\": \"en-US;en;q=0.9\",\n                \"Cache-Control\": \"no-cache\",\n                \"Connection\": \"keep-alive\",\n                \"Host\": url.split(\"/\")[2],\n                \"Pragma\": \"no-cache\",\n                \"Range\": \"bytes=0-\",\n                \"Referer\": \"https://www.tiktok.com/\",\n                \"User-Agent\": userAgent,\n            },\n            proxies=self.__format_proxy(proxy),\n            cookies=self.get_cookies(**kwargs),\n        )\n        return r.content\n", "docstring": "Returns TikTok's response as bytes, similar to get_data\n"}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def search_for_users(self, search_term, count=28, **kwargs) -> list:\n        \"\"\"Returns a list of users that match the search_term\n        ##### Parameters\n        * search_term: The string to search for users by\n            This string is the term you want to search for users by.\n        * count: The number of users to return\n            Note: maximum is around 28 for this type of endpoint.\n        \"\"\"\n        return self.discover_type(search_term, prefix=\"user\", count=count, **kwargs)\n", "docstring": "Returns a list of users that match the search_term"}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def search_for_hashtags(self, search_term, count=28, **kwargs) -> list:\n        \"\"\"Returns a list of hashtags that match the search_term\n        ##### Parameters\n        * search_term: The string to search for music by\n            This string is the term you want to search for music by.\n        * count: The number of music to return\n            Note: maximum is around 28 for this type of endpoint.\n        \"\"\"\n        return self.discover_type(\n            search_term, prefix=\"challenge\", count=count, **kwargs\n        )\n", "docstring": "Returns a list of hashtags that match the search_term"}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def user_posts(self, userID, secUID, count=30, cursor=0, **kwargs) -> dict:\n        \"\"\"Returns an array of dictionaries representing TikToks for a user.\n        ##### Parameters\n        * userID: The userID of the user, which TikTok assigns\n            You can find this from utilizing other methods or\n            just use by_username to find it.\n        * secUID: The secUID of the user, which TikTok assigns\n            You can find this from utilizing other methods or\n            just use by_username to find it.\n        * count: The number of posts to return\n            Note: seems to only support up to ~2,000\n        \"\"\"\n        (\n            region,\n            language,\n            proxy,\n            maxCount,\n            device_id,\n        ) = self.__process_kwargs__(kwargs)\n        kwargs[\"custom_device_id\"] = device_id\n        response = []\n        first = True\n        while len(response) < count:\n            if count < maxCount:\n                realCount = count\n            else:\n                realCount = maxCount\n            query = {\n                \"count\": realCount,\n                \"id\": userID,\n                \"cursor\": cursor,\n                \"type\": 1,\n                \"secUid\": secUID,\n                \"sourceType\": 8,\n                \"appId\": 1233,\n                \"region\": region,\n                \"priority_region\": region,\n                \"language\": language,\n            }\n            api_url = \"{}api/post/item_list/?{}&{}\".format(\n                BASE_URL, self.__add_url_params__(), urlencode(query)\n            )\n            res = self.get_data(url=api_url, **kwargs)\n            if \"itemList\" in res.keys():\n                for t in res.get(\"itemList\", []):\n                    response.append(t)\n            if not res[\"hasMore\"] and not first:\n                logging.info(\"TikTok isn't sending more TikToks beyond this point.\")\n                return response\n            realCount = count - len(response)\n            cursor = res[\"cursor\"]\n            first = False\n        return response[:count]\n", "docstring": "Returns an array of dictionaries representing TikToks for a user."}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def user_page(self, userID, secUID, page_size=30, cursor=0, **kwargs) -> dict:\n        \"\"\"Returns a dictionary listing of one page of TikToks given a user's ID and secUID\n        ##### Parameters\n        * userID: The userID of the user, which TikTok assigns\n            You can find this from utilizing other methods or\n            just use by_username to find it.\n        * secUID: The secUID of the user, which TikTok assigns\n            You can find this from utilizing other methods or\n            just use by_username to find it.\n        * page_size: The number of posts to return per page\n            Gets a specific page of a user, doesn't iterate.\n        * cursor: The offset of a page\n            The offset to return new videos from\n        \"\"\"\n        (\n            region,\n            language,\n            proxy,\n            maxCount,\n            device_id,\n        ) = self.__process_kwargs__(kwargs)\n        kwargs[\"custom_device_id\"] = device_id\n        api_url = (\n            BASE_URL + \"api/post/item_list/?{}&count={}&id={}&type=1&secUid={}\"\n            \"&cursor={}&sourceType=8&appId=1233&region={}&language={}\".format(\n                self.__add_url_params__(),\n                page_size,\n                str(userID),\n                str(secUID),\n                cursor,\n                region,\n                language,\n            )\n        )\n        return self.get_data(url=api_url, **kwargs)\n", "docstring": "Returns a dictionary listing of one page of TikToks given a user's ID and secUID"}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def user_liked(self, userID, secUID, count=30, cursor=0, **kwargs) -> dict:\n        \"\"\"Returns a dictionary listing TikToks that a given a user has liked.\n            Note: The user's likes must be public\n        ##### Parameters\n        * userID: The userID of the user, which TikTok assigns\n        * secUID: The secUID of the user, which TikTok assigns\n        * count: The number of posts to return\n            Note: seems to only support up to ~2,000\n        * cursor: The offset of a page\n            The offset to return new videos from\n        \"\"\"\n        (\n            region,\n            language,\n            proxy,\n            maxCount,\n            device_id,\n        ) = self.__process_kwargs__(kwargs)\n        kwargs[\"custom_device_id\"] = device_id\n        response = []\n        first = True\n        while len(response) < count:\n            if count < maxCount:\n                realCount = count\n            else:\n                realCount = maxCount\n            query = {\n                \"count\": realCount,\n                \"id\": userID,\n                \"type\": 2,\n                \"secUid\": secUID,\n                \"cursor\": cursor,\n                \"sourceType\": 9,\n                \"appId\": 1233,\n                \"region\": region,\n                \"priority_region\": region,\n                \"language\": language,\n            }\n            api_url = \"{}api/favorite/item_list/?{}&{}\".format(\n                BASE_URL, self.__add_url_params__(), urlencode(query)\n            )\n            res = self.get_data(url=api_url, **kwargs)\n            try:\n                res[\"itemList\"]\n            except Exception:\n                logging.error(\"User's likes are most likely private\")\n                return []\n            for t in res.get(\"itemList\", []):\n                response.append(t)\n            if not res[\"hasMore\"] and not first:\n                logging.info(\"TikTok isn't sending more TikToks beyond this point.\")\n                return response\n            realCount = count - len(response)\n            cursor = res[\"cursor\"]\n            first = False\n        return response[:count]\n", "docstring": "Returns a dictionary listing TikToks that a given a user has liked."}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def by_sound(self, id, count=30, offset=0, **kwargs) -> dict:\n        \"\"\"Returns a dictionary listing TikToks with a specific sound.\n        ##### Parameters\n        * id: The sound id to search by\n            Note: Can be found in the URL of the sound specific page or with other methods.\n        * count: The number of posts to return\n            Note: seems to only support up to ~2,000\n        \"\"\"\n        (\n            region,\n            language,\n            proxy,\n            maxCount,\n            device_id,\n        ) = self.__process_kwargs__(kwargs)\n        kwargs[\"custom_device_id\"] = device_id\n        response = []\n        while len(response) < count:\n            if count < maxCount:\n                realCount = count\n            else:\n                realCount = maxCount\n            query = {\n                \"secUid\": \"\",\n                \"musicID\": str(id),\n                \"count\": str(realCount),\n                \"cursor\": offset,\n                \"shareUid\": \"\",\n                \"language\": language,\n            }\n            api_url = \"{}api/music/item_list/?{}&{}\".format(\n                BASE_URL, self.__add_url_params__(), urlencode(query)\n            )\n            res = self.get_data(url=api_url, **kwargs)\n            try:\n                for t in res[\"items\"]:\n                    response.append(t)\n            except KeyError:\n                for t in res.get(\"itemList\", []):\n                    response.append(t)\n            if not res[\"hasMore\"]:\n                logging.info(\"TikTok isn't sending more TikToks beyond this point.\")\n                return response\n            realCount = count - len(response)\n            offset = res[\"cursor\"]\n        return response[:count]\n", "docstring": "Returns a dictionary listing TikToks with a specific sound."}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def get_music_object_full(self, id, **kwargs):\n        \"\"\"Returns a music object for a specific sound id.\n        ##### Parameters\n        * id: The sound id to get the object for\n            This can be found by using other methods.\n        \"\"\"\n        (\n            region,\n            language,\n            proxy,\n            maxCount,\n            device_id,\n        ) = self.__process_kwargs__(kwargs)\n        r = requests.get(\n            \"https://www.tiktok.com/music/-{}\".format(id),\n            headers={\n                \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n                \"authority\": \"www.tiktok.com\",\n                \"Accept-Encoding\": \"gzip, deflate\",\n                \"Connection\": \"keep-alive\",\n                \"Host\": \"www.tiktok.com\",\n                \"User-Agent\": self.userAgent,\n            },\n            proxies=self.__format_proxy(kwargs.get(\"proxy\", None)),\n            cookies=self.get_cookies(**kwargs),\n            **self.requests_extra_kwargs,\n        )\n        j_raw = self.__extract_tag_contents(r.text)\n        return json.loads(j_raw)[\"props\"][\"pageProps\"][\"musicInfo\"]\n", "docstring": "Returns a music object for a specific sound id."}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def by_hashtag(self, hashtag, count=30, offset=0, **kwargs) -> dict:\n        \"\"\"Returns a dictionary listing TikToks with a specific hashtag.\n        ##### Parameters\n        * hashtag: The hashtag to search by\n            Without the # symbol\n            A valid string is \"funny\"\n        * count: The number of posts to return\n            Note: seems to only support up to ~2,000\n        \"\"\"\n        (\n            region,\n            language,\n            proxy,\n            maxCount,\n            device_id,\n        ) = self.__process_kwargs__(kwargs)\n        kwargs[\"custom_device_id\"] = device_id\n        id = self.get_hashtag_object(hashtag)[\"challengeInfo\"][\"challenge\"][\"id\"]\n        response = []\n        required_count = count\n        while len(response) < required_count:\n            if count > maxCount:\n                count = maxCount\n            query = {\n                \"count\": count,\n                \"challengeID\": id,\n                \"type\": 3,\n                \"secUid\": \"\",\n                \"cursor\": offset,\n                \"priority_region\": \"\",\n            }\n            api_url = \"{}api/challenge/item_list/?{}&{}\".format(\n                BASE_URL, self.__add_url_params__(), urlencode(query)\n            )\n            res = self.get_data(url=api_url, **kwargs)\n            for t in res.get(\"itemList\", []):\n                response.append(t)\n            if not res[\"hasMore\"]:\n                logging.info(\"TikTok isn't sending more TikToks beyond this point.\")\n                return response\n            offset += maxCount\n        return response[:required_count]\n", "docstring": "Returns a dictionary listing TikToks with a specific hashtag."}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def get_recommended_tiktoks_by_video_id(self, id, count=30, **kwargs) -> dict:\n        \"\"\"Returns a dictionary listing reccomended TikToks for a specific TikTok video.\n        ##### Parameters\n        * id: The id of the video to get suggestions for\n            Can be found using other methods\n        * count: The count of results you want to return\n        \"\"\"\n        (\n            region,\n            language,\n            proxy,\n            maxCount,\n            device_id,\n        ) = self.__process_kwargs__(kwargs)\n        kwargs[\"custom_device_id\"] = device_id\n        response = []\n        first = True\n        while len(response) < count:\n            if count < maxCount:\n                realCount = count\n            else:\n                realCount = maxCount\n            query = {\n                \"count\": realCount,\n                \"id\": 1,\n                \"secUid\": \"\",\n                \"sourceType\": 12,\n                \"appId\": 1233,\n                \"region\": region,\n                \"priority_region\": region,\n                \"language\": language,\n            }\n            api_url = \"{}api/recommend/item_list/?{}&{}\".format(\n                BASE_URL, self.__add_url_params__(), urlencode(query)\n            )\n            res = self.get_data(url=api_url, **kwargs)\n            for t in res.get(\"itemList\", []):\n                response.append(t)\n            if not res[\"hasMore\"] and not first:\n                logging.info(\"TikTok isn't sending more TikToks beyond this point.\")\n                return response[:count]\n            realCount = count - len(response)\n            first = False\n        return response[:count]\n", "docstring": "Returns a dictionary listing reccomended TikToks for a specific TikTok video."}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def get_tiktok_by_url(self, url, **kwargs) -> dict:\n        \"\"\"Returns a dictionary of a TikTok object by url.\n        ##### Parameters\n        * url: The TikTok url you want to retrieve\n            This currently doesn't support the shortened TikTok\n            url links.\n        \"\"\"\n        (\n            region,\n            language,\n            proxy,\n            maxCount,\n            device_id,\n        ) = self.__process_kwargs__(kwargs)\n        kwargs[\"custom_device_id\"] = device_id\n        custom_device_id = kwargs.get(\"custom_device_id\", None)\n        if \"@\" in url and \"/video/\" in url:\n            post_id = url.split(\"/video/\")[1].split(\"?\")[0]\n        else:\n            raise Exception(\n                \"URL format not supported. Below is an example of a supported url.\\n\"\n                \"https://www.tiktok.com/@therock/video/6829267836783971589\"\n            )\n        return self.get_tiktok_by_id(\n            post_id,\n            **kwargs,\n        )\n", "docstring": "Returns a dictionary of a TikTok object by url."}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def discover_hashtags(self, **kwargs) -> dict:\n        \"\"\"Discover page, consists challenges (hashtags)\"\"\"\n        (\n            region,\n            language,\n            proxy,\n            maxCount,\n            device_id,\n        ) = self.__process_kwargs__(kwargs)\n        kwargs[\"custom_device_id\"] = device_id\n        query = {\"noUser\": 1, \"userCount\": 30, \"scene\": 0}\n        api_url = \"{}node/share/discover?{}&{}\".format(\n            BASE_URL, self.__add_url_params__(), urlencode(query)\n        )\n        return self.get_data(url=api_url, **kwargs)[\"body\"][1][\"exploreList\"]\n", "docstring": "Discover page, consists challenges (hashtags)\n"}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def get_user_object(self, username, **kwargs) -> dict:\n        \"\"\"Gets a user object (dictionary)\n        ##### Parameters\n        * username: The username of the user\n        \"\"\"\n        (\n            region,\n            language,\n            proxy,\n            maxCount,\n            device_id,\n        ) = self.__process_kwargs__(kwargs)\n        kwargs[\"custom_device_id\"] = device_id\n        return self.get_user(username, **kwargs)[\"userInfo\"][\"user\"]\n", "docstring": "Gets a user object (dictionary)"}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def get_video_by_tiktok(self, data, **kwargs) -> bytes:\n        \"\"\"Downloads video from TikTok using a TikTok object.\n        You will need to set a custom_device_id to do this for anything but trending.\n        To do this, this is pretty simple you can either generate one yourself or,\n        you can pass the generate_static_device_id=True into the constructor of the\n        TikTokApi class.\n        ##### Parameters\n        * data: A TikTok object\n            A TikTok JSON object from any other method.\n        \"\"\"\n        (\n            region,\n            language,\n            proxy,\n            maxCount,\n            device_id,\n        ) = self.__process_kwargs__(kwargs)\n        kwargs[\"custom_device_id\"] = device_id\n        try:\n            api_url = data[\"video\"][\"downloadAddr\"]\n        except Exception:\n            try:\n                api_url = data[\"itemInfos\"][\"video\"][\"urls\"][0]\n            except Exception:\n                api_url = data[\"itemInfo\"][\"itemStruct\"][\"video\"][\"playAddr\"]\n        return self.get_video_by_download_url(api_url, **kwargs)\n", "docstring": "Downloads video from TikTok using a TikTok object."}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def get_video_by_url(self, video_url, **kwargs) -> bytes:\n        \"\"\"Downloads a TikTok video by a URL\n        ##### Parameters\n        * video_url: The TikTok url to download the video from\n        \"\"\"\n        (\n            region,\n            language,\n            proxy,\n            maxCount,\n            device_id,\n        ) = self.__process_kwargs__(kwargs)\n        kwargs[\"custom_device_id\"] = device_id\n        tiktok_schema = self.get_tiktok_by_url(video_url, **kwargs)\n        download_url = tiktok_schema[\"itemInfo\"][\"itemStruct\"][\"video\"][\"downloadAddr\"]\n        return self.get_bytes(url=download_url, **kwargs)\n", "docstring": "Downloads a TikTok video by a URL"}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def get_music_title(self, id, **kwargs):\n        \"\"\"Retrieves a music title given an ID\n        ##### Parameters\n        * id: The music id to get the title for\n        \"\"\"\n        r = requests.get(\n            \"https://www.tiktok.com/music/-{}\".format(id),\n            headers={\n                \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n                \"authority\": \"www.tiktok.com\",\n                \"Accept-Encoding\": \"gzip, deflate\",\n                \"Connection\": \"keep-alive\",\n                \"Host\": \"www.tiktok.com\",\n                \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\",\n            },\n            proxies=self.__format_proxy(kwargs.get(\"proxy\", None)),\n            cookies=self.get_cookies(**kwargs),\n            **self.requests_extra_kwargs,\n        )\n        t = r.text\n        j_raw = self.__extract_tag_contents(r.text)\n        music_object = json.loads(j_raw)[\"props\"][\"pageProps\"][\"musicInfo\"]\n        if not music_object.get(\"title\", None):\n            raise TikTokNotFoundError(\"Song of {} id does not exist\".format(str(id)))\n        return music_object[\"title\"]\n", "docstring": "Retrieves a music title given an ID"}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def generate_device_id():\n        \"\"\"Generates a valid device_id for other methods. Pass this as the custom_device_id field to download videos\"\"\"\n        return \"\".join([random.choice(string.digits) for num in range(19)])\n", "docstring": "Generates a valid device_id for other methods. Pass this as the custom_device_id field to download videos\n"}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def __format_new_params__(self, parm) -> str:\n        # TODO: Maybe try not doing this? It should be handled by the urlencode.\n        return parm.replace(\"/\", \"%2F\").replace(\" \", \"+\").replace(\";\", \"%3B\")\n", "docstring": "TODO: Maybe try not doing this? It should be handled by the urlencode."}
{"repo": "TikTok-Api-master/TikTokApi/tiktok.py", "original_string": "    def __extract_tag_contents(self, html):\n        nonce_start = '<head nonce=\"'\n        nonce_end = '\">'\n        nonce = html.split(nonce_start)[1].split(nonce_end)[0]\n        j_raw = html.split(\n            '<script id=\"__NEXT_DATA__\" type=\"application/json\" nonce=\"%s\" crossorigin=\"anonymous\">'\n            % nonce\n        )[1].split(\"</script>\")[0]\n        return j_raw\n", "docstring": "nonce_start = '<head nonce=\"'"}
{"repo": "TikTok-Api-master/TikTokApi/browser.py", "original_string": "    def base36encode(self, number, alphabet=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"):\n        \"\"\"Converts an integer to a base36 string.\"\"\"\n        base36 = \"\"\n        sign = \"\"\n        if number < 0:\n            sign = \"-\"\n            number = -number\n        if 0 <= number < len(alphabet):\n            return sign + alphabet[number]\n        while number != 0:\n            number, i = divmod(number, len(alphabet))\n            base36 = alphabet[i] + base36\n        return sign + base36\n", "docstring": "Converts an integer to a base36 string.\n"}
{"repo": "TikTok-Api-master/TikTokApi/browser_selenium.py", "original_string": "    def base36encode(self, number, alphabet=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"):\n        \"\"\"Converts an integer to a base36 string.\"\"\"\n        base36 = \"\"\n        sign = \"\"\n        if number < 0:\n            sign = \"-\"\n            number = -number\n        if 0 <= number < len(alphabet):\n            return sign + alphabet[number]\n        while number != 0:\n            number, i = divmod(number, len(alphabet))\n            base36 = alphabet[i] + base36\n        return sign + base36\n", "docstring": "Converts an integer to a base36 string.\n"}
{"repo": "blueoil-master/blueoil/tfds_pre_processor.py", "original_string": "def tfds_resize_with_gt_boxes(image, gt_boxes, size=(256, 256)):\n    \"\"\"Resize an image and gt_boxes.\n    Args:\n        image    (tf.Tensor): image with 3 dim\n        gt_boxes (tf.Tensor): Ground truth boxes in the image. shape is [num_boxes, 5(x, y, width, height, class_id)].\n        size: [height, width]\n    \"\"\"\n    orig_height, orig_width, _ = image.get_shape().as_list()\n    height, width = size\n    image = tf.image.resize(image, size)\n    if gt_boxes is None:\n        return image, None\n    scale = [height / orig_height, width / orig_width]\n    if gt_boxes.get_shape().as_list()[0] > 0:\n        gt_boxes = tf.stack([\n            gt_boxes[:, 0] * scale[1],\n            gt_boxes[:, 1] * scale[0],\n            gt_boxes[:, 2] * scale[1],\n            gt_boxes[:, 3] * scale[0],\n            gt_boxes[:, 4]\n        ], 1)\n        gt_boxes = tf.concat([\n            tf.expand_dims(tf.minimum(gt_boxes[:, 0], width - gt_boxes[:, 2]), 1),\n            tf.expand_dims(tf.minimum(gt_boxes[:, 1], height - gt_boxes[:, 3]), 1),\n            gt_boxes[:, 2:]\n        ], 1)\n    return image, gt_boxes\n", "docstring": "Resize an image and gt_boxes."}
{"repo": "blueoil-master/blueoil/tfds_pre_processor.py", "original_string": "    def __call__(self, image, **kwargs):\n        return dict({'image': tf.image.per_image_standardization(image)}, **kwargs)\n", "docstring": "return dict({'image': tf.image.per_image_standardization(image)}, **kwargs)"}
{"repo": "blueoil-master/blueoil/tfds_augmentor.py", "original_string": "def _random_flip_left_right_bounding_box(image, gt_boxes, seed):\n    \"\"\"Flip left right only bounding box.\n    Args:\n        image    (tf.Tensor): image\n        gt_boxes (tf.Tensor): bounding boxes. shape is [num_boxes, 5(x, y, w, h, class_id)]\n        seed     (int)   : seed of a random factor\n    \"\"\"\n    width = image.get_shape().as_list()[1]\n    rand = tf.random.uniform([], minval=0, maxval=1, seed=seed)\n    cond = tf.less(rand, .5)\n    image = tf.cond(\n        cond,\n        lambda: tf.image.flip_left_right(image),\n        lambda: image\n    )\n    gt_boxes = tf.cond(\n        cond,\n        lambda: tf.concat([tf.expand_dims(width - gt_boxes[:, 0] - gt_boxes[:, 2], 1), gt_boxes[:, 1:]], 1),\n        lambda: gt_boxes)\n    return image, gt_boxes\n", "docstring": "Flip left right only bounding box."}
{"repo": "blueoil-master/blueoil/visualize.py", "original_string": "def visualize_classification(image, post_processed, config):\n    \"\"\"Draw classfication result to inference input image.\n    Args:\n        image (np.ndarray): A inference input RGB image to be draw.\n        post_processed (np.ndarray): A one batch output of model be already applied post process.\n            format is defined at https://github.com/blue-oil/blueoil/blob/master/lmnet/docs/specification/output_data.md\n        config (SmartDict): Inference config.\n    Returns:\n        PIL.Image.Image: drawn image object.\n    \"\"\"\n    colormap = get_color_map(len(config.CLASSES))\n    font_size = 16\n    max_class_id = int(np.argmax(post_processed))\n    image_width = image.shape[1]\n    image = PIL.Image.fromarray(image)\n    draw = PIL.ImageDraw.Draw(image)\n    font = PIL.ImageFont.truetype(FONT, font_size)\n    text_color = colormap[max_class_id]\n    class_name = config.CLASSES[max_class_id]\n    score = float(np.max(post_processed))\n    text = \"{}\\n{:.3f}\".format(class_name, score)\n    text_size = draw.multiline_textsize(text, font=font)\n    draw.multiline_text((image_width - text_size[0] - 10, 0), text, fill=text_color, font=font, align=\"right\")\n    return image\n", "docstring": "Draw classfication result to inference input image."}
{"repo": "blueoil-master/blueoil/visualize.py", "original_string": "def visualize_semantic_segmentation(image, post_processed, config):\n    \"\"\"Draw semantic segmentation result mask to image.\n    Args:\n        image (np.ndarray): A inference input RGB image to be draw.\n        post_processed (np.ndarray): A one batch output of model be already applied post process.\n            format is defined at https://github.com/blue-oil/blueoil/blob/master/lmnet/docs/specification/output_data.md\n        config (SmartDict): Inference config.\n    Returns:\n        PIL.Image.Image: drawn image object.\n    \"\"\"\n    colormap = np.array(get_color_map(len(config.CLASSES)), dtype=np.uint8)\n    alpha = 0.5\n    image_height = image.shape[0]\n    image_width = image.shape[1]\n    mask_image = label_to_color_image(np.expand_dims(post_processed, 0), colormap)\n    mask_img = PIL.Image.fromarray(mask_image)\n    mask_img = mask_img.resize(size=(image_width, image_height))\n    result = PIL.Image.blend(PIL.Image.fromarray(image), mask_img, alpha)\n    return result\n", "docstring": "Draw semantic segmentation result mask to image."}
{"repo": "blueoil-master/blueoil/visualize.py", "original_string": "def label_to_color_image(results, colormap):\n    \"\"\"Adds color defined by the colormap to the label.\n    Args:\n        results: A 2D array with float type, storing the segmentation label.\n        colormap: An ndarray with integer type. The number of classes with\n        respective colour label.\n    Returns:\n        A 2D array with integer type. The element of the array\n        is the color indexed by the corresponding element in the input label\n        to the CamVid color map.\n    Raises:\n        ValueError: If label is not of rank 2 or its value is larger than color\n            map maximum entry.\n    \"\"\"\n    if results.ndim != 4:\n        raise ValueError('Expect 4-D input results (1, height, width, classes).')\n    label = np.argmax(results, axis=3)\n    if np.max(label) >= len(colormap):\n        raise ValueError('label value too large.')\n    return np.squeeze(colormap[label])\n", "docstring": "Adds color defined by the colormap to the label."}
{"repo": "blueoil-master/blueoil/pre_processor.py", "original_string": "def resize(image, size=[256, 256], resample=\"NEAREST\"):\n    \"\"\"Resize an image.\n    Args:\n        image (np.ndarray): an image numpy array.\n        size: [height, width]\n        resample (str): A name of resampling filter\n    \"\"\"\n    width = size[1]\n    height = size[0]\n    if width == image.shape[1] and height == image.shape[0]:\n        return image\n    image = PIL.Image.fromarray(np.uint8(image))\n    image = image.resize([width, height], RESAMPLE_METHODS[resample])\n    image = np.array(image)\n    assert image.shape[0] == height\n    assert image.shape[1] == width\n    return image\n", "docstring": "Resize an image."}
{"repo": "blueoil-master/blueoil/pre_processor.py", "original_string": "def resize_with_gt_boxes(image, gt_boxes, size=(256, 256), resample=\"NEAREST\"):\n    \"\"\"Resize an image and gt_boxes.\n    Args:\n        image (np.ndarray): An image numpy array.\n        gt_boxes (np.ndarray): Ground truth boxes in the image. shape is [num_boxes, 5(x, y, width, height, class_id)].\n        size: [height, width]\n        resample (str): A name of resampling filter\n    \"\"\"\n    origin_width = image.shape[1]\n    origin_height = image.shape[0]\n    width = size[1]\n    height = size[0]\n    resized_image = resize(image, (height, width), resample=resample)\n    if gt_boxes is None:\n        return resized_image, None\n    resized_gt_boxes = gt_boxes.copy()\n    scale = [height / origin_height, width / origin_width]\n    if gt_boxes is not None and len(gt_boxes) != 0:\n        resized_gt_boxes[:, 0] = gt_boxes[:, 0] * scale[1]\n        resized_gt_boxes[:, 1] = gt_boxes[:, 1] * scale[0]\n        resized_gt_boxes[:, 2] = gt_boxes[:, 2] * scale[1]\n        resized_gt_boxes[:, 3] = gt_boxes[:, 3] * scale[0]\n        # move boxes beyond boundary of image for scaling error.\n        resized_gt_boxes[:, 0] = np.minimum(resized_gt_boxes[:, 0],\n                                            width - resized_gt_boxes[:, 2])\n        resized_gt_boxes[:, 1] = np.minimum(resized_gt_boxes[:, 1],\n                                            height - resized_gt_boxes[:, 3])\n    return resized_image, resized_gt_boxes\n", "docstring": "Resize an image and gt_boxes."}
{"repo": "blueoil-master/blueoil/pre_processor.py", "original_string": "def resize_with_joints(image, joints, image_size, resample=\"NEAREST\"):\n    \"\"\"Resize image with joints to target image_size.\n    Args:\n        image: a numpy array of shape (height, width, 3).\n        joints: a numpy array of shape (num_joints, 3).\n        image_size: a tuple, (new_height, new_width).\n        resample (str): A name of resampling filter\n    Returns:\n        resized_image: a numpy array of shape (new_height, new_width, 3).\n        new_joints: a numpy array of shape (num_joints, 3).\n    \"\"\"\n    original_height, original_width, _ = image.shape\n    scale_height = image_size[0] / original_height\n    scale_width = image_size[1] / original_width\n    resized_image = resize(image, image_size, resample=resample)\n    new_joints = joints.copy()\n    new_joints[:, 0] *= scale_width\n    new_joints[:, 1] *= scale_height\n    return resized_image, new_joints\n", "docstring": "Resize image with joints to target image_size."}
{"repo": "blueoil-master/blueoil/common.py", "original_string": "def get_color_map(length):\n    # Color Palette for General Purpose\n    # Sample image is here\n    # https://github.com/blue-oil/blueoil/tree/master/docs/_static/color_map.png\n    color_map_base = [\n        (192, 0, 128),  # COLOR00\n        (0, 128, 192),  # COLOR01\n        (0, 128, 64),  # COLOR02\n        (128, 0, 0),  # COLOR03\n        (64, 0, 128),  # COLOR04\n        (64, 0, 192),  # COLOR05\n        (192, 128, 64),  # COLOR06\n        (192, 192, 128),  # COLOR07\n        (64, 64, 128),  # COLOR08\n        (128, 0, 192),  # COLOR09\n        (192, 0, 64),  # COLOR10\n        (128, 128, 64),  # COLOR11\n        (192, 0, 192),  # COLOR12\n        (128, 64, 64),  # COLOR13\n        (64, 192, 128),  # COLOR14\n        (64, 64, 0),  # COLOR15\n        (128, 64, 128),  # COLOR16\n        (128, 128, 192),  # COLOR17\n        (0, 0, 192),  # COLOR18\n        (192, 128, 128),  # COLOR19\n    ]\n    # This function generate arbitrary length color map.\n    color_map = color_map_base * int(math.ceil(length / len(color_map_base)))\n    return color_map[:length]\n", "docstring": "Color Palette for General Purpose"}
{"repo": "blueoil-master/blueoil/post_processor.py", "original_string": "    def _offset_boxes(self, batch_size, num_cell_y, num_cell_x):\n        \"\"\"Numpy implementing of offset_boxes.\n        Return yolo space offset of x and y and w and h.\n        Args:\n            batch_size (int): batch size\n            num_cell_y: Number of cell y. The spatial dimension of the final convolutional features.\n            num_cell_x: Number of cell x. The spatial dimension of the final convolutional features.\n        \"\"\"\n        offset_y = np.arange(num_cell_y)\n        offset_y = np.reshape(offset_y, (1, num_cell_y, 1, 1))\n        offset_y = np.broadcast_to(offset_y, [batch_size, num_cell_y, num_cell_x, self.boxes_per_cell])\n        offset_x = np.arange(num_cell_x)\n        offset_x = np.reshape(offset_x, (1, 1, num_cell_x, 1))\n        offset_x = np.broadcast_to(offset_x, [batch_size, num_cell_y, num_cell_x, self.boxes_per_cell])\n        w_anchors = [anchor_w for anchor_w, anchor_h in self.anchors]\n        offset_w = np.broadcast_to(w_anchors, (batch_size, num_cell_y, num_cell_x, self.boxes_per_cell))\n        offset_w = offset_w.astype(np.float32)\n        h_anchors = [anchor_h for anchor_w, anchor_h in self.anchors]\n        offset_h = np.broadcast_to(h_anchors, (batch_size, num_cell_y, num_cell_x, self.boxes_per_cell))\n        offset_h = offset_h.astype(np.float32)\n        return offset_x, offset_y, offset_w, offset_h\n", "docstring": "Numpy implementing of offset_boxes."}
{"repo": "blueoil-master/blueoil/post_processor.py", "original_string": "    def __init__(self, threshold):\n        self.threshold = threshold\n", "docstring": "self.threshold = threshold"}
{"repo": "blueoil-master/blueoil/post_processor.py", "original_string": "    def _bilinear(inputs, size, compatible_tensorflow_v1=True):\n        output_height = size[0]\n        output_width = size[1]\n        input_height = inputs.shape[0]\n        input_width = inputs.shape[1]\n        if compatible_tensorflow_v1:\n            scale = [(input_height - 1)/(output_height - 1), (input_width - 1)/(output_width - 1)]\n        else:\n            scale = [(input_height - 0)/(output_height - 0), (input_width - 0)/(output_width - 0)]\n        h = np.arange(0, output_height)\n        w = np.arange(0, output_width)\n        if compatible_tensorflow_v1:\n            center_y = h * scale[0]\n            center_x = w * scale[1]\n            int_y = center_y.astype(np.int32)\n            int_x = center_x.astype(np.int32)\n        else:\n            center_y = (h + 0.5) * (scale[0]) - 0.5\n            center_x = (w + 0.5) * (scale[1]) - 0.5\n            int_y = (np.floor(center_y)).astype(np.int32)\n            int_x = (np.floor(center_x)).astype(np.int32)\n        dy = center_y - int_y\n        dx = center_x - int_x\n        dx = np.reshape(dx, (1, output_width, 1))\n        dy = np.reshape(dy, (output_height, 1, 1))\n        top = np.maximum(int_y, 0)\n        bottom = np.minimum(int_y + 1, input_height - 1)\n        left = np.maximum(int_x, 0)\n        right = np.minimum(int_x + 1, input_width - 1)\n        tops = inputs[top, :, :]\n        t_l = tops[:, left, :]\n        t_r = tops[:, right, :]\n        bottoms = inputs[bottom, :, :]\n        b_l = bottoms[:, left, :]\n        b_r = bottoms[:, right, :]\n        t = t_l + (t_r - t_l) * dx\n        b = b_l + (b_r - b_l) * dx\n        output = t + (b - t) * dy\n        return output\n", "docstring": "output_height = size[0]"}
{"repo": "blueoil-master/blueoil/data_processor.py", "original_string": "    def set_image_size(self, image_size):\n        \"\"\"Override processors image size\n        Args:\n            image_size(tuple): (height, width)\n        \"\"\"\n        # Avoid circular import\n        from blueoil.pre_processor import Resize, ResizeWithGtBoxes, ResizeWithMask, LetterBoxes\n        from blueoil.post_processor import FormatYoloV2\n        for process in self.processors:\n            class_list = (Resize, ResizeWithGtBoxes, ResizeWithMask, LetterBoxes)\n            if isinstance(process, class_list):\n                process.size = image_size\n            if isinstance(process, FormatYoloV2):\n                process.image_size = image_size\n", "docstring": "Override processors image size"}
{"repo": "blueoil-master/blueoil/data_processor.py", "original_string": "    def __call__(self, **kwargs):\n        \"\"\"Call processor method for each a element of data.\n        Return image and labels etc.\n        \"\"\"\n        return kwargs\n", "docstring": "Call processor method for each a element of data."}
{"repo": "blueoil-master/blueoil/data_augmentor.py", "original_string": "def _flip_left_right_boundingbox(image, boxes):\n    \"\"\"Flip left right only bounding box.\n    Args:\n        image (np.ndarray): a image. shape is [height, width, channel]\n        boxes (np.ndarray): bounding boxes. shape is [num_boxes, 5(x, y, w, h, class_id)]\n    \"\"\"\n    width = image.shape[1]\n    if len(boxes) > 0:\n        boxes[:, 0] = width - boxes[:, 0] - boxes[:, 2]\n    return boxes\n", "docstring": "Flip left right only bounding box."}
{"repo": "blueoil-master/blueoil/data_augmentor.py", "original_string": "def _flip_top_bottom_boundingbox(img, boxes):\n    \"\"\"Flip top bottom only bounding box.\n    Args:\n        img: np array image.\n        boxes(np.ndarray): bounding boxes. shape is [num_boxes, 5(x, y, w, h, class_id)]\n    \"\"\"\n    height = img.shape[0]\n    if len(boxes) > 0:\n        boxes[:, 1] = height - boxes[:, 1] - boxes[:, 3]\n    return boxes\n", "docstring": "Flip top bottom only bounding box."}
{"repo": "blueoil-master/blueoil/data_augmentor.py", "original_string": "def _random_erasing_in_box(image, box, probability, sl, sh, r1, content_type, mean):\n    \"\"\"Random Erasing in a box (util func).\n    Args:\n        image (np.ndarray): a image. shape is [height, width, channel]\n        box: Ground truth boxes in the image. shape is boxes, [5(x, y, w, h, class)]\n    \"\"\"\n    if random.uniform(0, 1) > probability:\n        return image\n    box_x, box_y = box[0], box[1]\n    box_w, box_h = box[2], box[3]\n    area = box_h * box_w\n    for _ in range(100):\n        target_area = random.uniform(sl, sh) * area\n        aspect_ratio = random.uniform(r1, 1/r1)\n        h = int(round(math.sqrt(target_area * aspect_ratio)))\n        w = int(round(math.sqrt(target_area / aspect_ratio)))\n        if h < box_h and w < box_w:\n            x1 = random.randint(box_x, box_x + box_w - w)\n            y1 = random.randint(box_y, box_y + box_h - h)\n            if content_type == \"mean\":\n                image[y1:y1+h, x1:x1+w, :] = mean\n            elif content_type == \"random\":\n                image[y1:y1+h, x1:x1+w, :] = np.random.randint(255, size=(h, w, 3))\n            return image\n    return image\n", "docstring": "Random Erasing in a box (util func)."}
{"repo": "blueoil-master/blueoil/environment.py", "original_string": "def init(experiment_id):\n    \"\"\"Initialize experiment environment.\n    experiment id embed to directories.\n    \"\"\"\n    global EXPERIMENT_ID, EXPERIMENT_DIR, TENSORBOARD_DIR, CHECKPOINTS_DIR\n    # remove OUTPUT_DIR if it be included in experiment_id.\n    if OUTPUT_DIR + os.path.sep in experiment_id:\n        experiment_id = experiment_id.replace(OUTPUT_DIR + os.path.sep, \"\")\n    EXPERIMENT_ID = experiment_id\n    EXPERIMENT_DIR = _EXPERIMENT_DIR.format(experiment_id=experiment_id)\n    # directory to save this experiment outputs for tensorboard.\n    TENSORBOARD_DIR = _TENSORBOARD_DIR.format(experiment_id=experiment_id)\n    # checkpoints_dir in the same way of tensorboard_dir.\n    CHECKPOINTS_DIR = _CHECKPOINTS_DIR.format(experiment_id=experiment_id)\n", "docstring": "Initialize experiment environment."}
{"repo": "blueoil-master/blueoil/environment.py", "original_string": "def teardown_test_environment():\n    \"\"\"Reset test environment.\"\"\"\n    global DATA_DIR, _EXPERIMENT_DIR, _TENSORBOARD_DIR, _CHECKPOINTS_DIR\n    default_data_dir = \"dataset\"\n    DATA_DIR = os.getenv(\"DATA_DIR\", default_data_dir)\n    default_output_dir = \"saved\"\n    OUTPUT_DIR = os.getenv(\"OUTPUT_DIR\", default_output_dir)\n    _EXPERIMENT_DIR = os.path.join(OUTPUT_DIR, \"{experiment_id}\")\n    _TENSORBOARD_DIR = os.path.join(OUTPUT_DIR, \"{experiment_id}\", \"tensorboard\")\n    _CHECKPOINTS_DIR = os.path.join(OUTPUT_DIR, \"{experiment_id}\", \"checkpoints\")\n", "docstring": "Reset test environment.\n"}
{"repo": "blueoil-master/blueoil/blocks.py", "original_string": "def darknet(name, inputs, filters, kernel_size, is_training=tf.constant(False), activation=None, data_format=\"NHWC\"):\n    \"\"\"Darknet19 block.\n    Do convolution, batch_norm, bias, leaky_relu activation.\n    Ref: https://arxiv.org/pdf/1612.08242.pdf\n         https://github.com/pjreddie/darknet/blob/3bf2f342c03b0ad22efd799d5be9990c9d792354/cfg/darknet19.cfg\n         https://github.com/pjreddie/darknet/blob/8215a8864d4ad07e058acafd75b2c6ff6600b9e8/cfg/yolo.2.0.cfg\n    \"\"\"\n    if data_format == \"NCHW\":\n        channel_data_format = \"channels_first\"\n    elif data_format == \"NHWC\":\n        channel_data_format = \"channels_last\"\n    else:\n        raise ValueError(\"data format must be 'NCHW' or 'NHWC'. got {}.\".format(data_format))\n    with tf.compat.v1.variable_scope(name):\n        if activation is None:\n            def activation(x): return tf.nn.leaky_relu(x, alpha=0.1, name=\"leaky_relu\")\n        conv = conv2d(\"conv\", inputs, filters=filters, kernel_size=kernel_size,\n                      activation=None, use_bias=False, data_format=channel_data_format,\n                      kernel_initializer=tf.variance_scaling_initializer,)  # he initializer\n        # TODO(wakisaka): Should be the same as darknet batch norm.\n        # https://github.com/tensorflow/tensorflow/blob/r1.1/tensorflow/contrib/layers/python/layers/layers.py\n        # https://github.com/pjreddie/darknet/blob/8215a8864d4ad07e058acafd75b2c6ff6600b9e8/src/batchnorm_layer.c#L135\n        batch_normed = batch_norm(\"bn\", conv, is_training=is_training, decay=0.99, scale=True, center=True,\n                                  data_format=data_format)\n        tf.compat.v1.summary.histogram(\"batch_normed\", batch_normed)\n        output = activation(batch_normed)\n        tf.compat.v1.summary.histogram(\"output\", output)\n        return output\n", "docstring": "Darknet19 block."}
{"repo": "blueoil-master/blueoil/networks/lmnet_multi.py", "original_string": "    def placeholders(self):\n        \"\"\"placeholders\"\"\"\n        images_placeholder = tf.compat.v1.placeholder(\n            tf.float32,\n            shape=(self.batch_size, self.image_size[0], self.image_size[1], 3),\n            name=\"images_placeholder\")\n        labels_placeholder = tf.compat.v1.placeholder(\n            tf.bool,\n            shape=(self.batch_size, self.num_classes),\n            name=\"labels_placeholder\")\n        return images_placeholder, labels_placeholder\n", "docstring": "placeholders\n"}
{"repo": "blueoil-master/blueoil/networks/base.py", "original_string": "    def base(self, images, is_training, *args, **kwargs):\n        \"\"\"Base function contains inference.\n        Args:\n            images: Input images.\n            is_training: A flag for if is training.\n        Returns:\n            tf.Tensor: Inference result.\n        \"\"\"\n        raise NotImplementedError()\n", "docstring": "Base function contains inference."}
{"repo": "blueoil-master/blueoil/networks/base.py", "original_string": "    def metrics(self, output, labels):\n        \"\"\"Metrics.\n        Args:\n            output: tensor from inference.\n            labels: labels tensor.\n        \"\"\"\n        raise NotImplementedError()\n", "docstring": "Metrics."}
{"repo": "blueoil-master/blueoil/networks/base.py", "original_string": "    def summary(self, output, labels=None):\n        \"\"\"Summary.\n        Args:\n            output: tensor from inference.\n            labels: labels tensor.\n        \"\"\"\n        var_list = tf.compat.v1.trainable_variables()\n        # Add histograms for all trainable variables like weights in every layer.\n        for var in var_list:\n            tf.compat.v1.summary.histogram(var.op.name, var)\n", "docstring": "Summary."}
{"repo": "blueoil-master/blueoil/networks/segmentation/lm_bisenet.py", "original_string": "    def _weight_decay_loss(self):\n        \"\"\"L2 weight decay (regularization) loss.\"\"\"\n        losses = []\n        print(\"apply l2 loss these variables\")\n        for var in tf.compat.v1.trainable_variables():\n            # exclude batch norm variable\n            if \"kernel\" in var.name:\n                print(var.name)\n                losses.append(tf.nn.l2_loss(var))\n        return tf.add_n(losses) * self.weight_decay_rate\n", "docstring": "L2 weight decay (regularization) loss.\n"}
{"repo": "blueoil-master/blueoil/networks/keypoint_detection/base.py", "original_string": "    def py_post_process(heatmaps, num_dimensions=2, stride=2):\n        \"\"\"Convert from heatmaps to joints, it is mainly used for visualization and metrics in training time.\n        Args:\n            heatmaps: a numpy array of shape (batch_size, height, width, num_joints).\n            num_dimensions: int.\n            stride: int, stride = image_height / heatmap_height.\n        Returns:\n            batch_joints: a numpy array of shape (batch_size, num_joints, 3).\n        \"\"\"\n        batch_size = heatmaps.shape[0]\n        list_joints = [gaussian_heatmap_to_joints(heatmaps[i], num_dimensions, stride=stride)\n                       for i in range(batch_size)]\n        return np.stack(list_joints)\n", "docstring": "Convert from heatmaps to joints, it is mainly used for visualization and metrics in training time."}
{"repo": "blueoil-master/blueoil/networks/keypoint_detection/base.py", "original_string": "    def py_visualize_output(images, heatmaps, stride=2):\n        \"\"\"Visualize pose estimation, it is mainly used for visualization in training time.\n        Args:\n            images: a numpy array of shape (batch_size, height, width, 3).\n            heatmaps: a numpy array of shape (batch_size, height, width, num_joints).\n            stride: int, stride = image_height / heatmap_height.\n        Returns:\n            drawed_images: a numpy array of shape (batch_size, height, width, 3).\n        \"\"\"\n        drawed_images = np.uint8(images * 255.0)\n        for i in range(images.shape[0]):\n            joints = gaussian_heatmap_to_joints(heatmaps[i], stride=stride)\n            drawed_images[i] = visualize_keypoint_detection(drawed_images[i], joints)\n        return drawed_images\n", "docstring": "Visualize pose estimation, it is mainly used for visualization in training time."}
{"repo": "blueoil-master/blueoil/networks/keypoint_detection/base.py", "original_string": "    def _compute_oks(self, output, labels):\n        \"\"\"Compute object keypoint similarity between output and labels.\n        Args:\n            output: a Tensor of shape (batch_size, height, width, num_joints).\n            labels: a Tensor of shape (batch_size, height, width, num_joints).\n        Returns:\n            oks: a Tensor represents object keypoint similarity.\n        \"\"\"\n        joints_gt = self.post_process(labels)\n        joints_pred = self.post_process(output)\n        return tf.compat.v1.py_func(compute_object_keypoint_similarity,\n                                    [joints_gt, joints_pred, self.image_size],\n                                    tf.float32)\n", "docstring": "Compute object keypoint similarity between output and labels."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v2.py", "original_string": "    def placeholders(self):\n        \"\"\"placeholders\"\"\"\n        if self.is_dynamic_image_size:\n            # shape is [batch_size, height, width, 3]\n            if self.data_format == \"NHWC\":\n                images_placeholder = tf.compat.v1.placeholder(\n                    tf.float32,\n                    shape=(self.batch_size, None, None, 3),\n                    name=\"images_placeholder\")\n            if self.data_format == \"NCHW\":\n                images_placeholder = tf.compat.v1.placeholder(\n                    tf.float32,\n                    shape=(self.batch_size, 3, None, None),\n                    name=\"images_placeholder\")\n        else:\n            if self.data_format == \"NHWC\":\n                images_placeholder = tf.compat.v1.placeholder(\n                    tf.float32,\n                    shape=(self.batch_size, self.image_size[0], self.image_size[1], 3),\n                    name=\"images_placeholder\")\n            if self.data_format == \"NCHW\":\n                images_placeholder = tf.compat.v1.placeholder(\n                    tf.float32,\n                    shape=(self.batch_size, 3, self.image_size[0], self.image_size[1]),\n                    name=\"images_placeholder\")\n        labels_placeholder = tf.compat.v1.placeholder(\n            tf.float32,\n            shape=(self.batch_size, self.num_max_boxes, 5),\n            name=\"labels_placeholder\")\n        return images_placeholder, labels_placeholder\n", "docstring": "placeholders\n"}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v2.py", "original_string": "    def convert_gt_boxes_xywh_to_cxcywh(self, gt_boxes):\n        \"\"\"Convert gt_boxes format form (x, y, w, h) to (center_x, center_y, w, h).\n        Args:\n            gt_boxes :3D tensor [batch_size, max_num_boxes, 5(x, y, w, h, class_id)]\n        \"\"\"\n        axis = 2\n        gt_boxes = tf.cast(gt_boxes, tf.float32)\n        gt_boxes_without_label = gt_boxes[:, :, :4]\n        gt_boxes_only_label = tf.reshape(gt_boxes[:, :, 4], [self.batch_size, -1, 1])\n        gt_boxes_without_label = format_XYWH_to_CXCYWH(gt_boxes_without_label, axis=axis)\n        result = tf.concat(axis=axis, values=[gt_boxes_without_label, gt_boxes_only_label], name=\"concat_gt_boxes\")\n        return result\n", "docstring": "Convert gt_boxes format form (x, y, w, h) to (center_x, center_y, w, h)."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v2.py", "original_string": "    def py_offset_boxes(num_cell_y, num_cell_x, batch_size, boxes_per_cell, anchors):\n        \"\"\"Numpy implementing of offset_boxes.\n        Return yolo space offset of x and y and w and h.\n        Args:\n            num_cell_y: Number of cell y. The spatial dimension of the final convolutional features.\n            num_cell_x: Number of cell x. The spatial dimension of the final convolutional features.\n            batch_size: int, Batch size.\n            boxes_per_cell: int, number of boxes per cell.\n            anchors: list of tuples.\n        \"\"\"\n        offset_y = np.arange(num_cell_y)\n        offset_y = np.reshape(offset_y, (1, num_cell_y, 1, 1))\n        offset_y = np.broadcast_to(offset_y, [batch_size, num_cell_y, num_cell_x, boxes_per_cell])\n        offset_x = np.arange(num_cell_x)\n        offset_x = np.reshape(offset_x, (1, 1, num_cell_x, 1))\n        offset_x = np.broadcast_to(offset_x, [batch_size, num_cell_y, num_cell_x, boxes_per_cell])\n        w_anchors = [anchor_w for anchor_w, anchor_h in anchors]\n        offset_w = np.broadcast_to(w_anchors, (batch_size, num_cell_y, num_cell_x, boxes_per_cell))\n        offset_w = offset_w.astype(np.float32)\n        h_anchors = [anchor_h for anchor_w, anchor_h in anchors]\n        offset_h = np.broadcast_to(h_anchors, (batch_size, num_cell_y, num_cell_x, boxes_per_cell))\n        offset_h = offset_h.astype(np.float32)\n        return offset_x, offset_y, offset_w, offset_h\n", "docstring": "Numpy implementing of offset_boxes."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v2.py", "original_string": "    def convert_boxes_space_from_real_to_yolo(self, boxes):\n        \"\"\"Convert boxes space size from real to yolo.\n        Real space boxes coordinates are in the interval [0, image_size].\n        Yolo space boxes x,y are in the interval [-1, 1]. w,h are in the interval [-inf, +inf].\n        Args:\n            boxes: 5D Tensor, shape is [batch_size, num_cell, num_cell, boxes_per_cell, 4(center_x, center_y, w, h)].\n        Returns:\n            resized_boxes: 5D Tensor,\n                           shape is [batch_size, num_cell, num_cell, boxes_per_cell, 4(center_x, center_y, w, h)].\n        \"\"\"\n        image_size_h, image_size_w = tf.cast(self.image_size[0], tf.float32), tf.cast(self.image_size[1], tf.float32)\n        num_cell_y, num_cell_x = tf.cast(self.num_cell[0], tf.float32), tf.cast(self.num_cell[1], tf.float32)\n        offset_x, offset_y, offset_w, offset_h = self.offset_boxes()\n        offset_x, offset_y = tf.cast(offset_x, tf.float32), tf.cast(offset_y, tf.float32)\n        resized_boxes = boxes / [\n            image_size_w,\n            image_size_h,\n            image_size_w,\n            image_size_h,\n        ]\n        epsilon = 1e-10\n        resized_boxes = tf.stack([\n            (resized_boxes[:, :, :, :, 0] * num_cell_x - offset_x),\n            (resized_boxes[:, :, :, :, 1] * num_cell_y - offset_y),\n            tf.math.log(resized_boxes[:, :, :, :, 2] * num_cell_x / offset_w + epsilon),\n            tf.math.log(resized_boxes[:, :, :, :, 3] * num_cell_y / offset_h + epsilon),\n        ], axis=4)\n        return resized_boxes\n", "docstring": "Convert boxes space size from real to yolo."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v2.py", "original_string": "    def _concat_predictions(self, predict_classes, predict_confidence, predict_boxes):\n        \"\"\"Concat predictions to inference output.\n        \"\"\"\n        with tf.name_scope(\"concat_predictions\"):\n            num_cell_y, num_cell_x = self.num_cell[0], self.num_cell[1]\n            output = tf.concat([predict_classes, predict_confidence, predict_boxes], axis=4, name=\"concat_predictions\")\n            output = tf.reshape(\n                output,\n                [self.batch_size, num_cell_y, num_cell_x, self.boxes_per_cell * (self.num_classes + 5)]\n            )\n            return output\n", "docstring": "Concat predictions to inference output."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v2.py", "original_string": "    def _format_output(self, output):\n        \"\"\"Format yolov2 inference output to predict boxes list.\n        Args:\n            output: Tensor of inference() outputs.\n        Return:\n            List of predict_boxes Tensor.\n            The Shape is [batch_size, num_predicted_boxes, 6(x, y, w, h, class_id, score)].\n            The score be calculated by for each class probability and confidence.\n        \"\"\"\n        if self.change_base_output:\n            predict_classes, predict_confidence, predict_boxes = self._split_predictions(output)\n        else:\n            predict_classes, predict_confidence, predict_boxes = self._predictions(output)\n            predict_boxes = self.convert_boxes_space_from_yolo_to_real(predict_boxes)\n        predict_boxes = format_CXCYWH_to_XYWH(predict_boxes, axis=4)\n        results = []\n        for class_id in range(len(self.classes)):\n            predict_prob = predict_classes[:, :, :, :, class_id]\n            predict_score = predict_prob * predict_confidence[:, :, :, :, 0]\n            result = tf.stack([\n                predict_boxes[:, :, :, :, 0],\n                predict_boxes[:, :, :, :, 1],\n                predict_boxes[:, :, :, :, 2],\n                predict_boxes[:, :, :, :, 3],\n                tf.fill(predict_score.shape, float(class_id)),\n                predict_score,\n            ], axis=4)\n            results.append(result)\n        results = tf.concat(results, axis=1)\n        results = tf.reshape(\n            results,\n            [self.batch_size, self.num_cell[0] * self.num_cell[1] * self.boxes_per_cell * self.num_classes, 6]\n        )\n        return results\n", "docstring": "Format yolov2 inference output to predict boxes list."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v2.py", "original_string": "    def _nms(self, formatted_output, iou_threshold, max_output_size, per_class):\n        \"\"\"Non Maximum Suppression.\n        Args:\n            formatted_output: python list of predict_boxes Tensor.\n                predict_boxes shape is [num_predicted_boxes, 6(x, y, w, h, class_id, probability)].\n            iou_threshold(float): The threshold for deciding whether boxes overlap with respect to IOU.\n            max_output_size(int): The maximum number of boxes to be selected\n            per_class(boolean): Whether or not, NMS respect to per class.\n        Returns:\n            python list of predict_boxes Tensor.\n            predict_boxes shape is [num_predicted_boxes, 6(x, y, w, h, class_id, probability)].\n            python list lenght is batch size.\n        \"\"\"\n        results = []\n        for i in range(self.batch_size):\n            predicted_per_batch = formatted_output[i]\n            if per_class:\n                nms_per_batch = []\n                for class_id in range(len(self.classes)):\n                    class_mask = tf.equal(predicted_per_batch[:, 4], class_id)\n                    class_masked = tf.boolean_mask(predicted_per_batch, class_mask)\n                    nms_indices = tf.image.non_max_suppression(\n                        format_XYWH_to_YX(class_masked[:, 0:4], axis=1),\n                        class_masked[:, 5],\n                        max_output_size,\n                        iou_threshold=iou_threshold,\n                        name=\"nms\",\n                    )\n                    nmsed_per_class = tf.gather(class_masked, nms_indices)\n                    nms_per_batch.append(nmsed_per_class)\n                nmsed = tf.concat(nms_per_batch, axis=0)\n            else:\n                nms_indices = tf.image.non_max_suppression(\n                    format_XYWH_to_YX(predicted_per_batch[:, 0:4], axis=1),\n                    predicted_per_batch[:, 5],\n                    max_output_size,\n                    iou_threshold=iou_threshold,\n                    name=\"nms\",\n                )\n                nmsed = tf.gather(predicted_per_batch, nms_indices)\n            results.append(nmsed)\n        return results\n", "docstring": "Non Maximum Suppression."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v2.py", "original_string": "    def _iou_per_gtbox(self, boxes, box):\n        \"\"\"Calculate ious.\n        Args:\n            boxes: 4-D np.ndarray [num_cell, num_cell, boxes_per_cell, 4(x_center, y_center, w, h)]\n            box: 1-D np.ndarray [4(x_center, y_center, w, h)]\n        Return:\n            iou: 3-D np.ndarray [num_cell, num_cell, boxes_per_cell]\n        \"\"\"\n        # left, top, right, bottom\n        # format left, top, right, bottom\n        boxes = np.stack([\n            boxes[:, :, :, 0] - boxes[:, :, :, 2] / 2,\n            boxes[:, :, :, 1] - boxes[:, :, :, 3] / 2,\n            boxes[:, :, :, 0] + boxes[:, :, :, 2] / 2,\n            boxes[:, :, :, 1] + boxes[:, :, :, 3] / 2,\n        ], axis=3)\n        box = np.array([\n            box[0] - box[2] / 2,\n            box[1] - box[3] / 2,\n            box[0] + box[2] / 2,\n            box[1] + box[3] / 2,\n        ])\n        # calculate the left up point\n        left_top = np.maximum(boxes[:, :, :, 0:2], box[0:2])\n        right_bottom = np.minimum(boxes[:, :, :, 2:], box[2:])\n        # calculate intersection. [num_cell, num_cell, boxes_per_cell, 2]\n        inter = right_bottom - left_top\n        inter_square = inter[:, :, :, 0] * inter[:, :, :, 1]\n        mask = (inter[:, :, :, 0] > 0) * (inter[:, :, :, 1] > 0)\n        intersection = mask * inter_square\n        # calculate the boxes1 square and boxes2 square\n        square1 = (boxes[:, :, :, 2] - boxes[:, :, :, 0]) * (boxes[:, :, :, 3] - boxes[:, :, :, 1])\n        square2 = (box[2] - box[0]) * (box[3] - box[1])\n        epsilon = 1e-10\n        union = square1 + square2 - intersection\n        iou = intersection / (union + epsilon)\n        iou[np.isnan(iou)] = 0.0\n        iou = np.clip(iou, 0.0, 1.0)\n        return iou\n", "docstring": "Calculate ious."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v2.py", "original_string": "    def _iou_gt_boxes(self, boxes, gt_boxes_list):\n        \"\"\"Calculate ious between predict box and gt box.\n        And choice best iou for each gt box.\n        Args:\n            boxes: Predicted boxes in real space coordinate.\n                 5-D tensor [batch_size, num_cell, num_cell, boxes_per_cell, 4(x_center, y_center, w, h)].\n            gt_boxes_list: 5-D tensor [batch_size, max_num_boxes, 5(center_x, center_y, w, h, class_id)]\n        Return:\n            iou: 4-D tensor [batch_size, num_cell, num_cell, boxes_per_cell]\n        \"\"\"\n        ious = tf.py_func(\n            self.__iou_gt_boxes,\n            [boxes, gt_boxes_list, self.num_cell],\n            tf.float32\n        )\n        return ious\n", "docstring": "Calculate ious between predict box and gt box."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v2.py", "original_string": "def format_XYWH_to_CXCYWH(boxes, axis=1):\n    \"\"\"Format form (x, y, w, h) to (center_x, center_y, w, h) along specific dimension.\n    Args:\n    boxes :a Tensor include boxes. [:, 4(x, y, w, h)]\n    axis: which dimension of the inputs Tensor is boxes.\n    \"\"\"\n    with tf.name_scope('format_xywh_to_cxcywh'):\n        x, y, w, h = tf.split(axis=axis, num_or_size_splits=4, value=boxes)\n        center_x = x + (w / 2)\n        center_y = y + (h / 2)\n        return tf.concat([center_x, center_y, w, h], axis=axis, name=\"concat_format_xywh_to_cxcywh\")\n", "docstring": "Format form (x, y, w, h) to (center_x, center_y, w, h) along specific dimension."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v2.py", "original_string": "def format_CXCYWH_to_YX(inputs, axis=1):\n    \"\"\"Format from (x, y, w, h) to (y1, x1, y2, x2) boxes along specific dimension.\n    Args:\n      inputs: a Tensor include boxes.\n      axis: which dimension of the inputs Tensor is boxes.\n    \"\"\"\n    with tf.name_scope('format_xywh_to_yx'):\n        center_x, center_y, w, h = tf.split(axis=axis, num_or_size_splits=4, value=inputs)\n        x1 = center_x - (w / 2)\n        x2 = center_x + (w / 2)\n        y1 = center_y - (h / 2)\n        y2 = center_y + (h / 2)\n        return tf.concat([y1, x1, y2, x2], axis=axis, name=\"concat_format_xywh_to_yx\")\n", "docstring": "Format from (x, y, w, h) to (y1, x1, y2, x2) boxes along specific dimension."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v1.py", "original_string": "    def placeholders(self):\n        \"\"\"placeholders\"\"\"\n        images_placeholder = tf.compat.v1.placeholder(\n            tf.float32,\n            shape=(self.batch_size, self.image_size[0], self.image_size[1], 3),\n            name=\"images_placeholder\")\n        labels_placeholder = tf.compat.v1.placeholder(\n            tf.int32,\n            shape=(self.batch_size, self.num_max_boxes, 5),\n            name=\"labels_placeholder\")\n        return images_placeholder, labels_placeholder\n", "docstring": "placeholders\n"}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v1.py", "original_string": "    def convert_gt_boxes_xywh_to_cxcywh(self, gt_boxes):\n        \"\"\"Convert gt_boxes format form (x, y, w, h) to (center_x, center_y, w, h).\n        Args:\n        gt_boxes :3D tensor [batch_size, max_num_boxes, 5(x, y, w, h, class_id)]\n        \"\"\"\n        axis = 2\n        gt_boxes = tf.cast(gt_boxes, tf.float32)\n        gt_boxes_without_label = gt_boxes[:, :, :4]\n        gt_boxes_only_label = tf.reshape(gt_boxes[:, :, 4], [self.batch_size, -1, 1])\n        gt_boxes_without_label = format_XYWH_to_CXCYWH(gt_boxes_without_label, axis=axis)\n        result = tf.concat(axis=axis, values=[gt_boxes_without_label, gt_boxes_only_label])\n        return result\n", "docstring": "Convert gt_boxes format form (x, y, w, h) to (center_x, center_y, w, h)."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v1.py", "original_string": "    def convert_boxes_space_from_real_to_yolo(self, boxes):\n        \"\"\"Convert boxes space size from real to yolo.\n        Real space boxes coodinates are in the interval [0, image_size].\n        Yolo space boxes coodinates are in the interval [-1, 1].\n        Args:\n        boxes: 5D Tensor, shape is [batch_size, cell_size, cell_size, boxes_per_cell, 4(center_x, center_y, w, h)].\n        \"\"\"\n        offset_x, offset_y = self.offset_boxes()\n        resized_boxes = boxes / [\n            self.image_size[1],\n            self.image_size[0],\n            self.image_size[1],\n            self.image_size[0],\n        ]\n        resized_boxes = tf.stack([\n            (resized_boxes[:, :, :, :, 0] * self.cell_size - offset_x),\n            (resized_boxes[:, :, :, :, 1] * self.cell_size - offset_y),\n            tf.sqrt(resized_boxes[:, :, :, :, 2]),\n            tf.sqrt(resized_boxes[:, :, :, :, 3]),\n        ], axis=4)\n        return resized_boxes\n", "docstring": "Convert boxes space size from real to yolo."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v1.py", "original_string": "    def _predictions(self, output):\n        \"\"\"Separate combined inference outputs to predictions.\n        Args:\n        output: combined fc outputs 2D Tensor.\n            shape is [batch_size, self.cell_size * self.cell_size * (self.num_classes + self.boxes_per_cell * 5)]\n        Returns:\n        predict_classes: 4D Tensor [batch_size, cell_size, cell_size, num_classes]\n        predict_confidence: 4D Tensor [batch_size, cell_size, cell_size, boxes_per_cell]\n        predict_boxes: 5D Tensor [batch_size, cell_size, cell_size, boxes_per_cell, 4(center_x, center_y, w, h)]\n        \"\"\"\n        boundary_classes = self.cell_size * self.cell_size * self.num_classes\n        boundary_boxes = boundary_classes + self.cell_size * self.cell_size * self.boxes_per_cell\n        predict_classes = tf.reshape(\n            output[:, :boundary_classes],\n            [self.batch_size, self.cell_size, self.cell_size, self.num_classes])\n        predict_confidence = tf.reshape(\n            output[:, boundary_classes:boundary_boxes],\n            [self.batch_size, self.cell_size, self.cell_size, self.boxes_per_cell])\n        predict_boxes = tf.reshape(\n            output[:, boundary_boxes:],\n            [self.batch_size, self.cell_size, self.cell_size, self.boxes_per_cell, 4])\n        return predict_classes, predict_confidence, predict_boxes\n", "docstring": "Separate combined inference outputs to predictions."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v1.py", "original_string": "    def _summary_predict_boxes(self, predict_classes, predict_confidence, predict_boxes, threshold=0.05):\n        \"\"\"Summary predict boxes on tensorboard.\n        Args:\n        predict_classes: [batch_size, cell_size, cell_size, num_classes]\n        predict_confidence: [batch_size, cell_size, cell_size, boxes_per_cell]\n        predict_boxes: [batch_size, cell_size, cell_size, boxes_per_cell, 4(center_x, center_y, w, h)]\n        threshold: threshold of predict score.\n        \"\"\"\n        predict_boxes = self.convert_boxes_space_from_yolo_to_real(predict_boxes)\n        with tf.name_scope(\"raw_predict_boxes\"):\n            resized_predict_boxes_for_summary = tf.reshape(predict_boxes, [self.batch_size, -1, 4])\n            summary_boxes(\n                \"predicted_boxes\",\n                self.images, format_CXCYWH_to_YX(resized_predict_boxes_for_summary, axis=2),\n                self.image_size,\n            )\n        with tf.name_scope(\"predict_boxes\"):\n            # [batch_size, cell_size, cell_size, boxes_per_cell, num_classes]\n            predict_probability = tf.expand_dims(predict_confidence, 4) * tf.expand_dims(predict_classes, 3)\n            tf.compat.v1.summary.histogram(\"predict_probability\", predict_probability)\n            mask = predict_probability > threshold\n            # shape is [batch_size, cell_size, cell_size, boxes_per_cell]\n            box_mask = tf.reduce_any(mask, axis=4)\n            for i in range(self.batch_size):\n                box_mask_by_batch = box_mask[i, :, :, :]\n                predict_boxes_by_batch = predict_boxes[i, :, :, :, :]\n                masked_boxes = tf.boolean_mask(predict_boxes_by_batch, box_mask_by_batch)\n                image = tf.expand_dims(self.images[i, :, :, :], 0)\n                masked_boxes = tf.expand_dims(masked_boxes, 0)\n                summary_boxes(\n                    \"summary_predict_boxes\",\n                    image,\n                    format_CXCYWH_to_YX(masked_boxes, axis=2),\n                    self.image_size,\n                )\n", "docstring": "Summary predict boxes on tensorboard."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v1.py", "original_string": "    def _iou(self, boxes1, boxes2):\n        \"\"\"Calculate ious.\n        Args:\n        boxes1: 5-D tensor [batch_size, cell_size, cell_size, boxes_per_cell, 4(x_center, y_center, w, h)]\n        boxes2: 5-D tensor [batch_size, cell_size, cell_size, boxes_per_cell, 4(x_center, y_center, w, h)]\n        Return:\n        iou: 4-D tensor [batch_size, cell_size, cell_size, boxes_per_cell]\n        \"\"\"\n        # left, top, right, bottom\n        boxes1 = tf.stack([\n            boxes1[:, :, :, :, 0] - boxes1[:, :, :, :, 2] / 2,\n            boxes1[:, :, :, :, 1] - boxes1[:, :, :, :, 3] / 2,\n            boxes1[:, :, :, :, 0] + boxes1[:, :, :, :, 2] / 2,\n            boxes1[:, :, :, :, 1] + boxes1[:, :, :, :, 3] / 2,\n        ], axis=4)\n        # left, top, right, bottom\n        boxes2 = tf.stack([\n            boxes2[:, :, :, :, 0] - boxes2[:, :, :, :, 2] / 2,\n            boxes2[:, :, :, :, 1] - boxes2[:, :, :, :, 3] / 2,\n            boxes2[:, :, :, :, 0] + boxes2[:, :, :, :, 2] / 2,\n            boxes2[:, :, :, :, 1] + boxes2[:, :, :, :, 3] / 2,\n        ], axis=4)\n        # calculate the left up point\n        left_top = tf.maximum(boxes1[:, :, :, :, 0:2], boxes2[:, :, :, :, 0:2])\n        right_bottom = tf.minimum(boxes1[:, :, :, :, 2:], boxes2[:, :, :, :, 2:])\n        # calculate intersection. [batch_size, cell_size, cell_size, boxes_per_cell, 2]\n        inter = right_bottom - left_top\n        inter_square = inter[:, :, :, :, 0] * inter[:, :, :, :, 1]\n        mask = tf.cast(inter[:, :, :, :, 0] > 0, tf.float32) * tf.cast(inter[:, :, :, :, 1] > 0, tf.float32)\n        intersection = mask * inter_square\n        # calculate the boxs1 square and boxs2 square\n        square1 = (boxes1[:, :, :, :, 2] - boxes1[:, :, :, :, 0]) * (boxes1[:, :, :, :, 3] - boxes1[:, :, :, :, 1])\n        square2 = (boxes2[:, :, :, :, 2] - boxes2[:, :, :, :, 0]) * (boxes2[:, :, :, :, 3] - boxes2[:, :, :, :, 1])\n        epsilon = 1e-10\n        union = square1 + square2 - mask * inter_square\n        return intersection / (union + epsilon)\n", "docstring": "Calculate ious."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v1.py", "original_string": "    def _gt_boxes_to_cell_loop_body(self, i, gt_boxes, cell_gt_box, object_mask):\n        \"\"\"Calculate the gt_boxes corresponding cell.\n        the cell`s object_mask is assigned 1.0 and the cell gt boxes assign gt_boxes coordinate.\n        Args:\n        i: scalr Tensor. while loop counter\n        gt_boxes: 2D Tensor [max_num_boxes, 5(center_x, center_y, w, h, class_id)]\n        cell_gt_box: 3D Tensor [max_num_boxes, 5(center_x, center_y, w, h, class_id)]\n        \"\"\"\n        center_y = gt_boxes[i, 1]\n        center_x = gt_boxes[i, 0]\n        cell_y_index = tf.cast(tf.floor((center_y / self.image_size[1]) * self.cell_size), tf.int32)\n        cell_x_index = tf.cast(tf.floor((center_x / self.image_size[0]) * self.cell_size), tf.int32)\n        boxes = []\n        mask_list = []\n        for y in range(self.cell_size):\n            for x in range(self.cell_size):\n                # Set True, when gt_boxes is in this [y, x] cell.\n                condition = tf.math.logical_and(tf.equal(y, cell_y_index), tf.equal(x, cell_x_index))\n                old_box = cell_gt_box[y, x, :]\n                # If gt_boxes is in this [y, x] cell, the cell_gt_boxes is assigned gt_boxes coordinate,\n                # else is assigned old box coordinate.\n                box = tf.where(condition, gt_boxes[i, :], old_box)\n                # If gt_boxes is in this [y, x] cell, the cell`s object_mask is assigned 1.0(True),\n                # else is assigned old object_mask.\n                mask = tf.where(condition, 1.0, object_mask[y, x, 0])\n                boxes.append(box)\n                mask_list.append(mask)\n        updated_cell_gt_box = tf.reshape(tf.stack(boxes), (self.cell_size, self.cell_size, 5))\n        updated_object_mask = tf.reshape(tf.stack(mask_list), (self.cell_size, self.cell_size, 1))\n        return i + 1, gt_boxes, updated_cell_gt_box, updated_object_mask\n", "docstring": "Calculate the gt_boxes corresponding cell."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v1.py", "original_string": "def format_XYWH_to_CXCYWH(boxes, axis=1):\n    \"\"\"Format form (x, y, w, h) to (center_x, center_y, w, h) along specific dimension.\n    Args:\n    boxes :a Tensor include boxes. [:, 4(x, y, w, h)]\n    axis: which dimension of the inputs Tensor is boxes.\n    \"\"\"\n    with tf.name_scope('format_xywh_to_cxcywh'):\n        x, y, w, h = tf.split(axis=axis, num_or_size_splits=4, value=boxes)\n        center_x = x + w / 2\n        center_y = y + h / 2\n        return tf.concat([center_x, center_y, w, h], axis=axis)\n", "docstring": "Format form (x, y, w, h) to (center_x, center_y, w, h) along specific dimension."}
{"repo": "blueoil-master/blueoil/networks/object_detection/yolo_v1.py", "original_string": "def format_CXCYWH_to_YX(inputs, axis=1):\n    \"\"\"Format from (x, y, w, h) to (y1, x1, y2, x2) boxes along specific dimension.\n    Args:\n      inputs: a Tensor include boxes.\n      axis: which dimension of the inputs Tensor is boxes.\n    \"\"\"\n    with tf.name_scope('format_xywh_to_yx'):\n        center_x, center_y, w, h = tf.split(axis=axis, num_or_size_splits=4, value=inputs)\n        x1 = center_x - (w / 2)\n        x2 = center_x + (w / 2)\n        y1 = center_y - (h / 2)\n        y2 = center_y + (h / 2)\n        return tf.concat([y1, x1, y2, x2], axis=axis)\n", "docstring": "Format from (x, y, w, h) to (y1, x1, y2, x2) boxes along specific dimension."}
{"repo": "blueoil-master/blueoil/networks/classification/lm_resnet.py", "original_string": "    def _conv2d_fix_padding(inputs, filters, kernel_size, strides):\n        \"\"\"Convolution layer deals with stride of 2\"\"\"\n        if strides == 2:\n            inputs = tf.space_to_depth(inputs, block_size=2, name=\"pool\")\n        return tf.layers.conv2d(\n            inputs, filters, kernel_size,\n            padding=\"SAME\",\n            kernel_initializer=tf.contrib.layers.xavier_initializer(),\n            use_bias=False)\n", "docstring": "Convolution layer deals with stride of 2\n"}
{"repo": "blueoil-master/blueoil/networks/classification/base.py", "original_string": "    def inference(self, images, is_training):\n        \"\"\"inference.\n        Args:\n            images: images tensor. shape is (batch_num, height, width, channel)\n            is_training:\n        \"\"\"\n        base = self.base(images, is_training)\n        softmax = tf.nn.softmax(base)\n        self.output = tf.identity(softmax, name=\"output\")\n        return self.output\n", "docstring": "inference."}
{"repo": "blueoil-master/blueoil/networks/classification/lmnet_v0.py", "original_string": "    def base(self, images, is_training, *args, **kwargs):\n        \"\"\"Base network.\n        Args:\n            images: Input images.\n            is_training: A flag for if is training.\n        Returns:\n            tf.Tensor: Inference result.\n        \"\"\"\n        channels_data_format = 'channels_last' if self.data_format == 'NHWC' else 'channels_first'\n        _lmnet_block = self._get_lmnet_block(is_training, channels_data_format)\n        _max_pooling2d = functools.partial(tf.compat.v1.layers.max_pooling2d, pool_size=2, strides=2, padding='SAME',\n                                           data_format=channels_data_format)\n        self.images = images\n        x = _lmnet_block('conv1', images, 32, 3)\n        x = _max_pooling2d(name='pool1', inputs=x)\n        x = _lmnet_block('conv2', x, 64, 3)\n        x = _max_pooling2d(name='pool2', inputs=x)\n        x = _lmnet_block('conv3', x, 128, 3)\n        x = _max_pooling2d(name='pool3', inputs=x)\n        x = _lmnet_block('conv4', x, 256, 3)\n        x = _max_pooling2d(name='pool4', inputs=x)\n        x = _lmnet_block('conv5', x, 256, 3)\n        x = _max_pooling2d(name='pool5', inputs=x)\n        x = _lmnet_block('conv6', x, 64, 1, activation=tf.nn.relu)\n        x = tf.compat.v1.layers.dropout(x, training=is_training)\n        kernel_initializer = tf.compat.v1.random_normal_initializer(mean=0.0, stddev=0.01)\n        x = tf.compat.v1.layers.conv2d(name='conv7',\n                                       inputs=x,\n                                       filters=self.num_classes,\n                                       kernel_size=1,\n                                       kernel_initializer=kernel_initializer,\n                                       activation=None,\n                                       use_bias=True,\n                                       data_format=channels_data_format)\n        self._heatmap_layer = x\n        h = x.get_shape()[1].value if self.data_format == 'NHWC' else x.get_shape()[2].value\n        w = x.get_shape()[2].value if self.data_format == 'NHWC' else x.get_shape()[3].value\n        x = tf.compat.v1.layers.average_pooling2d(name='pool7',\n                                                  inputs=x,\n                                                  pool_size=[h, w],\n                                                  padding='VALID',\n                                                  strides=1,\n                                                  data_format=channels_data_format)\n        self.base_output = tf.reshape(x, [-1, self.num_classes], name='pool7_reshape')\n        return self.base_output\n", "docstring": "Base network."}
{"repo": "blueoil-master/blueoil/datasets/image_folder.py", "original_string": "    def classes(self):\n        \"\"\"Returns the classes list in the data set.\"\"\"\n        classes = os.listdir(self.data_dir)\n        classes = [class_name for class_name in classes if class_name != \".DS_Store\"]\n        classes.sort(key=lambda item: item.lower())\n        return classes\n", "docstring": "Returns the classes list in the data set.\n"}
{"repo": "blueoil-master/blueoil/datasets/fer_2013.py", "original_string": "    def num_classes(self):\n        \"\"\"Returns the number of classes\"\"\"\n        return len(self.classes)\n", "docstring": "Returns the number of classes\n"}
{"repo": "blueoil-master/blueoil/datasets/fer_2013.py", "original_string": "    def num_per_epoch(self):\n        \"\"\"Returns the number of datas in the data subset\"\"\"\n        return len(self.images)\n", "docstring": "Returns the number of datas in the data subset\n"}
{"repo": "blueoil-master/blueoil/datasets/dataset_iterator.py", "original_string": "    def read(self):\n        \"\"\"Return batch size data.\"\"\"\n        result = []\n        for i in self._gen_ids(self.dataset.batch_size):\n            image, label = self.dataset[i]\n            image, label = _apply_augmentations(self.dataset, image, label)\n            result.append((image, label))\n        return _concat_data(result)\n", "docstring": "Return batch size data.\n"}
{"repo": "blueoil-master/blueoil/datasets/dataset_iterator.py", "original_string": "    def __init__(self, dataset, local_rank):\n        tf_dataset = dataset.tf_dataset.shuffle(1024).repeat()\n        if dataset.tfds_pre_processor or dataset.tfds_augmentor:\n            tf_dataset = tf_dataset.map(map_func=_generate_tfds_map_func(dataset),\n                                        num_parallel_calls=tf.data.experimental.AUTOTUNE)\n        tf_dataset = tf_dataset.batch(dataset.batch_size) \\\n                               .prefetch(tf.data.experimental.AUTOTUNE)\n        iterator = tf.compat.v1.data.make_initializable_iterator(tf_dataset)\n        self.dataset = dataset\n        if local_rank != -1:\n            # For distributed training\n            session_config = tf.compat.v1.ConfigProto(\n                gpu_options=tf.compat.v1.GPUOptions(\n                    allow_growth=True,\n                    visible_device_list=str(local_rank)\n                )\n            )\n        else:\n            session_config = tf.compat.v1.ConfigProto()\n        self.session = tf.compat.v1.Session(config=session_config)\n        self.session.run(iterator.initializer)\n        self.next_batch = iterator.get_next()\n", "docstring": "tf_dataset = dataset.tf_dataset.shuffle(1024).repeat()"}
{"repo": "blueoil-master/blueoil/datasets/dataset_iterator.py", "original_string": "    def update_dataset(self, indices):\n        \"\"\"Update own dataset by indices.\"\"\"\n        # do nothing so far\n        return\n", "docstring": "Update own dataset by indices.\n"}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_2012.py", "original_string": "    def num_max_boxes(self):\n        # calculate by cls.count_max_boxes(self.skip_difficult)\n        if self.skip_difficult:\n            return 39\n        else:\n            return 56\n", "docstring": "calculate by cls.count_max_boxes(self.skip_difficult)"}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_2012.py", "original_string": "    def _image_file_from_image_id(self, image_id):\n        \"\"\"Return image file name of a image.\"\"\"\n        return os.path.join(self.jpegimages_dir, \"{}.jpg\".format(image_id))\n", "docstring": "Return image file name of a image.\n"}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_custom.py", "original_string": "    def num_max_boxes(self):\n        # Took from pascalvoc_2007.py\n        if self.skip_difficult:\n            return 37\n        else:\n            return 42\n", "docstring": "Took from pascalvoc_2007.py"}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_custom.py", "original_string": "    def _image_file_from_image_id(self, image_id):\n        \"\"\"Return image file name of a image.\"\"\"\n        return os.path.join(self.jpegimages_dir, \"{}.jpg\".format(image_id))\n", "docstring": "Return image file name of a image.\n"}
{"repo": "blueoil-master/blueoil/datasets/base.py", "original_string": "    def classes():\n        \"\"\"Return the classes list in the data set.\"\"\"\n        pass\n", "docstring": "Return the classes list in the data set.\n"}
{"repo": "blueoil-master/blueoil/datasets/base.py", "original_string": "    def num_classes():\n        \"\"\"Return the number of classes in the data set.\"\"\"\n        pass\n", "docstring": "Return the number of classes in the data set.\n"}
{"repo": "blueoil-master/blueoil/datasets/base.py", "original_string": "    def extend_dir():\n        \"\"\"Return the extend dir path of the data set.\"\"\"\n        pass\n", "docstring": "Return the extend dir path of the data set.\n"}
{"repo": "blueoil-master/blueoil/datasets/base.py", "original_string": "    def num_per_epoch(self):\n        \"\"\"Returns the number of datas in the data subset.\"\"\"\n        raise DeprecationWarning()\n", "docstring": "Returns the number of datas in the data subset.\n"}
{"repo": "blueoil-master/blueoil/datasets/base.py", "original_string": "    def __getitem__(self, i):\n        \"\"\"Returns the i-th item of the dataset.\"\"\"\n        raise NotImplementedError()\n", "docstring": "Returns the i-th item of the dataset.\n"}
{"repo": "blueoil-master/blueoil/datasets/base.py", "original_string": "    def __len__(self):\n        \"\"\"returns the number of items in the dataset.\"\"\"\n        raise NotImplementedError()\n", "docstring": "returns the number of items in the dataset.\n"}
{"repo": "blueoil-master/blueoil/datasets/base.py", "original_string": "    def count_max_boxes(cls):\n        \"\"\"Count max boxes size over all subsets.\"\"\"\n        pass\n", "docstring": "Count max boxes size over all subsets.\n"}
{"repo": "blueoil-master/blueoil/datasets/base.py", "original_string": "    def num_max_boxes(self):\n        \"\"\"Return count max box size of available subsets.\"\"\"\n        pass\n", "docstring": "Return count max box size of available subsets.\n"}
{"repo": "blueoil-master/blueoil/datasets/base.py", "original_string": "    def _change_gt_boxes_shape(self, gt_boxes_list):\n        \"\"\"Change gt boxes list shape from [batch_size, num_boxes, 5] to [batch_size, num_max_boxes, 5].\n        fill dummy box when num boxes < num max boxes.\n        Args:\n          gt_boxes_list: python list of gt_boxes(np.ndarray). gt_boxes's shape is [batch_size, num_boxes, 5]\n        Return:\n          gt_boxes_list: numpy ndarray [batch_size, num_max_boxes, 5].\n        \"\"\"\n        results = []\n        for gt_boxes in gt_boxes_list:\n            gt_boxes = self._fill_dummy_boxes(gt_boxes)\n            results.append(gt_boxes)\n        return np.array(results)\n", "docstring": "Change gt boxes list shape from [batch_size, num_boxes, 5] to [batch_size, num_max_boxes, 5]."}
{"repo": "blueoil-master/blueoil/datasets/base.py", "original_string": "    def update_dataset(self, indices):\n        \"\"\"Update own dataset by indices.\"\"\"\n        pass\n", "docstring": "Update own dataset by indices.\n"}
{"repo": "blueoil-master/blueoil/datasets/base.py", "original_string": "    def get_shuffle_index(self):\n        \"\"\"Return list of shuffled index.\"\"\"\n        pass\n", "docstring": "Return list of shuffled index.\n"}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_base.py", "original_string": "    def count_max_boxes(cls, skip_difficult=True):\n        \"\"\"Count max boxes size over all subsets.\"\"\"\n        num_max_boxes = 0\n        for subset in cls.available_subsets:\n            obj = cls(subset=subset, skip_difficult=skip_difficult)\n            gt_boxes_list = obj.annotations\n            subset_max = max([len(gt_boxes) for gt_boxes in gt_boxes_list])\n            if subset_max >= num_max_boxes:\n                num_max_boxes = subset_max\n        return num_max_boxes\n", "docstring": "Count max boxes size over all subsets.\n"}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_base.py", "original_string": "    def _annotation_file_from_image_id(self, image_id):\n        \"\"\"Return annotation xml file path.\"\"\"\n        return os.path.join(self.annotations_dir, \"{}.xml\".format(image_id))\n", "docstring": "Return annotation xml file path.\n"}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_base.py", "original_string": "    def _gt_boxes_from_image_id(self, image_id):\n        \"\"\"Return gt boxes list ([[x, y, w, h, class_id]]) of a image.\"\"\"\n        annotation_file = self._annotation_file_from_image_id(image_id)\n        return self._get_boxes_from_annotation(annotation_file)\n", "docstring": "Return gt boxes list ([[x, y, w, h, class_id]]) of a image.\n"}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_base.py", "original_string": "    def _image_ids(self, data_type=None):\n        \"\"\"Get image ids in data_type, classes.\"\"\"\n        all_image_ids = self._all_image_ids(data_type)\n        all_gt_boxes_list = [self._gt_boxes_from_image_id(image_id) for image_id in all_image_ids]\n        if self.classes == self.default_classes:\n            return all_image_ids\n        image_ids = [\n            image_id for image_id, gt_boxes in zip(all_image_ids, all_gt_boxes_list) if len(gt_boxes) != 0\n        ]\n        return image_ids\n", "docstring": "Get image ids in data_type, classes.\n"}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_base.py", "original_string": "    def _all_image_ids(self, data_type=None, is_debug=False):\n        \"\"\"Get all image ids in data_type.\"\"\"\n        if data_type is None:\n            raise ValueError(\"Must provide data_type = train or val or trainval or test\")\n        filename = os.path.join(self.imagesets_dir, data_type + \".txt\")\n        with open(filename) as f:\n            image_ids = f.read().splitlines()\n        if is_debug:\n            image_ids = image_ids[:50]\n        return image_ids\n", "docstring": "Get all image ids in data_type.\n"}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_base.py", "original_string": "    def _init_files_and_annotations(self):\n        \"\"\"Init files and gt_boxes list, Cache these.\"\"\"\n        cache_key = self.subset + self.data_dir + str(self.classes) + str(self.skip_difficult)\n        cls = self.__class__\n        if cache_key in cls._cache:\n            cached_obj = cls._cache[cache_key]\n            self.files, self.annotations = cached_obj.files, cached_obj.annotations\n        else:\n            self.files, self.annotations = self._files_and_annotations()\n            cls._cache[cache_key] = self\n", "docstring": "Init files and gt_boxes list, Cache these.\n"}
{"repo": "blueoil-master/blueoil/datasets/ilsvrc_2012.py", "original_string": "    def classes(self):\n        # wget https://raw.githubusercontent.com/Lasagne/Recipes/master/examples/resnet50/imagenet_classes.txt\n        with open(os.path.join(self.data_dir, 'imagenet_classes.txt')) as f:\n            return [line.rstrip('\\n') for line in f]\n", "docstring": "wget https://raw.githubusercontent.com/Lasagne/Recipes/master/examples/resnet50/imagenet_classes.txt"}
{"repo": "blueoil-master/blueoil/datasets/mscoco_2017.py", "original_string": "    def _load_json(self):\n        \"\"\"Read items from JSON files\"\"\"\n        files = []\n        box_list = []\n        joints_list = []\n        self._coco = COCO(self.json)\n        image_ids = sorted(self._coco.getImgIds())\n        assert self._coco.getCatIds()[0] == 1\n        for entry in self._coco.loadImgs(image_ids):\n            dirname, filename = entry['coco_url'].split('/')[-2:]\n            abs_path = os.path.join(self.data_dir, dirname, filename)\n            valid_boxes, valid_joints = self._labels_from_entry(entry)\n            for i in range(len(valid_boxes)):\n                files.append(abs_path)\n                box_list.append(valid_boxes[i])\n                joints_list.append(valid_joints[i])\n        return files, box_list, joints_list\n", "docstring": "Read items from JSON files\n"}
{"repo": "blueoil-master/blueoil/datasets/cifar10.py", "original_string": "    def num_per_epoch(self):\n        \"\"\"Returns the number of datas in the data subset.\"\"\"\n        images = self.images\n        return len(images)\n", "docstring": "Returns the number of datas in the data subset.\n"}
{"repo": "blueoil-master/blueoil/datasets/cifar10.py", "original_string": "    def _load_data(self, filename):\n        # Load the pickled data-file.\n        data = self._unpickle(filename)\n        # Get the raw images.\n        images = data[b'data']\n        # Get the class-numbers for each image. Convert to numpy-array.\n        labels = np.array(data[b'labels'])\n        return images, labels\n", "docstring": "Load the pickled data-file."}
{"repo": "blueoil-master/blueoil/datasets/camvid.py", "original_string": "def get_image(filename, convert_rgb=True, ignore_class_idx=None):\n    \"\"\"Returns numpy array of an image\"\"\"\n    image = Image.open(filename)\n    #  sometime image data is gray.\n    if convert_rgb:\n        image = image.convert(\"RGB\")\n        image = np.array(image)\n    else:\n        image = image.convert(\"L\")\n        image = np.array(image)\n        if ignore_class_idx is not None:\n            # Replace ignore labelled class with enough large value\n            image = np.where(image == ignore_class_idx, 255, image)\n            image = np.where((image > ignore_class_idx) & (image != 255), image - 1, image)\n    return image\n", "docstring": "Returns numpy array of an image\n"}
{"repo": "blueoil-master/blueoil/datasets/camvid.py", "original_string": "    def files_and_annotations(self):\n        \"\"\"Return all files and gt_boxes list.\"\"\"\n        if self.subset == \"train\":\n            text = \"train.txt\"\n        if self.subset == \"validation\":\n            text = \"val.txt\"\n        filename = os.path.join(self.data_dir, text)\n        image_files, label_files = list(), list()\n        with open(filename) as f:\n            for line in f:\n                items = line.split()\n                image_files.append(items[0])\n                label_files.append(items[1])\n        image_files = [filename.replace(\"/SegNet/CamVid\", self.data_dir) for filename in image_files]\n        label_files = [filename.replace(\"/SegNet/CamVid\", self.data_dir) for filename in label_files]\n        return image_files, label_files\n", "docstring": "Return all files and gt_boxes list.\n"}
{"repo": "blueoil-master/blueoil/datasets/camvid.py", "original_string": "    def files_and_annotations(self):\n        \"\"\"Return all files and gt_boxes list.\"\"\"\n        if self.subset == \"train\":\n            text = \"train.txt\"\n        if self.subset == \"validation\":\n            text = \"val.txt\"\n        filename = os.path.join(self.data_dir, text)\n        image_files, label_files = list(), list()\n        with open(filename) as f:\n            for line in f:\n                items = line.split()\n                image_files.append(items[0])\n                label_files.append(items[1])\n        image_files = [filename.replace(\"/SegNet/CamVid\", self.data_dir) for filename in image_files]\n        label_files = [filename.replace(\"/SegNet/CamVid\", self.data_dir) for filename in label_files]\n        image_files, label_files = shuffle(image_files, label_files)\n        print(\"files and annotations are ready\")\n        return image_files, label_files\n", "docstring": "Return all files and gt_boxes list.\n"}
{"repo": "blueoil-master/blueoil/datasets/cifar100.py", "original_string": "    def num_per_epoch(self):\n        \"\"\"Returns the number of datas in the data subset.\"\"\"\n        images = self.images\n        return len(images)\n", "docstring": "Returns the number of datas in the data subset.\n"}
{"repo": "blueoil-master/blueoil/datasets/cifar100.py", "original_string": "    def _load_data(self, filename):\n        # Load the pickled data-file.\n        data = self._unpickle(filename)\n        # Get the raw images.\n        images = data[b\"data\"]\n        # Get the class-numbers for each image. Convert to numpy-array.\n        labels = np.array(data[b\"fine_labels\"])\n        return images, labels\n", "docstring": "Load the pickled data-file."}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_2007_2012.py", "original_string": "    def count_max_boxes(cls, skip_difficult=True):\n        \"\"\"Count max boxes size over all subsets.\"\"\"\n        num_max_boxes = 0\n        for subset in cls.available_subsets:\n            obj = cls(subset=subset, skip_difficult=skip_difficult)\n            gt_boxes_list = obj.annotations\n            subset_max = max([len(gt_boxes) for gt_boxes in gt_boxes_list])\n            if subset_max >= num_max_boxes:\n                num_max_boxes = subset_max\n        return num_max_boxes\n", "docstring": "Count max boxes size over all subsets.\n"}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_2007_2012.py", "original_string": "    def _init_files_and_annotations(self, *args, **kwargs):\n        \"\"\"Create files and annotations.\"\"\"\n        if self.subset == \"train\":\n            subset = \"train_validation\"\n        elif self.subset == \"validation\" or self.subset == \"test\":\n            subset = \"test\"\n        if subset == \"train_validation\":\n            pascalvoc_2007 = Pascalvoc2007(subset=subset, skip_difficult=self.skip_difficult, *args, **kwargs)\n            pascalvoc_2012 = Pascalvoc2012(subset=subset, skip_difficult=self.skip_difficult, *args, **kwargs)\n            self.files = pascalvoc_2007.files + pascalvoc_2012.files\n            self.annotations = pascalvoc_2007.annotations + pascalvoc_2012.annotations\n        elif subset == \"test\":\n            pascalvoc_2007 = Pascalvoc2007(subset=subset, skip_difficult=self.skip_difficult, *args, **kwargs)\n            self.files = pascalvoc_2007.files\n            self.annotations = pascalvoc_2007.annotations\n", "docstring": "Create files and annotations.\n"}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_2007_2012.py", "original_string": "    def num_max_boxes(self):\n        # calculate by cls.count_max_boxes(self.skip_difficult)\n        if self.skip_difficult:\n            return 39\n        else:\n            return 56\n", "docstring": "calculate by cls.count_max_boxes(self.skip_difficult)"}
{"repo": "blueoil-master/blueoil/datasets/bdd100k.py", "original_string": "    def num_max_boxes(self):\n        # from dataset:\n        # train - max 91 boxes, val - max 66 boxes\n        return 91\n", "docstring": "from dataset:"}
{"repo": "blueoil-master/blueoil/datasets/tfds.py", "original_string": "    def _init_available_splits(self):\n        \"\"\"Initializing available splits dictionary depending on\n           what kind of splits the dataset has.\n        \"\"\"\n        self.available_splits = {}\n        if tfds.Split.TRAIN not in self.info.splits:\n            raise ValueError(\"Datasets need to have a split \\\"TRAIN\\\".\")\n        if tfds.Split.VALIDATION in self.info.splits and tfds.Split.TEST in self.info.splits:\n            self.available_splits[\"train\"] = tfds.Split.TRAIN\n            self.available_splits[\"validation\"] = tfds.Split.VALIDATION\n            self.available_splits[\"test\"] = tfds.Split.TEST\n        elif tfds.Split.VALIDATION in self.info.splits:\n            self.available_splits[\"train\"] = tfds.Split.TRAIN\n            self.available_splits[\"validation\"] = tfds.Split.VALIDATION\n        elif tfds.Split.TEST in self.info.splits:\n            self.available_splits[\"train\"] = tfds.Split.TRAIN\n            self.available_splits[\"validation\"] = tfds.Split.TEST\n        else:\n            raise ValueError(\"Datasets need to have a split \\\"VALIDATION\\\" or \\\"TEST\\\".\")\n", "docstring": "Initializing available splits dictionary depending on"}
{"repo": "blueoil-master/blueoil/datasets/tfds.py", "original_string": "    def _format_dataset(self):\n        \"\"\"Converting the format of loaded dataset.\"\"\"\n        raise NotImplementedError()\n", "docstring": "Converting the format of loaded dataset.\n"}
{"repo": "blueoil-master/blueoil/datasets/open_images_v4.py", "original_string": "    def _target_labels(self):\n        \"\"\"Map of {csv raw label name: Be mapped target label name}.\"\"\"\n        target_labels = dict(self._make_target_labels())\n        return target_labels\n", "docstring": "Map of {csv raw label name: Be mapped target label name}.\n"}
{"repo": "blueoil-master/blueoil/datasets/open_images_v4.py", "original_string": "    def count_max_boxes(cls):\n        \"\"\"Count max boxes size over all subsets.\"\"\"\n        num_max_boxes = 0\n        for subset in cls.available_subsets:\n            obj = cls(subset=subset)\n            _, gt_boxes_list = obj.files_and_annotations\n            subset_max = max([len(gt_boxes) for gt_boxes in gt_boxes_list])\n            if subset_max >= num_max_boxes:\n                num_max_boxes = subset_max\n        return num_max_boxes\n", "docstring": "Count max boxes size over all subsets.\n"}
{"repo": "blueoil-master/blueoil/datasets/open_images_v4.py", "original_string": "    def class_descriptions_csv(self):\n        # if train_path has 'class-descriptions.csv', use it.\n        csv = os.path.join(self._train_data_dir, 'class-descriptions.csv')\n        if os.path.exists(csv):\n            return csv\n        return os.path.join(self.data_dir, 'annotations-bbox.csv')\n", "docstring": "if train_path has 'class-descriptions.csv', use it."}
{"repo": "blueoil-master/blueoil/datasets/mscoco.py", "original_string": "    def _image_ids(self):\n        \"\"\"Return all files and gt_boxes list.\"\"\"\n        classes = [class_name for class_name in self.classes if class_name != \"__background__\"]\n        target_class_ids = self.coco.getCatIds(catNms=classes)\n        image_ids = []\n        for target_class_id in target_class_ids:\n            target_image_ids = self.coco.getImgIds(catIds=[target_class_id])\n            image_ids = image_ids + target_image_ids\n        # remove duplicate with order preserving\n        seen = set()\n        return [x for x in image_ids if x not in seen and not seen.add(x)]\n", "docstring": "Return all files and gt_boxes list.\n"}
{"repo": "blueoil-master/blueoil/datasets/mscoco.py", "original_string": "    def count_max_boxes(cls):\n        \"\"\"Count max boxes size over all subsets.\"\"\"\n        num_max_boxes = 0\n        for subset in cls.available_subsets:\n            obj = cls(subset=subset)\n            gt_boxes_list = obj.annotations\n            subset_max = max([len(gt_boxes) for gt_boxes in gt_boxes_list])\n            if subset_max >= num_max_boxes:\n                num_max_boxes = subset_max\n        return num_max_boxes\n", "docstring": "Count max boxes size over all subsets.\n"}
{"repo": "blueoil-master/blueoil/datasets/mscoco.py", "original_string": "    def _image_ids(self):\n        \"\"\"Return all files and gt_boxes list.\"\"\"\n        classes = [class_name for class_name in self.classes if class_name != \"__background__\"]\n        target_class_ids = self.coco.getCatIds(catNms=classes)\n        image_ids = []\n        for target_class_id in target_class_ids:\n            target_image_ids = self.coco.getImgIds(catIds=[target_class_id])\n            image_ids = image_ids + target_image_ids\n        # remove duplicate with order preserving\n        seen = set()\n        r = [x for x in image_ids if x not in seen and not seen.add(x)]\n        r = sorted(r)\n        return r\n", "docstring": "Return all files and gt_boxes list.\n"}
{"repo": "blueoil-master/blueoil/datasets/mscoco.py", "original_string": "    def _gt_boxes_from_image_id(self, image_id):\n        \"\"\"Return gt boxes list ([[x, y, w, h, class_id]]) of a image.\"\"\"\n        classes = [class_name for class_name in self.classes if class_name != \"__background__\"]\n        class_ids = set(self.coco.getCatIds(catNms=classes))\n        boxes = []\n        annotation_ids = self.coco.getAnnIds(imgIds=[image_id], iscrowd=None)\n        annotations = self.coco.loadAnns(annotation_ids)\n        for annotation in annotations:\n            if annotation['category_id'] not in class_ids:\n                continue\n            class_id = self.coco_category_id_to_lmnet_class_id(annotation['category_id'])\n            box = annotation[\"bbox\"] + [class_id]\n            boxes.append(box)\n        return boxes\n", "docstring": "Return gt boxes list ([[x, y, w, h, class_id]]) of a image.\n"}
{"repo": "blueoil-master/blueoil/datasets/mscoco.py", "original_string": "    def _gt_boxes_from_image_id(self, image_id):\n        \"\"\"Return gt boxes list ([[x, y, w, h, class_id]]) of a image.\"\"\"\n        person_class_id = self.coco.getCatIds(catNms=['person'])[0]\n        boxes = []\n        annotation_ids = self.coco.getAnnIds(imgIds=[image_id], iscrowd=None)\n        annotations = self.coco.loadAnns(annotation_ids)\n        for annotation in annotations:\n            category_id = annotation['category_id']\n            if category_id != person_class_id:\n                continue\n            class_id = self.coco_category_id_to_lmnet_class_id(category_id)\n            box = annotation[\"bbox\"] + [class_id]\n            w = box[2]\n            h = box[3]\n            size = w * h\n            # remove small box.\n            if size < self.threshold_size:\n                continue\n            boxes.append(box)\n        return boxes\n", "docstring": "Return gt boxes list ([[x, y, w, h, class_id]]) of a image.\n"}
{"repo": "blueoil-master/blueoil/datasets/mscoco.py", "original_string": "    def _image_ids(self):\n        \"\"\"Return all files which contains person bounding boxes.\"\"\"\n        image_ids = []\n        target_class_ids = self.coco.getCatIds(catNms=['person'])\n        for image_id in self.coco.getImgIds(catIds=[target_class_ids[0]]):\n            gt_boxes = self._gt_boxes_from_image_id(image_id)\n            if len(gt_boxes) > 0:\n                image_ids.append(image_id)\n        return image_ids\n", "docstring": "Return all files which contains person bounding boxes.\n"}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_2007.py", "original_string": "    def num_max_boxes(self):\n        # calculate by cls.count_max_boxes(self.skip_difficult)\n        if self.skip_difficult:\n            return 37\n        else:\n            return 42\n", "docstring": "calculate by cls.count_max_boxes(self.skip_difficult)"}
{"repo": "blueoil-master/blueoil/datasets/pascalvoc_2007.py", "original_string": "    def _image_file_from_image_id(self, image_id):\n        \"\"\"Return image file name of a image.\"\"\"\n        return os.path.join(self.jpegimages_dir, \"{}.jpg\".format(image_id))\n", "docstring": "Return image file name of a image.\n"}
{"repo": "blueoil-master/blueoil/datasets/ytfaces.py", "original_string": "    def __getitem__(self, item):\n        \"\"\"Get an item given index.\n        Args:\n            item: int, index.\n        Returns:\n            image: a numpy array of shape (height, width, 3).\n            joints: a numpy array of shape (68, 3), which has coordinates in image.\n        \"\"\"\n        return load_image(self.files[item]), self.joints_list[item]\n", "docstring": "Get an item given index."}
{"repo": "blueoil-master/blueoil/converter/generate_project.py", "original_string": "def optimize_graph_step(graph: Graph, config: Config) -> None:\n    \"\"\"Optimizing graph that imported from tensorflow pb.\n    Args:\n        graph (Graph): Graph that optimization passes are applying to\n        config (Config): Collection of configurations\n    Returns:\n    \"\"\"\n    pass_remove_identities(graph)\n    pass_transpose(graph)\n    if config.activate_hard_quantization:\n        pass_lookup(graph, config)\n        pass_propagate_quantization_details_into_conv(graph)\n        if config.threshold_skipping:\n            pass_compute_thresholds(graph)\n        pass_pack_weights(graph)\n        pass_quantize_convolutions(graph)\n    pass_propagate_datatypes(graph)\n    pass_propagate_format(graph)\n    pass_constant_folding(graph)\n    pass_simplify_batchnorm(graph)\n    pass_insert_cast(graph)\n", "docstring": "Optimizing graph that imported from tensorflow pb."}
{"repo": "blueoil-master/blueoil/converter/util.py", "original_string": "def make_dirs(dir_pathes: Union[str, List[str]]) -> None:\n    \"\"\"Create one or more directories.\"\"\"\n    if isinstance(dir_pathes, str):\n        dir = Path(dir_pathes)\n        Path.mkdir(dir, parents=True, exist_ok=True)\n    elif isinstance(dir_pathes, list):\n        for dir_path in dir_pathes:\n            dir = Path(dir_path)\n            Path.mkdir(dir, parents=True, exist_ok=True)\n", "docstring": "Create one or more directories.\n"}
{"repo": "blueoil-master/blueoil/converter/util.py", "original_string": "def get_files(src_dir_path: str, excepts: str = '') -> List[str]:\n    \"\"\"Get a list of file pathes.\"\"\"\n    return [fp for fp in get_files_generator(src_dir_path, excepts)]\n", "docstring": "Get a list of file pathes.\n"}
{"repo": "blueoil-master/blueoil/converter/util.py", "original_string": "def dynamic_class_load(path: str) -> Any:\n    \"\"\"Load a class defined by the argument.\n    Args:\n        path (str): The full pathname that represents the class to be loaeded.\n            (Actually I don't know how to call it in Python.)\n    Returns:\n        Any: The class to be loaded.\n    \"\"\"\n    pathes = path.split('.')\n    class_name = pathes.pop()\n    module_name = '.'.join(pathes)\n    module = importlib.import_module(module_name)\n    return getattr(module, class_name)\n", "docstring": "Load a class defined by the argument."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def __connect_to_outputs(self) -> None:\n        \"\"\"Connect input operators' outputs to this object.\"\"\"\n        for ip in self._input_ops.values():\n            key = ip.output_names[0]\n            ip.add_output(key, self)\n", "docstring": "Connect input operators' outputs to this object.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def _check_consistency(self) -> None:\n        \"\"\"Check data consistency in the initialization.\"\"\"\n        # check the input ops\n        self._assert(set(self._input_ops.keys()).issubset(set(self._input_names)),\n                     f\"Operator inputs must consist of {', '.join(self._input_names)}\")\n", "docstring": "Check data consistency in the initialization.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def name(self) -> str:\n        \"\"\"Return name. This must be a unique name in the graph.\"\"\"\n        return self._name\n", "docstring": "Return name. This must be a unique name in the graph.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def op_type(self) -> str:\n        \"\"\"Return the operation type.\"\"\"\n        return type(self).__name__\n", "docstring": "Return the operation type.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def input_ops(self) -> Ops:\n        \"\"\"Return a dict of input operators.\n        Returns:\n            dict: Collection of input operators in a dictionary format.\n                The keys are input symbols, which can be taken from `input_names` property.\n        \"\"\"\n        return self._input_ops\n", "docstring": "Return a dict of input operators."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def input_names(cls) -> List[str]:\n        \"\"\"Return the input key names the operator provides.\n        For example, `Conv` has two inputs, 'X' for the input data and 'W' for the weight.\n        So `Conv.input_names` returns the list `['X', 'W']`.\n        Returns:\n            list[str]: List of key names\n        \"\"\"\n        return cls._input_names\n", "docstring": "Return the input key names the operator provides."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def input_nodes(self) -> List['Operator']:\n        \"\"\"Return a list of input operators in proper order (original protobuf argument order).\n        Returns:\n            list[Operator]: This list is already ordered following the order of the arguments in the original\n                protobuf operators (positional order in the list of arguments).\n        \"\"\"\n        return [self._input_ops[i] for i in self.input_names if self.input_ops.get(i)]\n", "docstring": "Return a list of input operators in proper order (original protobuf argument order)."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def output_ops(self) -> OutOps:\n        \"\"\"Return a dict of output operators.\n        Returns:\n            dict: Collection of (list of) output operators in a dictionary format.\n                The keys are output symbols, which can be taken from `output_names` property.\n        \"\"\"\n        return self._output_ops\n", "docstring": "Return a dict of output operators."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def output_op_list(self) -> List['Operator']:\n        \"\"\"Return a list of output operators.\n        Returns:\n            list[Operator]: List of output operators.\n        \"\"\"\n        return sum(list(self._output_ops.values()), [])\n", "docstring": "Return a list of output operators."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def output_names(cls) -> List[str]:\n        \"\"\"Return the output key names the operator provides.\n        For example, `Conv` has one output 'Y'.\n        So `Conv.output_names` returns the list `['Y']`.\n        Returns:\n            list[str]: List of key names\n        \"\"\"\n        return cls._output_names\n", "docstring": "Return the output key names the operator provides."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def add_inputs(self, inputs: Ops) -> None:\n        \"\"\"Add input (possibly multiple) nodes at a once.\n        Args:\n            outputs (dict): Collection of pair of key name and a operator to be registered as the input.\n                All the key names have to be in list `input_names`.\n        \"\"\"\n        assert set(inputs.keys()).issubset(set(self._input_names)), \"Illegal output names included\"\n        self._input_ops.update(inputs)\n", "docstring": "Add input (possibly multiple) nodes at a once."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def add_outputs(self, outputs: OutOps) -> None:\n        \"\"\"Add output (possibly multiple) nodes at a once.\n        Args:\n            outputs (Dict of str to list of Operators): Collection of pair of key name\n            and a list of operators to be registered as the output.\n                All the key names have to be in list `output_names`.\n        \"\"\"\n        assert set(outputs.keys()).issubset(set(self._output_names)), f\"Illegal output names included\"\n        for n in outputs.keys():\n            lst = self._output_ops.get(n)\n            if lst is not None:\n                lst += [x for x in outputs[n] if x not in lst]\n            else:\n                self._output_ops[n] = list(outputs[n])\n        self._output_ops.update(outputs)\n", "docstring": "Add output (possibly multiple) nodes at a once."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def remove_output(self, ident: str) -> None:\n        \"\"\"Remove an output node.\n        Args:\n            ident (str): Key name of the output node to be removed.\n                This key is in `output_names`, not the name of the operator.\n        \"\"\"\n        self._output_ops.pop(ident)\n", "docstring": "Remove an output node."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def shape(self) -> List[int]:\n        \"\"\"Get the shape defined in this node.\"\"\"\n        return self._shape\n", "docstring": "Get the shape defined in this node.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def shape(self, v: List[int]) -> None:\n        \"\"\"Set the shape defined in this node.\"\"\"\n        self._shape = v\n", "docstring": "Set the shape defined in this node.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def dtype(self) -> DataType:\n        \"\"\"Get the data type defined in this node.\"\"\"\n        return self._dtype\n", "docstring": "Get the data type defined in this node.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def dtype(self, v: DataType) -> None:\n        \"\"\"Set the data type defined in this node.\"\"\"\n        self._dtype = v\n", "docstring": "Set the data type defined in this node.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def ndims(self) -> int:\n        \"\"\"Get the number of dimension defined in this node.\"\"\"\n        return len(self._shape)\n", "docstring": "Get the number of dimension defined in this node.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def dimension(self) -> str:\n        \"\"\"Return dimension in string.\n        This dimension consists of 'N', 'C', 'H', and 'W', where 'N' is the number of batch size,\n        'C' is the number of channels, 'H' and 'C' are the height and the weight in the 2-D image.\n        \"\"\"\n        return self._dimension_format\n", "docstring": "Return dimension in string."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def size(self) -> int:\n        \"\"\"Get the whole size of the output data.\"\"\"\n        import operator\n        pred = functools.partial(functools.reduce, operator.mul)\n        return int(pred(self._shape, 1))  # type: ignore\n", "docstring": "Get the whole size of the output data.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def is_variable(self) -> bool:\n        \"\"\"Return if this node is a variable node (i.e. Input or Output).\"\"\"\n        return False\n", "docstring": "Return if this node is a variable node (i.e. Input or Output).\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def is_scalar(self) -> bool:\n        \"\"\"Return if this node is a scalar node (i.e. `ndims == 0`).\"\"\"\n        return self.ndims == 0\n", "docstring": "Return if this node is a scalar node (i.e. `ndims == 0`).\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def height(self) -> int:\n        \"\"\"Get the size of height in the shape.\"\"\"\n        if self.index_H is not None:\n            return self.shape[self.index_H]\n        else:\n            raise ValueError(f'Operator {self.name} does not have the height property.')\n", "docstring": "Get the size of height in the shape.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def width(self) -> int:\n        \"\"\"Get the size of width in the shape.\"\"\"\n        if self.index_W is not None:\n            return self.shape[self.index_W]\n        else:\n            raise ValueError(f'Operator {self.name} does not have the width property.')\n", "docstring": "Get the size of width in the shape.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def channels(self) -> int:\n        \"\"\"Get the number of channels in the shape.\"\"\"\n        if self.index_C is not None:\n            if self.index_C_low is not None:\n                return self.shape[self.index_C] * self.shape[self.index_C_low]\n            else:\n                return self.shape[self.index_C]\n        else:\n            raise ValueError(f'Operator {self.name} does not have the channel property.')\n", "docstring": "Get the number of channels in the shape.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def batchsize(self) -> int:\n        \"\"\"Get the number of batch size in the shape.\"\"\"\n        if self.index_N is not None:\n            return self.shape[self.index_N]\n        else:\n            raise ValueError(f'Operator {self.name} does not have the batchsize property.')\n", "docstring": "Get the number of batch size in the shape.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def data(self) -> np.ndarray:\n        \"\"\"Get the output data.\n        This value is valid only after `run_forward()` or some value has assigned with the setter.\n        \"\"\"\n        return self._data\n", "docstring": "Get the output data."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def run_forward(self) -> np.ndarray:\n        \"\"\"Run the operator, calculate and set the result.\n        This is actually an abstract method and should be overridden.\n        \"\"\"\n        raise NotImplementedError(\n            f'operator {self.op_type} does not have runtime implementation yet.')\n", "docstring": "Run the operator, calculate and set the result."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def preserve_quantization(self) -> bool:\n        \"\"\"whether to preserve the operator for quantization\"\"\"\n        raise NotImplementedError(\n            f'Preservation for quantization of operator {self.op_type} is not defined.')\n", "docstring": "whether to preserve the operator for quantization\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def is_variable(self) -> bool:\n        \"\"\"Return True, as this is a variable.\"\"\"\n        return True\n", "docstring": "Return True, as this is a variable.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def data(self) -> np.ndarray:\n        \"\"\"Return data.\"\"\"\n        return self._data\n", "docstring": "Return data.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def transposed_data(self) -> Optional[List[int]]:\n        \"\"\"Return transposed data.\"\"\"\n        return self._transposed_data\n", "docstring": "Return transposed data.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def binarizer(self, data: np.ndarray) -> np.ndarray:\n        \"\"\"Maps the quantized values into >= 0 integer values.\n        This is actually an abstract method and should be overridden.\n        \"\"\"\n        raise NotImplementedError(\n            f'operator {self.op_type} need to implement the binarizer method')\n", "docstring": "Maps the quantized values into >= 0 integer values."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def permutation(self) -> List[int]:\n        \"\"\"Get transpose permutation in list of ints.\"\"\"\n        return self._permutation\n", "docstring": "Get transpose permutation in list of ints.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def kernel_dimensions(self) -> int:\n        \"\"\"Get the number of dimensions.\"\"\"\n        return self._num_dimensions\n", "docstring": "Get the number of dimensions.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def dilations(self) -> List[int]:\n        \"\"\"Get dilations.\"\"\"\n        return self._dilations\n", "docstring": "Get dilations.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def pads(self) -> List[int]:\n        \"\"\"Get pads.\"\"\"\n        return self._pads\n", "docstring": "Get pads.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def strides(self) -> List[int]:\n        \"\"\"Get strides.\"\"\"\n        return self._strides\n", "docstring": "Get strides.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def is_quantized(self) -> bool:\n        \"\"\"Return if this operator is quantized.\n        Currently it always returns False, as quantized version is not supported yet.\n        \"\"\"\n        return self._is_quantized\n", "docstring": "Return if this operator is quantized."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def kernel_height(self) -> int:\n        \"\"\"Return the height in the kernel shape.\"\"\"\n        if self.kernel_index_H is not None:\n            return self.kernel_shape[self.kernel_index_H]\n        else:\n            raise ValueError(f'Operator {self.name} does not have the kernel_height property.')\n", "docstring": "Return the height in the kernel shape.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def kernel_width(self) -> int:\n        \"\"\"Return the weight in the kernel shape.\"\"\"\n        if self.kernel_index_W is not None:\n            return self.kernel_shape[self.kernel_index_W]\n        else:\n            raise ValueError(f'Operator {self.name} does not have the kernel_width property.')\n", "docstring": "Return the weight in the kernel shape.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def run(self, **kwargs) -> Dict:\n        \"\"\"Return the forward calculation results of batch normalization.\n        Currently this function is only used by threshold skipping optimization pass\n        for recursively calculating thresholds of the skipping patterns.\n        \"\"\"\n        scale = np.float64(self._input_ops['scale'].data)\n        beta = np.float64(self._input_ops['B'].data)\n        mean = np.float64(self._input_ops['mean'].data)\n        var = np.float64(self._input_ops['var'].data)\n        x_norm = (kwargs['data'] - mean) / np.sqrt(var + self.epsilon)\n        kwargs['data'] = scale * x_norm + beta\n        return kwargs\n", "docstring": "Return the forward calculation results of batch normalization."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def run(self, **kwargs) -> Dict:\n        \"\"\"Return the result of forward calculation of an activation quantizer.\n        Currently this function is only used by threshold skipping optimization pass\n        for recursively calculating thresholds of the skipping patterns.\n        \"\"\"\n        bit = self._input_ops['Y'].data\n        max_value = np.float64(self._input_ops['Z'].data)\n        in_data = np.float64(kwargs['data'])\n        n = 2 ** bit - 1\n        np.clip(in_data, 0, max_value, out=in_data)\n        kwargs['data'] = np.floor(in_data * n / max_value + 0.5).astype(np.int32)\n        return kwargs\n", "docstring": "Return the result of forward calculation of an activation quantizer."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def run_forward(self) -> np.ndarray:\n        \"\"\"General function for this quantization operator.\n        This function returns numpy array.\n        \"\"\"\n        data_dict = self.run(data=self._input_ops['X'].data)\n        self._data = data_dict['data']\n        return self._data\n", "docstring": "General function for this quantization operator."}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def kernel_height(self) -> int:\n        \"\"\"Get the height in the kernel shape.\"\"\"\n        if self.kernel_index_H is not None:\n            return self.kernel_shape[self.kernel_index_H]\n        else:\n            raise ValueError(f'Operator {self.name} does not have the kernel_height property.')\n", "docstring": "Get the height in the kernel shape.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def kernel_width(self) -> int:\n        \"\"\"Get the Width in the kernel shape.\"\"\"\n        if self.kernel_index_W is not None:\n            return self.kernel_shape[self.kernel_index_W]\n        else:\n            raise ValueError(f'Operator {self.name} does not have the kernel_width property.')\n", "docstring": "Get the Width in the kernel shape.\n"}
{"repo": "blueoil-master/blueoil/converter/core/operators.py", "original_string": "    def run(self, **kwargs) -> Dict:\n        \"\"\"Return the forward calculation results of batch normalization.\n        Currently this function is only used by threshold skipping optimization pass\n        for recursively calculating thresholds of the skipping patterns.\n        \"\"\"\n        scale = np.float64(self._input_ops['scale'].data)\n        bias = np.float64(self._input_ops['bias'].data)\n        kwargs['data'] = scale * kwargs['data'] + bias\n        return kwargs\n", "docstring": "Return the forward calculation results of batch normalization."}
{"repo": "blueoil-master/blueoil/converter/core/optimizer.py", "original_string": "def pass_remove_identities(graph: Graph) -> None:\n    \"\"\"Removes those nodes of a Graph that satisfies the condition node.op_type() == Identity.\n    Args:\n        graph (Graph): The input graph. It will be modified in-place.\n    \"\"\"\n    exec_list = [n for n in sort_graph(graph) if n.op_type == 'Identity']\n    to_be_removed = list()\n    for m in exec_list:\n        \"\"\"skip all identity.\"\"\"\n        in_op = m.input_ops['input']\n        out_ops = m.output_ops['output']\n        for out_op in out_ops:\n            for k, v in out_op.input_ops.items():\n                if v == m:\n                    # change the output's input to this identity's input\n                    out_op.add_input(k, in_op)\n                    # change the input's output to this identity's output\n                    for k2, v2 in in_op.output_ops.items():\n                        if m in v2:\n                            v2.remove(m)\n                            v2.append(out_op)\n                            break\n                    break\n        to_be_removed.append(m)\n    for op in to_be_removed:\n        graph.remove_op(op)\n", "docstring": "Removes those nodes of a Graph that satisfies the condition node.op_type() == Identity."}
{"repo": "blueoil-master/blueoil/converter/core/optimizer.py", "original_string": "def pass_constant_folding(graph: Graph) -> None:\n    \"\"\"Given a node N, if the value of each input of N is known at compilation time then N will be executed.\n       The node N and its inputs will be replaced with a Constant node which holds the computed output of N.\n    Args:\n        graph (Graph): The input graph. It will be modified in-place.\n        processed_nodes (list): The list of the processed nodes so far.\n    \"\"\"\n    done = False\n    processed_nodes = []\n    while not done:\n        exec_list = sort_graph(graph)\n        processed_before_precompute = len(processed_nodes)\n        to_be_removed = []\n        for m in exec_list:\n            if m in processed_nodes:\n                continue\n            # We want operators with inputs\n            if not m.input_nodes:\n                continue\n            precomputable = True\n            for input_node in m.input_nodes:\n                if input_node.op_type != 'Constant':\n                    precomputable = False\n            if not precomputable:\n                continue\n            processed_nodes += m.input_nodes\n            processed_nodes.append(m)\n            data = m.run_forward()\n            new_constant = Constant(\n                m.name + '_new',\n                m.dtype,\n                data,\n                dimension_format=m.dimension\n            )\n            graph.add_op(new_constant)\n            # get nodes to be removed after being disconnected\n            get_nodes_in_branch(m, None, to_be_removed)\n            new_constant.add_outputs({'output': m.output_op_list})\n            for output_name, consumer_list in m.output_ops.items():\n                for consumer_node in consumer_list:\n                    for input_name, input_node in consumer_node.input_ops.items():\n                        if input_node == m:\n                            consumer_node.add_input(input_name, new_constant)\n                            break\n        for op in to_be_removed:\n            graph.remove_op(op)\n        done = len(processed_nodes) == processed_before_precompute\n", "docstring": "Given a node N, if the value of each input of N is known at compilation time then N will be executed."}
{"repo": "blueoil-master/blueoil/converter/core/optimizer.py", "original_string": "def pass_quantize_convolutions(graph: Graph) -> None:\n    \"\"\"Given a convolution node C, if C has proper quantization details, it will mark C as quantized and it will\n       assign the correct output data types to the node C and its quantizers. Note that the expected output data type\n       on the runtime is defined as QUANTIZED_NOT_PACKED.\n    Args:\n        graph (Graph): The input graph. It will be modified in-place.\n    \"\"\"\n    b = 32\n    exec_list = [n for n in sort_graph(graph) if n.op_type == 'Conv']\n    for m in exec_list:\n        conv_node = m\n        # check if this is a quantized convolution\n        if not conv_node.quantizer or not conv_node.a_quantizer:\n            continue\n        # Mark as quantized convolution\n        conv_node.is_quantized = True\n        # change the output data type of the convolution if thresholds are available\n        if conv_node.has_thresholds:\n            conv_node.dtype = QUANTIZED_PACKED()\n            height = conv_node.height\n            width = conv_node.width\n            channels = conv_node.channels\n            channels_upper = (channels + b - 1) // b\n            conv_node.update_shape([channels_upper, height, width, 2, b], \"ChHWBCl\")\n        # change the output data type of the quantizers\n        conv_node.quantizer.dtype = PackedUint32()\n        for qtz in conv_node.a_quantizer:\n            if isinstance(qtz, Lookup):\n                continue\n            qtz.dtype = QUANTIZED_PACKED()\n            height = qtz.height\n            width = qtz.width\n            channels = qtz.channels\n            channels_upper = (channels + b - 1) // b\n            qtz.update_shape([channels_upper, height, width, 2, b], \"ChHWBCl\")\n", "docstring": "Given a convolution node C, if C has proper quantization details, it will mark C as quantized and it will"}
{"repo": "blueoil-master/blueoil/converter/core/optimizer.py", "original_string": "def pass_propagate_format(graph) -> None:\n    \"\"\"Further propagate output data types.\n    Args:\n        graph (Graph): The input graph. It will be modified in-place.\n    \"\"\"\n    exec_list = sort_graph(graph)\n    for m in exec_list:\n        if m.op_type != 'Conv' and m.preserve_quantization:\n            if m.input_nodes[0].dimension == 'ChHWBCl':\n                b = 32\n                shape = [(m.channels + b - 1) // b, m.height, m.width, 2, b]\n                m.update_shape(shape, m.input_nodes[0].dimension)\n", "docstring": "Further propagate output data types."}
{"repo": "blueoil-master/blueoil/converter/core/params.py", "original_string": "    def __init__(self, graph: Graph, config: Config) -> None:\n        \"\"\"Init this parameter object.\n        Parameters\n        ----------\n        graph : Graph\n            Graph object\n        config : Config\n            Configuration object\n        \"\"\"\n        self.graph = graph\n        self.config = config\n", "docstring": "Init this parameter object."}
{"repo": "blueoil-master/blueoil/converter/core/params.py", "original_string": "    def max_size_qinputs_per_layer(self):\n        # this is temporary because not every consts is kernel\n        # also later, each layer has different bitwidth\n        return int(self.max_size_inputs_per_layer / self.num_qinputs_in_qword)\n", "docstring": "this is temporary because not every consts is kernel"}
{"repo": "blueoil-master/blueoil/converter/core/params.py", "original_string": "    def max_size_qoutputs_per_layer(self):\n        # this is temporary because not every consts is kernel\n        # also later, each layer has different bitwidth\n        return int(self.max_size_outputs_per_layer / self.num_qinputs_in_qword)\n", "docstring": "this is temporary because not every consts is kernel"}
{"repo": "blueoil-master/blueoil/converter/core/params.py", "original_string": "    def max_size_qkernels_per_layer(self):\n        # this is temporary because not every consts is kernel\n        return int(self.max_size_kernels_per_layer / self.num_qkernels_in_qword)\n", "docstring": "this is temporary because not every consts is kernel"}
{"repo": "blueoil-master/blueoil/converter/core/graph_pattern_matching.py", "original_string": "def sort_graph(graph):\n    \"\"\"Helper function to topologically sort a given graph.\n    Args:\n        graph (Graph): The input graph to be sorted. It is not modified.\n    Returns:\n        list(Operator): A list of Operator. Each element of the list is a reference to\n            a Operator object.\n    \"\"\"\n    exec_list = list()\n    input_nodes = list()\n    for node in graph.operators:\n        input_nodes += [n.name for n in node.input_nodes]\n    output_nodes = list()\n    for node in graph.operators:\n        if node not in input_nodes:\n            output_nodes.append(node)\n    visited = {}\n    for node in graph.operators:\n        visited[node.name] = False\n    for node in output_nodes:\n        top_order(node, exec_list, visited)\n    return exec_list\n", "docstring": "Helper function to topologically sort a given graph."}
{"repo": "blueoil-master/blueoil/converter/core/graph.py", "original_string": "    def __init__(self) -> None:\n        \"\"\"Init the graph.\"\"\"\n        self.__ops: OrderedDict = OrderedDict()\n        self.__op_type_list: Dict[str, List[Operator]] = defaultdict(lambda: [])\n        self.__non_variable_list: List[Operator] = []\n", "docstring": "Init the graph.\n"}
{"repo": "blueoil-master/blueoil/converter/core/graph.py", "original_string": "    def add_op_and_inputs(self, op: Operator) -> Operator:\n        \"\"\"Add an operator and its inputs recursively.\n        Args:\n            op (Operator):\n        \"\"\"\n        self.add_op(op)\n        for i in op.input_ops.values():\n            self.add_op_and_inputs(i)\n        return op\n", "docstring": "Add an operator and its inputs recursively."}
{"repo": "blueoil-master/blueoil/converter/core/graph.py", "original_string": "    def operators(self) -> List[Operator]:\n        \"\"\"List up all operators in this graph.\"\"\"\n        return list(self.__ops.values())\n", "docstring": "List up all operators in this graph.\n"}
{"repo": "blueoil-master/blueoil/converter/core/graph.py", "original_string": "    def convs(self, quantized_only: bool = False) -> List[Conv]:\n        \"\"\"Return the list of conv operators in this graph.\n        Args:\n            quantized_only (bool): Flag that represents if the operators are only\n                quantized ones (Default value = False)\n        Returns:\n            list:\n        \"\"\"\n        return list(cast(List['Conv'], self.__op_type_list['Conv'])) \\\n            if not quantized_only else [x for x in cast(List['Conv'], self.__op_type_list['Conv'])\n                                        if cast(Conv, x).is_quantized]\n", "docstring": "Return the list of conv operators in this graph."}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def name(self) -> str:\n        \"\"\"Return the name corresponding to the node.\"\"\"\n        return self.nd_.name.replace('/', '_').replace('-', '_')\n", "docstring": "Return the name corresponding to the node.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def node_def_object(self):\n        \"\"\"Return node object.\"\"\"\n        return self.nd_\n", "docstring": "Return node object.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def op_type(self) -> str:\n        \"\"\"Return the op type of the node.\"\"\"\n        return self.nd_.op\n", "docstring": "Return the op type of the node.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def inputs(self) -> List[str]:\n        \"\"\"Return the name of corresponding inputs to the node.\"\"\"\n        def get_input_tuple(x: str) -> Tuple[str, int]:\n            ary = x.replace('/', '_').replace('-', '_').split(':', 1)\n            if len(ary) == 1:\n                return (ary[0], 0)\n            elif len(ary) == 2:\n                return (ary[0], int(ary[1]))\n            else:\n                raise AssertionError(f'Failed to parse input name: {x}')\n        return [get_input_tuple(x) for x in self.nd_.input]\n", "docstring": "Return the name of corresponding inputs to the node.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def tensor_type(self):\n        \"\"\"Get tensor type info.\"\"\"\n        if self.nd_.op in FLOAT32_TENSOR_TYPES:\n            typep = 1\n        else:\n            typep = self.nd_.attr[\"T\"].type\n        return typep\n", "docstring": "Get tensor type info.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def get_shapes(self) -> List[List[int]]:\n        \"\"\"Get the output shapes info.\"\"\"\n        out_shapes = []\n        shapes = self.nd_.attr.get('_output_shapes')\n        if shapes:\n            for d in shapes.list.shape:\n                shape = []\n                for v in range(len(d.dim)):\n                    shape.append(d.dim[v].size)\n                out_shapes.append(shape)\n        else:\n            raise ValueError(f'{self.name} does not have output shapes.')\n        return out_shapes\n", "docstring": "Get the output shapes info.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def get_format(self):\n        \"\"\"Get the output data format info.\"\"\"\n        if self.nd_.attr.get('data_format') and self.op_type != 'BiasAdd':\n            return self.nd_.attr.get('data_format').s.decode(encoding='utf-8')\n        else:\n            return None\n", "docstring": "Get the output data format info.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def attribute(self, attr_name: str) -> Any:\n        \"\"\"Return the attributes data corresponding to the node.\"\"\"\n        attrs = [x for x in self.attributes if x == attr_name]\n        if len(attrs) != 1:\n            raise ValueError(f'{self.op_type} {self.name} doesn\\'t have the valid attribute.')\n        # TODO: hard coded for now, looking for better extraction methods\n        attrs_data = []\n        if attr_name == 'padding' or attr_name == 'data_format':\n            attrs_data.append(self.nd_.attr[attr_name].s)\n        elif attr_name in {'strides', 'ksize'}:\n            attrs_data.append(self.nd_.attr[attr_name].list.i)\n        elif attr_name in {'epsilon', 'alpha'}:\n            attrs_data.append(self.nd_.attr[attr_name].f)\n        elif attr_name == 'is_training' or attr_name == 'use_cudnn_on_gpu':\n            attrs_data.append(self.nd_.attr[attr_name].b)\n        elif attr_name in {'block_size', 'num_split'}:\n            attrs_data.append(self.nd_.attr[attr_name].i)\n        else:\n            raise ValueError(f'{self.op_type} {self.name} doesn\\'t have the supported attribute.')\n        return attrs_data\n", "docstring": "Return the attributes data corresponding to the node.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def name(self) -> str:\n        \"\"\"Return the name of the node.\"\"\"\n        return self.in_.name.replace('/', '_').replace('-', '_')\n", "docstring": "Return the name of the node.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def op_type(self) -> str:\n        \"\"\"Return the op type of the node.\"\"\"\n        return self.in_.op\n", "docstring": "Return the op type of the node.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def nodedef_object(self):\n        \"\"\"Return node def object.\"\"\"\n        return self.in_\n", "docstring": "Return node def object.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def is_placeholder(self):\n        \"\"\"Check op is place holder or not.\"\"\"\n        return self.in_.op == 'Placeholder'\n", "docstring": "Check op is place holder or not.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def get_data(self):\n        \"\"\"Get data in numpy format.\"\"\"\n        if self.is_placeholder:\n            raise ValueError(\n                f'{self.name} is a placeholder, which does\\'t have no data...')\n        # convert tensor content to numpy\n        if self.tensor.tensor_content:\n            dtype = type(self)._TF_TO_NP[self.tensor.dtype]\n            return np.frombuffer(self.tensor.tensor_content, dtype=dtype).copy().reshape(self.get_shape())\n        else:\n            dtype = type(self)._TF_TO_NP[self.tensor.dtype]\n            if self.tensor.dtype == 3:\n                return np.asarray(self.tensor.int_val, dtype=dtype).reshape(self.get_shape())\n            if self.tensor.dtype == 1:\n                return np.asarray(self.tensor.float_val, dtype=dtype).reshape(self.get_shape())\n", "docstring": "Get data in numpy format.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def set_shape(self, val: List[str]) -> None:\n        \"\"\"Set shape info.\"\"\"\n        raise NotImplementedError\n", "docstring": "Set shape info.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def name(self) -> str:\n        \"\"\"Return the name corresponding to the node.\"\"\"\n        return self.out_.name.replace('/', '_').replace('-', '_')\n", "docstring": "Return the name corresponding to the node.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def op_type(self) -> str:\n        \"\"\"Return the name corresponding to the node.\"\"\"\n        return self.out_.op\n", "docstring": "Return the name corresponding to the node.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def inputs(self) -> List[str]:\n        \"\"\"Return the name of corresponding inputs to the node.\"\"\"\n        def get_input_tuple(x: str) -> Tuple[str, int]:\n            ary = x.replace('/', '_').replace('-', '_').split(':', 1)\n            if len(ary) == 1:\n                return (ary[0], 0)\n            elif len(ary) == 2:\n                return (ary[0], int(ary[1]))\n            else:\n                raise AssertionError(f'Failed to parse input name: {x}')\n        return [get_input_tuple(x) for x in self.out_.input]\n", "docstring": "Return the name of corresponding inputs to the node.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def node_def_object(self):\n        \"\"\"Return node object.\"\"\"\n        return self.out_\n", "docstring": "Return node object.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def tensor_type(self):\n        \"\"\"Get shape info.\"\"\"\n        if self.out_.op in FLOAT32_TENSOR_TYPES:\n            typep = 1\n        else:\n            typep = self.out_.attr[\"T\"].type\n        return typep\n", "docstring": "Get shape info.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def get_shape(self) -> List[str]:\n        \"\"\"Get shape info.\"\"\"\n        shape = []\n        for d in self.out_.attr.get('_output_shapes').list.shape:\n            for v in range(len(d.dim)):\n                shape.append(d.dim[v].size)\n        return shape[:4]\n", "docstring": "Get shape info.\n"}
{"repo": "blueoil-master/blueoil/converter/plugins/tf.py", "original_string": "    def validate_tf(self) -> None:\n        \"\"\"Validate if the GraphDef object is proper.\"\"\"\n        gp = self.tf_gp\n        assert len(gp.node) == (len(self.in_lst) + len(self.node_lst) + len(self.out_lst))\n", "docstring": "Validate if the GraphDef object is proper.\n"}
{"repo": "blueoil-master/blueoil/converter/frontend/base.py", "original_string": "    def read(self, path: str) -> Graph:\n        \"\"\"Read a model.\n        Args:\n            path (str): Path to the file to be read\n        \"\"\"\n        pass\n", "docstring": "Read a model."}
{"repo": "blueoil-master/blueoil/converter/frontend/tensorflow.py", "original_string": "    def read(self, pb_path: str) -> Graph:\n        \"\"\"Read TF file and load model.\n        Args:\n            pb_path (str): Path to TF file\n        Returns:\n            Model: Loaded model\n        \"\"\"\n        # load tensorflow model\n        graph_def = graph_pb2.GraphDef()\n        try:\n            f = open(path.abspath(pb_path), \"rb\")\n            graph_def.ParseFromString(f.read())\n            f.close()\n        except IOError:\n            print(\"Could not open file. Creating a new one.\")\n        # import graph\n        graph = Importer.make_graph(graph_def)\n        return graph\n", "docstring": "Read TF file and load model."}
{"repo": "blueoil-master/blueoil/cmd/convert.py", "original_string": "def create_output_directory(output_root_dir, output_template_dir=None):\n    \"\"\"Create output directory from template.\n    Args:\n        output_root_dir:\n        output_template_dir:  (Default value = None)\n    Returns:\n    \"\"\"\n    base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    env_output_template_dir = os.environ.get(\n        \"OUTPUT_TEMPLATE_DIR\",\n        os.path.join(os.path.dirname(base_dir), \"output_template\"),\n    )\n    template_dir = env_output_template_dir if not output_template_dir else output_template_dir\n    # Recreate output_root_dir from template\n    if os.path.exists(output_root_dir):\n        shutil.rmtree(output_root_dir)\n    shutil.copytree(template_dir, output_root_dir, symlinks=False, copy_function=shutil.copy)\n    # Create output directories\n    output_directories = get_output_directories(output_root_dir)\n    for _, output_dir in output_directories.items():\n        if not os.path.exists(output_dir):\n            os.makedirs(output_dir)\n    return output_directories\n", "docstring": "Create output directory from template."}
{"repo": "blueoil-master/blueoil/cmd/convert.py", "original_string": "def strip_binary(arch, use_fpga, target):\n    \"\"\"Strip binary file.\n    Args:\n        output:\n    \"\"\"\n    # TODO: These operations should be performed in Makefile instead of here\n    output = _output_binary_name(arch, use_fpga, target)\n    if arch in {\"x86\", \"x86_avx\"}:\n        if target == \"executable\":\n            subprocess.run((\"strip\", output))\n        elif target == \"dynamic\":\n            subprocess.run((\"strip\", \"-x\", \"--strip-unneeded\", output))\n    elif arch == \"arm\":\n        if target == \"executable\":\n            subprocess.run((\"arm-linux-gnueabihf-strip\", output))\n        elif target == \"dynamic\":\n            subprocess.run((\"arm-linux-gnueabihf-strip\", \"-x\", \"--strip-unneeded\", output))\n", "docstring": "Strip binary file."}
{"repo": "blueoil-master/blueoil/cmd/export.py", "original_string": "def _minimal_operations(sess):\n    \"\"\"Get inference operations.\"\"\"\n    minimal_graph_def = executor.convert_variables_to_constants(sess)\n    minimal_graph = tf.Graph()\n    with minimal_graph.as_default():\n        tf.import_graph_def(minimal_graph_def, name=\"\")\n    ops = minimal_graph.get_operations()\n    return ops\n", "docstring": "Get inference operations.\n"}
{"repo": "blueoil-master/blueoil/cmd/export.py", "original_string": "def main(experiment_id, restore_path, image_size, image, config_file):\n    \"\"\"Exporting a trained model to proto buffer files and meta config yaml.\n    In the case with `image` option, create each layer output value npy files into\n    `export/{restore_path}/{image_size}/inference_test_data/**.npy` as expected value for inference test and debug.\n    \"\"\"\n    run(experiment_id, restore_path, image_size, image, config_file)\n", "docstring": "Exporting a trained model to proto buffer files and meta config yaml."}
{"repo": "blueoil-master/blueoil/cmd/measure_latency.py", "original_string": "def main(config_file, experiment_id, restore_path, image_size, step_size, cpu):\n    \"\"\"Measure the average latency of certain model's prediction at runtime.\n    The latency is averaged over number of repeated executions -- by default is to run it 100 times.\n    Each execution is measured after tensorflow is already initialized and both model and images are loaded.\n    Batch size is always 1.\n    Measure two types latency,\n    First is `overall` (including pre-post-processing which is being executed on CPU), Second is `network-only` (model inference, excluding pre-post-processing).\n    \"\"\" # NOQA\n    run(config_file, experiment_id, restore_path, image_size, step_size, cpu)\n", "docstring": "Measure the average latency of certain model's prediction at runtime."}
{"repo": "blueoil-master/blueoil/cmd/profile_model.py", "original_string": "def main(experiment_id, restore_path, config_file, bit, unquant_layers):\n    \"\"\"Profiling a trained model.\n    If it exists unquantized layers, use `-uql` to point it out.\n    \"\"\"\n    run(experiment_id, restore_path, config_file, bit, unquant_layers)\n", "docstring": "Profiling a trained model."}
{"repo": "blueoil-master/blueoil/cmd/init.py", "original_string": "def generate_image_size_validate(network_name):\n    \"\"\"Generate image_size_validate depending on task_type.\n    Args:\n        network_name (string): network name.\n    Returns: validate function.\n    \"\"\"\n    max_size = IMAGE_SIZE_VALIDATION[network_name][\"max_size\"]\n    divider = IMAGE_SIZE_VALIDATION[network_name][\"divider\"]\n    def image_size_validate(answers, current):\n        # change to tuple (height, width).\n        image_size = image_size_filter(current)\n        image_size = (int(size) for size in image_size)\n        for size in image_size:\n            if not size % divider == 0:\n                raise inquirer.errors.ValidationError('',\n                                                      reason=\"Image size should be multiple of {}, but image size is {}\"\n                                                      .format(divider, current))\n            if size > max_size:\n                raise inquirer.errors.ValidationError('',\n                                                      reason=\"Image size should be lower than {} but image size is {}\"\n                                                      .format(max_size, current))\n        return True\n    return image_size_validate\n", "docstring": "Generate image_size_validate depending on task_type."}
{"repo": "blueoil-master/blueoil/cmd/tune_ray.py", "original_string": "def subproc_call(cmd, timeout=None):\n    \"\"\"Execute a command with timeout, and return both STDOUT/STDERR.\n    Args:\n        cmd (str): the command to execute.\n        timeout (float): timeout in seconds.\n    Returns:\n        output (bytes), retcode(int): If timeout, retcode is -1.\n    \"\"\"\n    try:\n        output = subprocess.check_output(\n            cmd, stderr=subprocess.STDOUT,\n            shell=True, timeout=timeout)\n        return output, 0\n    except subprocess.TimeoutExpired as e:\n        print(\"Command '{}' timeout!\".format(cmd))\n        print(e.output.decode('utf-8'))\n        return e.output, -1\n    except subprocess.CalledProcessError as e:\n        print(\"Command '{}' failed, return code={}\".format(cmd, e.returncode))\n        print(e.output.decode('utf-8'))\n        return e.output, e.returncode\n    except Exception:\n        print(\"Command '{}' failed to run.\".format(cmd))\n        return \"\", -2\n", "docstring": "Execute a command with timeout, and return both STDOUT/STDERR."}
{"repo": "blueoil-master/blueoil/cmd/tune_ray.py", "original_string": "def get_best_trial(trial_list, metric):\n    \"\"\"Retrieve the best trial.\"\"\"\n    return max(trial_list, key=lambda trial: trial.last_result.get(metric, 0))\n", "docstring": "Retrieve the best trial.\n"}
{"repo": "blueoil-master/blueoil/cmd/tune_ray.py", "original_string": "def get_best_result(trial_list, metric, param):\n    \"\"\"Retrieve the last result from the best trial.\"\"\"\n    return {metric: get_best_trial(trial_list, metric).last_result[metric],\n            param: get_best_trial(trial_list, metric).last_result[param]}\n", "docstring": "Retrieve the last result from the best trial.\n"}
{"repo": "blueoil-master/blueoil/cmd/tune_ray.py", "original_string": "def setup_dataset(config, subset, rank):\n    \"\"\"helper function from lmnet/train.py to setup the data iterator\"\"\"\n    dataset_class = config.DATASET_CLASS\n    dataset_kwargs = {key.lower(): val for key, val in config.DATASET.items()}\n    # If there is a settings for TFDS, TFDS dataset class will be used.\n    tfds_kwargs = dataset_kwargs.pop(\"tfds_kwargs\", {})\n    if tfds_kwargs:\n        if issubclass(dataset_class, ObjectDetectionBase):\n            dataset_class = TFDSObjectDetection\n        else:\n            dataset_class = TFDSClassification\n    dataset = dataset_class(subset=subset, **dataset_kwargs, **tfds_kwargs)\n    # TODO (Neil): Enable both train and validation\n    # For some reasons processes are not terminated cleanly, enable prefetch ONLY for the train dataset.\n    enable_prefetch = dataset_kwargs.pop(\"enable_prefetch\", False) if subset == 'train' else False\n    return DatasetIterator(dataset, seed=rank, enable_prefetch=enable_prefetch)\n", "docstring": "helper function from lmnet/train.py to setup the data iterator\n"}
{"repo": "blueoil-master/blueoil/quantizations/ternary.py", "original_string": "    def backward(weights, grad_quantized):\n        \"\"\"Backward\n        Args:\n            grad_quantized(tf.Tensor): The gradient w.r.t quantized weights.\n        Return:\n            grad_weights(tf.Tensor): The gradient w.r.t. normal (non-quantized) weights.\n        \"\"\"\n        grad_weights = grad_quantized\n        return grad_weights\n", "docstring": "Backward"}
{"repo": "blueoil-master/blueoil/quantizations/ternary.py", "original_string": "    def forward(weights):\n        \"\"\"Forward\n        Args:\n            weights(tf.Variable): The weights to be quantized.\n        Returns:\n            tf.Variable: The quantized weights.\n        \"\"\"\n        ternary_threshold = tf.reduce_sum(tf.abs(weights)) * threshold / tf.cast(tf.size(weights), tf.float32)\n        mask_positive = (weights > ternary_threshold)\n        mask_negative = (weights < -ternary_threshold)\n        mask_p_or_n = mask_positive | mask_negative\n        p_or_n_weights = tf.compat.v1.where(mask_p_or_n, weights, tf.zeros_like(weights))\n        scaling_factor = tf.reduce_sum(tf.abs(p_or_n_weights)) / tf.reduce_sum(tf.cast(mask_p_or_n, tf.float32))\n        positive_weights = scaling_factor * \\\n            tf.compat.v1.where(mask_positive, tf.ones_like(weights), tf.zeros_like(weights))\n        negative_weights = - scaling_factor * \\\n            tf.compat.v1.where(mask_negative, tf.ones_like(weights), tf.zeros_like(weights))\n        quantized = positive_weights + negative_weights\n        return quantized\n", "docstring": "Forward"}
{"repo": "blueoil-master/blueoil/quantizations/binary.py", "original_string": "    def _backward(op, grad_quantized):\n        \"\"\"Backward.\n        Args:\n            op (tf.Operation): The forward operation.\n            grad_quantized (tf.Tensor): The gradient w.r.t quantized input, weights normally.\n        Returns:\n            tf.Variable: The gradient w.r.t. normal (non-quantized) input.\n        \"\"\"\n        if backward:\n            return backward(op, grad_quantized)\n        return grad_quantized\n", "docstring": "Backward."}
{"repo": "blueoil-master/blueoil/quantizations/binary.py", "original_string": "    def _forward(x):\n        \"\"\"Forward.\n        Args:\n            x (tf.Variable): The input to be quantized, weights normally.\n        Returns:\n            tf.Variable: The quantized input.\n        \"\"\"\n        # x kernel shape is [height, width, in_channels, out_channels]\n        scaling_factor = tf.reduce_mean(tf.abs(x), axis=[0, 1, 2])\n        # TODO(wakisaka): tensorflow raise error.\n        # tf.compat.v1.summary.histogram(\"scaling_factor\", scaling_factor)\n        quantized = tf.where_v2((x >= 0), 1.0, -1.0) * scaling_factor\n        return quantized\n", "docstring": "Forward."}
{"repo": "blueoil-master/blueoil/quantizations/binary.py", "original_string": "    def _backward(op, grad_quantized):\n        \"\"\"Backward.\n        Args:\n            op (tf.Operation): The forward operation.\n            grad_quantized (tf.Tensor): The gradient w.r.t quantized input, weights normally.\n        Returns:\n            tf.Variable: The gradient w.r.t. normal (non-quantized) input.\n        \"\"\"\n        if backward:\n            return backward(op, grad_quantized)\n        return grad_quantized\n", "docstring": "Backward."}
{"repo": "blueoil-master/blueoil/quantizations/binary.py", "original_string": "    def _forward(x):\n        \"\"\"Forward.\n        Args:\n            x (tf.Variable): The input to be quantized, weights normally.\n        Returns:\n            tf.Variable: The quantized input.\n        \"\"\"\n        expectation = tf.reduce_mean(tf.abs(x))\n        return tf.where_v2((x >= 0), 1.0, -1.0) * expectation\n", "docstring": "Forward."}
{"repo": "blueoil-master/blueoil/quantizations/linear.py", "original_string": "    def _backward(op, grad_quantized):\n        \"\"\"Backward.\n        Args:\n            op (tf.Operation): The forward operation.\n            grad_quantized (tf.Tensor): The gradient w.r.t quantized input, weights normally.\n        Returns:\n            tf.Variable: The gradient w.r.t. normal (non-quantized) input.\n        \"\"\"\n        if backward:\n            return backward(op, grad_quantized)\n        x = op.inputs[0]\n        true = tf.ones(tf.shape(x))\n        false = tf.zeros(tf.shape(x))\n        dx = tf.compat.v1.where((x < max_value) & (x > min_value), true, false)\n        return grad_quantized * dx, None, None\n", "docstring": "Backward."}
{"repo": "blueoil-master/blueoil/metrics/metrics.py", "original_string": "def tp_tn_fp_fn_for_each(output, labels, threshold=0.5):\n    \"\"\"Calculate True Positive, True Negative, False Positive, False Negative.\n    Args:\n        output: network output sigmoided tensor. shape is [batch_size, num_class]\n        labels: multi label encoded bool tensor. shape is [batch_size, num_class]\n        threshold: python float\n    Returns:\n        shape is [4(tp, tn, fp, fn), num_class]\n    \"\"\"\n    predicted = tf.greater_equal(output, threshold)\n    gt_positive = tf.reduce_sum(tf.cast(labels, tf.int32), axis=0, keepdims=True)\n    gt_negative = tf.reduce_sum(tf.cast(tf.logical_not(labels), tf.int32), axis=0, keepdims=True)\n    true_positive = tf.math.logical_and(predicted, labels)\n    true_positive = tf.reduce_sum(tf.cast(true_positive, tf.int32), axis=0, keepdims=True)\n    true_negative = tf.math.logical_and(tf.logical_not(predicted), tf.math.logical_not(labels))\n    true_negative = tf.reduce_sum(tf.cast(true_negative, tf.int32), axis=0, keepdims=True)\n    false_negative = gt_positive - true_positive\n    false_positive = gt_negative - true_negative\n    return tf.concat(axis=0, values=[true_positive, true_negative, false_positive, false_negative])\n", "docstring": "Calculate True Positive, True Negative, False Positive, False Negative."}
{"repo": "blueoil-master/blueoil/metrics/object_keypoint_similarity.py", "original_string": "def compute_object_keypoint_similarity(joints_gt, joints_pred, image_size=(160, 160)):\n    \"\"\"Compute a object keypoint similarity for a batch of examples.\n    Args:\n        joints_gt: a numpy array of shape (batch_size, num_joints, 3).\n        joints_pred: a numpy array of shape (batch_size, num_joints, 3).\n        image_size: a tuple, (height, width).\n    Returns:\n        oks_batch: float.\n    \"\"\"\n    batch_size = joints_gt.shape[0]\n    oks_batch = 0\n    # count of valid joints in a batch\n    count = 0\n    for i in range(batch_size):\n        oks = _compute_oks(joints_gt[i], joints_pred[i], image_size=image_size)\n        if oks != -1:\n            oks_batch += oks\n            count += 1\n    if count == 0:\n        raise ValueError(\"Count of valid joint can not be zero.\")\n    oks_batch /= count\n    return np.float32(oks_batch)\n", "docstring": "Compute a object keypoint similarity for a batch of examples."}
{"repo": "blueoil-master/blueoil/metrics/mean_average_precision.py", "original_string": "def _safe_div_zeros(numerator, denominator, name):\n    \"\"\"Divides two values, returning 0 if the denominator is <= 0.\n    Args:\n      numerator: A real `Tensor`.\n      denominator: A real `Tensor`, with dtype matching `numerator`.\n      name: Name for the returned op.\n    Returns:\n      0 if `denominator` <= 0, else `numerator` / `denominator`\n    \"\"\"\n    return tf.compat.v1.where(\n        tf.greater(denominator, 0),\n        tf.divide(numerator, denominator),\n        tf.zeros_like(numerator),\n        name=name)\n", "docstring": "Divides two values, returning 0 if the denominator is <= 0."}
{"repo": "blueoil-master/blueoil/metrics/mean_average_precision.py", "original_string": "def _mean_average_precision(all_predict_boxes, all_gt_boxes, classes, overlap_thresh=0.5):\n    \"\"\"Calcurate mean average precision.\n    Args:\n        all_predict_boxes(list): python list of numpy.ndarray. all images predicted boxes.\n            all_pred_boxes[image_index] shape is [num_pred_boxes, 6(x, y, w, h, class, scores)]\n        all_gt_boxes(numpy.ndarray): ground truth boxes.\n            shape is [num_images, num_max_gt_boxes, 5(x, y, w, h, class)]\n        classes: classes list.\n        overlap_thresh: threshold of overlap.\n    Return:\n       dictionary include 'MeanAveragePrecision' 'AveragePrecision', 'Precision', 'Recall', 'OrderedPrecision',\n       'OrderedRecall', 'OrderedMaxedPrecision'\n    \"\"\"\n    result = {\n        'MeanAveragePrecision': None,\n        'AveragePrecision': [],\n        'Precision': [],\n        'Recall': [],\n        'OrderedPrecision': [],\n        'OrderedRecall': [],\n    }\n    for class_index, class_name in enumerate(classes):\n        pred_boxes, gt_boxes = \\\n            _boxes_in_the_class(all_predict_boxes, all_gt_boxes, class_index)\n        tp, fp, num_gt_boxes = \\\n            _tp_and_fp(pred_boxes, gt_boxes, overlap_thresh)\n        ordered_precision, ordered_recall, precision, recall = _calc_precision_recall(tp, fp, num_gt_boxes)\n        average_precision = _calc_average_precision(ordered_precision, ordered_recall)\n        result['AveragePrecision'].append(average_precision)\n        result['Precision'].append(precision)\n        result['Recall'].append(recall)\n        result['OrderedPrecision'].append(ordered_precision)\n        result['OrderedRecall'].append(ordered_recall)\n    MAP = sum(result['AveragePrecision'])/len(classes)\n    result['MeanAveragePrecision'] = MAP\n    return result\n", "docstring": "Calcurate mean average precision."}
{"repo": "blueoil-master/blueoil/metrics/mean_average_precision.py", "original_string": "def _tp_and_fp(class_pred_boxes, class_gt_boxes, overlap_thresh):\n    \"\"\"Calculate tp and fp in the classes.\n    Args:\n        pred_boxes_in_the_class_list(list): predicted boxes in the class.\n            pred_boxes_in_the_class_list[image_index] shape is [num_pred_boxes, 6(x, y, w, h, class, scores)]\n        gt_boxes_in_the_class_list(list): ground truth boxes in the class.\n            gt_boxes_in_the_class_list[image_index] shape is [num_gt_boxes, 5(x, y, w, h, class)]\n    Return:\n        tps(np.ndarray): prediction boxes length vector of tp sorted by score.\n        fps(np.ndarray): prediction boxes length vector of fp sorted by score.\n        num_gt_boxes(int): number of gt boxes.\n    \"\"\"\n    assert len(class_pred_boxes) == len(class_gt_boxes)\n    num_gt_boxes = 0\n    tps = []\n    fps = []\n    scores = []\n    for image_index in range(len(class_pred_boxes)):\n        pred_boxes_in_image = class_pred_boxes[image_index]\n        gt_boxes_in_image = class_gt_boxes[image_index]\n        num_gt_boxes += len(gt_boxes_in_image)\n        tp, fp, score = tp_fp_in_the_image(pred_boxes_in_image, gt_boxes_in_image, overlap_thresh)\n        tps.append(tp)\n        fps.append(fp)\n        scores.append(score)\n    tps = np.concatenate(tps)\n    fps = np.concatenate(fps)\n    scores = np.concatenate(scores)\n    sort_index = np.argsort(-scores, axis=0)\n    return tps[sort_index], fps[sort_index], num_gt_boxes\n", "docstring": "Calculate tp and fp in the classes."}
{"repo": "blueoil-master/blueoil/metrics/mean_average_precision.py", "original_string": "def _calc_precision_recall(tp, fp, num_gt_boxes):\n    \"\"\"Calculate precision and recall array.\n    Args:\n        tp(np.ndarray): sorted tp.\n        fp(np.ndarray): sorted fp.\n        num_gt_boxes(int): number of gt boxes\n    Return:\n        precision: detection boxes size precision array\n        recall: detection boxes size recall array\n        scalar_precision: precision\n        scalar_recall: recall\n    \"\"\"\n    fp = np.cumsum(fp)\n    tp = np.cumsum(tp)\n    # when gt_boxes is zero, Recall define 100%.\n    if num_gt_boxes == 0:\n        recall = np.ones(tp.size)\n    else:\n        recall = tp / num_gt_boxes\n    # avoid divide by zero in case the first detection matches a difficult\n    # ground truth\n    precision = tp / np.maximum(tp + fp, np.finfo(np.float64).eps)\n    scalar_precision = precision[-1] if precision.size != 0 else 0\n    scalar_recall = recall[-1] if recall.size != 0 else 0\n    return precision, recall, scalar_precision, scalar_recall\n", "docstring": "Calculate precision and recall array."}
{"repo": "blueoil-master/blueoil/utils/config.py", "original_string": "def check_config(config, mode=\"inference\"):\n    \"\"\"Check config dict key. Raise error when requirement keys don't exist in config\"\"\"\n    if mode == \"inference\":\n        requirements = REQUIEMNT_PARAMS_FOR_INFERENCE\n    if mode == \"training\":\n        requirements = REQUIEMNT_PARAMS_FOR_TRAINING\n    for key in requirements:\n        if isinstance(key, tuple):\n            keys = key\n            if not any([key in config for key in keys]):\n                raise KeyError(\"config file should include {} parameter\".format(\" or \".join(keys)))\n        else:\n            if key not in config:\n                raise KeyError(\"config file should include {} parameter\".format(key))\n", "docstring": "Check config dict key. Raise error when requirement keys don't exist in config\n"}
{"repo": "blueoil-master/blueoil/utils/config.py", "original_string": "def save_yaml(output_dir, config):\n    \"\"\"Save two yaml files.\n    1. 'config.yaml' is duplication of python config file as yaml.\n    2. 'meta.yaml' for application. The yaml's keys defined by `PARAMS_FOR_EXPORT`.\n    \"\"\"\n    if not file_io.exists(output_dir):\n        file_io.makedirs(output_dir)\n    config_yaml_path = _save_config_yaml(output_dir, config)\n    meta_yaml_path = _save_meta_yaml(output_dir, config)\n    return config_yaml_path, meta_yaml_path\n", "docstring": "Save two yaml files."}
{"repo": "blueoil-master/blueoil/utils/config.py", "original_string": "def load_from_experiment():\n    \"\"\"Load saved experiment config as module.\n    Return: SmartDict object\n    \"\"\"\n    config_file = _saved_config_file_path()\n    return load(config_file)\n", "docstring": "Load saved experiment config as module."}
{"repo": "blueoil-master/blueoil/utils/config.py", "original_string": "def copy_to_experiment_dir(config_file):\n    # copy config file to the experiment directory\n    saved_config_file_path = _config_file_path_to_copy(config_file)\n    file_io.copy(config_file, saved_config_file_path, overwrite=True)\n", "docstring": "copy config file to the experiment directory"}
{"repo": "blueoil-master/blueoil/utils/executor.py", "original_string": "def init_logging(config):\n    \"\"\"Init tensorflow logging level.\n    https://github.com/tensorflow/tensorflow/blob/be52c5c09e39ac2df007fb2d62abe122d5ade6d0/tensorflow/core/platform/default/logging.h#L30\n    \"\"\"\n    if \"TF_CPP_MIN_LOG_LEVEL\" not in os.environ:\n        if not config.IS_DEBUG:\n            # set ERROR log level\n            os.environ[\"TF_CPP_MIN_LOG_LEVEL\"] = \"2\"\n", "docstring": "Init tensorflow logging level."}
{"repo": "blueoil-master/blueoil/utils/box.py", "original_string": "def iou(boxes, box):\n    \"\"\"Calculate overlap\n    Args:\n        boxes: boxes in the image. shape is [num_boxes, 4 or more(x, y, w, h, ...)]\n        box: a single box in the image. shape is [4 or more (x, y, w, h, ...)]\n    Returns:\n        iou: shape is [num_boxes]\n    \"\"\"\n    if boxes.size == 0:\n        raise ValueError(\"Cannot calculate if ground truth boxes is zero\")\n    # format boxes (left, top, right, bottom)\n    boxes = np.stack([\n        boxes[:, 0],\n        boxes[:, 1],\n        boxes[:, 0] + boxes[:, 2],\n        boxes[:, 1] + boxes[:, 3],\n    ], axis=1)\n    # format box (left, top, right, bottom)\n    box = np.array([\n        box[0],\n        box[1],\n        box[0] + box[2],\n        box[1] + box[3],\n    ])\n    # calculate the left up point\n    left_top = np.maximum(boxes[:, 0:2], box[0:2])\n    # calculate the right bottom point\n    right_bottom = np.minimum(boxes[:, 2:], box[2:])\n    horizon_vertical = np.maximum(right_bottom - left_top, 0)\n    intersection = horizon_vertical[:, 0] * horizon_vertical[:, 1]\n    areas = (boxes[:, 2] - boxes[:, 0]) * (boxes[:, 3] - boxes[:, 1])\n    area = (box[2] - box[0]) * (box[3] - box[1])\n    epsilon = 1e-10\n    union = area + areas - intersection\n    return intersection / (union + epsilon)\n", "docstring": "Calculate overlap"}
{"repo": "blueoil-master/blueoil/utils/box.py", "original_string": "def crop_boxes(boxes, crop_rect):\n    \"\"\"Crop boxes\n    Args:\n        boxes: ground truth boxes in the image. shape is [num_boxes, 5(x, y, w, h, class)]\n        crop_rect: a crop rectangle. shape is [4(x, y, w, h)]\n    Returns:\n        cropped_boxes: shape is [num_boxes, 5(x, y, w, h, class)]\n    \"\"\"\n    # check crop_rect overlap with boxes.\n    if ((crop_rect[0] + crop_rect[2]) < boxes[:, 0]).any():\n        raise ValueError(\"Crop_rect does not overlap with some boxes.\"\n                         \"Increasing x or w of crop_rect may be helpful.\")\n    if ((crop_rect[1] + crop_rect[3]) < boxes[:, 1]).any():\n        raise ValueError(\"Crop_rect does not overlap with some boxes.\"\n                         \"Increasing y or h of crop_rect may be helpful.\")\n    if (crop_rect[0] > (boxes[:, 0] + boxes[:, 2])).any():\n        raise ValueError(\"Crop_rect does not overlap with some boxes.\"\n                         \"Decreasing x of crop_rect may be helpful.\")\n    if (crop_rect[1] > (boxes[:, 1] + boxes[:, 3])).any():\n        raise ValueError(\"Crop_rect does not overlap with some boxes.\"\n                         \"Decreasing y of crop_rect may be helpful.\")\n    # format to xmin, ymin, xmax, ymax\n    cropped_boxes = np.stack([\n        boxes[:, 0],\n        boxes[:, 1],\n        boxes[:, 0] + boxes[:, 2],\n        boxes[:, 1] + boxes[:, 3],\n    ], axis=1)\n    # shift to crop size.\n    cropped_boxes = np.stack([\n        cropped_boxes[:, 0] - crop_rect[0],\n        cropped_boxes[:, 1] - crop_rect[1],\n        cropped_boxes[:, 2] - crop_rect[0],\n        cropped_boxes[:, 3] - crop_rect[1],\n    ], axis=1)\n    # adjust beyond box\n    cropped_boxes = np.stack([\n        np.maximum(cropped_boxes[:, 0], 0),\n        np.maximum(cropped_boxes[:, 1], 0),\n        np.minimum(cropped_boxes[:, 2], crop_rect[2]),\n        np.minimum(cropped_boxes[:, 3], crop_rect[3]),\n    ], axis=1)\n    # format to x, y, w, h\n    cropped_boxes = np.stack([\n        cropped_boxes[:, 0],\n        cropped_boxes[:, 1],\n        cropped_boxes[:, 2] - cropped_boxes[:, 0],\n        cropped_boxes[:, 3] - cropped_boxes[:, 1],\n        boxes[:, 4],\n    ], axis=1)\n    return cropped_boxes\n", "docstring": "Crop boxes"}
{"repo": "blueoil-master/blueoil/utils/predict_output/writer.py", "original_string": "def save_npy(dest, outputs, step):\n    \"\"\"Save numpy array to disk.\n    Args:\n        dest (str): path to save file\n        outputs (np.ndarray): save ndarray\n        step (int): value of training step\n    Raises:\n        PermissionError: If dest dir has no permission to write.\n        ValueError: If type of step is not int.\n    \"\"\"\n    if type(step) is not int:\n        raise ValueError(\"step must be integer.\")\n    filepath = os.path.join(dest, \"npy\", \"{}.npy\".format(step))\n    file_io.makedirs(os.path.dirname(filepath))\n    file_io.save_npy(filepath, outputs)\n    logger.info(\"save npy: {}\".format(filepath))\n", "docstring": "Save numpy array to disk."}
{"repo": "blueoil-master/output_template/python/motion_jpeg_server_from_camera.py", "original_string": "def main(model, config_file, port):\n    \"\"\"Serve motion jpeg server from video camera source.\n    1. Run inference from video camera source image.\n    2. Visualize (decorate) input image from inference result.\n    3. Response decorated image as motion jpeg.\n    \"\"\"\n    run(model, config_file, port)\n", "docstring": "Serve motion jpeg server from video camera source."}
{"repo": "blueoil-master/output_template/python/usb_camera_demo.py", "original_string": "def run_impl(config):\n    # Set variables\n    q_input = Queue(2)\n    q_output = Queue(4)\n    p_capture = Process(target=capture_loop, args=(q_input,))\n    p_capture.start()\n    p_infer = Process(target=infer_loop, args=(q_input, q_output))\n    p_infer.start()\n    window_width = 320\n    window_height = 240\n    show_handles_table = {\n        \"IMAGE.OBJECT_DETECTION\": show_object_detection,\n        \"IMAGE.CLASSIFICATION\": show_classification,\n        \"IMAGE.SEMANTIC_SEGMENTATION\": show_semantic_segmentation,\n        \"IMAGE.KEYPOINT_DETECTION\": show_keypoint_detection\n    }\n    show_handle = show_handles_table[config.TASK]\n    #  ----------- Beginning of Main Loop ---------------\n    while True:\n        if not q_output.empty():\n            result, fps, img = q_output.get()\n            show_handle(img, result, fps, window_height, window_width, config)\n            key = cv2.waitKey(1)    # Wait for 1ms\n            if key == 27:           # ESC to quit\n                sleep(1.0)          # Wait for worker's current task is finished\n                p_capture.terminate()\n                p_infer.terminate()\n                return\n    # --------------------- End of main Loop -----------------------\n", "docstring": "Set variables"}
{"repo": "blueoil-master/output_template/python/config.py", "original_string": "def load_yaml(config_file):\n    \"\"\"Load meta.yaml that is output when the model is converted.\n    Args:\n        config_file (str): Path of the configuration file.\n    Returns:\n        SmartDict: Dictionary object of loaded configuration file.\n    Examples:\n        >>> config = load_yaml(\"/path/of/meta.yaml\")\n    \"\"\"\n    with open(config_file) as config_file_stream:\n        config = yaml.load(config_file_stream, Loader=yaml.Loader)\n    # use only upper key.\n    return SmartDict({k: v for k, v in config.items() if k.isupper()})\n", "docstring": "Load meta.yaml that is output when the model is converted."}
{"repo": "blueoil-master/output_template/python/config.py", "original_string": "def build_post_process(post_processor_config):\n    \"\"\"The post processor is loaded based on the information passed,\n    It is append to a Sequence object and returned in.\n    Args:\n        post_processor_config (List[Dict[str, Optional[Dict[str, Any]]]]): List of processors to load.\n    Returns:\n        Sequence: A Sequence object with a list of processors inside.\n    Examples:\n        >>> config = [\n                {\"FormatYoloV2\": {\n                    \"anchors\": [\n                        [1.3221, 1.73145],\n                        [3.19275, 4.00944],\n                        [5.05587, 8.09892],\n                        [9.47112, 4.84053],\n                        [11.2364, 10.0071],\n                    ],\n                    \"boxes_per_cell\": 5,\n                    \"data_format\": \"NHWC\",\n                    \"image_size\": [128, 128],\n                    \"num_classes\": 1,\n                }},\n                {\"ExcludeLowScoreBox\": {\"threshold\": 0.3}},\n                {\"NMS\": {\n                    \"classes\": [\"person\"],\n                    \"iou_threshold\": 0.5,\n                    \"max_output_size\": 100,\n                    \"per_class\": True,\n                }},\n            ]\n        >>> post_processors = build_post_process(config)\n    \"\"\"\n    return _build_process(post_processor, post_processor_config)\n", "docstring": "The post processor is loaded based on the information passed,"}
{"repo": "blueoil-master/output_template/python/lmnet/tensorflow_graph_runner.py", "original_string": "    def __init__(self, model_path):\n        \"\"\"Initialize by setting the model path first.\n        Args:\n            model_path(string): The protocol buffer file location.\n        \"\"\"\n        self.sess = None\n        self.output_op = None\n        self.images_placeholder = None\n        self.model_path = model_path\n", "docstring": "Initialize by setting the model path first."}
{"repo": "blueoil-master/output_template/python/blueoil/data_processor.py", "original_string": "    def set_image_size(self, image_size):\n        \"\"\"Override processors image size\n        Args:\n            image_size(tuple): (height, width)\n        \"\"\"\n        # Avoid circular import\n        from blueoil.pre_processor import Resize, ResizeWithGtBoxes, ResizeWithMask, LetterBoxes\n        from blueoil.post_processor import FormatYoloV2\n        for process in self.processors:\n            class_list = (Resize, ResizeWithGtBoxes, ResizeWithMask, LetterBoxes)\n            if isinstance(process, class_list):\n                process.size = image_size\n            if isinstance(process, FormatYoloV2):\n                process.image_size = image_size\n", "docstring": "Override processors image size"}
{"repo": "blueoil-master/output_template/python/blueoil/data_processor.py", "original_string": "    def __call__(self, **kwargs):\n        \"\"\"Call processor method for each a element of data.\n        Return image and labels etc.\n        \"\"\"\n        return kwargs\n", "docstring": "Call processor method for each a element of data."}
{"repo": "blueoil-master/tests/converter/test_graph.py", "original_string": "    def test_graph_conv(self) -> None:\n        \"\"\"Test code for making a simple graph with Conv.\"\"\"\n        graph = Graph()\n        # two inputs\n        x = Input(\n            'input',\n            [1, 5, 5, 3],\n            Float32(),\n        )\n        w = Constant(\n            'weight',\n            Float32(),\n            np.zeros([1, 2, 2, 3])\n        )\n        # Conv\n        conv = Conv(\n            'conv',\n            [1, 4, 4, 3],\n            Float32(),\n            {'X': x, 'W': w},  # you can get these keys by 'Conv.input_names'\n            kernel_shape=[2, 2]\n        )\n        # One output\n        y = Output(\n            'output',\n            [1, 4, 4, 3],\n            Float32(),\n            {'input': conv}  # you can get this key by 'Output.input_names'\n        )\n        # add ops to the graph\n        graph.add_op(x)\n        graph.add_op(w)\n        graph.add_op(conv)\n        graph.add_op(y)\n        self.assertTrue(graph.check_nodes(), \"All inputs of operators must match their outputs.\")\n        print(\"Graph test passed!\")\n", "docstring": "Test code for making a simple graph with Conv.\n"}
{"repo": "blueoil-master/tests/converter/test_code_generation.py", "original_string": "def dict_codegen_classification(cpu_name, use_fpga) -> dict:\n    \"\"\"Test parameters for testing code generation for classification on CPU \"\"\"\n    return {'model_path': os.path.join('tests', 'fixtures',\n                                       'classification', 'lmnet_quantize_cifar10_space_to_depth'),\n            'expected_output_set_name': '1000_dog.png',\n            'prefix': 'cls',\n            'input_name': '000_images_placeholder:0.npy',\n            'output_npy_name': '133_output:0.npy',\n            'cpu_name': cpu_name,\n            'use_fpga': use_fpga,\n            'hard_quantize': True,\n            'threshold_skipping': False,\n            }\n", "docstring": "Test parameters for testing code generation for classification on CPU \n"}
{"repo": "blueoil-master/tests/converter/test_code_generation.py", "original_string": "def dict_codegen_object_detection(cpu_name, use_fpga) -> dict:\n    \"\"\"Test parameters for testing code generation for object detection on CPU\"\"\"\n    return {'model_path': os.path.join('tests', 'fixtures',\n                                       'object_detection', 'fyolo_quantize_4_v4'),\n            'expected_output_set_name': 'network_input_output',\n            'prefix': 'det',\n            'input_name': '000_images_placeholder:0.npy',\n            'output_npy_name': '317_output:0.npy',\n            'cpu_name': cpu_name,\n            'use_fpga': use_fpga,\n            'hard_quantize': True,\n            'threshold_skipping': False,\n            }\n", "docstring": "Test parameters for testing code generation for object detection on CPU\n"}
{"repo": "blueoil-master/tests/converter/test_binary.py", "original_string": "    def test_time_measurement_with_x86(self) -> None:\n        \"\"\"Test code for time measurement on x86.\"\"\"\n        model_path = os.path.join(\n            'tests',\n            'fixtures',\n            'classification',\n            'lmnet_quantize_cifar10')\n        output_path = self.build_dir\n        project_name = 'test_binary'\n        arch_name = 'x86'\n        bin_name = 'lm_' + arch_name\n        project_dir = os.path.join(output_path, project_name + '.prj')\n        generated_bin = os.path.join(project_dir, bin_name + '.elf')\n        input_dir_path = os.path.abspath(os.path.join(os.getcwd(), model_path))\n        input_path = os.path.join(input_dir_path, 'minimal_graph_with_shape.pb')\n        debug_data_filename = 'cat.jpg'\n        compressed_debug_data_path = os.path.join(input_dir_path, debug_data_filename + '.tar.gz')\n        debug_data_path = os.path.join(output_path, debug_data_filename)\n        debug_data_input = os.path.join(debug_data_path, '000_images_placeholder:0.npy')\n        debug_data_output = os.path.join(debug_data_path, '133_output:0.npy')\n        gp.run(input_path=input_path,\n               dest_dir_path=output_path,\n               project_name=project_name,\n               activate_hard_quantization=False,\n               threshold_skipping=False,\n               debug=False,\n               cache_dma=False)\n        self.assertTrue(os.path.exists(project_dir))\n        run_and_check(['make', 'clean'],\n                      project_dir,\n                      join(project_dir, \"make_clean.out\"),\n                      join(project_dir, \"make_clean.err\"),\n                      self)\n        run_and_check(['make', 'build', 'ARCH=' + arch_name, 'TYPE=executable', '-j8'],\n                      project_dir,\n                      join(project_dir, \"make.out\"),\n                      join(project_dir, \"make.err\"),\n                      self)\n        self.assertTrue(os.path.exists(generated_bin))\n        run_and_check(['tar', 'xvzf', str(compressed_debug_data_path), '-C', str(output_path)],\n                      output_path,\n                      join(output_path, \"tar_xvzf.out\"),\n                      join(output_path, \"tar_xvzf.err\"),\n                      self,\n                      check_stdout_include=[debug_data_filename + '/raw_image.npy'])\n        self.assertTrue(os.path.exists(debug_data_input))\n        self.assertTrue(os.path.exists(debug_data_output))\n        run_and_check([str(generated_bin), str(debug_data_input), str(debug_data_output)],\n                      project_dir,\n                      join(project_dir, \"elf.out\"),\n                      join(project_dir, \"elf.err\"),\n                      self,\n                      check_stdout_include=['TotalRunTime '])\n        print(f\"Binary time-measurement test : passed!\")\n", "docstring": "Test code for time measurement on x86.\n"}
{"repo": "blueoil-master/tests/converter/test_dynamic_create_op.py", "original_string": "    def test_dynamic_create_unary(self) -> None:\n        \"\"\"Test code for unary operators.\"\"\"\n        unary_ops = [\n            'Identity',\n            'BinaryMeanScalingQuantizer',\n            'Transpose',\n            'LinearMidTreadHalfQuantizer',\n            'MaxPool',\n            'AveragePool',\n            'Reshape',\n            'Softmax'\n        ]\n        # unary input\n        shape = [1, 3, 3, 3]\n        x = Constant(\n            'const',\n            Float32(),\n            np.zeros(shape)\n        )\n        name = 'test'\n        dtype = Float32()\n        for op in unary_ops:\n            shape = [1, 3, 3, 3]\n            module = importlib.import_module('blueoil.converter.core.operators')\n            try:\n                op_def = getattr(module, op)\n                input_ops = {n: x for n in op_def.input_names}\n                shape = self.reverse_shape(shape) if op == 'Transpose' \\\n                    else [1, 2, 2, 3] if op == 'MaxPool' or op == 'AveragePool' \\\n                    else shape\n                args = [name, shape, dtype, input_ops]\n                obj = op_def(*args)\n                self.assertEqual(obj.name, name)\n            except Exception as e:\n                print(f'failed in testing {op}.')\n                raise e\n        print(\"Dynamic unary operator load test passed!\")\n", "docstring": "Test code for unary operators.\n"}
{"repo": "blueoil-master/tests/converter/test_dynamic_create_op.py", "original_string": "    def test_dynamic_create_binary(self) -> None:\n        \"\"\"Test code for binary operators.\"\"\"\n        x = Constant(\n            'const1',\n            Float32(),\n            np.zeros([1, 3, 3, 3])\n        )\n        w = Constant(\n            'const2',\n            Float32(),\n            np.zeros([1, 2, 2, 3])\n        )\n        binary_ops = [\n            'Conv',\n            'Add'\n        ]\n        name = 'test'\n        dtype = Float32()\n        for op in binary_ops:\n            shape = [1, 3, 3, 3]\n            module = importlib.import_module('blueoil.converter.core.operators')\n            try:\n                op_def = getattr(module, op)\n                shape = [1, 2, 2, 3] if op == 'Conv' else shape\n                input_ops = {n: opw for n, opw in zip(op_def.input_names, [x, w])} \\\n                    if op == 'Conv' else {n: x for n in op_def.input_names}\n                args = [name, shape, dtype, input_ops]\n                obj = op_def(*args)\n                self.assertEqual(obj.name, name)\n            except Exception as e:\n                print(f'failed in testing {op}.')\n                raise e\n        print(\"Dynamic binary operator load test passed!\")\n", "docstring": "Test code for binary operators.\n"}
{"repo": "blueoil-master/tests/converter/test_tf_io.py", "original_string": "    def test_tf_import(self) -> None:\n        \"\"\"Test code for importing Tensorflow file with TensorflowIO.\"\"\"\n        tf_path = path.join('tests', 'fixtures',\n                            'classification',\n                            'lmnet_v1_toy_graph',\n                            'minimal_graph_with_shape.pb')\n        tf_io = TensorFlowIO()\n        graph: Graph = tf_io.read(tf_path)\n        outputs = graph.get_outputs()\n        self.assertEqual(len(outputs), 1)\n        self.assertEqual(outputs[0].shape, [1, 10])\n        print(\"TF file import test passed!\")\n", "docstring": "Test code for importing Tensorflow file with TensorflowIO.\n"}
{"repo": "blueoil-master/tests/converter/test_tf_io.py", "original_string": "    def test_import_group_convolution_classification(self) -> None:\n        \"\"\"Test code for importing Tensorflow file with TensorflowIO.\"\"\"\n        tf_path = path.join('tests', 'fixtures',\n                            'classification',\n                            'lmnet_v1_group_conv',\n                            'minimal_graph_with_shape.pb')\n        tf_io = TensorFlowIO()\n        graph: Graph = tf_io.read(tf_path)\n        outputs = graph.get_outputs()\n        self.assertEqual(len(outputs), 1)\n        self.assertEqual(outputs[0].shape, [1, 10])\n        print(\"TF file import test passed for group convolution!\")\n", "docstring": "Test code for importing Tensorflow file with TensorflowIO.\n"}
{"repo": "blueoil-master/tests/converter/test_tf_io.py", "original_string": "        def equals(op1: Operator, op2: Operator) -> bool:\n            \"\"\"Return if these two objects are equivalent.\"\"\"\n            if op1 is None or not isinstance(op1, Operator):\n                print(f'{op1.name} has different type.')\n                return False\n            if op2 is None or not isinstance(op2, Operator):\n                print(f'{op2.name} has different type.')\n                return False\n            eq_type = op1.op_type == op2.op_type\n            if not eq_type:\n                print(f'{op1.name} and {op2.name} have different type: {op1.op_type} and {op2.op_type}')\n            eq_dtype = op1.dtype == op2.dtype\n            if not eq_dtype:\n                print(f'{op1.name} and {op2.name} have different dtype: {op1.dtype} and {op2.dtype}')\n            # Transpose the graph for data comparison if necessary\n            if op1.dimension != op2.dimension:\n                perm = [op2.dimension.index(s) for s in op1.dimension]\n                new_shape: List[int] = [op2.shape[i] for i in perm]\n                new_dimension: str = functools.reduce(lambda x, y: x + y, [op2.dimension[i] for i in perm])\n                new_data: np.ndarray = op2.data.transpose(perm)\n            else:\n                new_shape = op2.shape\n                new_dimension = op2.dimension\n                new_data = op2.data\n            eq_dim = op1.dimension == new_dimension\n            if not eq_dim:\n                print(f'{op1.name} and {op2.name} have different dimension: {op1.dimension} and {op2.dimension}')\n            eq_shape = op1.shape == new_shape\n            if not eq_shape:\n                print(f'{op1.name} and {op2.name} have different shape: {op1.shape} and {op2.shape}')\n            eq_data = eq_shape and np.allclose(op1.data, new_data)\n            if not eq_data:\n                print(f'{op1.name} and {op2.name} have different data: {op1.data} and {op2.data}')\n            return eq_type and eq_shape and eq_dtype and eq_dim and eq_data\n", "docstring": "Return if these two objects are equivalent.\n"}
{"repo": "blueoil-master/tests/converter/test_consistency_check.py", "original_string": "    def test_add_consistency1(self) -> None:\n        \"\"\"Test code for 'Add', which succeeds.\"\"\"\n        a = Constant(\n            'const1',\n            Float32(),\n            np.zeros([1, 3, 3])\n        )\n        b = Constant(\n            'const2',\n            Float32(),\n            np.zeros([3])\n        )\n        input_ops = {'A': cast(Operator, a), 'B': cast(Operator, b)}\n        Add(\n            'add1',\n            [1, 3, 3],\n            Float32(),\n            input_ops\n        )\n        print(\"Consistency test for 'Add' #1 passed!\")\n", "docstring": "Test code for 'Add', which succeeds.\n"}
{"repo": "blueoil-master/tests/converter/test_consistency_check.py", "original_string": "    def test_pool_consistency(self) -> None:\n        \"\"\"Test code for Pool.\"\"\"\n        x = Constant(\n            'const1',\n            Float32(),\n            np.zeros([1, 3, 3, 3])\n        )\n        input_ops = {'X': cast(Operator, x)}\n        MaxPool(\n            'max_pool1',\n            [1, 2, 2, 3],\n            Float32(),\n            input_ops,\n            kernel_shape=[3, 3],\n            pads=[1, 1, 1, 1],\n            strides=[2, 2]\n        )\n        print(\"Consistency test for pooling operator passed!\")\n", "docstring": "Test code for Pool.\n"}
{"repo": "blueoil-master/tests/converter/test_optimizer.py", "original_string": "    def test_pass_transpose(self) -> None:\n        \"\"\"Test code for transposing optimizer pass.\"\"\"\n        data = np.random.rand(3, 2, 2, 1)\n        graph1 = self.create_sample_graph(data)\n        graph2 = self.create_expected_graph(data)\n        pass_transpose(graph1)\n        self.assertEqual(graph1, graph2, 'transpose to NHWC failed.')\n        print(\"Test pass #1 transpose passed!\")\n", "docstring": "Test code for transposing optimizer pass.\n"}
{"repo": "blueoil-master/tests/converter/test_optimizer.py", "original_string": "    def test_pass_remove_identities(self) -> None:\n        \"\"\"Test code for removing identities optimizer pass.\"\"\"\n        data = np.random.rand(1, 2, 2, 3)\n        graph1 = self.create_sample_graph(data)\n        graph2 = self.create_expected_graph(data)\n        pass_remove_identities(graph1)\n        self.assertEqual(graph1, graph2, 'remove identities failed.')\n        print(\"Test pass #2 remove identities passed!\")\n", "docstring": "Test code for removing identities optimizer pass.\n"}
{"repo": "blueoil-master/tests/converter/test_optimizer.py", "original_string": "    def test_pass_propagate_quantization_details_into_conv(self) -> None:\n        \"\"\"Test pass.\"\"\"\n        data1 = np.random.rand(1, 2, 2, 3)\n        data2 = np.random.rand(1, 2, 2, 3)\n        graph1 = self.create_sample_graph(data1, data2)\n        graph2 = self.create_expected_graph(data1, data2)\n        pass_propagate_quantization_details_into_conv(graph1)\n        aq_g1 = graph1.get_op('conv2').a_quantizer\n        aq_g2 = graph2.get_op('conv2').a_quantizer\n        kq_g1 = graph1.get_op('conv2').quantizer\n        kq_g2 = graph2.get_op('conv2').quantizer\n        self.assertEqual(len(aq_g1), len(aq_g2), '[Failed] Found number of activation quantizer not matched')\n        if aq_g1 and aq_g2:\n            self.assertEqual(aq_g1[0].op_type, aq_g2[0].op_type,\n                             '[Failed] Found type of activation quantizer not matched')\n        self.assertEqual(kq_g1.op_type, kq_g2.op_type, '[Failed] Found type of kernel quantizer not matched')\n        self.assertEqual(graph1, graph2, '[Failed] Expected graph not matched')\n        print(\"Test pass #3 propagate_quantization_details_into_conv passed!\")\n", "docstring": "Test pass.\n"}
{"repo": "blueoil-master/tests/converter/test_optimizer.py", "original_string": "    def test_pass_pack_weights(self) -> None:\n        \"\"\"Test pass.\"\"\"\n        data1 = np.float32(np.random.rand(1, 2, 2, 3))\n        data2 = np.float32(np.random.rand(1, 2, 2, 3))\n        graph1 = self.create_sample_graph(data1, data2)\n        pass_pack_weights(graph1)\n        self.assertEqual(graph1.get_op('conv2').input_ops['W'].op_type, 'Constant',\n                         '[Failed] Found input kernel weights not a constant')\n        graph_2_1 = self.create_sample_graph_2(data1)\n        graph_2_2 = self.create_sample_graph_2(data1)\n        pass_pack_weights(graph_2_2)\n        self.assertEqual(graph_2_1, graph_2_2,\n                         '[Failed] Found optimized graph not the same')\n        print(\"Test pass #4 pack_weights passed!\")\n", "docstring": "Test pass.\n"}
{"repo": "blueoil-master/tests/converter/test_optimizer.py", "original_string": "    def test_pass_quantize_convolutions(self) -> None:\n        \"\"\"Test pass.\"\"\"\n        data1 = np.float32(np.random.rand(1, 2, 2, 3))\n        data2 = np.float32(np.random.rand(1, 2, 2, 3))\n        graph1 = self.create_sample_graph(data1, data2)\n        pass_quantize_convolutions(graph1)\n        self.assertEqual(graph1.get_op('aqtz1').dtype, QUANTIZED_PACKED(),\n                         '[Failed] Found output dtype of activation quantizer not proper')\n        self.assertEqual(graph1.get_op('kqtz1').dtype, PackedUint32(),\n                         '[Failed] Found output dtype of kernel quantizer not proper')\n        self.assertEqual(graph1.get_op('conv2').dtype, Float32(),\n                         '[Failed] Found output dtype of conv not proper')\n        print(\"Test pass #5 quantize_convolutions passed!\")\n", "docstring": "Test pass.\n"}
{"repo": "blueoil-master/tests/converter/test_optimizer.py", "original_string": "    def test_pass_propagate_datatypes(self) -> None:\n        \"\"\"Test pass.\"\"\"\n        data1 = np.float32(np.random.rand(1, 2, 2, 3))\n        graph1 = self.create_sample_graph(data1)\n        # graph2 = self.create_expected_graph(data1, data2)\n        pass_propagate_datatypes(graph1)\n        self.assertEqual(graph1.get_op('s2d').dtype, QUANTIZED_PACKED(),\n                         '[Failed] Found dtype of SpaceToDepth not propagate correctly')\n        print(\"Test pass #6 propagate data types passed!\")\n", "docstring": "Test pass.\n"}
{"repo": "blueoil-master/tests/converter/test_optimizer.py", "original_string": "    def test_pass_compute_thresholds(self) -> None:\n        \"\"\"Test pass.\"\"\"\n        data1 = np.float32(np.random.rand(1, 2, 2, 3))\n        data2 = np.float32(np.random.rand(1, 2, 2, 3))\n        graph1 = self.create_sample_graph(data1, data2)\n        pass_compute_thresholds(graph1)\n        self.assertEqual(graph1.get_op('conv2').has_thresholds, True,\n                         '[Failed] Found threshold of Conv not calculated')\n        print(\"Test pass #8 compute_thresholds passed!\")\n", "docstring": "Test pass.\n"}
{"repo": "blueoil-master/tests/converter/test_optimizer.py", "original_string": "    def test_pass_constant_folding(self) -> None:\n        \"\"\"Test pass.\"\"\"\n        graph1 = self.create_sample_graph()\n        pass_constant_folding(graph1)\n        self.assertEqual(set(graph1.get_op('potatoes_new').data), set(np.array([2, 5])),\n                         '[Failed] Found folded constant not correct')\n        print(\"Test pass #9 constant folding passed!\")\n", "docstring": "Test pass.\n"}
{"repo": "blueoil-master/tests/converter/test_operators.py", "original_string": "    def test_maxpool(self) -> None:\n        \"\"\"Test code for MaxPool.\"\"\"\n        # get MaxPool's input names\n        i_names = MaxPool.input_names\n        self.assertEqual(i_names, ['X'])\n        # set x to MaxPool m's input\n        x = Constant(\n            'const',\n            Float32(),\n            np.zeros([1, 3, 3, 3])\n        )\n        inputs: Dict[str, Operator] = {i_names[0]: x}\n        MaxPool(\n            \"MaxPool\",\n            [1, 2, 2, 3],\n            Float32(),\n            inputs,\n            kernel_shape=[2, 2]\n        )\n        print(\"MaxPool test passed!\")\n", "docstring": "Test code for MaxPool.\n"}
{"repo": "blueoil-master/tests/converter/test_packer.py", "original_string": "    def test_bw1_dividable_by_wordsize(self):\n        \"\"\"Test for when the input tensor size is able to divide by wordsize (1 bit version).\"\"\"\n        packer = Packer(1, 32)\n        test_input = np.zeros([32], dtype=np.float32)\n        test_input[0:6] = [0, 1, 0, 1, 0, 1]\n        test_output = packer.run(test_input)\n        self.assertEqual(test_output[0], 42)\n", "docstring": "Test for when the input tensor size is able to divide by wordsize (1 bit version).\n"}
{"repo": "blueoil-master/tests/converter/test_packer.py", "original_string": "    def test_bw1_not_dividable_by_wordsize(self):\n        \"\"\"Test for when the input tensor size is not able to divide by wordsize (1 bit version).\"\"\"\n        packer = Packer(1, 37)\n        test_input = np.zeros([37], dtype=np.float32)\n        test_input[0::2] = 1\n        test_output = packer.run(test_input)\n        expected_output = [1431655765]\n        np.testing.assert_array_equal(test_output[0], expected_output)\n", "docstring": "Test for when the input tensor size is not able to divide by wordsize (1 bit version).\n"}
{"repo": "blueoil-master/tests/converter/test_packer.py", "original_string": "    def test_raise_exception_bitwidth(self):\n        \"\"\"Raise an exception if an input value is larger than bitwidth.\"\"\"\n        packer = Packer(2, 32)\n        test_input = np.zeros([64], dtype=np.float32)\n        test_input[0:-1:2] = 1\n        test_input[0:-1:4] = 4\n        with self.assertRaises(ValueError):\n            packer.run(test_input)\n", "docstring": "Raise an exception if an input value is larger than bitwidth.\n"}
{"repo": "blueoil-master/tests/unit/create_images.py", "original_string": "def horizontal_stripe(size=[240, 120], stripe=2):\n    \"\"\"Create test image\n    Args:\n        size: [height, width]\n    \"\"\"\n    image = np.zeros((size[0], size[1], 3,), dtype=np.uint8)\n    for h in range(size[0]):\n        if h % stripe == 0:\n            image[h, :, :] = 255\n    img = PIL.Image.fromarray(image, mode=\"RGB\")\n    filename = 'horizontal_stripe_h{}_w{}.png'.format(size[0], size[1])\n    filename = os.path.join(OUTPUT_DIR, filename)\n    img.save(filename)\n    return image\n", "docstring": "Create test image"}
{"repo": "blueoil-master/tests/unit/create_images.py", "original_string": "def red(size=[240, 120]):\n    \"\"\"Create test image\n    Args:\n        size: [height, width]\n    \"\"\"\n    image = np.zeros((size[0], size[1], 3,), dtype=np.uint8)\n    image[:, :, 0] = 255\n    img = PIL.Image.fromarray(image, mode=\"RGB\")\n    filename = 'red_h{}_w{}.png'.format(size[0], size[1])\n    filename = os.path.join(OUTPUT_DIR, filename)\n    img.save(filename)\n    return image\n", "docstring": "Create test image"}
{"repo": "blueoil-master/tests/unit/create_images.py", "original_string": "def green(size=[240, 120]):\n    \"\"\"Create test image\n    Args:\n        size: [height, width]\n    \"\"\"\n    image = np.zeros((size[0], size[1], 3,), dtype=np.uint8)\n    image[:, :, 1] = 255\n    img = PIL.Image.fromarray(image, mode=\"RGB\")\n    filename = 'green_h{}_w{}.png'.format(size[0], size[1])\n    filename = os.path.join(OUTPUT_DIR, filename)\n    img.save(filename)\n    return image\n", "docstring": "Create test image"}
{"repo": "blueoil-master/tests/unit/test_configs.py", "original_string": "def test_core_configs():\n    \"\"\"Test that all config files in `configs/core` dir include requirement keys.\"\"\"\n    dir_path = os.path.join(\"configs\", \"core\")\n    for config_file in glob.glob(os.path.join(dir_path, \"**\", \"*.py\"), recursive=True):\n        config = _load_py(config_file)\n        check_config(config, \"training\")\n        check_config(config, \"inference\")\n", "docstring": "Test that all config files in `configs/core` dir include requirement keys.\n"}
{"repo": "blueoil-master/tests/unit/test_configs.py", "original_string": "def test_example_classification_config_yaml():\n    \"\"\"Test that export config and meta yaml from example classification config python.\"\"\"\n    config_file = os.path.join(\"..\", \"blueoil\", \"configs\", \"example\", \"classification.py\")\n    config = _load_py(config_file)\n    config_yaml = os.path.join(\"..\", \"blueoil\", \"configs\", \"example\", \"classification.yaml\")\n    config_meta = os.path.join(\"..\", \"blueoil\", \"configs\", \"example\", \"classification_meta.yaml\")\n    environment.init(\"test_example_classification_config_yaml\")\n    saved_config, saved_meta = save_yaml(environment.EXPERIMENT_DIR, config)\n    print(saved_meta)\n    with open(config_yaml) as f:\n        expected = f.read()\n    with open(saved_config) as f:\n        data = f.read()\n        assert expected == data\n    with open(config_meta) as f:\n        expected = f.read()\n    with open(saved_meta) as f:\n        data = f.read()\n        assert expected == data\n", "docstring": "Test that export config and meta yaml from example classification config python.\n"}
{"repo": "blueoil-master/tests/unit/test_visualize.py", "original_string": "def test_draw_fps():\n    \"\"\"Verify just image is changed.\"\"\"\n    pil_image = PIL.Image.new(\"RGB\", size=(100, 200))\n    stored = np.array(pil_image)\n    fps = 11.1\n    fps_only_network = 22.2\n    draw_fps(pil_image, fps, fps_only_network)\n    assert not np.all(np.array(stored) == np.array(pil_image))\n", "docstring": "Verify just image is changed.\n"}
{"repo": "blueoil-master/tests/unit/test_visualize.py", "original_string": "def test_object_detection():\n    \"\"\"Verify just image is changed.\"\"\"\n    input_image = PIL.Image.new(\"RGB\", size=(100, 200))\n    results = np.array([[32, 20, 10, 5, 2, 0.5], [2, 4, 2, 4, 1, 0.5]])\n    config = SmartDict({\"IMAGE_SIZE\": (64, 64), \"CLASSES\": [\"a\", \"b\", \"c\", \"d\"]})\n    result_image = visualize_object_detection(np.array(input_image), results, config)\n    assert not np.all(np.array(input_image) == np.array(result_image))\n", "docstring": "Verify just image is changed.\n"}
{"repo": "blueoil-master/tests/unit/test_visualize.py", "original_string": "def test_keypoint_detection():\n    \"\"\"Verify just image is changed.\"\"\"\n    input_image = PIL.Image.new(\"RGB\", size=(100, 200))\n    joints = np.zeros(shape=(17, 3), dtype=np.int)\n    joints[0] = [30, 30, 1]\n    result_image = visualize_keypoint_detection(np.array(input_image), joints)\n    assert not np.all(np.array(input_image) == np.array(result_image))\n", "docstring": "Verify just image is changed.\n"}
{"repo": "blueoil-master/tests/unit/test_post_processor.py", "original_string": "def test_resize_bilinear_pillow():\n    \"\"\"Verify Bilinear post process results are same as Pillow resize().\"\"\"\n    batch_size = 2\n    height = 3\n    width = 2\n    num_classes = 3\n    size = (12, 16)\n    inputs = np.random.normal(size=(batch_size, height, width, num_classes)).astype(np.float32)\n    expect = []\n    for i in range(batch_size):\n        image = inputs[i, :, :, :]\n        feature_maps = np.split(image, num_classes, axis=2)\n        result = []\n        for class_id in range(num_classes):\n            feature_map = np.squeeze(feature_maps[class_id])\n            image = PIL.Image.fromarray(feature_map)\n            resized = image.resize([size[1], size[0]], resample=PIL.Image.BILINEAR)\n            resized = np.array(resized)\n            resized = np.expand_dims(resized, axis=2)\n            result.append(resized)\n        image = np.concatenate(result, axis=2)\n        expect.append(image)\n    expect = np.array(expect)\n    bilinear = Bilinear(size=size, compatible_tensorflow_v1=False)\n    out = bilinear(outputs=inputs)[\"outputs\"]\n    assert np.allclose(out, expect, atol=1e-4, rtol=1e-4)\n", "docstring": "Verify Bilinear post process results are same as Pillow resize().\n"}
{"repo": "blueoil-master/tests/unit/test_quantizations.py", "original_string": "def numerical_derivative(x, fun):\n    \"\"\"Numerical derivative\n    \"\"\"\n    h = 1e-5\n    # use float64 to take care about derivative result precision.\n    x = x.astype(np.float64)\n    d = (fun(x + h) - fun(x - h)) / (2 * h)\n    return d.astype(np.float32)\n", "docstring": "Numerical derivative"}
{"repo": "blueoil-master/tests/unit/test_quantizations.py", "original_string": "def make_test_input(x_size=default_x_size, input_range=(-10., 10.)):\n    \"\"\"Make test input\n    \"\"\"\n    assert len(x_size) == 4\n    assert len(input_range) == 2\n    np_x = np.random.uniform(input_range[0], input_range[1], size=x_size).astype(np.float32)\n    x = tf.convert_to_tensor(np_x)\n    return np_x, x\n", "docstring": "Make test input"}
{"repo": "blueoil-master/tests/unit/conftest.py", "original_string": "def reset_default_graph():\n    \"\"\"Reset tensorflow default graph.\"\"\"\n    print(\"reset_default_graph\")\n    tf.reset_default_graph()\n", "docstring": "Reset tensorflow default graph.\n"}
{"repo": "blueoil-master/tests/unit/datasets_tests/test_camvid.py", "original_string": "def _test_camvid_basic(train_dataset, test_dataset):\n    # test train dataset\n    train_image_files, train_label_files = train_dataset.feed()\n    assert train_image_files.shape[0] == 1\n    assert train_label_files.shape[0] == 1\n    train_images, train_labels = train_dataset.feed()\n    assert isinstance(train_images, np.ndarray)\n    assert train_images.shape == (1, 360, 480, 3)\n    assert train_labels.shape == (1, 360, 480)\n    # _show_image_with_annotation(train_images[0], train_labels[0], colors)\n    # test test dataset\n    test_image_files, test_label_files = test_dataset.feed()\n    assert test_image_files.shape[0] == 1\n    assert test_label_files.shape[0] == 1\n    test_images, test_labels = test_dataset.feed()\n    assert isinstance(test_images, np.ndarray)\n    assert test_images.shape == (1, 360, 480, 3)\n    assert test_labels.shape == (1, 360, 480)\n    # _show_image_with_annotation(test_images[0], test_labels[0], colors)\n", "docstring": "test train dataset"}
{"repo": "blueoil-master/tests/unit/networks_tests/classification_test/test_example_quantize.py", "original_string": "def test_training():\n    \"\"\"Test only that no error raised.\"\"\"\n    config = SmartDict()\n    config.NETWORK_CLASS = SampleNetworkQuantize\n    config.DATASET_CLASS = Dummy\n    config.IS_DEBUG = False\n    config.IMAGE_SIZE = [32, 32]\n    config.BATCH_SIZE = 2\n    config.TEST_STEPS = 1\n    config.MAX_STEPS = 2\n    config.SAVE_CHECKPOINT_STEPS = 1\n    config.KEEP_CHECKPOINT_MAX = 5\n    config.SUMMARISE_STEPS = 1\n    config.IS_PRETRAIN = False\n    config.TASK = Tasks.CLASSIFICATION\n    # network model config\n    config.NETWORK = SmartDict()\n    config.NETWORK.OPTIMIZER_CLASS = tf.train.AdamOptimizer\n    config.NETWORK.OPTIMIZER_KWARGS = {\"learning_rate\": 0.001}\n    config.NETWORK.IMAGE_SIZE = config.IMAGE_SIZE\n    config.NETWORK.BATCH_SIZE = config.BATCH_SIZE\n    config.NETWORK.ACTIVATION_QUANTIZER = linear_mid_tread_half_quantizer\n    config.NETWORK.ACTIVATION_QUANTIZER_KWARGS = {\n        'bit': 2,\n        'max_value': 2\n    }\n    config.NETWORK.WEIGHT_QUANTIZER = binary_mean_scaling_quantizer\n    config.NETWORK.WEIGHT_QUANTIZER_KWARGS = {}\n    config.NETWORK.DATA_FORMAT = \"NHWC\"\n    # dataset config\n    config.DATASET = SmartDict()\n    config.DATASET.PRE_PROCESSOR = Resize(config.IMAGE_SIZE)\n    config.DATASET.BATCH_SIZE = config.BATCH_SIZE\n    config.DATASET.DATA_FORMAT = \"NHWC\"\n    environment.init(\"test_example_quantize\")\n    prepare_dirs(recreate=True)\n    start_training(config, profile_step=1)\n", "docstring": "Test only that no error raised.\n"}
{"repo": "blueoil-master/tests/unit/networks_tests/classification_test/test_lm_resnet_quantize.py", "original_string": "def test_training():\n    \"\"\"Test only that no error raised.\"\"\"\n    config = SmartDict()\n    config.NETWORK_CLASS = LmResnetQuantize\n    config.DATASET_CLASS = Dummy\n    config.IS_DEBUG = False\n    config.IMAGE_SIZE = [32, 32]\n    config.BATCH_SIZE = 2\n    config.TEST_STEPS = 1\n    config.MAX_STEPS = 2\n    config.SAVE_CHECKPOINT_STEPS = 1\n    config.KEEP_CHECKPOINT_MAX = 5\n    config.SUMMARISE_STEPS = 1\n    config.IS_PRETRAIN = False\n    config.TASK = Tasks.CLASSIFICATION\n    # network model config\n    config.NETWORK = SmartDict()\n    config.NETWORK.OPTIMIZER_CLASS = tf.train.AdamOptimizer\n    config.NETWORK.OPTIMIZER_KWARGS = {\"learning_rate\": 0.001}\n    config.NETWORK.IMAGE_SIZE = config.IMAGE_SIZE\n    config.NETWORK.BATCH_SIZE = config.BATCH_SIZE\n    config.NETWORK.ACTIVATION_QUANTIZER = linear_mid_tread_half_quantizer\n    config.NETWORK.ACTIVATION_QUANTIZER_KWARGS = {\n        'bit': 2,\n        'max_value': 2\n    }\n    config.NETWORK.WEIGHT_QUANTIZER = binary_mean_scaling_quantizer\n    config.NETWORK.WEIGHT_QUANTIZER_KWARGS = {}\n    # dataset config\n    config.DATASET = SmartDict()\n    config.DATASET.PRE_PROCESSOR = Resize(config.IMAGE_SIZE)\n    config.DATASET.BATCH_SIZE = config.BATCH_SIZE\n    environment.init(\"test_lm_resnet_quantize\")\n    prepare_dirs(recreate=True)\n    start_training(config, profile_step=1)\n", "docstring": "Test only that no error raised.\n"}
{"repo": "blueoil-master/tests/unit/networks_tests/classification_test/test_darknet.py", "original_string": "def test_training():\n    \"\"\"Test only no error raised.\"\"\"\n    config = SmartDict()\n    config.NETWORK_CLASS = Darknet\n    config.DATASET_CLASS = Dummy\n    config.IS_DEBUG = False\n    config.IMAGE_SIZE = [28, 14]\n    config.BATCH_SIZE = 2\n    config.TEST_STEPS = 1\n    config.MAX_STEPS = 2\n    config.SAVE_CHECKPOINT_STEPS = 1\n    config.KEEP_CHECKPOINT_MAX = 5\n    config.SUMMARISE_STEPS = 1\n    config.IS_PRETRAIN = False\n    config.TASK = Tasks.CLASSIFICATION\n    # network model config\n    config.NETWORK = SmartDict()\n    config.NETWORK.OPTIMIZER_CLASS = tf.train.AdamOptimizer\n    config.NETWORK.OPTIMIZER_KWARGS = {\"learning_rate\": 0.001}\n    config.NETWORK.IMAGE_SIZE = config.IMAGE_SIZE\n    config.NETWORK.BATCH_SIZE = config.BATCH_SIZE\n    # daasegt config\n    config.DATASET = SmartDict()\n    config.DATASET.PRE_PROCESSOR = Resize(config.IMAGE_SIZE)\n    config.DATASET.BATCH_SIZE = config.BATCH_SIZE\n    environment.init(\"test_darknet\")\n    prepare_dirs(recreate=True)\n    start_training(config, profile_step=1)\n", "docstring": "Test only no error raised.\n"}
{"repo": "blueoil-master/tests/unit/networks_tests/classification_test/test_lmnet_quantize.py", "original_string": "def test_training():\n    \"\"\"Test only that no error raised.\"\"\"\n    config = SmartDict()\n    config.NETWORK_CLASS = LmnetQuantize\n    config.DATASET_CLASS = Dummy\n    config.IS_DEBUG = False\n    config.IMAGE_SIZE = [32, 32]\n    config.BATCH_SIZE = 2\n    config.TEST_STEPS = 1\n    config.MAX_STEPS = 2\n    config.SAVE_CHECKPOINT_STEPS = 1\n    config.KEEP_CHECKPOINT_MAX = 5\n    config.SUMMARISE_STEPS = 1\n    config.IS_PRETRAIN = False\n    config.TASK = Tasks.CLASSIFICATION\n    # network model config\n    config.NETWORK = SmartDict()\n    config.NETWORK.OPTIMIZER_CLASS = tf.train.AdamOptimizer\n    config.NETWORK.OPTIMIZER_KWARGS = {\"learning_rate\": 0.001}\n    config.NETWORK.IMAGE_SIZE = config.IMAGE_SIZE\n    config.NETWORK.BATCH_SIZE = config.BATCH_SIZE\n    config.NETWORK.ACTIVATION_QUANTIZER = linear_mid_tread_half_quantizer\n    config.NETWORK.ACTIVATION_QUANTIZER_KWARGS = {\n        'bit': 2,\n        'max_value': 2\n    }\n    config.NETWORK.WEIGHT_QUANTIZER = binary_mean_scaling_quantizer\n    config.NETWORK.WEIGHT_QUANTIZER_KWARGS = {}\n    # dataset config\n    config.DATASET = SmartDict()\n    config.DATASET.PRE_PROCESSOR = Resize(config.IMAGE_SIZE)\n    config.DATASET.BATCH_SIZE = config.BATCH_SIZE\n    environment.init(\"test_lmnet_quantize\")\n    prepare_dirs(recreate=True)\n    start_training(config, profile_step=1)\n", "docstring": "Test only that no error raised.\n"}
{"repo": "blueoil-master/tests/unit/networks_tests/segmentation_tests/test_lm_bisenet.py", "original_string": "def test_training():\n    \"\"\"Verify only that no error raised.\"\"\"\n    config = SmartDict()\n    config.NETWORK_CLASS = LMBiSeNet\n    config.DATASET_CLASS = DummyCamvid\n    config.IS_DEBUG = False\n    config.IMAGE_SIZE = [128, 160]\n    config.BATCH_SIZE = 2\n    config.TEST_STEPS = 1\n    config.MAX_STEPS = 2\n    config.SAVE_CHECKPOINT_STEPS = 1\n    config.KEEP_CHECKPOINT_MAX = 5\n    config.SUMMARISE_STEPS = 1\n    config.IS_PRETRAIN = False\n    config.TASK = Tasks.SEMANTIC_SEGMENTATION\n    # network model config\n    config.NETWORK = SmartDict()\n    config.NETWORK.OPTIMIZER_CLASS = tf.train.AdamOptimizer\n    config.NETWORK.OPTIMIZER_KWARGS = {\"learning_rate\": 0.001}\n    config.NETWORK.IMAGE_SIZE = config.IMAGE_SIZE\n    config.NETWORK.BATCH_SIZE = config.BATCH_SIZE\n    config.NETWORK.DATA_FORMAT = \"NHWC\"\n    # daasegt config\n    config.DATASET = SmartDict()\n    config.DATASET.PRE_PROCESSOR = Resize(config.IMAGE_SIZE)\n    config.DATASET.BATCH_SIZE = config.BATCH_SIZE\n    config.DATASET.DATA_FORMAT = \"NHWC\"\n    environment.init(\"test_lm_bisenet\")\n    prepare_dirs(recreate=True)\n    start_training(config, profile_step=1)\n", "docstring": "Verify only that no error raised.\n"}
{"repo": "blueoil-master/tests/unit/networks_tests/keypoint_detection_tests/test_lm_single_pose_v1.py", "original_string": "def test_training():\n    \"\"\"Test only no error raised.\"\"\"\n    config = SmartDict()\n    config.NETWORK_CLASS = LmSinglePoseV1Quantize\n    config.DATASET_CLASS = MscocoSinglePersonKeypoints\n    config.IS_DEBUG = False\n    config.IMAGE_SIZE = [160, 160]\n    config.BATCH_SIZE = 2\n    config.TEST_STEPS = 1\n    config.MAX_STEPS = 2\n    config.SAVE_CHECKPOINT_STEPS = 1\n    config.KEEP_CHECKPOINT_MAX = 5\n    config.SUMMARISE_STEPS = 1\n    config.IS_PRETRAIN = False\n    config.IS_DISTRIBUTION = False\n    config.TASK = Tasks.KEYPOINT_DETECTION\n    # network model config\n    config.NETWORK = SmartDict()\n    config.NETWORK.OPTIMIZER_CLASS = tf.train.AdamOptimizer\n    config.NETWORK.OPTIMIZER_KWARGS = {\"learning_rate\": 0.001}\n    config.NETWORK.IMAGE_SIZE = config.IMAGE_SIZE\n    config.NETWORK.BATCH_SIZE = config.BATCH_SIZE\n    config.NETWORK.ACTIVATION_QUANTIZER = linear_mid_tread_half_quantizer\n    config.NETWORK.ACTIVATION_QUANTIZER_KWARGS = {\n        'bit': 2,\n        'max_value': 2.0\n    }\n    config.NETWORK.WEIGHT_QUANTIZER = binary_channel_wise_mean_scaling_quantizer\n    config.NETWORK.WEIGHT_QUANTIZER_KWARGS = {}\n    # daasegt config\n    config.DATASET = SmartDict()\n    config.DATASET.PRE_PROCESSOR = Sequence([\n        ResizeWithJoints(image_size=config.IMAGE_SIZE),\n        JointsToGaussianHeatmap(image_size=config.IMAGE_SIZE, stride=2),\n        DivideBy255()])\n    config.DATASET.BATCH_SIZE = config.BATCH_SIZE\n    environment.init(\"test_lm_single_pose_v1\")\n    prepare_dirs(recreate=True)\n    start_training(config, profile_step=1)\n", "docstring": "Test only no error raised.\n"}
{"repo": "blueoil-master/tests/unit/networks_tests/object_detection_tests/test_yolo_v1.py", "original_string": "def test_training():\n    \"\"\"Test only that no error raised.\"\"\"\n    config = SmartDict()\n    config.NETWORK_CLASS = YoloV1\n    config.DATASET_CLASS = Pascalvoc2007\n    config.IS_DEBUG = False\n    config.IMAGE_SIZE = [70, 70]\n    config.BATCH_SIZE = 4\n    config.TEST_STEPS = 1\n    config.MAX_STEPS = 2\n    config.SAVE_CHECKPOINT_STEPS = 1\n    config.KEEP_CHECKPOINT_MAX = 5\n    config.SUMMARISE_STEPS = 1\n    config.IS_PRETRAIN = False\n    config.TASK = Tasks.OBJECT_DETECTION\n    # network model config\n    config.NETWORK = SmartDict()\n    config.NETWORK.IMAGE_SIZE = config.IMAGE_SIZE\n    config.NETWORK.BATCH_SIZE = config.BATCH_SIZE\n    # daasegt config\n    config.DATASET = SmartDict()\n    config.DATASET.PRE_PROCESSOR = ResizeWithGtBoxes(config.IMAGE_SIZE)\n    config.DATASET.BATCH_SIZE = config.BATCH_SIZE\n    environment.init(\"test_yolov_1\")\n    prepare_dirs(recreate=True)\n    start_training(config, profile_step=1)\n", "docstring": "Test only that no error raised.\n"}
{"repo": "blueoil-master/tests/unit/networks_tests/object_detection_tests/test_yolo_v2.py", "original_string": "def test_convert_boxes_space_inverse():\n    \"\"\"Test from_real_to_yolo is inverse function of from_yolo_to_real.\"\"\"\n    model = YoloV2(\n        anchors=[(2.0, 4.0), (3.5, 4.5)],\n        image_size=[64, 96],\n        batch_size=1,\n    )\n    tf.InteractiveSession()\n    # shape is  [batch_size, image_size[0]/32, image_size[1]/32, boxes_per_cell, 4(center_x, center_y, w, h)]\n    boxes = np.array([\n        [\n            [\n                [\n                    [10, 20, 5, 8, ],\n                ],\n                [\n                    [5, 10, 40, 20, ],\n                ],\n                [\n                    [90, 32, 2, 10],\n                ],\n            ],\n            [\n                [\n                    [1, 2, 30, 38, ],\n                ],\n                [\n                    [20, 40, 4, 4, ],\n                ],\n                [\n                    [90, 32, 2, 10],\n                ],\n            ],\n        ],\n    ])\n    boxes_tensor = tf.convert_to_tensor(boxes, dtype=tf.float32)\n    yolo_boxes = model.convert_boxes_space_from_real_to_yolo(boxes_tensor)\n    # real -> yolo -> real\n    reversed_boxes = model.convert_boxes_space_from_yolo_to_real(\n        model.convert_boxes_space_from_real_to_yolo(boxes_tensor)\n    )\n    assert np.allclose(reversed_boxes.eval(), boxes)\n    # yolo -> real -> yolo\n    yolo_boxes = model.convert_boxes_space_from_real_to_yolo(boxes_tensor)\n    reversed_boxes = model.convert_boxes_space_from_real_to_yolo(\n        model.convert_boxes_space_from_yolo_to_real(yolo_boxes)\n    )\n    assert np.allclose(reversed_boxes.eval(), yolo_boxes.eval())\n", "docstring": "Test from_real_to_yolo is inverse function of from_yolo_to_real.\n"}
{"repo": "blueoil-master/tests/unit/networks_tests/object_detection_tests/test_yolo_v2.py", "original_string": "def test_training():\n    \"\"\"Test only that no error raised.\"\"\"\n    config = SmartDict()\n    config.NETWORK_CLASS = YoloV2\n    config.DATASET_CLASS = Pascalvoc2007\n    config.IS_DEBUG = False\n    config.IMAGE_SIZE = [128, 160]\n    config.BATCH_SIZE = 2\n    config.TEST_STEPS = 1\n    config.MAX_STEPS = 2\n    config.SAVE_CHECKPOINT_STEPS = 1\n    config.KEEP_CHECKPOINT_MAX = 5\n    config.SUMMARISE_STEPS = 1\n    config.IS_PRETRAIN = False\n    config.TASK = Tasks.OBJECT_DETECTION\n    # network model config\n    config.NETWORK = SmartDict()\n    config.NETWORK.OPTIMIZER_CLASS = tf.train.AdamOptimizer\n    config.NETWORK.OPTIMIZER_KWARGS = {\"learning_rate\": 0.001}\n    config.NETWORK.IMAGE_SIZE = config.IMAGE_SIZE\n    config.NETWORK.BATCH_SIZE = config.BATCH_SIZE\n    config.NETWORK.DATA_FORMAT = \"NHWC\"\n    # dataset config\n    config.DATASET = SmartDict()\n    config.DATASET.PRE_PROCESSOR = ResizeWithGtBoxes(config.IMAGE_SIZE)\n    config.DATASET.BATCH_SIZE = config.BATCH_SIZE\n    config.DATASET.DATA_FORMAT = \"NHWC\"\n    environment.init(\"test_yolo_v2\")\n    prepare_dirs(recreate=True)\n    start_training(config, profile_step=1)\n", "docstring": "Test only that no error raised.\n"}
{"repo": "blueoil-master/tests/unit/networks_tests/object_detection_tests/test_yolo_v2_quantize.py", "original_string": "def test_training():\n    \"\"\"Test only no error raised.\"\"\"\n    config = SmartDict()\n    config.NETWORK_CLASS = YoloV2Quantize\n    config.DATASET_CLASS = Pascalvoc2007\n    config.IS_DEBUG = False\n    config.IMAGE_SIZE = [128, 160]\n    config.BATCH_SIZE = 2\n    config.TEST_STEPS = 1\n    config.MAX_STEPS = 2\n    config.SAVE_CHECKPOINT_STEPS = 1\n    config.KEEP_CHECKPOINT_MAX = 5\n    config.SUMMARISE_STEPS = 1\n    config.IS_PRETRAIN = False\n    config.TASK = Tasks.OBJECT_DETECTION\n    # network model config\n    config.NETWORK = SmartDict()\n    config.NETWORK.OPTIMIZER_CLASS = tf.train.AdamOptimizer\n    config.NETWORK.OPTIMIZER_KWARGS = {\"learning_rate\": 0.001}\n    config.NETWORK.IMAGE_SIZE = config.IMAGE_SIZE\n    config.NETWORK.BATCH_SIZE = config.BATCH_SIZE\n    config.NETWORK.ACTIVATION_QUANTIZER = linear_mid_tread_half_quantizer\n    config.NETWORK.ACTIVATION_QUANTIZER_KWARGS = {\n        'bit': 2,\n        'max_value': 2.0\n    }\n    config.NETWORK.WEIGHT_QUANTIZER = binary_channel_wise_mean_scaling_quantizer\n    config.NETWORK.WEIGHT_QUANTIZER_KWARGS = {}\n    # daasegt config\n    config.DATASET = SmartDict()\n    config.DATASET.PRE_PROCESSOR = ResizeWithGtBoxes(config.IMAGE_SIZE)\n    config.DATASET.BATCH_SIZE = config.BATCH_SIZE\n    environment.init(\"test_yolov_2_quantize\")\n    prepare_dirs(recreate=True)\n    start_training(config, profile_step=1)\n", "docstring": "Test only no error raised.\n"}
{"repo": "blueoil-master/tests/unit/util_tests/predict_output/test_writer.py", "original_string": "def test_save_npy_not_existed_dir(temp_dir):\n    \"\"\"Test for save npy to not existed dir\"\"\"\n    data = np.array([[1, 2, 3], [4, 5, 6]])\n    dist = os.path.join(temp_dir, 'not_existed')\n    save_npy(dist, data, step=1)\n    assert os.path.exists(os.path.join(dist, \"npy\", \"1.npy\"))\n", "docstring": "Test for save npy to not existed dir\n"}
{"repo": "blueoil-master/tests/unit/util_tests/predict_output/test_writer.py", "original_string": "def test_save_json(temp_dir):\n    \"\"\"Test for save json to existed dir\"\"\"\n    data = json.dumps({\"k\": \"v\", \"list\": [1, 2, 3]})\n    save_json(temp_dir, data, step=1)\n    assert os.path.exists(os.path.join(temp_dir, \"json\", \"1.json\"))\n", "docstring": "Test for save json to existed dir\n"}
{"repo": "blueoil-master/tests/unit/util_tests/predict_output/test_writer.py", "original_string": "def test_save_json_with_invalid_step(temp_dir):\n    \"\"\"Test for save json with invalid step arg\"\"\"\n    data = json.dumps({\"k\": \"v\", \"list\": [1, 2, 3]})\n    with pytest.raises(ValueError):\n        save_json(temp_dir, data, step={\"invalid\": \"dict\"})\n", "docstring": "Test for save json with invalid step arg\n"}
{"repo": "blueoil-master/tests/unit/executor_tests/test_train.py", "original_string": "def test_train():\n    \"\"\"Test only didn't get error\"\"\"\n    config_file = \"unit/fixtures/configs/for_train.py\"\n    expriment_id = \"for_test\"\n    run(config_file, expriment_id, recreate=True, profile_step=7)\n", "docstring": "Test only didn't get error\n"}
{"repo": "blueoil-master/tests/e2e/conftest.py", "original_string": "def init_env():\n    \"\"\"Initialize blueoil environment\"\"\"\n    blueoil_dir = str(Path('{}/../../../'.format(__file__)).resolve())\n    config_dir = os.path.join(blueoil_dir, 'tests/fixtures/configs')\n    train_output_dir = os.path.join(blueoil_dir, 'tmp')\n    predict_output_dir = tempfile.TemporaryDirectory()\n    environment_originals = {}\n    environ_originals = {}\n    # TODO: Remove this setting after blueoil.environment has been refactored.\n    envs = {\n        \"DATA_DIR\": os.path.join(blueoil_dir, \"tests\", \"unit\", \"fixtures\", \"datasets\"),\n        \"OUTPUT_DIR\": train_output_dir,\n        \"_EXPERIMENT_DIR\": os.path.join(train_output_dir, \"{experiment_id}\"),\n        \"_TENSORBOARD_DIR\": os.path.join(train_output_dir, \"{experiment_id}\", \"tensorboard\"),\n        \"_CHECKPOINTS_DIR\": os.path.join(train_output_dir, \"{experiment_id}\", \"checkpoints\"),\n    }\n    for k, v in envs.items():\n        environment_originals[k] = getattr(environment, k)\n        environ_originals[k] = os.environ.get(k)\n        setattr(environment, k, v)\n        os.environ[k] = v\n    yield {\n        \"train_output_dir\": train_output_dir,\n        \"predict_output_dir\": predict_output_dir.name,\n        \"blueoil_dir\": blueoil_dir,\n        \"config_dir\": config_dir,\n    }\n    for k, v in environment_originals.items():\n        setattr(environment, k, v)\n    for k, v in environ_originals.items():\n        if v is not None:\n            os.environ[k] = v\n        else:\n            del os.environ[k]\n    predict_output_dir.cleanup()\n", "docstring": "Initialize blueoil environment\n"}
{"repo": "croniter-master/src/croniter/croniter.py", "original_string": "    def __init__(self, expr_format, start_time=None, ret_type=float,\n                 day_or=True, max_years_between_matches=None, is_prev=False,\n                 hash_id=None):\n        self._ret_type = ret_type\n        self._day_or = day_or\n        if hash_id:\n            if not isinstance(hash_id, (bytes, str)):\n                raise TypeError('hash_id must be bytes or UTF-8 string')\n            if not isinstance(hash_id, bytes):\n                hash_id = hash_id.encode('UTF-8')\n        self._max_years_btw_matches_explicitly_set = (\n            max_years_between_matches is not None)\n        if not self._max_years_btw_matches_explicitly_set:\n            max_years_between_matches = 50\n        self._max_years_between_matches = max(int(max_years_between_matches), 1)\n        if start_time is None:\n            start_time = time()\n        self.tzinfo = None\n        self.start_time = None\n        self.dst_start_time = None\n        self.cur = None\n        self.set_current(start_time)\n        self.expanded, self.nth_weekday_of_month = self.expand(expr_format, hash_id=hash_id)\n        self._is_prev = is_prev\n", "docstring": "day_or=True, max_years_between_matches=None, is_prev=False,"}
{"repo": "croniter-master/src/croniter/croniter.py", "original_string": "    def all_next(self, ret_type=None):\n        '''Generator of all consecutive dates. Can be used instead of\n        implicit call to __iter__, whenever non-default\n        'ret_type' has to be specified.\n        '''\n        # In a Python 3.7+ world:  contextlib.supress and contextlib.nullcontext could be used instead\n        try:\n            while True:\n                self._is_prev = False\n                yield self._get_next(ret_type or self._ret_type)\n        except CroniterBadDateError:\n            if self._max_years_btw_matches_explicitly_set:\n                return\n            else:\n                raise\n", "docstring": "Generator of all consecutive dates. Can be used instead of"}
{"repo": "croniter-master/src/croniter/croniter.py", "original_string": "    def iter(self, *args, **kwargs):\n        return (self._is_prev and self.all_prev or self.all_next)\n", "docstring": "return (self._is_prev and self.all_prev or self.all_next)"}
{"repo": "croniter-master/src/croniter/croniter.py", "original_string": "    def _get_nth_weekday_of_month(year, month, day_of_week):\n        \"\"\" For a given year/month return a list of days in nth-day-of-month order.\n        The last weekday of the month is always [-1].\n        \"\"\"\n        w = (day_of_week + 6) % 7\n        c = calendar.Calendar(w).monthdayscalendar(year, month)\n        if c[0][0] == 0:\n            c.pop(0)\n        return tuple(i[0] for i in c)\n", "docstring": "For a given year/month return a list of days in nth-day-of-month order."}
{"repo": "croniter-master/src/croniter/croniter.py", "original_string": "    def expand(cls, expr_format, hash_id=None):\n        \"\"\"Shallow non Croniter ValueError inside a nice CroniterBadCronError\"\"\"\n        try:\n            return cls._expand(expr_format, hash_id=hash_id)\n        except ValueError as exc:\n            error_type, error_instance, traceback = sys.exc_info()\n            if isinstance(exc, CroniterError):\n                raise\n            if int(sys.version[0]) >= 3:\n                globs, locs = _get_caller_globals_and_locals()\n                exec(\"raise CroniterBadCronError from  exc\", globs, locs)\n            else:\n                raise CroniterBadCronError(\"{0}\".format(exc))\n", "docstring": "Shallow non Croniter ValueError inside a nice CroniterBadCronError\n"}
{"repo": "croniter-master/src/croniter/tests/test_croniter.py", "original_string": "    def testBlockDupRanges(self):\n        \"\"\" Ensure that duplicate/overlapping ranges are squashed \"\"\"\n        m, h, d, mon, dow, s = range(6)\n        self.assertEqual(croniter('* 5,5,1-6 * * *').expanded[h], [1,2,3,4,5,6])\n        self.assertEqual(croniter('* * * * 2-3,4-5,3,3,3').expanded[dow], [2,3,4,5])\n        self.assertEqual(croniter('* * * * * 1,5,*/20,20,15').expanded[s], [0, 1, 5, 15, 20, 40])\n        self.assertEqual(croniter('* 4,1-4,5,4 * * *').expanded[h], [1, 2, 3, 4, 5])\n        # Real life example\n        self.assertEqual(croniter('59 23 * 1 wed,fri,mon-thu,tue,tue').expanded[dow], [1,2,3,4,5])\n", "docstring": "Ensure that duplicate/overlapping ranges are squashed \n"}
{"repo": "croniter-master/src/croniter/tests/test_croniter.py", "original_string": "    def testPrevNthWeekDay(self):\n        base = datetime(2010, 8, 25, 15, 56)\n        itr = croniter('0 0 * * sat#1,sun#2', base)\n        prev1 = itr.get_prev(datetime)\n        self.assertEqual(prev1.year, base.year)\n        self.assertEqual(prev1.month, base.month)\n        self.assertEqual(prev1.day, 8)\n        self.assertEqual(prev1.hour, 0)\n        self.assertEqual(prev1.minute, 0)\n        prev2 = itr.get_prev(datetime)\n        self.assertEqual(prev2.year, base.year)\n        self.assertEqual(prev2.month, base.month)\n        self.assertEqual(prev2.day, 7)\n        self.assertEqual(prev2.hour, 0)\n        self.assertEqual(prev2.minute, 0)\n        prev3 = itr.get_prev(datetime)\n        self.assertEqual(prev3.year, base.year)\n        self.assertEqual(prev3.month, 7)\n        self.assertEqual(prev3.day, 11)\n        self.assertEqual(prev3.hour, 0)\n        self.assertEqual(prev3.minute, 0)\n", "docstring": "base = datetime(2010, 8, 25, 15, 56)"}
{"repo": "croniter-master/src/croniter/tests/test_croniter.py", "original_string": "    def test_error_alpha_cron(self):\n        self.assertRaises(CroniterNotAlphaError, croniter.expand,\n                          '* * * janu-jun *')\n", "docstring": "self.assertRaises(CroniterNotAlphaError, croniter.expand,"}
{"repo": "croniter-master/src/croniter/tests/test_croniter.py", "original_string": "    def test_lwom_friday_2hours(self):\n        # This works with +/- 'days=1' in proc_day_of_week_last() and I don't know WHY?!?\n        it = croniter(\"0 1,5 * * L5\", datetime(1987, 1, 15), ret_type=datetime)\n        items = [next(it) for i in range(12)]\n        self.assertListEqual(items, [\n            datetime(1987, 1, 30, 1),\n            datetime(1987, 1, 30, 5),\n            datetime(1987, 2, 27, 1),\n            datetime(1987, 2, 27, 5),\n            datetime(1987, 3, 27, 1),\n            datetime(1987, 3, 27, 5),\n            datetime(1987, 4, 24, 1),\n            datetime(1987, 4, 24, 5),\n            datetime(1987, 5, 29, 1),\n            datetime(1987, 5, 29, 5),\n            datetime(1987, 6, 26, 1),\n            datetime(1987, 6, 26, 5),\n        ])\n", "docstring": "This works with +/- 'days=1' in proc_day_of_week_last() and I don't know WHY?!?"}
{"repo": "croniter-master/src/croniter/tests/test_croniter.py", "original_string": "    def test_hash_mixup_all_fri_3rd_sat(self):\n        # It appears that it's not possible to MIX a literal dow with a `dow#n` format\n        cron_a = \"0 0 * * 6#3\"\n        cron_b = \"0 0 * * 5\"\n        cron_c = \"0 0 * * 5,6#3\"\n        start = datetime(2021, 3, 1)\n        expect_a = [ datetime(2021, 3, 20) ]\n        expect_b = [\n            datetime(2021, 3, 5),\n            datetime(2021, 3, 12),\n            datetime(2021, 3, 19),\n            datetime(2021, 3, 26),\n        ]\n        expect_c = sorted(set(expect_a) & set(expect_b))\n        def getn(expr, n):\n            it = croniter(expr, start, ret_type=datetime)\n            return [next(it) for i in range(n)]\n        self.assertListEqual(getn(cron_a, 1), expect_a)\n        self.assertListEqual(getn(cron_b, 4), expect_b)\n        with self.assertRaises(CroniterUnsupportedSyntaxError):\n            self.assertListEqual(getn(cron_c, 5), expect_c)\n", "docstring": "It appears that it's not possible to MIX a literal dow with a `dow#n` format"}
{"repo": "croniter-master/src/croniter/tests/test_croniter.py", "original_string": "    def test_lwom_mixup_firstlast_sat(self):\n        # First saturday, last saturday\n        start = datetime(2021, 3, 1)\n        cron_a = \"0 0 * * 6#1\"\n        cron_b = \"0 0 * * L6\"\n        cron_c = \"0 0 * * L6,6#1\"\n        expect_a = [\n            datetime(2021, 3, 6),\n            datetime(2021, 4, 3),\n            datetime(2021, 5, 1),\n        ]\n        expect_b = [\n            datetime(2021, 3, 27),\n            datetime(2021, 4, 24),\n            datetime(2021, 5, 29),\n        ]\n        expect_c = sorted(expect_a + expect_b)\n        def getn(expr, n):\n            it = croniter(expr, start, ret_type=datetime)\n            return [next(it) for i in range(n)]\n        self.assertListEqual(getn(cron_a, 3), expect_a)\n        self.assertListEqual(getn(cron_b, 3), expect_b)\n        self.assertListEqual(getn(cron_c, 6), expect_c)\n", "docstring": "First saturday, last saturday"}
{"repo": "croniter-master/src/croniter/tests/test_croniter.py", "original_string": "    def test_issue145_getnext(self):\n        # Example of quarterly event cron schedule\n        start = datetime(2020, 9, 24)\n        cron = \"0 13 8 1,4,7,10 wed\"\n        with self.assertRaises(CroniterBadDateError):\n            it = croniter(cron, start, day_or=False, max_years_between_matches=1)\n            it.get_next()\n        # New functionality (0.3.35) allowing croniter to find spare matches of cron patterns across multiple years\n        it = croniter(cron, start, day_or=False, max_years_between_matches=5)\n        self.assertEqual(it.get_next(datetime), datetime(2025, 1, 8, 13))\n", "docstring": "Example of quarterly event cron schedule"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_hash.py", "original_string": "    def test_hash_hourly(self):\n        \"\"\"Test manually-defined hourly\"\"\"\n        self._test_iter('H * * * *', datetime(2020, 1, 1, 0, 10), timedelta(hours=1))\n", "docstring": "Test manually-defined hourly\n"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_hash.py", "original_string": "    def test_hash_weekly(self):\n        \"\"\"Test manually-defined weekly\"\"\"\n        # croniter 1.0.5 changes the defined weekly range from (0, 6)\n        # to (0, 7), to match cron's behavior that Sunday is 0 or 7.\n        # This changes the hash, so test for either.\n        self._test_iter(\n            'H H * * H',\n            (datetime(2020, 1, 3, 11, 10), datetime(2020, 1, 5, 11, 10)),\n            timedelta(weeks=1),\n        )\n", "docstring": "Test manually-defined weekly\n"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_hash.py", "original_string": "    def test_hash_yearly(self):\n        \"\"\"Test manually-defined yearly\"\"\"\n        self._test_iter('H H H H *', datetime(2020, 9, 1, 11, 10), timedelta(days=365))\n", "docstring": "Test manually-defined yearly\n"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_hash.py", "original_string": "    def test_hash_id_change(self):\n        \"\"\"Test a different hash_id returns different results given same definition and epoch\"\"\"\n        self._test_iter('H H * * *', datetime(2020, 1, 1, 11, 10), timedelta(days=1))\n        self._test_iter(\n            'H H * * *',\n            datetime(2020, 1, 1, 0, 24),\n            timedelta(days=1),\n            hash_id='different id',\n        )\n", "docstring": "Test a different hash_id returns different results given same definition and epoch\n"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_hash.py", "original_string": "    def test_hash_range(self):\n        \"\"\"Test a hashed range definition\"\"\"\n        self._test_iter(\n            'H H H(3-5) * *', datetime(2020, 1, 5, 11, 10), timedelta(days=31)\n        )\n", "docstring": "Test a hashed range definition\n"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_hash.py", "original_string": "    def test_hash_range_division(self):\n        \"\"\"Test a hashed range + division definition\"\"\"\n        self._test_iter(\n            'H(30-59)/10 H * * *', datetime(2020, 1, 1, 11, 31), timedelta(minutes=10)\n        )\n", "docstring": "Test a hashed range + division definition\n"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_hash.py", "original_string": "    def test_hash_float(self):\n        \"\"\"Test result as a float object\"\"\"\n        self._test_iter('H H * * *', 1577877000.0, (60 * 60 * 24), next_type=float)\n", "docstring": "Test result as a float object\n"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_hash.py", "original_string": "    def test_invalid_hash_id_type(self):\n        \"\"\"Test an invalid hash_id type raises TypeError\"\"\"\n        with self.assertRaises(TypeError):\n            croniter('H H * * *', self.epoch, hash_id={1: 2})\n", "docstring": "Test an invalid hash_id type raises TypeError\n"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_hash.py", "original_string": "    def test_hash_word_midnight(self):\n        \"\"\"Test built-in @midnight\n        @midnight is actually up to 3 hours after midnight, not exactly midnight\n        \"\"\"\n        self._test_iter('@midnight', datetime(2020, 1, 1, 2, 10, 32), timedelta(days=1))\n", "docstring": "Test built-in @midnight"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_hash.py", "original_string": "    def test_hash_word_daily(self):\n        \"\"\"Test built-in @daily\"\"\"\n        self._test_iter('@daily', datetime(2020, 1, 1, 11, 10, 32), timedelta(days=1))\n", "docstring": "Test built-in @daily\n"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_hash.py", "original_string": "    def test_hash_word_monthly(self):\n        \"\"\"Test built-in @monthly\"\"\"\n        self._test_iter(\n            '@monthly', datetime(2020, 1, 1, 11, 10, 32), timedelta(days=31)\n        )\n", "docstring": "Test built-in @monthly\n"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_range.py", "original_string": "    def test_timezone_dst(self):\n        \"\"\" Test across DST transition, which technically is a timzone change. \"\"\"\n        tz = pytz.timezone(\"US/Eastern\")\n        start = tz.localize(datetime(2020, 10, 30))\n        stop =  tz.localize(datetime(2020, 11, 10))\n        res = list(croniter_range(start, stop, '0 0 * * *'))\n        self.assertNotEqual(res[0].tzinfo, res[-1].tzinfo)\n        self.assertEqual(len(res), 12)\n", "docstring": "Test across DST transition, which technically is a timzone change. \n"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_range.py", "original_string": "        def datetime_tz(*args, **kw):\n            \"\"\" Defined this in another branch.  single-use-version \"\"\"\n            tzinfo = kw.pop(\"tzinfo\")\n            return tzinfo.localize(datetime(*args))\n", "docstring": "Defined this in another branch.  single-use-version \n"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_range.py", "original_string": "    def test_issue145_getnext(self):\n        # Example of quarterly event cron schedule\n        start = datetime(2020, 9, 24)\n        cron = \"0 13 8 1,4,7,10 wed\"\n        with self.assertRaises(CroniterBadDateError):\n            it = croniter(cron, start, day_or=False, max_years_between_matches=1)\n            it.get_next()\n        # New functionality (0.3.35) allowing croniter to find spare matches of cron patterns across multiple years\n        it = croniter(cron, start, day_or=False, max_years_between_matches=5)\n        self.assertEqual(it.get_next(datetime), datetime(2025, 1, 8, 13))\n", "docstring": "Example of quarterly event cron schedule"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_range.py", "original_string": "    def test_croniter_range_derived_class(self):\n        # trivial example extending croniter\n        class croniter_nosec(croniter):\n            \"\"\" Like croniter, but it forbids second-level cron expressions. \"\"\"\n            @classmethod\n            def expand(cls, expr_format, *args, **kwargs):\n                if len(expr_format.split()) == 6:\n                    raise CroniterBadCronError(\"Expected 'min hour day mon dow'\")\n                return croniter.expand(expr_format, *args, **kwargs)\n        cron = \"0 13 8 1,4,7,10 wed\"\n        matches = list(croniter_range(datetime(2020, 1, 1), datetime(2020, 12, 31), cron, day_or=False, _croniter=croniter_nosec))\n        self.assertEqual(len(matches), 3)\n        cron = \"0 1 8 1,15,L wed 15,45\"\n        with self.assertRaises(CroniterBadCronError):\n            # Should fail using the custom class that forbids the seconds expression\n            croniter_nosec(cron)\n        with self.assertRaises(CroniterBadCronError):\n            # Should similarly fail because the custom class rejects seconds expr\n            i = croniter_range(datetime(2020, 1, 1), datetime(2020, 12, 31), cron, _croniter=croniter_nosec)\n            next(i)\n", "docstring": "trivial example extending croniter"}
{"repo": "croniter-master/src/croniter/tests/test_croniter_random.py", "original_string": "    def test_random(self):\n        \"\"\"Test random definition\"\"\"\n        obj = croniter('R R * * *', self.epoch)\n        result_1 = obj.get_next(datetime)\n        self.assertGreaterEqual(result_1, datetime(2020, 1, 1, 0, 0))\n        self.assertLessEqual(result_1, datetime(2020, 1, 1, 0, 0) + timedelta(days=1))\n        result_2 = obj.get_next(datetime)\n        self.assertGreaterEqual(result_2, datetime(2020, 1, 2, 0, 0))\n        self.assertLessEqual(result_2, datetime(2020, 1, 2, 0, 0) + timedelta(days=1))\n", "docstring": "Test random definition\n"}
{"repo": "croniter-master/src/croniter/tests/test_speed.py", "original_string": "    def testMinute(self):\n        # minute asterisk\n        base = datetime(2010, 1, 23, 12, 18)\n        itr = croniter('*/1 * * * *', base)\n        n1 = itr.get_next(datetime)    # 19\n        base.year == n1.year\n        base.month == n1.month\n        base.day == n1.day\n        base.hour == n1.hour\n        base.minute == n1.minute - 1\n        for i in range(39):  # ~ 58\n            itr.get_next()\n        n2 = itr.get_next(datetime)\n        n2.minute == 59\n        n3 = itr.get_next(datetime)\n        n3.minute == 0\n        n3.hour == 13\n        itr = croniter('*/5 * * * *', base)\n        n4 = itr.get_next(datetime)\n        n4.minute == 20\n        for i in range(6):\n            itr.get_next()\n        n5 = itr.get_next(datetime)\n        n5.minute == 55\n        n6 = itr.get_next(datetime)\n        n6.minute == 0\n        n6.hour == 13\n", "docstring": "minute asterisk"}
{"repo": "python-certifi-master/certifi/core.py", "original_string": "    def where():\n        # This is slightly terrible, but we want to delay extracting the file\n        # in cases where we're inside of a zipimport situation until someone\n        # actually calls where(), but we don't want to re-extract the file\n        # on every call of where(), so we'll do it once then store it in a\n        # global variable.\n        global _CACERT_CTX\n        global _CACERT_PATH\n        if _CACERT_PATH is None:\n            # This is slightly janky, the importlib.resources API wants you to\n            # manage the cleanup of this file, so it doesn't actually return a\n            # path, it returns a context manager that will give you the path\n            # when you enter it and will do any cleanup when you leave it. In\n            # the common case of not needing a temporary file, it will just\n            # return the file system location and the __exit__() is a no-op.\n            #\n            # We also have to hold onto the actual context manager, because\n            # it will do the cleanup whenever it gets garbage collected, so\n            # we will also store that at the global level as well.\n            _CACERT_CTX = get_path(\"certifi\", \"cacert.pem\")\n            _CACERT_PATH = str(_CACERT_CTX.__enter__())\n        return _CACERT_PATH\n", "docstring": "This is slightly terrible, but we want to delay extracting the file"}
{"repo": "PyAdvancedControl-master/mpc_path_tracking/main.py", "original_string": "def CalcInput(A, B, C, x, u):\n    x_0 = x[:]\n    x = Variable((x.shape[0], T + 1))\n    u = Variable((u.shape[0], T))\n    # MPC controller\n    states = []\n    for t in range(T):\n        constr = [x[:, t + 1] == A * x[:, t] + B * u[:, t] + C]\n        constr += [abs(u[:, t]) <= 0.5]\n        constr += [x[2, t + 1] <= max_speed]\n        constr += [x[2, t + 1] >= min_speed]\n        #  cost = sum_squares(u[:,t])\n        cost = sum_squares(abs(x[0, t] - target[0])) * 10.0 * t\n        cost += sum_squares(abs(x[1, t] - target[1])) * 10.0 * t\n        if t == T - 1:\n            cost += (x[0, t + 1] - target[0]) ** 2 * 10000.0\n            cost += (x[1, t + 1] - target[1]) ** 2 * 10000.0\n        states.append(Problem(Minimize(cost), constr))\n    prob = sum(states)\n    prob.constraints += [x[:, 0] == x_0, x[2, T] == 0.0]\n    start = time.time()\n    #  result=prob.solve(verbose=True)\n    result = prob.solve()\n    elapsed_time = time.time() - start\n    print(\"calc time:{0}\".format(elapsed_time) + \"[sec]\")\n    print(prob.value)\n    if prob.status != OPTIMAL:\n        print(\"Cannot calc opt\")\n    #  print(prob.status)\n    return u, x, prob.value\n", "docstring": "x_0 = x[:]"}
{"repo": "PyAdvancedControl-master/mpc_tracking/pyecosqp.py", "original_string": "def test2():\n    import cvxopt\n    from cvxopt import matrix\n    P = np.matrix([[1., 0., 0., 0., 0., 0., 0., 0., 0.],\n                   [0., 1., 0., 0., 0., 0., 0., 0., 0.],\n                   [0., 0., 1., 0., 0., 0., 0., 0., 0.],\n                   [0., 0., 0., 1., 0., 0., 0., 0., 0.],\n                   [0., 0., 0., 0., 1., 0., 0., 0., 0.],\n                   [0., 0., 0., 0., 0., 1., 0., 0., 0.],\n                   [0., 0., 0., 0., 0., 0., 1., 0., 0.],\n                   [0., 0., 0., 0., 0., 0., 0., 1., 0.],\n                   [0., 0., 0., 0., 0., 0., 0., 0., 1.]])\n    #  print(P.shape)\n    q = np.matrix([[0.],\n                   [0.],\n                   [0.],\n                   [0.],\n                   [0.],\n                   [0.],\n                   [0.],\n                   [0.],\n                   [0.]])\n    #  print(q.shape)\n    A = np.matrix([[1., 0., 0., 1., 0., 0., 0., 0., 0.],\n                   [-2., -0., -0., 0., 1., 0., 0., 0., 0.],\n                   [0., 1., 0., -0.8, -1., 1., 0., 0., 0.],\n                   [-0., -2., -0., 0., -0.9, 0., 1., 0., 0.],\n                   [0., 0., 1., 0., 0., -0.8, -1., 1., 0.],\n                   [-0., -0., -2., 0., 0., 0., -0.9, 0., 1.]])\n    #  print(A.shape)\n    B = np.matrix([[2.8],\n                   [1.8],\n                   [0.],\n                   [0.],\n                   [0.],\n                   [0.]])\n    #  print(B.shape)\n    sol = cvxopt.solvers.qp(matrix(P), matrix(q), A=matrix(A), b=matrix(B))\n    #  #  print(sol)\n    print(sol[\"x\"])\n    #  #  print(sol[\"primal objective\"])\n    sol2 = ecosqp(P, q, Aeq=A, Beq=B)\n    print(sol2[\"x\"])\n    for i in range(len(sol[\"x\"])):\n        print(sol[\"x\"][i], sol2[\"x\"][i])\n        assert (sol[\"x\"][i] - sol2[\"x\"][i]) <= 0.001, \"Error1\"\n", "docstring": "import cvxopt"}
{"repo": "PyAdvancedControl-master/mpc_tracking/mpc_tracking.py", "original_string": "def generate_u_constraints_mat(G, h, N, nu, u0, minu, maxu):\n    # calc F\n    F = np.matrix(np.zeros((0, N * nu + 1)))\n    for i in range(N * nu):\n        if maxu is not None:\n            tF = np.zeros((1, N * nu + 1))\n            tF[0, i] = 1.0 / maxu\n            tF[0, -1] = -1.0\n            F = np.vstack([F, tF])\n        if minu is not None:\n            tF = np.zeros((1, N * nu + 1))\n            tF[0, i] = 1.0 / minu\n            tF[0, -1] = -1.0\n            F = np.vstack([F, tF])\n    f = F[:, -1]\n    #  print(f)\n    # calc SF\n    SF = np.matrix(np.zeros((F.shape[0], F.shape[1] - 1)))\n    for i in range(0, N * nu):\n        for ii in range(i, N * nu):\n            SF[:, i] += F[:, ii]\n    #  print(SF)\n    SF1 = SF[:, 0]\n    #  print(SF1)\n    th = -SF1 * u0 - f\n    #  print(th)\n    G = np.vstack([G, SF])\n    h = np.vstack([h, th])\n    return G, h\n", "docstring": "calc F"}
{"repo": "PyAdvancedControl-master/inverted_pendulum_mpc_control/inverted_pendulum_mpc_control.py", "original_string": "def get_model_matrix():\n    # Model Parameter\n    A = np.array([\n        [0.0, 1.0, 0.0, 0.0],\n        [0.0, 0.0, m * g / M, 0.0],\n        [0.0, 0.0, 0.0, 1.0],\n        [0.0, 0.0, g * (M + m) / (l_bar * M), 0.0]\n    ])\n    A = np.eye(nx) + delta_t * A\n    B = np.array([\n        [0.0],\n        [1.0 / M],\n        [0.0],\n        [1.0 / (l_bar * M)]\n    ])\n    B = delta_t * B\n    return A, B\n", "docstring": "Model Parameter"}
{"repo": "PyAdvancedControl-master/lqr_sample/main.py", "original_string": "def dlqr_with_iteration(Ad, Bd, Q, R):\n    \"\"\"Solve the discrete time lqr controller.\n    x[k+1] = Ad x[k] + Bd u[k]\n    cost = sum x[k].T*Q*x[k] + u[k].T*R*u[k]\n    # ref Bertsekas, p.151\n    \"\"\"\n    # first, try to solve the ricatti equation\n    X = solve_DARE_with_iteration(Ad, Bd, Q, R)\n    # compute the LQR gain\n    K = np.matrix(la.inv(Bd.T * X * Bd + R) * (Bd.T * X * Ad))\n    return K\n", "docstring": "Solve the discrete time lqr controller."}
{"repo": "PyAdvancedControl-master/mpc_modeling/pyecosqp.py", "original_string": "def test2():\n    import cvxopt\n    from cvxopt import matrix\n    P = np.matrix([[1., 0., 0., 0., 0., 0., 0., 0., 0.],\n                   [0., 1., 0., 0., 0., 0., 0., 0., 0.],\n                   [0., 0., 1., 0., 0., 0., 0., 0., 0.],\n                   [0., 0., 0., 1., 0., 0., 0., 0., 0.],\n                   [0., 0., 0., 0., 1., 0., 0., 0., 0.],\n                   [0., 0., 0., 0., 0., 1., 0., 0., 0.],\n                   [0., 0., 0., 0., 0., 0., 1., 0., 0.],\n                   [0., 0., 0., 0., 0., 0., 0., 1., 0.],\n                   [0., 0., 0., 0., 0., 0., 0., 0., 1.]])\n    #  print(P.shape)\n    q = np.matrix([[0.],\n                   [0.],\n                   [0.],\n                   [0.],\n                   [0.],\n                   [0.],\n                   [0.],\n                   [0.],\n                   [0.]])\n    #  print(q.shape)\n    A = np.matrix([[1., 0., 0., 1., 0., 0., 0., 0., 0.],\n                   [-2., -0., -0., 0., 1., 0., 0., 0., 0.],\n                   [0., 1., 0., -0.8, -1., 1., 0., 0., 0.],\n                   [-0., -2., -0., 0., -0.9, 0., 1., 0., 0.],\n                   [0., 0., 1., 0., 0., -0.8, -1., 1., 0.],\n                   [-0., -0., -2., 0., 0., 0., -0.9, 0., 1.]])\n    #  print(A.shape)\n    B = np.matrix([[2.8],\n                   [1.8],\n                   [0.],\n                   [0.],\n                   [0.],\n                   [0.]])\n    #  print(B.shape)\n    sol = cvxopt.solvers.qp(matrix(P), matrix(q), A=matrix(A), b=matrix(B))\n    #  #  print(sol)\n    print(sol[\"x\"])\n    #  #  print(sol[\"primal objective\"])\n    sol2 = ecosqp(P, q, Aeq=A, Beq=B)\n    print(sol2[\"x\"])\n    for i in range(len(sol[\"x\"])):\n        print(sol[\"x\"][i], sol2[\"x\"][i])\n        assert (sol[\"x\"][i] - sol2[\"x\"][i]) <= 0.001, \"Error1\"\n", "docstring": "import cvxopt"}
{"repo": "PyAdvancedControl-master/mpc_modeling/mpc_modeling_with_ECOS.py", "original_string": "def test4():\n    print(\"start!!\")\n    A = np.array([[0.8, 1.0], [0, 0.9]])\n    B = np.array([[-1.0], [2.0]])\n    (nx, nu) = B.shape\n    N = 10  # number of horizon\n    Q = np.eye(nx)\n    R = np.eye(nu)\n    P = np.eye(nx)\n    x0 = np.array([[1.0], [2.0]])  # init state\n    x, u = use_modeling_tool(A, B, N, Q, R, P, x0)\n    rx1 = np.array(x[0, :]).flatten()\n    rx2 = np.array(x[1, :]).flatten()\n    ru = np.array(u[0, :]).flatten()\n    if DEBUG_:\n        flg, ax = plt.subplots(1)\n        plt.plot(rx1, label=\"x1\")\n        plt.plot(rx2, label=\"x2\")\n        plt.plot(ru, label=\"u\")\n        plt.legend()\n        plt.grid(True)\n    x, u = opt_mpc_with_state_constr(A, B, N, Q, R, P, x0)\n    x1 = np.array(x[0, :]).flatten()\n    x2 = np.array(x[1, :]).flatten()\n    u = np.array(u).flatten()\n    if DEBUG_:\n        #  flg, ax = plt.subplots(1)\n        plt.plot(x1, '*r', label=\"x1\")\n        plt.plot(x2, '*b', label=\"x2\")\n        plt.plot(u, '*k', label=\"u\")\n        plt.legend()\n        plt.grid(True)\n        test_output_check(rx1, rx2, ru, x1, x2, u)\n        plt.show()\n", "docstring": "print(\"start!!\")"}
{"repo": "PyAdvancedControl-master/mpc_modeling/mpc_modeling.py", "original_string": "def test1():\n    print(\"start!!\")\n    A = np.array([[0.8, 1.0], [0, 0.9]])\n    #  print(A)\n    B = np.array([[-1.0], [2.0]])\n    #  print(B)\n    (nx, nu) = B.shape\n    #  print(nx, nu)\n    N = 10  # number of horizon\n    Q = np.eye(nx)\n    #  print(Q)\n    R = np.eye(nu)\n    #  print(R)\n    P = np.eye(nx)\n    #  print(P)\n    #  umax = 0.7\n    x0 = np.array([[1.0],\n                   [2.0]])  # init state\n    x, u = use_modeling_tool(A, B, N, Q, R, P, x0)\n    rx1 = np.array(x[0, :]).flatten()\n    rx2 = np.array(x[1, :]).flatten()\n    ru = np.array(u[0, :]).flatten()\n    if DEBUG_:\n        flg, ax = plt.subplots(1)\n        plt.plot(rx1, label=\"x1\")\n        plt.plot(rx2, label=\"x2\")\n        plt.plot(ru, label=\"u\")\n        plt.legend()\n        plt.grid(True)\n    x, u = opt_mpc_with_input_const(A, B, N, Q, R, P, x0)\n    x1 = np.array(x[:, 0]).flatten()\n    x2 = np.array(x[:, 1]).flatten()\n    u = np.array(u).flatten()\n    if DEBUG_:\n        plt.plot(x1, '*r', label=\"x1\")\n        plt.plot(x2, '*b', label=\"x2\")\n        plt.plot(u, '*k', label=\"u\")\n        plt.legend()\n        plt.grid(True)\n        plt.show()\n    test_output_check(rx1, rx2, ru, x1, x2, u)\n", "docstring": "print(\"start!!\")"}
{"repo": "django-bootstrap-pagination-master/bootstrap_pagination/templatetags/bootstrap_pagination.py", "original_string": "    def __init__(self, page, kwargs):\n        self.page = page\n        self.kwargs = kwargs\n", "docstring": "self.page = page"}
{"repo": "btfxwss-master/btfxwss/queue_processor.py", "original_string": "    def run(self):\n        \"\"\"Main routine.\n        :return:\n        \"\"\"\n        while not self._stopped.is_set():\n            try:\n                message = self.q.get(timeout=0.1)\n            except Empty:\n                continue\n            dtype, data, ts = message\n            if dtype in ('subscribed', 'unsubscribed', 'conf', 'auth', 'unauth'):\n                try:\n                    self._response_handlers[dtype](dtype, data, ts)\n                except KeyError:\n                    self.log.error(\"Dtype '%s' does not have a response \"\n                                   \"handler! (%s)\", dtype, message)\n            elif dtype == 'data':\n                try:\n                    channel_id = data[0]\n                    if channel_id != 0:\n                        # Get channel type associated with this data to the\n                        # associated data type (from 'data' to\n                        # 'book', 'ticker' or similar\n                        channel_type, *_ = self.channel_directory[channel_id]\n                        # Run the associated data handler for this channel type.\n                        self._data_handlers[channel_type](channel_type, data, ts)\n                        # Update time stamps.\n                        self.update_timestamps(channel_id, ts)\n                    else:\n                        # This is data from auth channel, call handler\n                        self._handle_account(data=data, ts=ts)\n                except KeyError:\n                    self.log.error(\"Channel ID does not have a data handler! %s\",\n                                   message)\n            else:\n                self.log.error(\"Unknown dtype on queue! %s\", message)\n                continue\n", "docstring": "Main routine."}
{"repo": "btfxwss-master/btfxwss/queue_processor.py", "original_string": "    def _handle_unsubscribed(self, dtype, data, ts):\n        \"\"\"Handles responses to unsubscribe() commands.\n        Removes a channel id from the client.\n        :param dtype:\n        :param data:\n        :param ts:\n        :return:\n        \"\"\"\n        self.log.debug(\"_handle_unsubscribed: %s - %s - %s\", dtype, data, ts)\n        channel_id = data.pop('chanId')\n        # Unregister the channel from all internal attributes\n        chan_identifier = self.channel_directory.pop(channel_id)\n        self.channel_directory.pop(chan_identifier)\n        self.channel_handlers.pop(channel_id)\n        self.last_update.pop(channel_id)\n        self.log.info(\"Successfully unsubscribed from %s\", chan_identifier)\n", "docstring": "Handles responses to unsubscribe() commands."}
{"repo": "btfxwss-master/btfxwss/queue_processor.py", "original_string": "    def _handle_conf(self, dtype, data, ts):\n        \"\"\"Handles configuration messages.\n        :param dtype:\n        :param data:\n        :param ts:\n        :return:\n        \"\"\"\n        self.log.debug(\"_handle_conf: %s - %s - %s\", dtype, data, ts)\n        self.log.info(\"Configuration accepted: %s\", dtype)\n        return\n", "docstring": "Handles configuration messages."}
{"repo": "btfxwss-master/btfxwss/queue_processor.py", "original_string": "    def _handle_account(self, data, ts):\n        \"\"\" Handles Account related data.\n        translation table for channel names:\n            Data Channels\n            os      -   Orders\n            hos     -   Historical Orders\n            ps      -   Positions\n            hts     -   Trades (snapshot)\n            te      -   Trade Event\n            tu      -   Trade Update\n            ws      -   Wallets\n            bu      -   Balance Info\n            miu     -   Margin Info\n            fiu     -   Funding Info\n            fos     -   Offers\n            hfos    -   Historical Offers\n            fcs     -   Credits\n            hfcs    -   Historical Credits\n            fls     -   Loans\n            hfls    -   Historical Loans\n            htfs    -   Funding Trades\n            n       -   Notifications (WIP)\n        :param dtype:\n        :param data:\n        :param ts:\n        :return:\n        \"\"\"\n        # channel_short, data\n        chan_id, channel_short_name, *data = data\n        entry = (channel_short_name, data, ts)\n        self.account.put(entry)\n", "docstring": "Handles Account related data."}
{"repo": "btfxwss-master/btfxwss/queue_processor.py", "original_string": "    def _handle_book(self, dtype, data, ts):\n        \"\"\"Updates the order book stored in self.books[chan_id].\n        :param dtype:\n        :param data:\n        :param ts:\n        :return:\n        \"\"\"\n        self.log.debug(\"_handle_book: %s - %s - %s\", dtype, data, ts)\n        channel_id, *data = data\n        log.debug(\"ts: %s\\tchan_id: %s\\tdata: %s\", ts, channel_id, data)\n        channel_identifier = self.channel_directory[channel_id]\n        entry = (data, ts)\n        self.books[channel_identifier].put(entry)\n", "docstring": "Updates the order book stored in self.books[chan_id]."}
{"repo": "btfxwss-master/btfxwss/queue_processor.py", "original_string": "    def _handle_trades(self, dtype, data, ts):\n        \"\"\"Files trades in self._trades[chan_id].\n        :param dtype:\n        :param data:\n        :param ts:\n        :return:\n        \"\"\"\n        self.log.debug(\"_handle_trades: %s - %s - %s\", dtype, data, ts)\n        channel_id, *data = data\n        channel_identifier = self.channel_directory[channel_id]\n        entry = (data, ts)\n        self.trades[channel_identifier].put(entry)\n", "docstring": "Files trades in self._trades[chan_id]."}
{"repo": "btfxwss-master/btfxwss/connection.py", "original_string": "    def reconnect(self):\n        \"\"\"Issues a reconnection by setting the reconnect_required event.\n        :return:\n        \"\"\"\n        # Reconnect attempt at self.reconnect_interval\n        self.log.debug(\"reconnect(): Initialzion reconnect sequence..\")\n        self.connected.clear()\n        self.reconnect_required.set()\n        if self.socket:\n            self.socket.close()\n", "docstring": "Issues a reconnection by setting the reconnect_required event."}
{"repo": "btfxwss-master/btfxwss/connection.py", "original_string": "    def run(self):\n        \"\"\"Main method of Thread.\n        :return:\n        \"\"\"\n        self.log.debug(\"run(): Starting up..\")\n        self._connect()\n", "docstring": "Main method of Thread."}
{"repo": "btfxwss-master/btfxwss/connection.py", "original_string": "    def _start_timers(self):\n        \"\"\"Resets and starts timers for API data and connection.\n        :return:\n        \"\"\"\n        self.log.debug(\"_start_timers(): Resetting timers..\")\n        self._stop_timers()\n        # Sends a ping at ping_interval to see if API still responding\n        self.ping_timer = Timer(self.ping_interval, self.send_ping)\n        self.ping_timer.start()\n        # Automatically reconnect if we didnt receive data\n        self.connection_timer = Timer(self.connection_timeout,\n                                      self._connection_timed_out)\n        self.connection_timer.start()\n", "docstring": "Resets and starts timers for API data and connection."}
{"repo": "btfxwss-master/btfxwss/connection.py", "original_string": "    def _check_pong(self):\n        \"\"\"Checks if a Pong message was received.\n        :return:\n        \"\"\"\n        self.pong_timer.cancel()\n        if self.pong_received:\n            self.log.debug(\"_check_pong(): Pong received in time.\")\n            self.pong_received = False\n        else:\n            # reconnect\n            self.log.debug(\"_check_pong(): Pong not received in time.\"\n                           \"Issuing reconnect..\")\n            self.reconnect()\n", "docstring": "Checks if a Pong message was received."}
{"repo": "btfxwss-master/btfxwss/connection.py", "original_string": "    def pass_to_client(self, event, data, *args):\n        \"\"\"Passes data up to the client via a Queue().\n        :param event:\n        :param data:\n        :param args:\n        :return:\n        \"\"\"\n        self.q.put((event, data, *args))\n", "docstring": "Passes data up to the client via a Queue()."}
{"repo": "btfxwss-master/btfxwss/connection.py", "original_string": "    def _pause(self):\n        \"\"\"Pauses the connection.\n        :return:\n        \"\"\"\n        self.log.debug(\"_pause(): Setting paused() Flag!\")\n        self.paused.set()\n", "docstring": "Pauses the connection."}
{"repo": "btfxwss-master/btfxwss/connection.py", "original_string": "    def _heartbeat_handler(self):\n        \"\"\"Handles heartbeat messages.\n        :return:\n        \"\"\"\n        # Restart our timers since we received some data\n        self.log.debug(\"_heartbeat_handler(): Received a heart beat \"\n                       \"from connection!\")\n        self._start_timers()\n", "docstring": "Handles heartbeat messages."}
{"repo": "btfxwss-master/btfxwss/connection.py", "original_string": "    def _system_handler(self, data, ts):\n        \"\"\"Distributes system messages to the appropriate handler.\n        System messages include everything that arrives as a dict,\n        or a list containing a heartbeat.\n        :param data:\n        :param ts:\n        :return:\n        \"\"\"\n        self.log.debug(\"_system_handler(): Received a system message: %s\", data)\n        # Unpack the data\n        event = data.pop('event')\n        if event == 'pong':\n            self.log.debug(\"_system_handler(): Distributing %s to _pong_handler..\",\n                      data)\n            self._pong_handler()\n        elif event == 'info':\n            self.log.debug(\"_system_handler(): Distributing %s to _info_handler..\",\n                      data)\n            self._info_handler(data)\n        elif event == 'error':\n            self.log.debug(\"_system_handler(): Distributing %s to _error_handler..\",\n                      data)\n            self._error_handler(data)\n        elif event in ('subscribed', 'unsubscribed', 'conf', 'auth', 'unauth'):\n            self.log.debug(\"_system_handler(): Distributing %s to \"\n                           \"_response_handler..\", data)\n            self._response_handler(event, data, ts)\n        else:\n            self.log.error(\"Unhandled event: %s, data: %s\", event, data)\n", "docstring": "Distributes system messages to the appropriate handler."}
{"repo": "btfxwss-master/btfxwss/connection.py", "original_string": "    def _data_handler(self, data, ts):\n        \"\"\"Handles data messages by passing them up to the client.\n        :param data:\n        :param ts:\n        :return:\n        \"\"\"\n        # Pass the data up to the Client\n        self.log.debug(\"_data_handler(): Passing %s to client..\",\n                  data)\n        self.pass_to_client('data', data, ts)\n", "docstring": "Handles data messages by passing them up to the client."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def channel_configs(self):\n        return self.conn.channel_configs\n", "docstring": "return self.conn.channel_configs"}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def start(self):\n        \"\"\"Start the client.\n        :return:\n        \"\"\"\n        self.conn.start()\n        self.queue_processor.start()\n", "docstring": "Start the client."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def reset(self):\n        \"\"\"Reset the client.\n        :return:\n        \"\"\"\n        self.conn.reconnect()\n        while not self.conn.connected.is_set():\n            log.info(\"reset(): Waiting for connection to be set up..\")\n            time.sleep(1)\n        for key in self.channel_configs:\n            self.conn.send(**self.channel_configs[key])\n", "docstring": "Reset the client."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def tickers(self, pair):\n        \"\"\"Return a queue containing all received ticker data.\n        :param pair:\n        :return: Queue()\n        \"\"\"\n        key = ('ticker', pair)\n        return self.queue_processor.tickers[key]\n", "docstring": "Return a queue containing all received ticker data."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def raw_books(self, pair):\n        \"\"\"Return a queue containing all received raw book data.\n        :param pair:\n        :return: Queue()\n        \"\"\"\n        key = ('raw_book', pair)\n        return self.queue_processor.raw_books[key]\n", "docstring": "Return a queue containing all received raw book data."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def candles(self, pair, timeframe=None):\n        \"\"\"Return a queue containing all received candles data.\n        :param pair: str, Symbol pair to request data for\n        :param timeframe: str\n        :return: Queue()\n        \"\"\"\n        timeframe = '1m' if not timeframe else timeframe\n        key = ('candles', pair, timeframe)\n        return self.queue_processor.candles[key]\n", "docstring": "Return a queue containing all received candles data."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def subscribe_to_ticker(self, pair, **kwargs):\n        \"\"\"Subscribe to the passed pair's ticker channel.\n        :param pair: str, Symbol pair to request data for\n        :param kwargs:\n        :return:\n        \"\"\"\n        identifier = ('ticker', pair)\n        self._subscribe('ticker', identifier, symbol=pair, **kwargs)\n", "docstring": "Subscribe to the passed pair's ticker channel."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def unsubscribe_from_ticker(self, pair, **kwargs):\n        \"\"\"Unsubscribe to the passed pair's ticker channel.\n        :param pair: str, Symbol pair to request data for\n        :param kwargs:\n        :return:\n        \"\"\"\n        identifier = ('ticker', pair)\n        self._unsubscribe('ticker', identifier, symbol=pair, **kwargs)\n", "docstring": "Unsubscribe to the passed pair's ticker channel."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def subscribe_to_order_book(self, pair, **kwargs):\n        \"\"\"Subscribe to the passed pair's order book channel.\n        :param pair: str, Symbol pair to request data for\n        :param kwargs:\n        :return:\n        \"\"\"\n        identifier = ('book', pair)\n        self._subscribe('book', identifier, symbol=pair, **kwargs)\n", "docstring": "Subscribe to the passed pair's order book channel."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def unsubscribe_from_order_book(self, pair, **kwargs):\n        \"\"\"Unsubscribe to the passed pair's order book channel.\n        :param pair: str, Symbol pair to request data for\n        :param kwargs:\n        :return:\n        \"\"\"\n        identifier = ('book', pair)\n        self._unsubscribe('book', identifier, symbol=pair, **kwargs)\n", "docstring": "Unsubscribe to the passed pair's order book channel."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def subscribe_to_raw_order_book(self, pair, prec=None, **kwargs):\n        \"\"\"Subscribe to the passed pair's raw order book channel.\n        :param pair: str, Symbol pair to request data for\n        :param prec:\n        :param kwargs:\n        :return:\n        \"\"\"\n        identifier = ('raw_book', pair)\n        prec = 'R0' if prec is None else prec\n        self._subscribe('book', identifier, pair=pair, prec=prec, **kwargs)\n", "docstring": "Subscribe to the passed pair's raw order book channel."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def unsubscribe_from_raw_order_book(self, pair, prec=None, **kwargs):\n        \"\"\"Unsubscribe to the passed pair's raw order book channel.\n        :param pair: str, Symbol pair to request data for\n        :param prec:\n        :param kwargs:\n        :return:\n        \"\"\"\n        identifier = ('raw_book', pair)\n        prec = 'R0' if prec is None else prec\n        self._unsubscribe('book', identifier, pair=pair, prec=prec, **kwargs)\n", "docstring": "Unsubscribe to the passed pair's raw order book channel."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def subscribe_to_trades(self, pair, **kwargs):\n        \"\"\"Subscribe to the passed pair's trades channel.\n        :param pair: str, Symbol pair to request data for\n        :param kwargs:\n        :return:\n        \"\"\"\n        identifier = ('trades', pair)\n        self._subscribe('trades', identifier, symbol=pair, **kwargs)\n", "docstring": "Subscribe to the passed pair's trades channel."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def unsubscribe_from_trades(self, pair, **kwargs):\n        \"\"\"Unsubscribe to the passed pair's trades channel.\n        :param pair: str, Symbol pair to request data for\n        :param kwargs:\n        :return:\n        \"\"\"\n        identifier = ('trades', pair)\n        self._unsubscribe('trades', identifier, symbol=pair, **kwargs)\n", "docstring": "Unsubscribe to the passed pair's trades channel."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def subscribe_to_candles(self, pair, timeframe=None, **kwargs):\n        \"\"\"Subscribe to the passed pair's OHLC data channel.\n        :param pair: str, Symbol pair to request data for\n        :param timeframe: str, {1m, 5m, 15m, 30m, 1h, 3h, 6h, 12h,\n                                1D, 7D, 14D, 1M}\n        :param kwargs:\n        :return:\n        \"\"\"\n        valid_tfs = ['1m', '5m', '15m', '30m', '1h', '3h', '6h', '12h', '1D',\n                     '7D', '14D', '1M']\n        if timeframe:\n            if timeframe not in valid_tfs:\n                raise ValueError(\"timeframe must be any of %s\" % valid_tfs)\n        else:\n            timeframe = '1m'\n        identifier = ('candles', pair, timeframe)\n        pair = 't' + pair if not pair.startswith('t') else pair\n        key = 'trade:' + timeframe + ':' + pair\n        self._subscribe('candles', identifier, key=key, **kwargs)\n", "docstring": "Subscribe to the passed pair's OHLC data channel."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def unsubscribe_from_candles(self, pair, timeframe=None, **kwargs):\n        \"\"\"Unsubscribe to the passed pair's OHLC data channel.\n        :param timeframe: str, {1m, 5m, 15m, 30m, 1h, 3h, 6h, 12h,\n                                1D, 7D, 14D, 1M}\n        :param kwargs:\n        :return:\n        \"\"\"\n        valid_tfs = ['1m', '5m', '15m', '30m', '1h', '3h', '6h', '12h', '1D',\n                     '7D', '14D', '1M']\n        if timeframe:\n            if timeframe not in valid_tfs:\n                raise ValueError(\"timeframe must be any of %s\" % valid_tfs)\n        else:\n            timeframe = '1m'\n        identifier = ('candles', pair, timeframe)\n        pair = 't' + pair if not pair.startswith('t') else pair\n        key = 'trade:' + timeframe + ':' + pair\n        self._unsubscribe('candles', identifier, key=key, **kwargs)\n", "docstring": "Unsubscribe to the passed pair's OHLC data channel."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def authenticate(self):\n        \"\"\"Authenticate with the Bitfinex API.\n        :return:\n        \"\"\"\n        if not self.key and not self.secret:\n            raise ValueError(\"Must supply both key and secret key for API!\")\n        self.channel_configs['auth'] = {'api_key': self.key, 'secret': self.secret}\n        self.conn.send(api_key=self.key, secret=self.secret, auth=True)\n", "docstring": "Authenticate with the Bitfinex API."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def new_order(self, **order_settings):\n        \"\"\"Post a new Order via Websocket.\n        :param kwargs:\n        :return:\n        \"\"\"\n        self._send_auth_command('on', order_settings)\n", "docstring": "Post a new Order via Websocket."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def cancel_order(self, multi=False, **order_identifiers):\n        \"\"\"Cancel one or multiple orders via Websocket.\n        :param multi: bool, whether order_settings contains settings for one, or\n                      multiples orders\n        :param order_identifiers: Identifiers for the order(s) you with to cancel\n        :return:\n        \"\"\"\n        if multi:\n            self._send_auth_command('oc_multi', order_identifiers)\n        else:\n            self._send_auth_command('oc', order_identifiers)\n", "docstring": "Cancel one or multiple orders via Websocket."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def order_multi_op(self, *operations):\n        \"\"\"Execute multiple, order-related operations via Websocket.\n        :param operations: operations to send to the websocket\n        :return:\n        \"\"\"\n        self._send_auth_command('ox_multi', operations)\n", "docstring": "Execute multiple, order-related operations via Websocket."}
{"repo": "btfxwss-master/btfxwss/client.py", "original_string": "    def calc(self, *calculations):\n        \"\"\"Request one or several operations via Websocket.\n        :param calculations: calculations as strings to send to the websocket\n        :return:\n        \"\"\"\n        self._send_auth_command('calc', calculations)\n", "docstring": "Request one or several operations via Websocket."}
{"repo": "mars-master/mars/utils.py", "original_string": "def sort_dataframe_result(df, result: pd.DataFrame) -> pd.DataFrame:\n    \"\"\" sort DataFrame on client according to `should_be_monotonic` attribute \"\"\"\n    if hasattr(df, 'index_value'):\n        if getattr(df.index_value, 'should_be_monotonic', False):\n            try:\n                result.sort_index(inplace=True)\n            except TypeError:  # pragma: no cover\n                # cudf doesn't support inplace\n                result = result.sort_index()\n        if hasattr(df, 'columns_value'):\n            if getattr(df.columns_value, 'should_be_monotonic', False):\n                try:\n                    result.sort_index(axis=1, inplace=True)\n                except TypeError:  # pragma: no cover\n                    # cudf doesn't support inplace\n                    result = result.sort_index(axis=1)\n    return result\n", "docstring": "sort DataFrame on client according to `should_be_monotonic` attribute \n"}
{"repo": "mars-master/mars/utils.py", "original_string": "def has_unknown_shape(*tiled_tileables: TileableType) -> bool:\n    for tileable in tiled_tileables:\n        if getattr(tileable, 'shape', None) is None:\n            continue\n        if any(pd.isnull(s) for s in tileable.shape):\n            return True\n        if any(pd.isnull(s) for s in itertools.chain(*tileable.nsplits)):\n            return True\n    return False\n", "docstring": "for tileable in tiled_tileables:"}
{"repo": "mars-master/mars/utils.py", "original_string": "    def __init__(self, file_obj, fixed_size):\n        self._file_obj = file_obj\n        self._cur = self._file_obj.tell()\n        self._size = fixed_size\n        self._end = self._cur + self._size\n", "docstring": "self._file_obj = file_obj"}
{"repo": "mars-master/mars/utils.py", "original_string": "def quiet_stdio():\n    \"\"\"Quiets standard outputs when inferring types of functions\"\"\"\n    with _io_quiet_lock:\n        _io_quiet_local.is_wrapped = True\n        sys.stdout = _QuietIOWrapper(sys.stdout)\n        sys.stderr = _QuietIOWrapper(sys.stderr)\n    try:\n        yield\n    finally:\n        with _io_quiet_lock:\n            sys.stdout = sys.stdout.wrapped\n            sys.stderr = sys.stderr.wrapped\n            if not isinstance(sys.stdout, _QuietIOWrapper):\n                _io_quiet_local.is_wrapped = False\n", "docstring": "Quiets standard outputs when inferring types of functions\n"}
{"repo": "mars-master/mars/utils.py", "original_string": "def replace_objects(nested: Union[List, Dict],\n                    mapping: Dict) -> Union[List, Dict]:\n    if not mapping:\n        return nested\n    if isinstance(nested, dict):\n        vals = list(nested.values())\n    else:\n        vals = list(nested)\n    new_vals = []\n    for val in vals:\n        if isinstance(val, (dict, list, tuple, set)):\n            new_val = replace_objects(val, mapping)\n        else:\n            try:\n                new_val = mapping.get(val, val)\n            except TypeError:\n                new_val = val\n        new_vals.append(new_val)\n    if isinstance(nested, dict):\n        return type(nested)((k, v) for k, v in zip(nested.keys(), new_vals))\n    else:\n        return type(nested)(new_vals)\n", "docstring": "mapping: Dict) -> Union[List, Dict]:"}
{"repo": "mars-master/mars/utils.py", "original_string": "def dataslots(cls):\n    # Need to create a new class, since we can't set __slots__\n    #  after a class has been created.\n    # Make sure __slots__ isn't already set.\n    if '__slots__' in cls.__dict__:  # pragma: no cover\n        raise TypeError(f'{cls.__name__} already specifies __slots__')\n    # Create a new dict for our new class.\n    cls_dict = dict(cls.__dict__)\n    field_names = tuple(f.name for f in dataclasses.fields(cls))\n    cls_dict['__slots__'] = field_names\n    for field_name in field_names:\n        # Remove our attributes, if present. They'll still be\n        #  available in _MARKER.\n        cls_dict.pop(field_name, None)\n    # Remove __dict__ itself.\n    cls_dict.pop('__dict__', None)\n    # And finally create the class.\n    qualname = getattr(cls, '__qualname__', None)\n    cls = type(cls)(cls.__name__, cls.__bases__, cls_dict)\n    if qualname is not None:\n        cls.__qualname__ = qualname\n    return cls\n", "docstring": "Need to create a new class, since we can't set __slots__"}
{"repo": "mars-master/mars/services/storage/core.py", "original_string": "def build_data_info(storage_info: ObjectInfo, level, size, band_name=None):\n    # todo handle multiple\n    if band_name is None:\n        band_name = 'numa-0' if storage_info.device is None \\\n            else f'gpu-{storage_info.device}'\n    if storage_info.size is None:\n        store_size = size\n    else:\n        store_size = storage_info.size\n    return DataInfo(storage_info.object_id, level, size, store_size, band_name)\n", "docstring": "todo handle multiple"}
{"repo": "mars-master/mars/services/storage/spill.py", "original_string": "    def __init__(self, level: StorageLevel):\n        self._level = level\n        self._data_sizes = dict()\n        self._pinned_keys = defaultdict(int)\n        self._spilling_keys = set()\n", "docstring": "self._level = level"}
{"repo": "mars-master/mars/services/task/analyzer/assigner.py", "original_string": "    def __init__(self,\n                 chunk_graph: ChunkGraph,\n                 start_ops: List[Operand],\n                 band_slots: Dict[BandType, int]):\n        super().__init__(chunk_graph, start_ops, band_slots)\n        self._undirected_chunk_graph = None\n        self._op_keys: Set[str] = {start_op.key for start_op in start_ops}\n", "docstring": "chunk_graph: ChunkGraph,"}
{"repo": "mars-master/mars/services/cluster/backends/base.py", "original_string": "def register_cluster_backend(backend: Type[AbstractClusterBackend]):\n    _cluster_backend_types[backend.name] = backend\n    return backend\n", "docstring": "_cluster_backend_types[backend.name] = backend"}
{"repo": "mars-master/mars/services/subtask/worker/manager.py", "original_string": "    def __init__(self, subtask_processor_cls: Type):\n        # specify subtask process class\n        # for test purpose\n        self._subtask_processor_cls = subtask_processor_cls\n        self._cluster_api = None\n        self._band_slot_runner_refs = dict()\n", "docstring": "specify subtask process class"}
{"repo": "mars-master/mars/services/scheduling/worker/workerslot.py", "original_string": "    def gen_uid(cls, band_name: str, slot_id: int):\n        return f'{band_name}_{slot_id}_band_slot_control'\n", "docstring": "return f'{band_name}_{slot_id}_band_slot_control'"}
{"repo": "mars-master/mars/services/scheduling/worker/quota.py", "original_string": "    def dump_data(self):\n        return QuotaDumpType(self._allocations, self._requests, self._hold_sizes)\n", "docstring": "return QuotaDumpType(self._allocations, self._requests, self._hold_sizes)"}
{"repo": "mars-master/mars/services/scheduling/supervisor/globalslot.py", "original_string": "    def release_subtask_slots(self, band: Tuple, session_id: str, subtask_id: str):\n        # todo ensure slots released when subtasks ends in all means\n        slots_delta = self._band_stid_slots[band].pop((session_id, subtask_id), 0)\n        self._band_used_slots[band] -= slots_delta\n", "docstring": "todo ensure slots released when subtasks ends in all means"}
{"repo": "mars-master/mars/core/context.py", "original_string": "    def get_chunks_result(self,\n                          data_keys: List[str]) -> List:\n        \"\"\"\n        Get result of chunks.\n        Parameters\n        ----------\n        data_keys : list\n            Data keys.\n        Returns\n        -------\n        results : list\n            Result of chunks\n        \"\"\"\n", "docstring": "data_keys: List[str]) -> List:"}
{"repo": "mars-master/mars/core/context.py", "original_string": "    def get_chunks_meta(self,\n                        data_keys: List[str],\n                        fields: List[str] = None,\n                        error='raise') -> List[Dict]:\n        \"\"\"\n        Get meta of chunks.\n        Parameters\n        ----------\n        data_keys : list\n            Data keys.\n        fields : list\n            Fields to filter.\n        error : str\n            raise, ignore\n        Returns\n        -------\n        meta_list : list\n            Meta list.\n        \"\"\"\n", "docstring": "data_keys: List[str],"}
{"repo": "mars-master/mars/core/context.py", "original_string": "    def destroy_remote_object(self,\n                              name: str):\n        \"\"\"\n        Destroy remote object.\n        Parameters\n        ----------\n        name : str\n            Object name.\n        \"\"\"\n", "docstring": "name: str):"}
{"repo": "mars-master/mars/core/context.py", "original_string": "    def register_custom_log_path(self,\n                                 session_id: str,\n                                 tileable_op_key: str,\n                                 chunk_op_key: str,\n                                 worker_address: str,\n                                 log_path: str):\n        \"\"\"\n        Register custom log path.\n        Parameters\n        ----------\n        session_id : str\n            Session ID.\n        tileable_op_key : str\n            Key of tileable's op.\n        chunk_op_key : str\n            Kye of chunk's op.\n        worker_address : str\n            Worker address.\n        log_path : str\n            Log path.\n        \"\"\"\n", "docstring": "session_id: str,"}
{"repo": "mars-master/mars/core/context.py", "original_string": "    def __enter__(self):\n        Context.prev = Context.current\n        Context.current = self\n", "docstring": "Context.prev = Context.current"}
{"repo": "mars-master/mars/core/custom_log.py", "original_string": "    def __init__(self,\n                 tileable_op_key: str,\n                 session: SessionType):\n        self._tileable_op_key = tileable_op_key\n        self._session = session\n        self._chunk_op_key_to_result = dict()\n        self._chunk_op_key_to_offsets = dict()\n", "docstring": "tileable_op_key: str,"}
{"repo": "mars-master/mars/core/operand/fetch.py", "original_string": "    def check_inputs(self, inputs):\n        # no inputs\n        if inputs and len(inputs) > 0:\n            raise ValueError(f\"{type(self).__name__} has no inputs\")\n", "docstring": "no inputs"}
{"repo": "mars-master/mars/core/operand/base.py", "original_string": "    def on_output_modify(self, new_output):\n        # when `create_view` is True, if the output is modified,\n        # the modification should be set back to the input.\n        # This function is for this sort of usage.\n        # Remember, if `create_view` is False, this function should take no effect.\n        raise NotImplementedError\n", "docstring": "when `create_view` is True, if the output is modified,"}
{"repo": "mars-master/mars/core/operand/core.py", "original_string": "    def tile(cls, op: OperandType):\n        raise NotImplementedError\n", "docstring": "raise NotImplementedError"}
{"repo": "mars-master/mars/core/operand/core.py", "original_string": "    def execute(cls, ctx: Union[dict, Context], op: OperandType):\n        raise NotImplementedError\n", "docstring": "raise NotImplementedError"}
{"repo": "mars-master/mars/core/operand/core.py", "original_string": "    def estimate_size(cls, ctx: dict, op: OperandType):\n        from .fetch import FetchShuffle\n        exec_size = 0\n        outputs = op.outputs\n        pure_dep_keys = \\\n            set(inp.key for inp, is_dep in zip(op.inputs or (), op.pure_depends or ()) if is_dep)\n        if all(not c.is_sparse() and hasattr(c, 'nbytes') and\n               not np.isnan(c.nbytes) for c in outputs):\n            for out in outputs:\n                ctx[out.key] = (out.nbytes, out.nbytes)\n        for inp in op.inputs or ():\n            if inp.key in pure_dep_keys:\n                continue\n            try:\n                if isinstance(inp.op, FetchShuffle):\n                    keys_and_shapes = inp.extra_params.get('_shapes', dict()).items()\n                else:\n                    keys_and_shapes = [(inp.key, getattr(inp, 'shape', None))]\n                # execution size of a specific data chunk may be\n                # larger than stored type due to objects\n                for key, shape in keys_and_shapes:\n                    exec_size += ctx[key][0]\n            except KeyError:\n                if not op.sparse:\n                    inp_size = calc_data_size(inp)\n                    if not np.isnan(inp_size):\n                        exec_size += inp_size\n        exec_size = int(exec_size)\n        total_out_size = 0\n        chunk_sizes = dict()\n        for out in outputs:\n            try:\n                if not out.is_sparse():\n                    chunk_size = calc_data_size(out)\n                else:\n                    chunk_size = exec_size\n                if np.isnan(chunk_size):\n                    raise TypeError\n                chunk_sizes[out.key] = chunk_size\n                total_out_size += chunk_size\n            except (AttributeError, TypeError, ValueError):\n                pass\n        exec_size = max(exec_size, total_out_size)\n        memory_scale = op.memory_scale or 1.0\n        for out in outputs:\n            if out.key in ctx:\n                continue\n            if out.key in chunk_sizes:\n                result_size = chunk_sizes[out.key]\n            else:\n                result_size = max(exec_size // len(outputs),\n                                  total_out_size // max(len(chunk_sizes), 1))\n            try:\n                if getattr(out, 'dtype', None) is not None and out.is_sparse():\n                    max_sparse_size = out.nbytes + np.dtype(np.int64).itemsize * np.prod(out.shape) * out.ndim\n                else:\n                    max_sparse_size = np.nan\n            except TypeError:  # pragma: no cover\n                max_sparse_size = np.nan\n            if not np.isnan(max_sparse_size):\n                result_size = min(result_size, max_sparse_size)\n            ctx[out.key] = (result_size, exec_size * memory_scale // len(outputs))\n", "docstring": "from .fetch import FetchShuffle"}
{"repo": "mars-master/mars/core/graph/entity.py", "original_string": "    def __init__(self, result_tileables: List[Tileable] = None):\n        super().__init__()\n        self._result_tileables = result_tileables\n", "docstring": "super().__init__()"}
{"repo": "mars-master/mars/core/entity/objects.py", "original_string": "    def params(self) -> Dict[str, Any]:\n        # params return the properties which useful to rebuild a new chunk\n        return {\n            'index': self.index,\n        }\n", "docstring": "params return the properties which useful to rebuild a new chunk"}
{"repo": "mars-master/mars/core/entity/objects.py", "original_string": "    def params(self):\n        # params return the properties which useful to rebuild a new tileable object\n        return dict()\n", "docstring": "params return the properties which useful to rebuild a new tileable object"}
{"repo": "mars-master/mars/core/entity/tileables.py", "original_string": "    def params(self) -> dict:\n        # params return the properties which useful to rebuild a new tileable object\n        return dict()\n", "docstring": "params return the properties which useful to rebuild a new tileable object"}
{"repo": "mars-master/mars/core/entity/tileables.py", "original_string": "    def params(self):\n        # params return the properties which useful to rebuild a new tileable object\n        return {\n            'shape': self.shape\n        }\n", "docstring": "params return the properties which useful to rebuild a new tileable object"}
{"repo": "mars-master/mars/core/entity/fuse.py", "original_string": "    def composed(self):\n        # for compatibility, just return the topological ordering,\n        # once we apply optimization on the subgraph,\n        # `composed` is not needed any more and should be removed then.\n        assert getattr(self._op, 'fuse_graph', None) is not None\n        fuse_graph = self._op.fuse_graph\n        return list(fuse_graph.topological_iter())\n", "docstring": "for compatibility, just return the topological ordering,"}
{"repo": "mars-master/mars/storage/shared_memory.py", "original_string": "        def __del__(self):\n            # close fd only\n            fd = self._fd\n            if os.name != \"nt\" and fd >= 0:\n                os.close(fd)\n", "docstring": "close fd only"}
{"repo": "mars-master/mars/storage/shared_memory.py", "original_string": "    def _write_init(self):\n        # keep last 8 bytes to record actual memory size\n        self.shm = shm = SharedMemory(\n            name=self._object_id, create=True, size=self._size + 8)\n        self._write_actual_size()\n        self._buffer = self._mv = shm.buf\n", "docstring": "keep last 8 bytes to record actual memory size"}
{"repo": "mars-master/mars/storage/ray.py", "original_string": "def _register_sparse_matrix_serializer():\n    # register a custom serializer for Mars SparseMatrix\n    register_ray_serializer(sparse.matrix.SparseMatrix,\n                            serializer=_mars_sparse_matrix_serializer,\n                            deserializer=_mars_sparse_matrix_deserializer)\n", "docstring": "register a custom serializer for Mars SparseMatrix"}
{"repo": "mars-master/mars/storage/ray.py", "original_string": "    def level(self) -> StorageLevel:\n        # TODO(fyrestone): return StorageLevel.MEMORY & StorageLevel.DISK\n        # if object spilling is available.\n        return StorageLevel.MEMORY | StorageLevel.REMOTE\n", "docstring": "TODO(fyrestone): return StorageLevel.MEMORY & StorageLevel.DISK"}
{"repo": "mars-master/mars/storage/core.py", "original_string": "    def object_id(self):\n        return self._object_id\n", "docstring": "return self._object_id"}
{"repo": "mars-master/mars/tensor/utils.py", "original_string": "def inject_dtype(dtype):\n    def inner(func):\n        @wraps(func)\n        def call(*tensors, **kw):\n            kw['dtype'] = np.dtype(dtype)\n            ret = func(*tensors, **kw)\n            if ret is NotImplemented:\n                reverse_func = getattr(inspect.getmodule(func), f'r{func.__name__}', None)\n                if reverse_func is not None:\n                    ret = reverse_func(*tensors[::-1], **kw)\n                if ret is NotImplemented:\n                    raise TypeError(\n                        \"unsupported operand type(s) for {0}: '{1}' and '{2}\".format(\n                            func.__name__, *[type(t) for t in tensors]))\n            return ret\n        return call\n    return inner\n", "docstring": "def inner(func):"}
{"repo": "mars-master/mars/tensor/utils.py", "original_string": "def decide_unify_split(*splits):\n    # TODO (jisheng): In the future, we need more sophisticated way to decide the rechunk split\n    # right now, for (2, 2) and (3, 1), we get the rechunk split as (2, 1, 1)\n    if not splits:\n        return ()\n    raw_splits = splits\n    # support broadcasting rules\n    # decide_unify_splits((1,), (5,))  --> (5,)\n    splits = set(s for s in splits if ((len(s) > 1) or (len(s) == 1 and s[0] != 1)))\n    if len(splits) == 1:\n        return splits.pop()\n    if len(splits) == 0:\n        return raw_splits[0]\n    if any(np.isnan(sum(s)) for s in splits):\n        raise ValueError(f'Tensor chunk sizes are unknown: {splits}')\n    if len(set(sum(s) for s in splits)) > 1:\n        raise ValueError(f'Splits not of same size: {splits}')\n    q = [list(s) for s in splits]\n    size = sum(q[0])\n    cum = 0\n    res = []\n    while cum < size:\n        m = min(s[0] for s in q)\n        res.append(m)\n        for s in q:\n            s[0] -= m\n            if s[0] == 0:\n                s.pop(0)\n        cum += m\n    return tuple(res)\n", "docstring": "TODO (jisheng): In the future, we need more sophisticated way to decide the rechunk split"}
{"repo": "mars-master/mars/tensor/utils.py", "original_string": "def _create_tiledb_ctx(conf_tuple):\n    if conf_tuple is not None:\n        return tiledb.Ctx(dict(conf_tuple))\n    return tiledb.Ctx()\n", "docstring": "if conf_tuple is not None:"}
{"repo": "mars-master/mars/tensor/core.py", "original_string": "    def params(self) -> Dict[str, Any]:\n        # params return the properties which useful to rebuild a new chunk\n        return {\n            'shape': self.shape,\n            'dtype': self.dtype,\n            'order': self.order,\n            'index': self.index,\n        }\n", "docstring": "params return the properties which useful to rebuild a new chunk"}
{"repo": "mars-master/mars/tensor/core.py", "original_string": "    def params(self):\n        # params return the properties which useful to rebuild a new tileable object\n        return {\n            'shape': self.shape,\n            'dtype': self.dtype,\n            'order': self.order\n        }\n", "docstring": "params return the properties which useful to rebuild a new tileable object"}
{"repo": "mars-master/mars/tensor/core.py", "original_string": "    def copy(self, order='C'):\n        return super().copy().astype(self.dtype, order=order, copy=False)\n", "docstring": "return super().copy().astype(self.dtype, order=order, copy=False)"}
{"repo": "mars-master/mars/tensor/core.py", "original_string": "    def to_dataframe(self, *args, **kwargs):\n        return self._data.to_dataframe(*args, **kwargs)\n", "docstring": "return self._data.to_dataframe(*args, **kwargs)"}
{"repo": "mars-master/mars/tensor/core.py", "original_string": "    def __init__(self, tensor):\n        # flatten creates a copy\n        self._flatten_tensor = tensor.flatten()\n        # ravel creates a view\n        self._ravel_tensor = tensor.ravel()\n", "docstring": "flatten creates a copy"}
{"repo": "mars-master/mars/tensor/core.py", "original_string": "    def __setitem__(self, key, value):\n        # a.flat[item] = value will apply changes to original tensor\n        self._ravel_tensor[key] = value\n", "docstring": "a.flat[item] = value will apply changes to original tensor"}
{"repo": "mars-master/mars/tensor/spatial/distance/cdist.py", "original_string": "    def tile(cls, op):\n        # make sure every inputs have known shape\n        if has_unknown_shape(*op.inputs):\n            yield\n        xa = op.xa.rechunk({1: op.xa.shape[1]})\n        xb = op.xb.rechunk({1: op.xb.shape[1]})\n        xa, xb = yield from recursive_tile(xa, xb)\n        # rechunk w, v, vi into one chunk if any of them has value\n        extra_inputs = [None] * 3\n        for i, ei in enumerate([op.w, op.v, op.vi]):\n            if ei is None:\n                continue\n            new_ei = yield from recursive_tile(ei.rechunk(ei.shape))\n            extra_inputs[i] = new_ei\n        w, v, vi = extra_inputs\n        if len(xa.chunks) == 1 and len(xb.chunks) == 1:\n            # only 1 chunk\n            return cls._tile_one_chunk(op, xa, xb, w, v, vi)\n        else:\n            return cls._tile_chunks(op, xa, xb, w, v, vi)\n", "docstring": "make sure every inputs have known shape"}
{"repo": "mars-master/mars/tensor/spatial/distance/pdist.py", "original_string": "    def tile(cls, op):\n        # make sure every inputs have known shape\n        if has_unknown_shape(*op.inputs):\n            yield\n        in_tensor = yield from recursive_tile(\n            op.input.rechunk({1: op.input.shape[1]}))\n        # rechunk w, v, vi into one chunk if any of them has value\n        extra_inputs = [None] * 3\n        for i, ei in enumerate([op.w, op.v, op.vi]):\n            if ei is None:\n                continue\n            new_ei = yield from recursive_tile(ei.rechunk(ei.shape))\n            extra_inputs[i] = new_ei\n        w, v, vi = extra_inputs\n        if len(in_tensor.chunks) == 1:\n            # only 1 chunk\n            return cls._tile_one_chunk(op, in_tensor, w, v, vi)\n        else:\n            return cls._tile_chunks(op, in_tensor, w, v, vi)\n", "docstring": "make sure every inputs have known shape"}
{"repo": "mars-master/mars/tensor/base/sort.py", "original_string": "    def tile(cls, op):\n        in_tensor = op.inputs[0]\n        return_value, return_indices = op.return_value, op.return_indices\n        if in_tensor.chunk_shape[op.axis] == 1:\n            out_chunks, out_indices_chunks = [], []\n            for chunk in in_tensor.chunks:\n                chunk_op = op.copy().reset_key()\n                kws = []\n                if return_value:\n                    kws.append({\n                        'shape': chunk.shape,\n                        'index': chunk.index,\n                        'order': chunk.order,\n                        'dtype': chunk.dtype,\n                        'type': 'sorted'\n                    })\n                if return_indices:\n                    kws.append({\n                        'shape': chunk.shape,\n                        'index': chunk.index,\n                        'order': TensorOrder.C_ORDER,\n                        'dtype': np.dtype(np.int64),\n                        'type': 'argsort'\n                    })\n                chunks = chunk_op.new_chunks([chunk], kws=kws)\n                if return_value:\n                    out_chunks.append(chunks[0])\n                if return_indices:\n                    out_indices_chunks.append(chunks[-1])\n            new_op = op.copy()\n            kws = [out.params for out in op.outputs]\n            if return_value:\n                kws[0]['nsplits'] = in_tensor.nsplits\n                kws[0]['chunks'] = out_chunks\n            if return_indices:\n                kws[-1]['nsplits'] = in_tensor.nsplits\n                kws[-1]['chunks'] = out_indices_chunks\n            return new_op.new_tensors([in_tensor], kws=kws)\n        else:\n            # use parallel sorting by regular sampling\n            return (yield from cls._tile_psrs(op))\n", "docstring": "in_tensor = op.inputs[0]"}
{"repo": "mars-master/mars/tensor/base/searchsorted.py", "original_string": "    def _execute_map(cls, xp, a, v, op):\n        # in the map phase, calculate the indices and positions\n        # for instance, a=[1, 4, 6], v=5, return will be (2, 6)\n        indices = xp.atleast_1d(xp.searchsorted(a, v, side=op.side))\n        data_indices = indices.copy()\n        # if the value is larger than all data\n        # for instance, a=[1, 4, 6], v=7\n        # return will be (2, 6), not (3, 6), thus needs to subtract 1\n        data_indices = xp.subtract(data_indices, 1, out=data_indices,\n                                   where=data_indices >= len(a))\n        data = a[data_indices]\n        if op.offset > 0:\n            indices = xp.add(indices, op.offset, out=indices)\n        if np.isscalar(v):\n            indices, data = indices[0], data[0]\n        return indices, data\n", "docstring": "in the map phase, calculate the indices and positions"}
{"repo": "mars-master/mars/tensor/base/partition.py", "original_string": "    def calc_paritions_info(cls, op, kth, size, sort_info_chunks):\n        # stage5, collect sort infos and calculate partition info for each partitions\n        if isinstance(kth, TENSOR_TYPE):\n            kth = kth.chunks[0]\n            is_kth_input = True\n        else:\n            is_kth_input = False\n        calc_op = CalcPartitionsInfo(kth=kth, size=size,\n                                     dtype=np.dtype(np.int32), gpu=op.gpu)\n        kws = []\n        for i, sort_info_chunk in enumerate(sort_info_chunks):\n            kws.append({\n                'shape': sort_info_chunk.shape + (len(kth),),\n                'order': sort_info_chunk.order,\n                'index': sort_info_chunk.index,\n                'pos': i\n            })\n        inputs = list(sort_info_chunks)\n        if is_kth_input:\n            inputs.insert(0, kth)\n        return calc_op.new_chunks(inputs, kws=kws, output_limit=len(kws))\n", "docstring": "stage5, collect sort infos and calculate partition info for each partitions"}
{"repo": "mars-master/mars/tensor/base/partition.py", "original_string": "    def psrs_kinds(self):\n        # to keep compatibility with PSRS\n        # remember when merging data in PSRSShuffle(reduce),\n        # we don't need sort, thus set psrs_kinds[2] to None\n        return ['quicksort', 'mergesort', None]\n", "docstring": "to keep compatibility with PSRS"}
{"repo": "mars-master/mars/tensor/base/partition.py", "original_string": "    def tile(cls, op):\n        in_tensor = op.input\n        if np.isnan(in_tensor.shape[op.axis]):\n            yield\n        kth = op.kth\n        if isinstance(kth, TENSOR_TYPE):\n            # if `kth` is a tensor, make sure no unknown shape\n            if has_unknown_shape(kth):\n                yield\n            kth = yield from recursive_tile(kth.rechunk(kth.shape))\n        return_value, return_indices = op.return_value, op.return_indices\n        if in_tensor.chunk_shape[op.axis] == 1:\n            out_chunks, out_indices_chunks = [], []\n            for chunk in in_tensor.chunks:\n                chunk_op = op.copy().reset_key()\n                kws = []\n                if return_value:\n                    kws.append({\n                        'shape': chunk.shape,\n                        'index': chunk.index,\n                        'order': chunk.order,\n                        'dtype': chunk.dtype,\n                        'type': 'partitioned'\n                    })\n                if return_indices:\n                    kws.append({\n                        'shape': chunk.shape,\n                        'index': chunk.index,\n                        'order': TensorOrder.C_ORDER,\n                        'dtype': np.dtype(np.int64),\n                        'type': 'argpartition'\n                    })\n                chunk_inputs = [chunk]\n                if isinstance(kth, TENSOR_TYPE):\n                    chunk_inputs.append(kth.chunks[0])\n                chunks = chunk_op.new_chunks(chunk_inputs, kws=kws)\n                if return_value:\n                    out_chunks.append(chunks[0])\n                if return_indices:\n                    out_indices_chunks.append(chunks[-1])\n            new_op = op.copy()\n            kws = [out.params for out in op.outputs]\n            if return_value:\n                kws[0]['nsplits'] = in_tensor.nsplits\n                kws[0]['chunks'] = out_chunks\n            if return_indices:\n                kws[-1]['nsplits'] = in_tensor.nsplits\n                kws[-1]['chunks'] = out_indices_chunks\n            return new_op.new_tensors([in_tensor], kws=kws)\n        else:\n            return (yield from cls._tile_psrs(op, kth))\n", "docstring": "in_tensor = op.input"}
{"repo": "mars-master/mars/tensor/base/psrs.py", "original_string": "    def local_sort_and_regular_sample(cls, op, in_data, axis_chunk_shape, axis_offsets, out_idx):\n        # stage 1: local sort and regular samples collected\n        sorted_chunks, indices_chunks, sampled_chunks = [], [], []\n        sampled_dtype = np.dtype([(o, in_data.dtype[o]) for o in op.order]) \\\n            if op.order is not None else in_data.dtype\n        for i in range(axis_chunk_shape):\n            idx = list(out_idx)\n            idx.insert(op.axis, i)\n            in_chunk = in_data.cix[tuple(idx)]\n            kind = None if op.psrs_kinds is None else op.psrs_kinds[0]\n            chunk_op = PSRSSortRegularSample(axis=op.axis, order=op.order, kind=kind,\n                                             return_indices=op.return_indices,\n                                             n_partition=axis_chunk_shape,\n                                             axis_offset=axis_offsets[i],\n                                             gpu=op.gpu)\n            kws = []\n            sort_shape = in_chunk.shape\n            kws.append({'shape': sort_shape,\n                        'order': in_chunk.order,\n                        'dtype': in_chunk.dtype,\n                        'index': in_chunk.index,\n                        'type': 'sorted'})\n            if op.return_indices:\n                kws.append({'shape': sort_shape,\n                            'order': TensorOrder.C_ORDER,\n                            'dtype': np.dtype(np.int64),\n                            'index': in_chunk.index,\n                            'type': 'argsort'})\n            sampled_shape = (axis_chunk_shape,)\n            kws.append({'shape': sampled_shape,\n                        'order': in_chunk.order,\n                        'dtype': sampled_dtype,\n                        'index': (i,),\n                        'type': 'regular_sampled'})\n            chunks = chunk_op.new_chunks([in_chunk], kws=kws, output_limit=len(kws))\n            if len(chunks) == 2:\n                sort_chunk, sampled_chunk = chunks\n                sorted_chunks.append(sort_chunk)\n                sampled_chunks.append(sampled_chunk)\n            else:\n                sort_chunk, indices_chunk, sampled_chunk = chunks\n                sorted_chunks.append(sort_chunk)\n                indices_chunks.append(indices_chunk)\n                sampled_chunks.append(sampled_chunk)\n        return sorted_chunks, indices_chunks, sampled_chunks\n", "docstring": "stage 1: local sort and regular samples collected"}
{"repo": "mars-master/mars/tensor/base/psrs.py", "original_string": "    def concat_and_pivot(cls, op, axis_chunk_shape, out_idx, sorted_chunks, sampled_chunks):\n        # stage 2: gather and merge samples, choose and broadcast p-1 pivots\n        concat_pivot_op = PSRSConcatPivot(axis=op.axis,\n                                          order=op.order,\n                                          kind=None if op.psrs_kinds is None else op.psrs_kinds[1],\n                                          dtype=sampled_chunks[0].dtype,\n                                          gpu=op.gpu)\n        concat_pivot_shape = \\\n            sorted_chunks[0].shape[:op.axis] + (axis_chunk_shape - 1,) + \\\n            sorted_chunks[0].shape[op.axis + 1:]\n        concat_pivot_index = out_idx[:op.axis] + (0,) + out_idx[op.axis:]\n        concat_pivot_chunk = concat_pivot_op.new_chunk(sampled_chunks,\n                                                       shape=concat_pivot_shape,\n                                                       index=concat_pivot_index)\n        return concat_pivot_chunk\n", "docstring": "stage 2: gather and merge samples, choose and broadcast p-1 pivots"}
{"repo": "mars-master/mars/tensor/base/psrs.py", "original_string": "    def partition_merge_data(cls, op, need_align, return_value, partition_chunks, proxy_chunk):\n        # stage 4: all *ith* classes are gathered and merged\n        return_value = return_value if return_value is not None else op.return_value\n        return_indices = op.return_indices\n        partition_sort_chunks, partition_indices_chunks, sort_info_chunks = [], [], []\n        for i, partition_chunk in enumerate(partition_chunks):\n            kind = None if op.psrs_kinds is None else op.psrs_kinds[2]\n            partition_shuffle_reduce = PSRSShuffle(return_value=return_value,\n                                                   return_indices=return_indices,\n                                                   stage=OperandStage.reduce,\n                                                   axis=op.axis, order=op.order,\n                                                   kind=kind,\n                                                   reducer_index=(i,),\n                                                   dtype=partition_chunk.dtype,\n                                                   gpu=partition_chunk.op.gpu,\n                                                   need_align=need_align)\n            kws = []\n            chunk_shape = list(partition_chunk.shape)\n            chunk_shape[op.axis] = np.nan\n            if return_value:\n                kws.append({\n                    'shape': tuple(chunk_shape),\n                    'order': partition_chunk.order,\n                    'index': partition_chunk.index,\n                    'dtype': partition_chunk.dtype,\n                    'type': 'sorted',\n                })\n            if return_indices:\n                kws.append({\n                    'shape': tuple(chunk_shape),\n                    'order': TensorOrder.C_ORDER,\n                    'index': partition_chunk.index,\n                    'dtype': np.dtype(np.int64),\n                    'type': 'argsort'\n                })\n            if need_align:\n                s = list(chunk_shape)\n                s.pop(op.axis)\n                kws.append({\n                    'shape': tuple(s),\n                    'order': TensorOrder.C_ORDER,\n                    'index': partition_chunk.index,\n                    'dtype': np.dtype(np.int32),\n                    'type': 'sort_info',\n                })\n            cs = partition_shuffle_reduce.new_chunks([proxy_chunk], kws=kws)\n            i = 0\n            if return_value:\n                partition_sort_chunks.append(cs[0])\n                i += 1\n            if return_indices:\n                partition_indices_chunks.append(cs[i])\n            if need_align:\n                sort_info_chunks.append(cs[-1])\n        return partition_sort_chunks, partition_indices_chunks, sort_info_chunks\n", "docstring": "stage 4: all *ith* classes are gathered and merged"}
{"repo": "mars-master/mars/tensor/base/psrs.py", "original_string": "    def output_limit(self):\n        # return sorted tensor, indices(optional) and regular sampled tensor\n        return 2 if not self._return_indices else 3\n", "docstring": "return sorted tensor, indices(optional) and regular sampled tensor"}
{"repo": "mars-master/mars/tensor/base/tests/test_base_execute.py", "original_string": "def test_sort_indices_execution(setup):\n    # only 1 chunk when axis = -1\n    raw = np.random.rand(100, 10)\n    x = tensor(raw, chunk_size=20)\n    r = sort(x, return_index=True)\n    sr, si = r.execute().fetch()\n    np.testing.assert_array_equal(sr, np.take_along_axis(raw, si, axis=-1))\n    x = tensor(raw, chunk_size=(22, 4))\n    r = sort(x, return_index=True)\n    sr, si = r.execute().fetch()\n    np.testing.assert_array_equal(sr, np.take_along_axis(raw, si, axis=-1))\n    raw = np.random.rand(100)\n    x = tensor(raw, chunk_size=23)\n    r = sort(x, axis=0, return_index=True)\n    sr, si = r.execute().fetch()\n    np.testing.assert_array_equal(sr, raw[si])\n", "docstring": "only 1 chunk when axis = -1"}
{"repo": "mars-master/mars/tensor/base/tests/test_base_execute.py", "original_string": "def test_argpartition_execution(setup):\n    # only 1 chunk when axis = -1\n    raw = np.random.rand(100, 10)\n    x = tensor(raw, chunk_size=10)\n    kth = [6, 3, 8]\n    pa = argpartition(x, kth)\n    r = pa.execute().fetch()\n    np.testing.assert_array_equal(np.sort(raw)[:, kth], np.take_along_axis(raw, r, axis=-1)[:, kth])\n    x = tensor(raw, chunk_size=(22, 4))\n    pa = argpartition(x, kth)\n    r = pa.execute().fetch()\n    np.testing.assert_array_equal(np.sort(raw)[:, kth], np.take_along_axis(raw, r, axis=-1)[:, kth])\n    raw = np.random.rand(100)\n    x = tensor(raw, chunk_size=23)\n    pa = argpartition(x, kth, axis=0)\n    r = pa.execute().fetch()\n    np.testing.assert_array_equal(np.sort(raw, axis=0)[kth], raw[r][kth])\n", "docstring": "only 1 chunk when axis = -1"}
{"repo": "mars-master/mars/tensor/base/tests/test_base.py", "original_string": "def test_asfortranarray():\n    # dtype different\n    raw_a = np.random.rand(2, 4)\n    raw_b = np.asfortranarray(raw_a, dtype='f4')\n    a = tensor(raw_a, chunk_size=2)\n    b = asfortranarray(a, dtype='f4')\n    assert a.dtype == raw_a.dtype\n    assert a.flags['C_CONTIGUOUS'] == raw_a.flags['C_CONTIGUOUS']\n    assert a.flags['F_CONTIGUOUS'] == raw_a.flags['F_CONTIGUOUS']\n    assert b.dtype == raw_b.dtype\n    assert b.flags['C_CONTIGUOUS'] == raw_b.flags['C_CONTIGUOUS']\n    assert b.flags['F_CONTIGUOUS'] == raw_b.flags['F_CONTIGUOUS']\n    # no copy\n    raw_a = np.asfortranarray(np.random.rand(2, 4))\n    raw_b = np.asfortranarray(raw_a)\n    a = tensor(raw_a, chunk_size=2)\n    b = asfortranarray(a)\n    assert a.dtype == raw_a.dtype\n    assert a.flags['C_CONTIGUOUS'] == raw_a.flags['C_CONTIGUOUS']\n    assert a.flags['F_CONTIGUOUS'] == raw_a.flags['F_CONTIGUOUS']\n    assert b.dtype == raw_b.dtype\n    assert b.flags['C_CONTIGUOUS'] == raw_b.flags['C_CONTIGUOUS']\n    assert b.flags['F_CONTIGUOUS'] == raw_b.flags['F_CONTIGUOUS']\n", "docstring": "dtype different"}
{"repo": "mars-master/mars/tensor/statistics/histogram.py", "original_string": "def _ptp(range_):\n    \"\"\"Peak-to-peak value of x.\n    This implementation avoids the problem of signed integer arrays having a\n    peak-to-peak value that cannot be represented with the array's data type.\n    This function returns an unsigned value for signed integer arrays.\n    \"\"\"\n    return _unsigned_subtract(*range_[::-1])\n", "docstring": "Peak-to-peak value of x."}
{"repo": "mars-master/mars/tensor/statistics/histogram.py", "original_string": "def _ravel_and_check_weights(a, weights):\n    \"\"\" Check a and weights have matching shapes, and ravel both \"\"\"\n    a = astensor(a)\n    # Ensure that the array is a \"subtractable\" dtype\n    if a.dtype == np.bool_:\n        warnings.warn(f\"Converting input from {a.dtype} to {np.uint8} for compatibility.\",\n                      RuntimeWarning, stacklevel=3)\n        a = a.astype(np.uint8)\n    if weights is not None:\n        weights = astensor(weights)\n        if weights.shape != a.shape:\n            raise ValueError(\n                'weights should have the same shape as a.')\n        weights = weights.ravel()\n    a = a.ravel()\n    return a, weights\n", "docstring": "Check a and weights have matching shapes, and ravel both \n"}
{"repo": "mars-master/mars/tensor/statistics/histogram.py", "original_string": "def _get_bin_edges(op, a, bins, range, weights):\n    # parse the overloaded bins argument\n    n_equal_bins = None\n    bin_edges = None\n    first_edge = None\n    last_edge = None\n    if isinstance(bins, str):\n        # when `bins` is str, x.min() and x.max()\n        # will be calculated in advance\n        bin_name = bins\n        if a.size > 0:\n            assert range is not None\n        raw_range = range\n        first_edge, last_edge = _get_outer_edges(a, range)\n        if a.size == 0:\n            n_equal_bins = 1\n        else:\n            # Do not call selectors on empty arrays\n            selector = _hist_bin_selectors[bin_name](op, a, (first_edge, last_edge), raw_range)\n            yield from selector.check()\n            width = selector.get_result()\n            if width:\n                n_equal_bins = int(np.ceil(_unsigned_subtract(last_edge, first_edge) / width))\n            else:\n                # Width can be zero for some estimators, e.g. FD when\n                # the IQR of the data is zero.\n                n_equal_bins = 1\n    elif mt.ndim(bins) == 0:\n        first_edge, last_edge = _get_outer_edges(a, range)\n        n_equal_bins = bins\n    else:\n        # cannot be Tensor, must be calculated first\n        assert mt.ndim(bins) == 1 and not isinstance(bins, TENSOR_TYPE)\n        bin_edges = np.asarray(bins)\n        if not is_asc_sorted(bin_edges):\n            raise ValueError(\n                '`bins` must increase monotonically, when an array')\n    if n_equal_bins is not None:\n        # numpy gh-10322 means that type resolution rules are dependent on array\n        # shapes. To avoid this causing problems, we pick a type now and stick\n        # with it throughout.\n        bin_type = np.result_type(first_edge, last_edge, a)\n        if np.issubdtype(bin_type, np.integer):\n            bin_type = np.result_type(bin_type, float)\n        # bin edges must be computed\n        bin_edges = mt.linspace(\n            first_edge, last_edge, n_equal_bins + 1,\n            endpoint=True, dtype=bin_type, gpu=op.gpu)\n        return bin_edges, (first_edge, last_edge, n_equal_bins)\n    else:\n        return mt.tensor(bin_edges), None\n", "docstring": "parse the overloaded bins argument"}
{"repo": "mars-master/mars/tensor/statistics/histogram.py", "original_string": "    def __init__(self, input=None, bins=None, range=None, weights=None,\n                 input_min=None, input_max=None, **kw):\n        super().__init__(_input=input, _bins=bins, _range=range,\n                         _weights=weights, **kw)\n", "docstring": "input_min=None, input_max=None, **kw):"}
{"repo": "mars-master/mars/tensor/statistics/quantile.py", "original_string": "def _quantile_is_valid(q):\n    # avoid expensive reductions, relevant for arrays with < O(1000) elements\n    if q.ndim == 1 and q.size < 10:\n        for i in range(q.size):\n            if q[i] < 0.0 or q[i] > 1.0:\n                return False\n    else:\n        # faster than any()\n        if np.count_nonzero(q < 0.0) or np.count_nonzero(q > 1.0):\n            return False\n    return True\n", "docstring": "avoid expensive reductions, relevant for arrays with < O(1000) elements"}
{"repo": "mars-master/mars/tensor/indexing/fill_diagonal.py", "original_string": "    def _tile_2d(cls, op, val):\n        from ..datasource import diag\n        d = yield from recursive_tile(diag(op.input))\n        index_to_diag_chunk = {c.inputs[0].index: c for c in d.chunks}\n        cum_sizes = [0] + np.cumsum(d.nsplits[0]).tolist()\n        out_chunks = []\n        for chunk in op.input.chunks:\n            if chunk.index not in index_to_diag_chunk:\n                out_chunks.append(chunk)\n            else:\n                diag_chunk = index_to_diag_chunk[chunk.index]\n                diag_idx = diag_chunk.index[0]\n                input_chunks = [chunk]\n                chunk_val = cls._gen_val(val, diag_idx, cum_sizes)\n                if len(op.inputs) == 2:\n                    input_chunks.append(chunk_val)\n                chunk_op = op.copy().reset_key()\n                chunk_op._wrap = False\n                chunk_op._k = diag_chunk.op.k\n                chunk_op._val = chunk_val\n                out_chunk = chunk_op.new_chunk(input_chunks, shape=chunk.shape,\n                                               order=chunk.order,\n                                               index=chunk.index)\n                out_chunks.append(out_chunk)\n        out = op.outputs[0]\n        new_op = op.copy()\n        return new_op.new_tensors(op.inputs, shape=out.shape, order=out.order,\n                                  chunks=out_chunks, nsplits=op.input.nsplits)\n", "docstring": "from ..datasource import diag"}
{"repo": "mars-master/mars/tensor/indexing/fill_diagonal.py", "original_string": "    def _tile_nd(cls, op, val):\n        # if more than 3d, we will rechunk the tensor into square chunk\n        # on the diagonal direction\n        in_tensor = op.input\n        nsplits = np.array(in_tensor.nsplits)\n        if not np.issubdtype(nsplits.dtype, np.integer) or \\\n                not np.all(np.diff(nsplits, axis=1) == 0):\n            # need rechunk\n            nsplit = decide_unify_split(*in_tensor.nsplits)\n            in_tensor = yield from recursive_tile(in_tensor.rechunk(\n                tuple(nsplit for _ in range(in_tensor.ndim))))\n        cum_sizes = [0] + np.cumsum(in_tensor.nsplits[0]).tolist()\n        out_chunks = []\n        for chunk in in_tensor.chunks:\n            if len(set(chunk.index)) == 1:\n                # chunk on the diagonal direction\n                chunk_op = op.copy().reset_key()\n                chunk_op._k = 0\n                chunk_inputs = [chunk]\n                chunk_val = cls._gen_val(val, chunk.index[0], cum_sizes)\n                if len(op.inputs) == 2:\n                    chunk_inputs.append(chunk_val)\n                chunk_op._val = chunk_val\n                out_chunk = chunk_op.new_chunk(chunk_inputs, shape=chunk.shape,\n                                               order=chunk.order,\n                                               index=chunk.index)\n                out_chunks.append(out_chunk)\n            else:\n                out_chunks.append(chunk)\n        out = op.outputs[0]\n        new_op = op.copy()\n        return new_op.new_tensors(op.inputs, shape=out.shape, order=out.order,\n                                  chunks=out_chunks, nsplits=in_tensor.nsplits)\n", "docstring": "if more than 3d, we will rechunk the tensor into square chunk"}
{"repo": "mars-master/mars/tensor/indexing/fill_diagonal.py", "original_string": "    def tile(cls, op):\n        # input tensor must have no unknown chunk shape\n        if has_unknown_shape(*op.inputs):\n            yield\n        in_tensor = op.input\n        is_in_tensor_tall = cls._is_tall(in_tensor)\n        if op.val.ndim > 0:\n            val = yield from cls._process_val(op.val, in_tensor, op.wrap)\n        else:\n            val = op.val\n        if len(in_tensor.chunks) == 1:\n            return cls._tile_one_chunk(op, val)\n        if op.input.ndim == 2:\n            if op.wrap and is_in_tensor_tall:\n                from ..merge import concatenate\n                sub_tensors = cls._split_tall_matrix(in_tensor)\n                for i, sub_tensor in enumerate(sub_tensors):\n                    if val.ndim > 0:\n                        sub_val = val[i * sub_tensor.shape[1]:\n                                      (i + 1) * sub_tensor.shape[1]]\n                    else:\n                        sub_val = val\n                    fill_diagonal(sub_tensor, sub_val, wrap=False)\n                out_tensor = concatenate(sub_tensors)\n                return [(yield from recursive_tile(out_tensor))]\n            else:\n                return (yield from cls._tile_2d(op, val))\n        else:\n            return (yield from cls._tile_nd(op, val))\n", "docstring": "input tensor must have no unknown chunk shape"}
{"repo": "mars-master/mars/tensor/indexing/index_lib.py", "original_string": "    def is_first(cls, index_info: IndexInfo, context: IndexHandlerContext) -> bool:\n        # check if is first fancy index after parsing\n        fancy_indexes = context.get_indexes(index_info.index_type)\n        i = fancy_indexes.index(index_info)\n        if i > 0:\n            # only process for the first fancy indexes\n            return False\n        else:\n            return True\n", "docstring": "check if is first fancy index after parsing"}
{"repo": "mars-master/mars/tensor/indexing/index_lib.py", "original_string": "    def _process(cls, context, index_infos):\n        # process\n        for index_info in index_infos:\n            process = index_info.handler.process(index_info, context)\n            if inspect.isgenerator(process):\n                yield from process\n        context.processed_chunks = context.out_chunks = out_chunks = []\n        for chunk_index, chunk_index_info in context.chunk_index_to_info.items():\n            out_chunks.append(context.create_chunk(chunk_index, chunk_index_info))\n        index_to_shape = OrderedDict(sorted([(c.index, c.shape) for c in out_chunks],\n                                            key=itemgetter(0)))\n        context.out_nsplits = calc_nsplits(index_to_shape)\n", "docstring": "process"}
{"repo": "mars-master/mars/tensor/indexing/index_lib.py", "original_string": "    def _postprocess(cls, context, index_infos):\n        # post process\n        for index_info in index_infos:\n            index_info.handler.postprocess(index_info, context)\n", "docstring": "post process"}
{"repo": "mars-master/mars/tensor/random/tests/test_random_execute.py", "original_string": "def test_sparse_randint_execution(setup):\n    # size_executor = ExecutorForTest(sync_provider_type=ExecutorForTest.SyncProviderType.MOCK)\n    arr = tensor.random.randint(1, 2, size=(30, 50), density=.1,\n                                chunk_size=20, dtype='f4')\n    # size_res = size_executor.execute_tensor(arr, mock=True)\n    # assert pytest.approx(arr.nbytes * 0.1) == sum(tp[0] for tp in size_res)\n    res = arr.execute().fetch()\n    assert issparse(res) is True\n    assert res.shape == (30, 50)\n    np.testing.assert_array_less(res.data, 2)\n    np.testing.assert_array_less(0, res.data)\n    assert pytest.approx((res >= 1).toarray().sum(), 30 * 50 * .1, abs=20)\n", "docstring": "size_executor = ExecutorForTest(sync_provider_type=ExecutorForTest.SyncProviderType.MOCK)"}
{"repo": "mars-master/mars/tensor/linalg/inv.py", "original_string": "    def execute(cls, ctx, op):\n        (inp,), device_id, xp = as_same_device(\n            [ctx[c.key] for c in op.inputs], device=op.device, ret_extra=True)\n        with device(device_id):\n            ctx[op.outputs[0].key] = xp.linalg.inv(inp)\n", "docstring": "(inp,), device_id, xp = as_same_device("}
{"repo": "mars-master/mars/tensor/einsum/einsumfunc.py", "original_string": "def _parse_possible_contraction(positions, input_sets, output_set, idx_dict, memory_limit, path_cost, naive_cost):\n    \"\"\"Compute the cost (removed size + flops) and resultant indices for\n    performing the contraction specified by ``positions``.\n    Parameters\n    ----------\n    positions : tuple of int\n        The locations of the proposed tensors to contract.\n    input_sets : list of sets\n        The indices found on each tensors.\n    output_set : set\n        The output indices of the expression.\n    idx_dict : dict\n        Mapping of each index to its size.\n    memory_limit : int\n        The total allowed size for an intermediary tensor.\n    path_cost : int\n        The contraction cost so far.\n    naive_cost : int\n        The cost of the unoptimized expression.\n    Returns\n    -------\n    cost : (int, int)\n        A tuple containing the size of any indices removed, and the flop cost.\n    positions : tuple of int\n        The locations of the proposed tensors to contract.\n    new_input_sets : list of sets\n        The resulting new list of indices if this proposed contraction is performed.\n    \"\"\"\n    # Find the contraction\n    contract = _find_contraction(positions, input_sets, output_set)\n    idx_result, new_input_sets, idx_removed, idx_contract = contract\n    # Sieve the results based on memory_limit\n    new_size = _compute_size_by_dict(idx_result, idx_dict)\n    if new_size > memory_limit:\n        return None\n    # Build sort tuple\n    old_sizes = (_compute_size_by_dict(input_sets[p], idx_dict) for p in positions)\n    removed_size = sum(old_sizes) - new_size\n    # NB: removed_size used to be just the size of any removed indices i.e.:\n    #     helpers.compute_size_by_dict(idx_removed, idx_dict)\n    cost = _flop_count(idx_contract, idx_removed, len(positions), idx_dict)\n    sort = (-removed_size, cost)\n    # Sieve based on total cost as well\n    if (path_cost + cost) > naive_cost:\n        return None\n    # Add contraction to possible choices\n    return [sort, positions, new_input_sets]\n", "docstring": "Compute the cost (removed size + flops) and resultant indices for"}
{"repo": "mars-master/mars/tensor/arithmetic/add.py", "original_string": "def radd(x1, x2, **kwargs):\n    op = TensorAdd(**kwargs)\n    return op.rcall(x1, x2)\n", "docstring": "op = TensorAdd(**kwargs)"}
{"repo": "mars-master/mars/tensor/arithmetic/core.py", "original_string": "    def _call(self, x1, x2, out=None, where=None):\n        # check tensor ufunc, if x1 or x2 is not a tensor, e.g. Mars DataFrame\n        # which implements tensor ufunc, will delegate the computation\n        # to it if possible\n        ret = self._call_tensor_ufunc(x1, x2, out=out, where=where)\n        if ret is not None:\n            return ret\n        x1, x2, out, where = self._process_inputs(x1, x2, out, where)\n        # check broadcast\n        x1_shape = () if np.isscalar(x1) else x1.shape\n        x2_shape = () if np.isscalar(x2) else x2.shape\n        shape = broadcast_shape(x1_shape, x2_shape)\n        order = self._calc_order(x1, x2, out)\n        inputs = filter_inputs([x1, x2, out, where])\n        t = self.new_tensor(inputs, shape, order=order)\n        if out is None:\n            return t\n        check_out_param(out, t, getattr(self, '_casting'))\n        out_shape, out_dtype = out.shape, out.dtype\n        # if `out` is specified, use out's dtype and shape\n        if t.shape != out_shape:\n            t = self.new_tensor(inputs, out_shape, order=order)\n        setattr(self, 'dtype', out_dtype)\n        out.data = t.data\n        return out\n", "docstring": "check tensor ufunc, if x1 or x2 is not a tensor, e.g. Mars DataFrame"}
{"repo": "mars-master/mars/tensor/arithmetic/core.py", "original_string": "    def _call(self, x, out=None, where=None):\n        # check tensor ufunc, if x is not a tensor, e.g. Mars DataFrame\n        # which implements tensor ufunc, will delegate the computation\n        # to it if possible\n        ret = self._call_tensor_ufunc(x, out=out, where=where)\n        if ret is not None:\n            return ret\n        x, out, where = self._process_inputs(x, out, where)\n        shape = x.shape\n        order = self._calc_order(x, out)\n        inputs = filter_inputs([x, out, where])\n        t = self.new_tensor(inputs, shape, order=order)\n        if out is None:\n            return t\n        check_out_param(out, t, getattr(self, '_casting'))\n        out_shape, out_dtype = out.shape, out.dtype\n        # if `out` is specified, use out's dtype and shape\n        if t.shape != out_shape:\n            t = self.new_tensor(inputs, out_shape, order=order)\n        setattr(self, 'dtype', out_dtype)\n        out.data = t.data\n        return out\n", "docstring": "check tensor ufunc, if x is not a tensor, e.g. Mars DataFrame"}
{"repo": "mars-master/mars/tensor/arithmetic/multiply.py", "original_string": "def rmultiply(x1, x2, **kwargs):\n    op = TensorMultiply(**kwargs)\n    return op.rcall(x1, x2)\n", "docstring": "op = TensorMultiply(**kwargs)"}
{"repo": "mars-master/mars/tensor/datasource/array.py", "original_string": "def asarray(x, dtype=None, order=None, chunk_size=None):\n    \"\"\"Convert the input to an array.\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to a tensor.  This\n        includes lists, lists of tuples, tuples, tuples of tuples, tuples\n        of lists and tensors.\n    dtype : data-type, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F'}, optional\n        Whether to use row-major (C-style) or\n        column-major (Fortran-style) memory representation.\n    chunk_size: int, tuple, optional\n        Specifies chunk size for each dimension.\n    Returns\n    -------\n    out : Tensor\n        Tensor interpretation of `a`.  No copy is performed if the input\n        is already an ndarray with matching dtype and order.  If `a` is a\n        subclass of ndarray, a base class ndarray is returned.\n    See Also\n    --------\n    ascontiguousarray : Convert input to a contiguous tensor.\n    asfortranarray : Convert input to a tensor with column-major\n                     memory order.\n    Examples\n    --------\n    Convert a list into a tensor:\n    >>> import mars.tensor as mt\n    >>> a = [1, 2]\n    >>> mt.asarray(a).execute()\n    array([1, 2])\n    Existing arrays are not copied:\n    >>> a = mt.array([1, 2])\n    >>> mt.asarray(a) is a\n    True\n    If `dtype` is set, array is copied only if dtype does not match:\n    >>> a = mt.array([1, 2], dtype=mt.float32)\n    >>> mt.asarray(a, dtype=mt.float32) is a\n    True\n    >>> mt.asarray(a, dtype=mt.float64) is a\n    False\n    \"\"\"\n    return array(x, dtype=dtype, copy=False, order=order, chunk_size=chunk_size)\n", "docstring": "Convert the input to an array."}
{"repo": "mars-master/mars/tensor/datasource/core.py", "original_string": "    def check_inputs(self, inputs):\n        # no inputs\n        if inputs and len(inputs) > 0:\n            raise ValueError(\"Tensor data source has no inputs\")\n", "docstring": "no inputs"}
{"repo": "mars-master/mars/tensor/merge/block.py", "original_string": "def _atleast_nd(a, ndim):\n    # Ensures `a` has at least `ndim` dimensions by prepending\n    # ones to `a.shape` as necessary\n    return array(a, ndmin=ndim, copy=False)\n", "docstring": "Ensures `a` has at least `ndim` dimensions by prepending"}
{"repo": "mars-master/mars/tensor/merge/block.py", "original_string": "def _concatenate_shapes(shapes, axis):\n    \"\"\"Given array shapes, return the resulting shape and slices prefixes.\n    These help in nested concatenation.\n    Returns\n    -------\n    shape: tuple of int\n        This tuple satisfies:\n        ```\n        shape, _ = _concatenate_shapes([arr.shape for shape in arrs], axis)\n        shape == concatenate(arrs, axis).shape\n        ```\n    slice_prefixes: tuple of (slice(start, end), )\n        For a list of arrays being concatenated, this returns the slice\n        in the larger array at axis that needs to be sliced into.\n        For example, the following holds:\n        ```\n        ret = concatenate([a, b, c], axis)\n        _, (sl_a, sl_b, sl_c) = concatenate_slices([a, b, c], axis)\n        ret[(slice(None),) * axis + sl_a] == a\n        ret[(slice(None),) * axis + sl_b] == b\n        ret[(slice(None),) * axis + sl_c] == c\n        ```\n        These are called slice prefixes since they are used in the recursive\n        blocking algorithm to compute the left-most slices during the\n        recursion. Therefore, they must be prepended to rest of the slice\n        that was computed deeper in the recursion.\n        These are returned as tuples to ensure that they can quickly be added\n        to existing slice tuple without creating a new tuple every time.\n    \"\"\"\n    # Cache a result that will be reused.\n    shape_at_axis = [shape[axis] for shape in shapes]\n    # Take a shape, any shape\n    first_shape = shapes[0]\n    first_shape_pre = first_shape[:axis]\n    first_shape_post = first_shape[axis + 1:]\n    if any(shape[:axis] != first_shape_pre or\n           shape[axis + 1:] != first_shape_post for shape in shapes):\n        raise ValueError(\n                'Mismatched array shapes in block along axis {}.'.format(axis))\n    shape = (first_shape_pre + (sum(shape_at_axis),) + first_shape[axis + 1:])\n    offsets_at_axis = _accumulate(shape_at_axis)\n    slice_prefixes = [(slice(start, end),)\n                      for start, end in zip([0] + offsets_at_axis,\n                                            offsets_at_axis)]\n    return shape, slice_prefixes\n", "docstring": "Given array shapes, return the resulting shape and slices prefixes."}
{"repo": "mars-master/mars/tensor/rechunk/core.py", "original_string": "def _divide_to_width(desired_chunk_size, max_width):\n    \"\"\" Minimally divide the given chunks so as to make the largest chunk\n    width less or equal than *max_width*.\n    \"\"\"\n    chunk_size = []\n    for c in desired_chunk_size:\n        nb_divides = int(np.ceil(c / max_width))\n        for i in range(nb_divides):\n            n = c // (nb_divides - i)\n            chunk_size.append(n)\n            c -= n\n        assert c == 0\n    return tuple(chunk_size)\n", "docstring": "Minimally divide the given chunks so as to make the largest chunk"}
{"repo": "mars-master/mars/tensor/special/gamma_funcs.py", "original_string": "def loggamma(x, **kwargs):\n    op = TensorLogGamma(**kwargs)\n    return op(x)\n", "docstring": "op = TensorLogGamma(**kwargs)"}
{"repo": "mars-master/mars/oscar/backends/router.py", "original_string": "    def set_instance(router: Optional[\"Router\"]):\n        # Default router is set when an actor pool started\n        Router._instance = router\n", "docstring": "Default router is set when an actor pool started"}
{"repo": "mars-master/mars/oscar/backends/message.py", "original_string": "    def __init__(self,\n                 message_id: bytes,\n                 address: str,\n                 control_message_type: ControlMessageType,\n                 content: Any,\n                 protocol: int = None,\n                 message_trace: List[MessageTraceItem] = None):\n        super().__init__(message_id,\n                         protocol=protocol,\n                         message_trace=message_trace)\n        self.address = address\n        self.control_message_type = control_message_type\n        self.content = content\n", "docstring": "message_id: bytes,"}
{"repo": "mars-master/mars/oscar/backends/pool.py", "original_string": "    def _set_global_router(router: Router):\n        # be cautious about setting global router\n        # for instance, multiple main pool may be created in the same process\n        # get default router or create an empty one\n        default_router = Router.get_instance_or_empty()\n        Router.set_instance(default_router)\n        # append this router to global\n        default_router.add_router(router)\n", "docstring": "be cautious about setting global router"}
{"repo": "mars-master/mars/oscar/backends/pool.py", "original_string": "    def process_index_gen(cls, address):\n        # make sure different processes does not share process indexes\n        pid = os.getpid()\n        for idx in cls._process_index_gen:\n            yield pid << 16 + idx\n", "docstring": "make sure different processes does not share process indexes"}
{"repo": "mars-master/mars/oscar/backends/communication/base.py", "original_string": "    def info(self) -> Dict:\n        return {\n            'name': self.name,\n            'compression': self.compression,\n            'type': self.type,\n            'local_address': self.local_address,\n            'dest_address': self.dest_address\n        }\n", "docstring": "return {"}
{"repo": "mars-master/mars/oscar/backends/communication/base.py", "original_string": "    def info(self) -> Dict:\n        return {\n            'name': self.scheme,\n            'address': self.address,\n            'channel_type': self.channel_type\n        }\n", "docstring": "return {"}
{"repo": "mars-master/mars/oscar/backends/communication/base.py", "original_string": "    def info(self) -> Dict:\n        return {\n            'local_address': self.local_address,\n            'dest_address': self.dest_address,\n            'channel_name': self.channel.name,\n            'channel_type': self.channel_type\n        }\n", "docstring": "return {"}
{"repo": "mars-master/mars/oscar/backends/mars/backend.py", "original_string": "    def name():\n        # return None because Mars is default scheme\n        return\n", "docstring": "return None because Mars is default scheme"}
{"repo": "mars-master/mars/oscar/backends/ray/utils.py", "original_string": "def process_placement_to_address(pg_name: str, bundle_index: int, process_index: int = 0):\n    return f\"ray://{pg_name}/{bundle_index}/{process_index}\"\n", "docstring": "return f\"ray://{pg_name}/{bundle_index}/{process_index}\""}
{"repo": "mars-master/mars/oscar/backends/ray/pool.py", "original_string": "    def exit_actor(self):\n        \"\"\"Exiting current process gracefully.\"\"\"\n        logger.info('Exiting %s of process %s now', self, os.getpid())\n        ray.actor.exit_actor()\n", "docstring": "Exiting current process gracefully.\n"}
{"repo": "mars-master/mars/oscar/backends/ray/tests/test_ray_actor_driver.py", "original_string": "def test_address_to_pg_bundle():\n    # Missing bundle index.\n    with pytest.raises(ValueError):\n        node_address_to_placement(\"ray://bundle_name\")\n    # Extra path is not allowed.\n    with pytest.raises(ValueError):\n        node_address_to_placement(\"ray://bundle_name/0/\")\n    # The scheme is not ray\n    with pytest.raises(ValueError):\n        node_address_to_placement(\"http://bundle_name/0\")\n    # The bundle index is not an int string.\n    with pytest.raises(ValueError):\n        node_address_to_placement(\"ray://abc/def\")\n    pg_name, bundle_index = node_address_to_placement(\"ray://bundle_name/0\")\n    assert pg_name == \"bundle_name\"\n    assert bundle_index == 0\n    pg_name, bundle_index = node_address_to_placement(\"ray://127.0.0.1/1\")\n    assert pg_name == \"127.0.0.1\"\n    assert bundle_index == 1\n    pg_name, bundle_index = node_address_to_placement(\"ray://127.0.0.1%2F2\")\n    assert pg_name == \"127.0.0.1\"\n    assert bundle_index == 2\n    with pytest.raises(ValueError):\n        node_address_to_placement(\"ray://\")\n", "docstring": "Missing bundle index."}
{"repo": "mars-master/mars/remote/run_script.py", "original_string": "    def _build_envs(cls, ctx, op):\n        # set mars envs\n        envs = dict()\n        envs['RANK'] = str(op.rank)\n        envs['WORLD_SIZE'] = str(op.world_size)\n        return envs\n", "docstring": "set mars envs"}
{"repo": "mars-master/mars/learn/neighbors/_faiss.py", "original_string": "    def _execute_one_chunk(cls, ctx, op):\n        (inp,), device_id, xp = as_same_device(\n            [ctx[c.key] for c in op.inputs], device=op.device, ret_extra=True)\n        with device(device_id):\n            inp = inp.astype(np.float32, copy=False)\n            # create index\n            index = faiss.index_factory(inp.shape[1], op.faiss_index,\n                                        op.faiss_metric_type)\n            # GPU\n            if device_id >= 0:  # pragma: no cover\n                index = _index_to_gpu(index, device_id)\n            # train index\n            if not index.is_trained:\n                assert op.n_sample is not None\n                sample_indices = xp.random.choice(inp.shape[0],\n                                                  size=op.n_sample, replace=False)\n                sampled = inp[sample_indices]\n                index.train(sampled)\n            if op.metric == 'cosine':\n                # faiss does not support cosine distances directly,\n                # data needs to be normalize before adding to index,\n                # refer to:\n                # https://github.com/facebookresearch/faiss/wiki/FAQ#how-can-i-index-vectors-for-cosine-distance\n                faiss.normalize_L2(inp)\n            # add vectors to index\n            if device_id >= 0:  # pragma: no cover\n                # gpu\n                index.add_c(inp.shape[0], _swig_ptr_from_cupy_float32_array(inp))\n            else:\n                index.add(inp)\n            ctx[op.outputs[0].key] = _store_index(index, device_id)\n", "docstring": "(inp,), device_id, xp = as_same_device("}
{"repo": "mars-master/mars/learn/neighbors/_faiss.py", "original_string": "def _load_index(index, device_id):\n    # distributed\n    fn = tempfile.mkstemp('.index', prefix='faiss_')[1]\n    with open(fn, 'wb') as f:\n        f.write(index)\n    index = faiss.read_index(f.name)\n    if device_id >= 0:  # pragma: no cover\n        index = _index_to_gpu(index, device_id)\n    return index\n", "docstring": "distributed"}
{"repo": "mars-master/mars/learn/proxima/core.py", "original_string": "def rechunk_tensor(tensor, chunk_size):\n    # TODO(hks): Provide a unify rechunk logic with mmap.\n    cur_chunks = []\n    out_nchunks = tensor.shape[0] // chunk_size\n    row_nsplits = [chunk_size] * out_nchunks\n    rest = tensor.shape[0] % chunk_size\n    if rest >= out_nchunks:\n        row_nsplits.append(rest)\n    else:\n        for i in range(tensor.shape[0] % chunk_size):\n            row_nsplits[-i-1] += 1\n    tensor_cumnrows = np.cumsum([0] + list(tensor.nsplits[0]))\n    offset = 0\n    out_groups = []\n    for split in row_nsplits:\n        start_chunk_index = int(tensor_cumnrows.searchsorted(offset))\n        start_chunk_index = start_chunk_index - 1 if start_chunk_index != 0 else 0\n        end_chunk_index = int(tensor_cumnrows.searchsorted(offset + split) - 1)\n        if start_chunk_index == end_chunk_index:\n            t = tensor.chunks[start_chunk_index]\n            slice_op = TensorSlice((slice(offset - tensor_cumnrows[start_chunk_index],\n                                          split + offset - tensor_cumnrows[end_chunk_index]),\n                                    slice(None)), dtype=t.dtype)\n            out_groups.append([slice_op.new_chunk([t], shape=(split, t.shape[1]),\n                                                  index=(len(cur_chunks), 0),\n                                                  order=t.order)])\n        else:\n            chunks = []\n            start_chunk = tensor.chunks[start_chunk_index]\n            start_slice = int(offset - tensor_cumnrows[start_chunk_index])\n            slice_op = TensorSlice((slice(start_slice, None),\n                                    slice(None)), dtype=start_chunk.dtype)\n            chunks.append(slice_op.new_chunk([start_chunk], shape=(start_chunk.shape[0] - start_slice,\n                                                                   start_chunk.shape[1]),\n                                             index=(0, 0),\n                                             order=start_chunk.order))\n            chunks.extend(tensor.chunks[start_chunk_index + 1: end_chunk_index])\n            end_chunk = tensor.chunks[end_chunk_index]\n            end_slice = int(split + offset - tensor_cumnrows[end_chunk_index])\n            slice_op_end = TensorSlice((slice(None, end_slice),\n                                        slice(None)), dtype=start_chunk.dtype)\n            chunks.append(slice_op_end.new_chunk([end_chunk], shape=(end_slice, end_chunk.shape[1]),\n                                                 index=(end_chunk_index - start_chunk_index, 0),\n                                                 order=end_chunk.order))\n            out_groups.append(chunks)\n        offset += split\n    return out_groups\n", "docstring": "TODO(hks): Provide a unify rechunk logic with mmap."}
{"repo": "mars-master/mars/learn/semi_supervised/_label_propagation.py", "original_string": "    def predict_proba(self, X, session=None, run_kwargs=None):\n        \"\"\"Predict probability for each possible outcome.\n        Compute the probability estimates for each single sample in X\n        and each possible outcome seen during training (categorical\n        distribution).\n        Parameters\n        ----------\n        X : array_like, shape = [n_samples, n_features]\n        Returns\n        -------\n        probabilities : Tensor, shape = [n_samples, n_classes]\n            Normalized probability distributions across\n            class labels\n        \"\"\"\n        check_is_fitted(self, 'X_')\n        X_2d = check_array(X, accept_sparse=True)\n        weight_matrices = self._get_kernel(self.X_, X_2d)\n        if self.kernel == 'knn':\n            probabilities = mt.array([\n                mt.sum(self.label_distributions_[weight_matrix], axis=0)\n                for weight_matrix in weight_matrices])\n        else:\n            weight_matrices = weight_matrices.T\n            probabilities = mt.dot(weight_matrices, self.label_distributions_)\n        normalizer = mt.atleast_2d(mt.sum(probabilities, axis=1)).T\n        probabilities /= normalizer\n        probabilities.execute(session=session, **(run_kwargs or dict()))\n        return probabilities\n", "docstring": "Predict probability for each possible outcome."}
{"repo": "mars-master/mars/learn/semi_supervised/tests/test_label_propagation.py", "original_string": "def test_convergence_warning(setup):\n    # This is a non-regression test for #5774\n    X = np.array([[1., 0.], [0., 1.], [1., 2.5]])\n    y = np.array([0, 1, -1])\n    mdl = LabelPropagation(kernel='rbf', max_iter=1)\n    assert_warns(ConvergenceWarning, mdl.fit, X, y)\n    assert mdl.n_iter_ == mdl.max_iter\n    mdl = LabelPropagation(kernel='rbf', max_iter=500)\n    assert_no_warnings(mdl.fit, X, y)\n", "docstring": "This is a non-regression test for #5774"}
{"repo": "mars-master/mars/learn/contrib/statsmodels/train.py", "original_string": "    def _execute_combine(cls, ctx, op: \"StatsModelsTrain\"):\n        # code from statsmodels.base.distributed_estimation::DistributedModel.fit\n        results_list = [pickle.loads(ctx[inp.key]) for inp in op.inputs]  # nosec\n        params = op.join_method(results_list, **op.join_kwds)\n        res_mod = op.model_class([0], [0], **op.init_kwds)\n        result = op.results_class(res_mod, params, **op.results_kwds)\n        ctx[op.outputs[0].key] = pickle.dumps(result)\n", "docstring": "code from statsmodels.base.distributed_estimation::DistributedModel.fit"}
{"repo": "mars-master/mars/learn/contrib/xgboost/tracker.py", "original_string": "    def accept_slaves(self, nslave):\n        # set of nodes that finishes the job\n        shutdown = {}\n        # set of nodes that is waiting for connections\n        wait_conn = {}\n        # maps job id to rank\n        job_map = {}\n        # list of workers that is pending to be assigned rank\n        pending = []\n        # lazy initialize tree_map\n        tree_map = None\n        while len(shutdown) != nslave:\n            fd, s_addr = self.sock.accept()\n            s = SlaveEntry(fd, s_addr)\n            if s.cmd == 'print':\n                msg = s.sock.recvstr()\n                logging.info(msg.strip())\n                continue\n            if s.cmd == 'shutdown':\n                assert s.rank >= 0 and s.rank not in shutdown\n                assert s.rank not in wait_conn\n                shutdown[s.rank] = s\n                logging.debug('Recieve %s signal from %d', s.cmd, s.rank)\n                continue\n            assert s.cmd == 'start' or s.cmd == 'recover'\n            # lazily initialize the slaves\n            if tree_map is None:\n                assert s.cmd == 'start'\n                if s.world_size > 0:\n                    nslave = s.world_size\n                tree_map, parent_map, ring_map = self.get_link_map(nslave)\n                # set of nodes that is pending for getting up\n                todo_nodes = list(range(nslave))\n            else:\n                assert s.world_size == -1 or s.world_size == nslave\n            if s.cmd == 'recover':\n                assert s.rank >= 0\n            rank = s.decide_rank(job_map)\n            # batch assignment of ranks\n            if rank == -1:\n                assert todo_nodes\n                pending.append(s)\n                if len(pending) == len(todo_nodes):\n                    pending.sort(key=lambda x: x.host)\n                    for s in pending:\n                        rank = todo_nodes.pop(0)\n                        if s.jobid != 'NULL':\n                            job_map[s.jobid] = rank\n                        s.assign_rank(rank, wait_conn, tree_map, parent_map, ring_map)\n                        if s.wait_accept > 0:\n                            wait_conn[rank] = s\n                        logging.debug('Recieve %s signal from %s; assign rank %d',\n                                      s.cmd, s.host, s.rank)\n                if not todo_nodes:\n                    logging.info('@tracker All of %d nodes getting started', nslave)\n                    self.start_time = time.time()\n            else:\n                s.assign_rank(rank, wait_conn, tree_map, parent_map, ring_map)\n                logging.debug('Recieve %s signal from %d', s.cmd, s.rank)\n                if s.wait_accept > 0:\n                    wait_conn[rank] = s\n        logging.info('@tracker All nodes finishes job')\n        self.end_time = time.time()\n        logging.info('@tracker %s secs between node start and job finish',\n                     str(self.end_time - self.start_time))\n", "docstring": "set of nodes that finishes the job"}
{"repo": "mars-master/mars/learn/contrib/xgboost/tracker.py", "original_string": "        def run():\n            self.accept_slaves(nslave)\n", "docstring": "self.accept_slaves(nslave)"}
{"repo": "mars-master/mars/learn/contrib/xgboost/train.py", "original_string": "    def _get_dmatrix_chunks_workers(ctx, dmatrix):\n        # dmatrix_chunk.inputs is concat, and concat's input is the coallocated chunks\n        metas = ctx.get_chunks_meta(\n            [c.inputs[0].inputs[0].key for c in dmatrix.chunks], fields=['bands'])\n        return [m['bands'][0][0] for m in metas]\n", "docstring": "dmatrix_chunk.inputs is concat, and concat's input is the coallocated chunks"}
{"repo": "mars-master/mars/learn/contrib/joblib/backend.py", "original_string": "    def apply_async(self, func, callback=None):\n        # todo allow execute f() in remote end to reduce data copy latency\n        def f():\n            spawned = []\n            for func_obj, args, kwargs in func.items:\n                spawned.append(remote.spawn(func_obj, args=args, kwargs=kwargs))\n            ret = remote.ExecutableTuple(spawned) \\\n                .execute(session=self.session) \\\n                .fetch(self.session)\n            callback(ret)\n            return ret\n        future = self.executor.submit(f)\n        future.get = future.result\n        return future\n", "docstring": "todo allow execute f() in remote end to reduce data copy latency"}
{"repo": "mars-master/mars/learn/contrib/lightgbm/_train.py", "original_string": "    def _get_data_chunks_workers(ctx, data):\n        # data_chunk.inputs is concat, and concat's input is the co-allocated chunks\n        metas = ctx.get_chunks_meta([c.key for c in data.chunks], fields=['bands'])\n        return [m['bands'][0][0] for m in metas]\n", "docstring": "data_chunk.inputs is concat, and concat's input is the co-allocated chunks"}
{"repo": "mars-master/mars/learn/decomposition/_base.py", "original_string": "    def get_covariance(self, session=None):\n        \"\"\"Compute data covariance with the generative model.\n        ``cov = components_.T * S**2 * components_ + sigma2 * eye(n_features)``\n        where S**2 contains the explained variances, and sigma2 contains the\n        noise variances.\n        Returns\n        -------\n        cov : Tensor, shape=(n_features, n_features)\n            Estimated covariance of data.\n        \"\"\"\n        components_ = self.components_\n        exp_var = self.explained_variance_\n        if self.whiten:\n            components_ = components_ * mt.sqrt(exp_var[:, mt.newaxis])\n        exp_var_diff = mt.maximum(exp_var - self.noise_variance_, 0.)\n        cov = mt.dot(components_.T * exp_var_diff, components_)\n        cov.flat[::len(cov) + 1] += self.noise_variance_  # modify diag inplace\n        cov.execute(session=session)\n        return cov\n", "docstring": "Compute data covariance with the generative model."}
{"repo": "mars-master/mars/learn/decomposition/_base.py", "original_string": "    def fit(X, y=None, session=None, run_kwargs=None):\n        \"\"\"Placeholder for fit. Subclasses should implement this method!\n        Fit the model with X.\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            Training data, where n_samples is the number of samples and\n            n_features is the number of features.\n        Returns\n        -------\n        self : object\n            Returns the instance itself.\n        \"\"\"\n", "docstring": "Placeholder for fit. Subclasses should implement this method!"}
{"repo": "mars-master/mars/learn/decomposition/_pca.py", "original_string": "def _assess_dimension(spectrum, rank, n_samples):\n    \"\"\"Compute the log-likelihood of a rank ``rank`` dataset.\n    The dataset is assumed to be embedded in gaussian noise of shape(n,\n    dimf) having spectrum ``spectrum``.\n    Parameters\n    ----------\n    spectrum : array of shape (n_features)\n        Data spectrum.\n    rank : int\n        Tested rank value. It should be strictly lower than n_features,\n        otherwise the method isn't specified (division by zero in equation\n        (31) from the paper).\n    n_samples : int\n        Number of samples.\n    Returns\n    -------\n    ll : float,\n        The log-likelihood\n    Notes\n    -----\n    This implements the method of `Thomas P. Minka:\n    Automatic Choice of Dimensionality for PCA. NIPS 2000: 598-604`\n    \"\"\"\n    xp = get_array_module(spectrum, nosparse=True)\n    n_features = spectrum.shape[0]\n    if not 1 <= rank < n_features:  # pragma: no cover\n        raise ValueError(\"the tested rank should be in [1, n_features - 1]\")\n    eps = 1e-15\n    if spectrum[rank - 1] < eps:  # pragma: no cover\n        # When the tested rank is associated with a small eigenvalue, there's\n        # no point in computing the log-likelihood: it's going to be very\n        # small and won't be the max anyway. Also, it can lead to numerical\n        # issues below when computing pa, in particular in log((spectrum[i] -\n        # spectrum[j]) because this will take the log of something very small.\n        return -np.inf\n    pu = -rank * log(2.)\n    for i in range(1, rank + 1):\n        pu += (gammaln((n_features - i + 1) / 2.) -\n               log(np.pi) * (n_features - i + 1) / 2.)\n    pl = xp.sum(xp.log(spectrum[:rank]))\n    pl = -pl * n_samples / 2.\n    v = max(eps, xp.sum(spectrum[rank:]) / (n_features - rank))\n    pv = -xp.log(v) * n_samples * (n_features - rank) / 2.\n    m = n_features * rank - rank * (rank + 1.) / 2.\n    pp = log(2. * np.pi) * (m + rank) / 2.\n    pa = 0.\n    spectrum_ = spectrum.copy()\n    spectrum_[rank:n_features] = v\n    for i in range(rank):\n        for j in range(i + 1, len(spectrum)):\n            pa += log((spectrum[i] - spectrum[j]) *\n                      (1. / spectrum_[j] - 1. / spectrum_[i])) + log(n_samples)\n    ll = pu + pl + pv + pp - pa / 2. - rank * log(n_samples) / 2.\n    return ll\n", "docstring": "Compute the log-likelihood of a rank ``rank`` dataset."}
{"repo": "mars-master/mars/learn/decomposition/_pca.py", "original_string": "    def fit_transform(self, X, y=None, session=None):\n        \"\"\"Fit the model with X and apply the dimensionality reduction on X.\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            Training data, where n_samples is the number of samples\n            and n_features is the number of features.\n        y : Ignored\n        Returns\n        -------\n        X_new : array-like, shape (n_samples, n_components)\n        \"\"\"\n        U, S, _ = self._fit(X, session=session, run=False)\n        U = U[:, :self.n_components_]\n        if self.whiten:\n            # X_new = X * V / S * sqrt(n_samples) = U * sqrt(n_samples)\n            U *= sqrt(X.shape[0] - 1)\n        else:\n            # X_new = X * V = U * S * V^T * V = U * S\n            U *= S[:self.n_components_]\n        self._run([U], session=session)\n        return U\n", "docstring": "Fit the model with X and apply the dimensionality reduction on X."}
{"repo": "mars-master/mars/learn/decomposition/_pca.py", "original_string": "    def _fit(self, X, session=None, run=True, run_kwargs=None):\n        \"\"\"Dispatch to the right submethod depending on the chosen solver.\"\"\"\n        # Raise an error for sparse input.\n        # This is more informative than the generic one raised by check_array.\n        if (hasattr(X, 'issparse') and X.issparse()) or issparse(X):\n            raise TypeError('PCA does not support sparse input. See '\n                            'TruncatedSVD for a possible alternative.')\n        X = check_array(X, dtype=[mt.float64, mt.float32], ensure_2d=True,\n                        copy=self.copy)\n        # Handle n_components==None\n        if self.n_components is None:\n            if self.svd_solver != 'arpack':\n                n_components = min(X.shape)\n            else:\n                n_components = min(X.shape) - 1\n        else:\n            n_components = self.n_components\n        # Handle svd_solver\n        self._fit_svd_solver = self.svd_solver\n        if self._fit_svd_solver == 'auto':\n            # Small problem or n_components == 'mle', just call full PCA\n            if max(X.shape) <= 500 or n_components == 'mle':\n                self._fit_svd_solver = 'full'\n            elif n_components >= 1 and n_components < .8 * min(X.shape):\n                self._fit_svd_solver = 'randomized'\n            # This is also the case of n_components in (0,1)\n            else:\n                self._fit_svd_solver = 'full'\n        # Call different fits for either full or truncated SVD\n        if self._fit_svd_solver == 'full':\n            ret = self._fit_full(X, n_components, session=session)\n        elif self._fit_svd_solver in ['arpack', 'randomized']:\n            ret = self._fit_truncated(X, n_components, self._fit_svd_solver)\n        else:\n            raise ValueError(f\"Unrecognized svd_solver='{self._fit_svd_solver}'\")\n        if run:\n            self._run(ret, session=session, run_kwargs=run_kwargs)\n        return ret\n", "docstring": "Dispatch to the right submethod depending on the chosen solver.\n"}
{"repo": "mars-master/mars/learn/decomposition/_pca.py", "original_string": "    def score_samples(self, X, session=None):\n        \"\"\"Return the log-likelihood of each sample.\n        See. \"Pattern Recognition and Machine Learning\"\n        by C. Bishop, 12.2.1 p. 574\n        or http://www.miketipping.com/papers/met-mppca.pdf\n        Parameters\n        ----------\n        X : tensor, shape(n_samples, n_features)\n            The data.\n        Returns\n        -------\n        ll : tensor, shape (n_samples,)\n            Log-likelihood of each sample under the current model\n        \"\"\"\n        log_like = self._score_samples(X, session=session)\n        log_like.execute(session=session)\n        return log_like\n", "docstring": "Return the log-likelihood of each sample."}
{"repo": "mars-master/mars/learn/decomposition/_truncated_svd.py", "original_string": "    def fit_transform(self, X, y=None, session=None):\n        \"\"\"Fit LSI model to X and perform dimensionality reduction on X.\n        Parameters\n        ----------\n        X : {array-like, sparse matrix}, shape (n_samples, n_features)\n            Training data.\n        session : session to run\n        y : Ignored\n        Returns\n        -------\n        X_new : array, shape (n_samples, n_components)\n            Reduced version of X. This will always be a dense array.\n        \"\"\"\n        X = check_array(X, accept_sparse=['csr', 'csc'],\n                        ensure_min_features=2)\n        random_state = check_random_state(self.random_state)\n        if self.algorithm == \"arpack\":\n            # U, Sigma, VT = svds(X, k=self.n_components, tol=self.tol)\n            # # svds doesn't abide by scipy.linalg.svd/randomized_svd\n            # # conventions, so reverse its outputs.\n            # Sigma = Sigma[::-1]\n            # U, VT = svd_flip(U[:, ::-1], VT[::-1])\n            raise NotImplementedError('Does not support arpack for truncated_svd')\n        elif self.algorithm == \"randomized\":\n            k = self.n_components\n            n_features = X.shape[1]\n            if k >= n_features:\n                raise ValueError(\"n_components must be < n_features; \"\n                                 f\"got {k} >= {n_features}\")\n            U, Sigma, VT = randomized_svd(X, self.n_components,\n                                          n_iter=self.n_iter,\n                                          random_state=random_state)\n        else:\n            raise ValueError(f\"unknown algorithm {self.algorithm!r}\")\n        self.components_ = VT\n        # Calculate explained variance & explained variance ratio\n        X_transformed = U * Sigma\n        self.explained_variance_ = exp_var = np.var(X_transformed, axis=0)\n        full_var = mt.var(X, axis=0).sum()\n        self.explained_variance_ratio_ = exp_var / full_var\n        self.singular_values_ = Sigma  # Store the singular values.\n        to_run_tensors = [X_transformed, self.components_, self.explained_variance_,\n                          self.explained_variance_ratio_, self.singular_values_]\n        ExecutableTuple(to_run_tensors).execute(session=session)\n        return X_transformed\n", "docstring": "Fit LSI model to X and perform dimensionality reduction on X."}
{"repo": "mars-master/mars/learn/decomposition/tests/test_pca.py", "original_string": "def test_whitening(setup):\n    # Check that PCA output has unit-variance\n    rng = np.random.RandomState(0)\n    n_samples = 100\n    n_features = 80\n    n_components = 30\n    rank = 50\n    # some low rank data with correlated features\n    X = mt.dot(rng.randn(n_samples, rank),\n               mt.dot(mt.diag(mt.linspace(10.0, 1.0, rank)),\n                      rng.randn(rank, n_features)))\n    # the component-wise variance of the first 50 features is 3 times the\n    # mean component-wise variance of the remaining 30 features\n    X[:, :50] *= 3\n    assert X.shape == (n_samples, n_features)\n    # the component-wise variance is thus highly varying:\n    assert X.std(axis=0).std().to_numpy() > 43.8\n    for solver, copy in product(solver_list, (True, False)):\n        # whiten the data while projecting to the lower dim subspace\n        X_ = X.copy()  # make sure we keep an original across iterations.\n        pca = PCA(n_components=n_components, whiten=True, copy=copy,\n                  svd_solver=solver, random_state=0, iterated_power=7)\n        # test fit_transform\n        X_whitened = pca.fit_transform(X_.copy())\n        assert X_whitened.shape == (n_samples, n_components)\n        X_whitened2 = pca.transform(X_)\n        assert_array_almost_equal(X_whitened.fetch(), X_whitened2.fetch())\n        assert_almost_equal(X_whitened.std(ddof=1, axis=0).to_numpy(),\n                            np.ones(n_components),\n                            decimal=6)\n        assert_almost_equal(X_whitened.mean(axis=0).to_numpy(), np.zeros(n_components))\n        X_ = X.copy()\n        pca = PCA(n_components=n_components, whiten=False, copy=copy,\n                  svd_solver=solver).fit(X_)\n        X_unwhitened = pca.transform(X_)\n        assert X_unwhitened.shape == (n_samples, n_components)\n        # in that case the output components still have varying variances\n        assert_almost_equal(X_unwhitened.std(axis=0).std().to_numpy(), 74.1, 1)\n        # we always center, so no test for non-centering.\n", "docstring": "Check that PCA output has unit-variance"}
{"repo": "mars-master/mars/learn/decomposition/tests/test_pca.py", "original_string": "def test_singular_values(setup):\n    # Check that the PCA output has the correct singular values\n    rng = np.random.RandomState(0)\n    n_samples = 100\n    n_features = 80\n    X = mt.tensor(rng.randn(n_samples, n_features))\n    pca = PCA(n_components=2, svd_solver='full',\n              random_state=rng).fit(X)\n    rpca = PCA(n_components=2, svd_solver='randomized',\n               random_state=rng).fit(X)\n    assert_array_almost_equal(pca.singular_values_.fetch(),\n                              rpca.singular_values_.fetch(), 1)\n    # Compare to the Frobenius norm\n    X_pca = pca.transform(X)\n    X_rpca = rpca.transform(X)\n    assert_array_almost_equal(mt.sum(pca.singular_values_**2.0).to_numpy(),\n                              (mt.linalg.norm(X_pca, \"fro\")**2.0).to_numpy(), 12)\n    assert_array_almost_equal(mt.sum(rpca.singular_values_**2.0).to_numpy(),\n                              (mt.linalg.norm(X_rpca, \"fro\")**2.0).to_numpy(), 0)\n    # Compare to the 2-norms of the score vectors\n    assert_array_almost_equal(pca.singular_values_.fetch(),\n                              mt.sqrt(mt.sum(X_pca**2.0, axis=0)).to_numpy(), 12)\n    assert_array_almost_equal(rpca.singular_values_.fetch(),\n                              mt.sqrt(mt.sum(X_rpca**2.0, axis=0)).to_numpy(), 2)\n    # Set the singular values and see what we get back\n    rng = np.random.RandomState(0)\n    n_samples = 100\n    n_features = 110\n    X = mt.tensor(rng.randn(n_samples, n_features))\n    pca = PCA(n_components=3, svd_solver='full', random_state=rng)\n    rpca = PCA(n_components=3, svd_solver='randomized', random_state=rng)\n    X_pca = pca.fit_transform(X)\n    X_pca /= mt.sqrt(mt.sum(X_pca**2.0, axis=0))\n    X_pca[:, 0] *= 3.142\n    X_pca[:, 1] *= 2.718\n    X_hat = mt.dot(X_pca, pca.components_)\n    pca.fit(X_hat)\n    rpca.fit(X_hat)\n    assert_array_almost_equal(pca.singular_values_.fetch(), [3.142, 2.718, 1.0], 14)\n    assert_array_almost_equal(rpca.singular_values_.fetch(), [3.142, 2.718, 1.0], 14)\n", "docstring": "Check that the PCA output has the correct singular values"}
{"repo": "mars-master/mars/learn/decomposition/tests/test_pca.py", "original_string": "def test_pca_inverse(setup):\n    # Test that the projection of data can be inverted\n    rng = np.random.RandomState(0)\n    n, p = 50, 3\n    X = mt.tensor(rng.randn(n, p))  # spherical data\n    X[:, 1] *= .00001  # make middle component relatively small\n    X += [5, 4, 3]  # make a large mean\n    # same check that we can find the original data from the transformed\n    # signal (since the data is almost of rank n_components)\n    pca = PCA(n_components=2, svd_solver='full').fit(X)\n    Y = pca.transform(X)\n    Y_inverse = pca.inverse_transform(Y)\n    assert_almost_equal(X.to_numpy(), Y_inverse.to_numpy(), decimal=3)\n    # same as above with whitening (approximate reconstruction)\n    for solver in solver_list:\n        pca = PCA(n_components=2, whiten=True, svd_solver=solver)\n        pca.fit(X)\n        Y = pca.transform(X)\n        Y_inverse = pca.inverse_transform(Y)\n        assert_almost_equal(X.to_numpy(), Y_inverse.to_numpy(), decimal=3)\n", "docstring": "Test that the projection of data can be inverted"}
{"repo": "mars-master/mars/learn/decomposition/tests/test_pca.py", "original_string": "def test_randomized_pca_check_list(setup):\n    # Test that the projection by randomized PCA on list data is correct\n    X = mt.tensor([[1.0, 0.0], [0.0, 1.0]])\n    X_transformed = PCA(n_components=1, svd_solver='randomized',\n                        random_state=0).fit(X).transform(X)\n    assert X_transformed.shape == (2, 1)\n    assert_almost_equal(X_transformed.mean().to_numpy(), 0.00, 2)\n    assert_almost_equal(X_transformed.std().to_numpy(), 0.71, 2)\n", "docstring": "Test that the projection by randomized PCA on list data is correct"}
{"repo": "mars-master/mars/learn/decomposition/tests/test_pca.py", "original_string": "def test_n_components_mle(setup):\n    # Ensure that n_components == 'mle' doesn't raise error for auto/full\n    # svd_solver and raises error for arpack/randomized svd_solver\n    rng = np.random.RandomState(0)\n    n_samples = 600\n    n_features = 10\n    X = mt.tensor(rng.randn(n_samples, n_features))\n    n_components_dict = {}\n    for solver in solver_list:\n        pca = PCA(n_components='mle', svd_solver=solver)\n        if solver in ['auto', 'full']:\n            pca.fit(X)\n            n_components_dict[solver] = pca.n_components_\n        else:  # arpack/randomized solver\n            error_message = (\"n_components='mle' cannot be a string with \"\n                             f\"svd_solver='{solver}'\")\n            assert_raise_message(ValueError, error_message, pca.fit, X)\n    assert n_components_dict['auto'] == n_components_dict['full']\n", "docstring": "Ensure that n_components == 'mle' doesn't raise error for auto/full"}
{"repo": "mars-master/mars/learn/decomposition/tests/test_pca.py", "original_string": "def test_infer_dim_1(setup):\n    # TODO: explain what this is testing\n    # Or at least use explicit variable names...\n    n, p = 1000, 5\n    rng = np.random.RandomState(0)\n    X = (mt.tensor(rng.randn(n, p)) * .1 + mt.tensor(rng.randn(n, 1)) * mt.array([3, 4, 5, 1, 2]) +\n         mt.array([1, 0, 7, 4, 6]))\n    pca = PCA(n_components=p, svd_solver='full')\n    pca.fit(X)\n    spect = pca.explained_variance_.to_numpy()\n    ll = np.array([_assess_dimension(spect, k, n) for k in range(1, p)])\n    assert ll[1] > ll.max() - .01 * n\n", "docstring": "TODO: explain what this is testing"}
{"repo": "mars-master/mars/learn/decomposition/tests/test_pca.py", "original_string": "def test_pca_score(setup):\n    # Test that probabilistic PCA scoring yields a reasonable score\n    n, p = 1000, 3\n    rng = np.random.RandomState(0)\n    X = mt.tensor(rng.randn(n, p) * .1) + mt.array([3, 4, 5])\n    for solver in solver_list:\n        pca = PCA(n_components=2, svd_solver=solver)\n        pca.fit(X)\n        ll1 = pca.score(X)\n        h = -0.5 * mt.log(2 * mt.pi * mt.exp(1) * 0.1 ** 2) * p\n        np.testing.assert_almost_equal((ll1 / h).to_numpy(), 1, 0)\n", "docstring": "Test that probabilistic PCA scoring yields a reasonable score"}
{"repo": "mars-master/mars/learn/decomposition/tests/test_pca.py", "original_string": "def test_pca_score3(setup):\n    # Check that probabilistic PCA selects the right model\n    n, p = 200, 3\n    rng = np.random.RandomState(0)\n    Xl = mt.tensor(rng.randn(n, p) + rng.randn(n, 1) * np.array([3, 4, 5]) +\n                   np.array([1, 0, 7]))\n    Xt = mt.tensor(rng.randn(n, p) + rng.randn(n, 1) * np.array([3, 4, 5]) +\n                   np.array([1, 0, 7]))\n    ll = mt.zeros(p)\n    for k in range(p):\n        pca = PCA(n_components=k, svd_solver='full')\n        pca.fit(Xl)\n        ll[k] = pca.score(Xt)\n    assert ll.argmax().to_numpy() == 1\n", "docstring": "Check that probabilistic PCA selects the right model"}
{"repo": "mars-master/mars/learn/decomposition/tests/test_pca.py", "original_string": "def test_pca_zero_noise_variance_edge_cases(setup):\n    # ensure that noise_variance_ is 0 in edge cases\n    # when n_components == min(n_samples, n_features)\n    n, p = 100, 3\n    rng = np.random.RandomState(0)\n    X = mt.tensor(rng.randn(n, p) * .1) + mt.array([3, 4, 5])\n    # arpack raises ValueError for n_components == min(n_samples,\n    # n_features)\n    svd_solvers = ['full', 'randomized']\n    for svd_solver in svd_solvers:\n        pca = PCA(svd_solver=svd_solver, n_components=p)\n        pca.fit(X)\n        assert pca.noise_variance_ == 0\n        pca.fit(X.T)\n        assert pca.noise_variance_ == 0\n", "docstring": "ensure that noise_variance_ is 0 in edge cases"}
{"repo": "mars-master/mars/learn/decomposition/tests/test_pca.py", "original_string": "def _check_pca_int_dtype_upcast_to_double(svd_solver):\n    # Ensure that all int types will be upcast to float64\n    X_i64 = mt.tensor(np.random.RandomState(0).randint(0, 1000, (1000, 4)))\n    X_i64 = X_i64.astype(np.int64, copy=False)\n    X_i32 = X_i64.astype(np.int32, copy=False)\n    pca_64 = PCA(n_components=3, svd_solver=svd_solver,\n                 random_state=0).fit(X_i64)\n    pca_32 = PCA(n_components=3, svd_solver=svd_solver,\n                 random_state=0).fit(X_i32)\n    assert pca_64.components_.dtype == np.float64\n    assert pca_32.components_.dtype == np.float64\n    assert pca_64.transform(X_i64).dtype == np.float64\n    assert pca_32.transform(X_i32).dtype == np.float64\n    assert_array_almost_equal(pca_64.components_.to_numpy(), pca_32.components_.to_numpy(),\n                              decimal=5)\n", "docstring": "Ensure that all int types will be upcast to float64"}
{"repo": "mars-master/mars/learn/model_selection/tests/test_split.py", "original_string": "def test_train_test_split_sparse(setup):\n    # check that train_test_split converts scipy sparse matrices\n    # to csr, as stated in the documentation\n    X = np.arange(100).reshape((10, 10))\n    sparse_types = [sps.csr_matrix, sps.csc_matrix, sps.coo_matrix]\n    for InputFeatureType in sparse_types:\n        X_s = InputFeatureType(X)\n        for x in (X_s, mt.tensor(X_s, chunk_size=(2, 5))):\n            X_train, X_test = train_test_split(x)\n            assert isinstance(X_train.fetch(), SparseNDArray)\n            assert isinstance(X_test.fetch(), SparseNDArray)\n", "docstring": "check that train_test_split converts scipy sparse matrices"}
{"repo": "mars-master/mars/learn/metrics/_ranking.py", "original_string": "def auc(x, y, session=None, run_kwargs=None):\n    \"\"\"Compute Area Under the Curve (AUC) using the trapezoidal rule\n    This is a general function, given points on a curve.  For computing the\n    area under the ROC-curve, see :func:`roc_auc_score`.  For an alternative\n    way to summarize a precision-recall curve, see\n    :func:`average_precision_score`.\n    Parameters\n    ----------\n    x : tensor, shape = [n]\n        x coordinates. These must be either monotonic increasing or monotonic\n        decreasing.\n    y : tensor, shape = [n]\n        y coordinates.\n    Returns\n    -------\n    auc : tensor, with float value\n    Examples\n    --------\n    >>> import mars.tensor as mt\n    >>> from mars.learn import metrics\n    >>> y = mt.array([1, 1, 2, 2])\n    >>> pred = mt.array([0.1, 0.4, 0.35, 0.8])\n    >>> fpr, tpr, thresholds = metrics.roc_curve(y, pred, pos_label=2)\n    >>> metrics.auc(fpr, tpr)\n    0.75\n    See also\n    --------\n    roc_auc_score : Compute the area under the ROC curve\n    average_precision_score : Compute average precision from prediction scores\n    precision_recall_curve :\n        Compute precision-recall pairs for different probability thresholds\n    \"\"\"\n    check_consistent_length(x, y)\n    x = column_or_1d(x)\n    y = column_or_1d(y)\n    if x.shape[0] < 2:\n        raise ValueError('At least 2 points are needed to compute'\n                         f' area under curve, but x.shape = {x.shape}')\n    direction = 1\n    dx = mt.diff(x)\n    any_dx_lt_0 = mt.any(dx < 0)\n    all_dx_le_0 = mt.all(dx <= 0)\n    mt.ExecutableTuple([x, any_dx_lt_0, all_dx_le_0]).execute(\n        session=session, **(run_kwargs or dict()))\n    if any_dx_lt_0.fetch(session=session):\n        if all_dx_le_0.fetch(session=session):\n            direction = -1\n        else:\n            x_data = x.fetch(session=session)\n            raise ValueError(f\"x is neither increasing nor decreasing : {x_data}.\")\n    area = direction * mt.trapz(y, x)\n    return area.execute(session=session, **(run_kwargs or dict()))\n", "docstring": "Compute Area Under the Curve (AUC) using the trapezoidal rule"}
{"repo": "mars-master/mars/learn/metrics/_classification.py", "original_string": "    def tile(cls, op):\n        # make sure type_true executed first\n        chunks = [op.type_true.chunks[0]]\n        yield chunks\n        ctx = get_context()\n        type_true = ctx.get_chunks_result([chunks[0].key])[0]\n        y_true, y_pred = op.y_true, op.y_pred\n        if type_true.item().startswith('multilabel'):\n            differing_labels = mt.count_nonzero(y_true - y_pred, axis=1)\n            score = mt.equal(differing_labels, 0)\n        else:\n            score = mt.equal(y_true, y_pred)\n        result = _weighted_sum(score, op.sample_weight, op.normalize)\n        return [(yield from recursive_tile(result))]\n", "docstring": "make sure type_true executed first"}
{"repo": "mars-master/mars/learn/metrics/pairwise/core.py", "original_string": "    def check_pairwise_arrays(X, Y, precomputed=False, dtype=None):\n        X, Y, dtype_float = PairwiseDistances._return_float_dtype(X, Y)\n        estimator = 'check_pairwise_arrays'\n        if dtype is None:\n            dtype = dtype_float\n        if Y is X or Y is None:\n            X = Y = check_array(X, accept_sparse=True, dtype=dtype,\n                                estimator=estimator)\n        else:\n            X = check_array(X, accept_sparse=True, dtype=dtype,\n                            estimator=estimator)\n            Y = check_array(Y, accept_sparse=True, dtype=dtype,\n                            estimator=estimator)\n        if precomputed:\n            if X.shape[1] != Y.shape[0]:\n                raise ValueError(\"Precomputed metric requires shape \"\n                                 f\"(n_queries, n_indexed). Got ({X.shape[0]}, {X.shape[1]}) \"\n                                 f\"for {Y.shape[0]} indexed.\")\n        elif X.shape[1] != Y.shape[1]:\n            raise ValueError(\"Incompatible dimension for X and Y matrices: \"\n                             f\"X.shape[1] == {X.shape[1]} while Y.shape[1] == {Y.shape[1]}\")\n        return X, Y\n", "docstring": "X, Y, dtype_float = PairwiseDistances._return_float_dtype(X, Y)"}
{"repo": "mars-master/mars/learn/metrics/pairwise/euclidean.py", "original_string": "    def __call__(self, X, Y=None, Y_norm_squared=None, X_norm_squared=None):\n        # If norms are passed as float32, they are unused. If arrays are passed as\n        # float32, norms needs to be recomputed on upcast chunks.\n        # TODO: use a float64 accumulator in row_norms to avoid the latter.\n        if X_norm_squared is not None:\n            XX = check_array(X_norm_squared)\n            if XX.shape == (1, X.shape[0]):\n                XX = XX.T\n            elif XX.shape != (X.shape[0], 1):\n                raise ValueError(\n                    \"Incompatible dimensions for X and X_norm_squared\")\n            if XX.dtype == np.float32:\n                XX = self._x_norm_squared = None\n        else:\n            XX = None\n        if X is Y and XX is not None:\n            # shortcut in the common case euclidean_distances(X, X)\n            YY = XX.T\n        elif Y_norm_squared is not None:\n            YY = mt.atleast_2d(Y_norm_squared)\n            if YY.shape != (1, Y.shape[0]):\n                raise ValueError(\n                    \"Incompatible dimensions for Y and Y_norm_squared\")\n            if YY.dtype == np.float32:\n                YY = self._y_norm_squared = None\n        else:\n            YY = None\n        inputs = [X, Y]\n        if XX is not None:\n            inputs.append(XX)\n        if YY is not None:\n            inputs.append(YY)\n        return self.new_tensor(inputs, shape=(X.shape[0], Y.shape[0]),\n                               order=TensorOrder.C_ORDER)\n", "docstring": "If norms are passed as float32, they are unused. If arrays are passed as"}
{"repo": "mars-master/mars/learn/metrics/pairwise/pairwise_distances_topk.py", "original_string": "def _check_chunk_size(reduced, chunk_size):  # pragma: no cover\n    \"\"\"Checks chunk is a sequence of expected size or a tuple of same\n    \"\"\"\n    if reduced is None:\n        return\n    is_tuple = isinstance(reduced, tuple)\n    if not is_tuple:\n        reduced = (reduced,)\n    if any(isinstance(r, tuple) or not hasattr(r, '__iter__')\n           for r in reduced):\n        raise TypeError('reduce_func returned %r. '\n                        'Expected sequence(s) of length %d.' %\n                        (reduced if is_tuple else reduced[0], chunk_size))\n    if any(_num_samples(r) != chunk_size for r in reduced):\n        actual_size = tuple(_num_samples(r) for r in reduced)\n        raise ValueError('reduce_func returned object of length %s. '\n                         'Expected same length as input: %d.' %\n                         (actual_size if is_tuple else actual_size[0],\n                          chunk_size))\n", "docstring": "Checks chunk is a sequence of expected size or a tuple of same"}
{"repo": "mars-master/mars/learn/metrics/pairwise/pairwise_distances_topk.py", "original_string": "    def _topk_reduce_func(cls, dist, start, topk, xp, metric):\n        \"\"\"Reduce a chunk of distances to topk\n        Parameters\n        ----------\n        dist : array of shape (n_samples_chunk, n_samples)\n        start : int\n            The index in X which the first row of dist corresponds to.\n        topk : int\n        Returns\n        -------\n        dist : array of shape (n_samples_chunk, n_neighbors)\n        neigh : array of shape (n_samples_chunk, n_neighbors)\n        \"\"\"\n        sample_range = xp.arange(dist.shape[0])[:, None]\n        if topk - 1 >= dist.shape[1]:\n            neigh_ind = xp.repeat(\n                xp.arange(dist.shape[1]).reshape(1, -1), dist.shape[0], axis=0)\n        else:\n            neigh_ind = xp.argpartition(dist, topk - 1, axis=1)\n            neigh_ind = neigh_ind[:, :topk]\n        # argpartition doesn't guarantee sorted order, so we sort again\n        neigh_ind = neigh_ind[\n            sample_range, xp.argsort(dist[sample_range, neigh_ind])]\n        return dist[sample_range, neigh_ind], neigh_ind\n", "docstring": "Reduce a chunk of distances to topk"}
{"repo": "mars-master/mars/learn/metrics/pairwise/tests/test_haversine_distances.py", "original_string": "def test_haversine_distances_op():\n    # shape[1] != 2\n    with pytest.raises(ValueError):\n        haversine_distances(mt.random.rand(10, 3))\n    # shape[1] != 2\n    with pytest.raises(ValueError):\n        haversine_distances(mt.random.rand(10, 2), mt.random.rand(11, 3))\n    # cannot support sparse\n    with pytest.raises(TypeError):\n        haversine_distances(mt.random.randint(10, size=(10, 2), density=0.5))\n", "docstring": "shape[1] != 2"}
{"repo": "mars-master/mars/learn/metrics/tests/test_classification.py", "original_string": "def test__check_targets(setup, type1, y1, type2, y2):\n    # Check that _check_targets correctly merges target types, squeezes\n    # output and fails if input lengths differ.\n    try:\n        expected = EXPECTED[type1, type2]\n    except KeyError:\n        expected = EXPECTED[type2, type1]\n    if expected is None:\n        with pytest.raises(ValueError):\n            _check_targets(y1, y2).execute()\n        if type1 != type2:\n            with pytest.raises(ValueError):\n                _check_targets(y1, y2).execute()\n        else:\n            if type1 not in (BIN, MC, IND):\n                with pytest.raises(ValueError):\n                    _check_targets(y1, y2).execute()\n    else:\n        merged_type, y1out, y2out = \\\n            _check_targets(y1, y2).execute().fetch()\n        assert merged_type == expected\n        if merged_type.startswith('multilabel'):\n            assert isinstance(y1out, SparseNDArray)\n            assert isinstance(y2out, SparseNDArray)\n        else:\n            np.testing.assert_array_equal(y1out, np.squeeze(y1))\n            np.testing.assert_array_equal(y2out, np.squeeze(y2))\n        with pytest.raises(ValueError):\n            _check_targets(y1[:-1], y2).execute()\n", "docstring": "Check that _check_targets correctly merges target types, squeezes"}
{"repo": "mars-master/mars/learn/metrics/tests/test_ranking.py", "original_string": "def test_roc_returns_consistency(setup):\n    # Test whether the returned threshold matches up with tpr\n    # make small toy dataset\n    y_true, _, probas_pred = make_prediction(binary=True)\n    fpr, tpr, thresholds = roc_curve(y_true, probas_pred).fetch()\n    # use the given thresholds to determine the tpr\n    tpr_correct = []\n    for t in thresholds:\n        tp = np.sum((probas_pred >= t) & y_true)\n        p = np.sum(y_true)\n        tpr_correct.append(1.0 * tp / p)\n    # compare tpr and tpr_correct to see if the thresholds' order was correct\n    np.testing.assert_array_almost_equal(tpr, tpr_correct, decimal=2)\n    assert fpr.shape == tpr.shape\n    assert fpr.shape == thresholds.shape\n", "docstring": "Test whether the returned threshold matches up with tpr"}
{"repo": "mars-master/mars/learn/metrics/tests/test_ranking.py", "original_string": "def test_roc_curve_confidence(setup):\n    # roc_curve for confidence scores\n    y_true, _, probas_pred = make_prediction(binary=True)\n    fpr, tpr, thresholds = roc_curve(y_true, probas_pred - 0.5)\n    roc_auc = auc(fpr, tpr).fetch()\n    np.testing.assert_array_almost_equal(roc_auc, 0.90, decimal=2)\n    assert fpr.shape == tpr.shape\n    assert fpr.shape == thresholds.shape\n", "docstring": "roc_curve for confidence scores"}
{"repo": "mars-master/mars/learn/metrics/tests/test_ranking.py", "original_string": "def test_roc_curve_fpr_tpr_increasing(setup):\n    # Ensure that fpr and tpr returned by roc_curve are increasing.\n    # Construct an edge case with float y_score and sample_weight\n    # when some adjacent values of fpr and tpr are actually the same.\n    y_true = [0, 0, 1, 1, 1]\n    y_score = [0.1, 0.7, 0.3, 0.4, 0.5]\n    sample_weight = np.repeat(0.2, 5)\n    fpr, tpr, _ = roc_curve(y_true, y_score, sample_weight=sample_weight)\n    assert ((mt.diff(fpr) < 0).sum() == 0).to_numpy()\n    assert ((mt.diff(tpr) < 0).sum() == 0).to_numpy()\n", "docstring": "Ensure that fpr and tpr returned by roc_curve are increasing."}
{"repo": "mars-master/mars/learn/metrics/tests/test_ranking.py", "original_string": "def test_auc_errors(setup):\n    # Incompatible shapes\n    with pytest.raises(ValueError):\n        auc([0.0, 0.5, 1.0], [0.1, 0.2])\n    # Too few x values\n    with pytest.raises(ValueError):\n        auc([0.0], [0.1])\n    # x is not in order\n    x = [2, 1, 3, 4]\n    y = [5, 6, 7, 8]\n    error_message = f\"x is neither increasing nor decreasing : {np.array(x)}\"\n    with pytest.raises(ValueError, match=re.escape(error_message)):\n        auc(x, y)\n", "docstring": "Incompatible shapes"}
{"repo": "mars-master/mars/learn/preprocessing/_data.py", "original_string": "def _handle_zeros_in_scale(scale, copy=True):\n    \"\"\"Makes sure that whenever scale is zero, we handle it correctly.\n    This happens in most scalers when we have constant features.\n    \"\"\"\n    # if we are fitting on 1D arrays, scale might be a scalar\n    if np.isscalar(scale):  # pragma: no cover\n        if scale == .0:\n            scale = 1.\n        return scale\n    elif hasattr(scale, 'ndim') and scale.ndim == 0:  # pragma: no cover\n        # scalar that is tensor\n        return mt.where(scale == .0, 1., scale)\n    elif isinstance(scale, (np.ndarray, TENSOR_TYPE)):\n        if copy:\n            # New array to avoid side-effects\n            scale = scale.copy()\n        scale[scale == 0.0] = 1.0\n        return scale\n", "docstring": "Makes sure that whenever scale is zero, we handle it correctly."}
{"repo": "mars-master/mars/learn/preprocessing/_data.py", "original_string": "    def fit(self, X, y=None, session=None, run_kwargs=None):\n        \"\"\"Compute the minimum and maximum to be used for later scaling.\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data used to compute the per-feature minimum and maximum\n            used for later scaling along the features axis.\n        y : None\n            Ignored.\n        Returns\n        -------\n        self : object\n            Fitted scaler.\n        \"\"\"\n        # Reset internal state before fitting\n        self._reset()\n        return self.partial_fit(X, y, session=session, run_kwargs=run_kwargs)\n", "docstring": "Compute the minimum and maximum to be used for later scaling."}
{"repo": "mars-master/mars/learn/preprocessing/_data.py", "original_string": "    def transform(self, X, session=None, run_kwargs=None):\n        \"\"\"Scale features of X according to feature_range.\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input data that will be transformed.\n        Returns\n        -------\n        Xt : ndarray of shape (n_samples, n_features)\n            Transformed data.\n        \"\"\"\n        check_is_fitted(self)\n        X = self._validate_data(X, copy=self.copy, dtype=FLOAT_DTYPES,\n                                force_all_finite=\"allow-nan\", reset=False)\n        X *= self.scale_\n        X += self.min_\n        if self.clip:\n            X = mt.clip(X, self.feature_range[0], self.feature_range[1])\n        return X.execute(session=session, **(run_kwargs or dict()))\n", "docstring": "Scale features of X according to feature_range."}
{"repo": "mars-master/mars/learn/preprocessing/normalize.py", "original_string": "    def _need_tile_into_chunks(cls, op):\n        # if true, try to tile into chunks\n        # whose implementation is based on sklearn itself\n        x = op.input\n        if op.gpu:  # pragma: no cover\n            return False\n        if x.issparse() and op.return_norm and op.norm in ('l1', 'l2'):\n            # sklearn cannot handle\n            return False\n        if x.chunk_shape[op.axis] > 1:\n            return False\n        return True\n", "docstring": "if true, try to tile into chunks"}
{"repo": "mars-master/mars/learn/preprocessing/tests/test_data.py", "original_string": "def test_min_max_scaler_partial_fit(setup, chunk_size):\n    # Test if partial_fit run over many batches of size 1 and 50\n    # gives the same results as fit\n    X = X_2d\n    n = X.shape[0]\n    # Test mean at the end of the process\n    scaler_batch = MinMaxScaler().fit(X)\n    scaler_incr = MinMaxScaler()\n    for batch in gen_batches(n_samples, chunk_size):\n        scaler_incr = scaler_incr.partial_fit(X[batch])\n    assert_array_almost_equal(scaler_batch.data_min_,\n                              scaler_incr.data_min_)\n    assert_array_almost_equal(scaler_batch.data_max_,\n                              scaler_incr.data_max_)\n    assert scaler_batch.n_samples_seen_ == scaler_incr.n_samples_seen_\n    assert_array_almost_equal(scaler_batch.data_range_,\n                              scaler_incr.data_range_)\n    assert_array_almost_equal(scaler_batch.scale_, scaler_incr.scale_)\n    assert_array_almost_equal(scaler_batch.min_, scaler_incr.min_)\n    # Test std after 1 step\n    batch0 = slice(0, chunk_size)\n    scaler_batch = MinMaxScaler().fit(X[batch0])\n    scaler_incr = MinMaxScaler().partial_fit(X[batch0])\n    assert_array_almost_equal(scaler_batch.data_min_,\n                              scaler_incr.data_min_)\n    assert_array_almost_equal(scaler_batch.data_max_,\n                              scaler_incr.data_max_)\n    assert scaler_batch.n_samples_seen_ == scaler_incr.n_samples_seen_\n    assert_array_almost_equal(scaler_batch.data_range_,\n                              scaler_incr.data_range_)\n    assert_array_almost_equal(scaler_batch.scale_, scaler_incr.scale_)\n    assert_array_almost_equal(scaler_batch.min_, scaler_incr.min_)\n    # Test std until the end of partial fits, and\n    _ = MinMaxScaler().fit(X)\n    scaler_incr = MinMaxScaler()  # Clean estimator\n    for i, batch in enumerate(gen_batches(n_samples, chunk_size)):\n        scaler_incr = scaler_incr.partial_fit(X[batch])\n        assert_correct_incr(i, batch_start=batch.start,\n                            batch_stop=batch.stop, n=n,\n                            chunk_size=chunk_size,\n                            n_samples_seen=scaler_incr.n_samples_seen_)\n", "docstring": "Test if partial_fit run over many batches of size 1 and 50"}
{"repo": "mars-master/mars/learn/preprocessing/tests/test_data.py", "original_string": "def test_min_max_scaler_zero_variance_features(setup):\n    # Check min max scaler on toy data with zero variance features\n    X = [[0., 1., +0.5],\n         [0., 1., -0.1],\n         [0., 1., +1.1]]\n    X_new = [[+0., 2., 0.5],\n             [-1., 1., 0.0],\n             [+0., 1., 1.5]]\n    # default params\n    scaler = MinMaxScaler()\n    X_trans = scaler.fit_transform(X)\n    X_expected_0_1 = [[0., 0., 0.5],\n                      [0., 0., 0.0],\n                      [0., 0., 1.0]]\n    assert_array_almost_equal(X_trans, X_expected_0_1)\n    X_trans_inv = scaler.inverse_transform(X_trans)\n    assert_array_almost_equal(X, X_trans_inv)\n    X_trans_new = scaler.transform(X_new)\n    X_expected_0_1_new = [[+0., 1., 0.500],\n                          [-1., 0., 0.083],\n                          [+0., 0., 1.333]]\n    assert_array_almost_equal(X_trans_new, X_expected_0_1_new, decimal=2)\n    # not default params\n    scaler = MinMaxScaler(feature_range=(1, 2))\n    X_trans = scaler.fit_transform(X)\n    X_expected_1_2 = [[1., 1., 1.5],\n                      [1., 1., 1.0],\n                      [1., 1., 2.0]]\n    assert_array_almost_equal(X_trans, X_expected_1_2)\n    # function interface\n    X_trans = minmax_scale(X)\n    assert_array_almost_equal(X_trans, X_expected_0_1)\n    X_trans = minmax_scale(X, feature_range=(1, 2))\n    assert_array_almost_equal(X_trans, X_expected_1_2)\n", "docstring": "Check min max scaler on toy data with zero variance features"}
{"repo": "mars-master/mars/learn/utils/checks.py", "original_string": "    def __call__(self, x, value=None):\n        # output input if value not specified\n        self._value = value = value if value is not None else x\n        self.output_types = get_output_types(value)\n        self.stage = OperandStage.agg\n        return self.new_tileable([x, value],\n                                 kws=[value.params])\n", "docstring": "output input if value not specified"}
{"repo": "mars-master/mars/learn/utils/checks.py", "original_string": "    def _execute_combine(cls, ctx, op):\n        # just pass value cuz all inputs executed successfully\n        ctx[op.outputs[0].key] = np.array(True)\n", "docstring": "just pass value cuz all inputs executed successfully"}
{"repo": "mars-master/mars/learn/utils/checks.py", "original_string": "    def _execute_combine_reduce(cls, ctx, op):\n        # just return True\n        ctx[op.outputs[0].key] = np.array(True)\n", "docstring": "just return True"}
{"repo": "mars-master/mars/learn/utils/validation.py", "original_string": "def _num_samples(x):\n    \"\"\"Return number of samples in array-like x.\"\"\"\n    if hasattr(x, 'fit') and callable(x.fit):\n        # Don't get num_samples from an ensembles length!\n        raise TypeError(f'Expected sequence or array-like, got estimator {x}')\n    if not hasattr(x, '__len__') and not hasattr(x, 'shape'):\n        if hasattr(x, '__array__'):\n            x = mt.asarray(x)\n        else:\n            raise TypeError(f\"Expected sequence or array-like, got {type(x)}\")\n    if hasattr(x, 'shape'):\n        if len(x.shape) == 0:\n            if isinstance(x.op, AssertAllFinite):\n                x = x.op.x\n            if hasattr(x.op, 'data') and x.op.data is not None:\n                x = np.asarray(x.op.data)\n            raise TypeError(f\"Singleton array {x!r} cannot be considered\"\n                            \" a valid collection.\")\n        # Check that shape is returning an integer or default to len\n        if isinstance(x.shape[0], numbers.Integral):\n            return x.shape[0]\n        elif np.isnan(x.shape[0]):\n            return x.shape[0]\n        else:\n            return len(x)\n    else:\n        return len(x)\n", "docstring": "Return number of samples in array-like x.\n"}
{"repo": "mars-master/mars/learn/utils/validation.py", "original_string": "def _make_indexable(iterable):\n    \"\"\"Ensure iterable supports indexing or convert to an indexable variant.\n    Convert sparse matrices to csr and other non-indexable iterable to arrays.\n    Let `None` and indexable objects (e.g. pandas dataframes) pass unchanged.\n    Parameters\n    ----------\n    iterable : {list, dataframe, array, sparse} or None\n        Object to be converted to an indexable iterable.\n    \"\"\"\n    if issparse(iterable):\n        return mt.tensor(iterable)\n    elif hasattr(iterable, \"iloc\"):\n        if iterable.ndim == 1:\n            return md.Series(iterable)\n        else:\n            return md.DataFrame(iterable)\n    elif hasattr(iterable, \"__getitem__\"):\n        return mt.tensor(iterable)\n    elif iterable is None:\n        return iterable\n    return mt.tensor(iterable)\n", "docstring": "Ensure iterable supports indexing or convert to an indexable variant."}
{"repo": "mars-master/mars/learn/utils/tests/test_validation.py", "original_string": "def test_ordering():\n    # Check that ordering is enforced correctly by validation utilities.\n    # We need to check each validation utility, because a 'copy' without\n    # 'order=K' will kill the ordering.\n    X = mt.ones((10, 5))\n    for A in X, X.T:\n        for copy in (True, False):\n            B = check_array(A, order='C', copy=copy)\n            assert B.flags['C_CONTIGUOUS'] is True\n            B = check_array(A, order='F', copy=copy)\n            assert B.flags['F_CONTIGUOUS'] is True\n            if copy:\n                assert A is not B\n", "docstring": "Check that ordering is enforced correctly by validation utilities."}
{"repo": "mars-master/mars/learn/utils/tests/test_validation.py", "original_string": "def test_check_array_pandas_dtype_object_conversion():\n    # test that data-frame like objects with dtype object\n    # get converted\n    X = mt.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=mt.object)\n    X_df = MockDataFrame(X)\n    assert check_array(X_df).dtype.kind == \"f\"\n    assert check_array(X_df, ensure_2d=False).dtype.kind == \"f\"\n    # smoke-test against dataframes with column named \"dtype\"\n    X_df.dtype = \"Hans\"\n    assert check_array(X_df, ensure_2d=False).dtype.kind == \"f\"\n", "docstring": "test that data-frame like objects with dtype object"}
{"repo": "mars-master/mars/learn/utils/tests/test_validation.py", "original_string": "def test_check_array_min_samples_and_features_messages():\n    # empty list is considered 2D by default:\n    msg = \"0 feature(s) (shape=(1, 0)) while a minimum of 1 is required.\"\n    assert_raise_message(ValueError, msg, check_array, [[]])\n    # If considered a 1D collection when ensure_2d=False, then the minimum\n    # number of samples will break:\n    msg = \"0 sample(s) (shape=(0,)) while a minimum of 1 is required.\"\n    assert_raise_message(ValueError, msg, check_array, [], ensure_2d=False)\n    # Invalid edge case when checking the default minimum sample of a scalar\n    msg = \"Singleton array array(42) cannot be considered a valid collection.\"\n    assert_raise_message(TypeError, msg, check_array, 42, ensure_2d=False)\n", "docstring": "empty list is considered 2D by default:"}
{"repo": "mars-master/mars/learn/utils/tests/test_multiclass.py", "original_string": "def test_unique_labels(setup):\n    # Empty iterable\n    with pytest.raises(ValueError):\n        unique_labels()\n    # Multiclass problem\n    assert_array_equal(unique_labels(range(10)), np.arange(10))\n    assert_array_equal(unique_labels(np.arange(10)), np.arange(10))\n    assert_array_equal(unique_labels([4, 0, 2]), np.array([0, 2, 4]))\n    # Multilabel indicator\n    assert_array_equal(unique_labels(np.array([[0, 0, 1],\n                                               [1, 0, 1],\n                                               [0, 0, 0]])),\n                       np.arange(3))\n    assert_array_equal(unique_labels(np.array([[0, 0, 1],\n                                               [0, 0, 0]])),\n                       np.arange(3))\n    # Several arrays passed\n    assert_array_equal(unique_labels([4, 0, 2], range(5)),\n                       np.arange(5))\n    assert_array_equal(unique_labels((0, 1, 2), (0,), (2, 1)),\n                       np.arange(3))\n    # Border line case with binary indicator matrix\n    with pytest.raises(ValueError):\n        unique_labels([4, 0, 2], np.ones((5, 5))).execute()\n    with pytest.raises(ValueError):\n        unique_labels(np.ones((5, 4)), np.ones((5, 5))).execute()\n    assert_array_equal(unique_labels(np.ones((4, 5)), np.ones((5, 5))),\n                       np.arange(5))\n", "docstring": "Empty iterable"}
{"repo": "mars-master/mars/learn/utils/tests/test_multiclass.py", "original_string": "def test_unique_labels_mixed_types(setup):\n    # Mix with binary or multiclass and multilabel\n    mix_clf_format = product(EXAMPLES[\"multilabel-indicator\"],\n                             EXAMPLES[\"multiclass\"] +\n                             EXAMPLES[\"binary\"])\n    for y_multilabel, y_multiclass in mix_clf_format:\n        with pytest.raises(ValueError):\n            unique_labels(y_multiclass, y_multilabel).execute()\n        with pytest.raises(ValueError):\n            unique_labels(y_multilabel, y_multiclass).execute()\n    with pytest.raises(ValueError):\n        unique_labels([[1, 2]], [[\"a\", \"d\"]]).execute()\n    with pytest.raises(ValueError):\n        unique_labels([\"1\", 2]).execute()\n    with pytest.raises(ValueError):\n        unique_labels([[\"1\", 2], [1, 3]]).execute()\n    with pytest.raises(ValueError):\n        unique_labels([[\"1\", \"2\"], [2, 3]]).execute()\n", "docstring": "Mix with binary or multiclass and multilabel"}
{"repo": "mars-master/mars/learn/cluster/_k_means_elkan_iter.py", "original_string": "    def tile(cls, op: \"KMeansElkanInitBounds\"):\n        # unify chunks on axis 0\n        if has_unknown_shape(op.centers, op.center_half_distances):\n            yield\n        x = op.x\n        centers = yield from recursive_tile(\n            op.centers.rechunk(op.centers.shape))\n        center_half_distances = yield from recursive_tile(\n            op.center_half_distances.rechunk(op.center_half_distances.shape))\n        out_chunks = [list() for _ in range(op.output_limit)]\n        for c in x.chunks:\n            chunk_op = op.copy().reset_key()\n            chunk_params = []\n            # labels chunk\n            chunk_params.append({\n                'shape': (c.shape[0],),\n                'index': (c.index[0],),\n                'dtype': np.dtype(np.int32),\n                'order': TensorOrder.C_ORDER\n            })\n            # upper bounds\n            chunk_params.append({\n                'shape': (c.shape[0],),\n                'index': (c.index[0],),\n                'dtype': c.dtype,\n                'order': TensorOrder.C_ORDER\n            })\n            # lower bounds\n            chunk_params.append({\n                'shape': (c.shape[0], op.n_clusters),\n                'index': (c.index[0], 0),\n                'dtype': c.dtype,\n                'order': TensorOrder.C_ORDER\n            })\n            chunks = chunk_op.new_chunks(\n                [c, centers.chunks[0], center_half_distances.chunks[0]],\n                kws=chunk_params)\n            for i, out_chunk in enumerate(chunks):\n                out_chunks[i].append(out_chunk)\n        out_nsplits = [\n            (x.nsplits[0],),\n            (x.nsplits[0],),\n            (x.nsplits[0], (op.n_clusters,))]\n        out_params = [out.params for out in op.outputs]\n        for i, chunks in enumerate(out_chunks):\n            out_params[i]['chunks'] = chunks\n        for i, nsplits in enumerate(out_nsplits):\n            out_params[i]['nsplits'] = nsplits\n        new_op = op.copy()\n        return new_op.new_tileables(op.inputs, kws=out_params)\n", "docstring": "unify chunks on axis 0"}
{"repo": "mars-master/mars/learn/cluster/_kmeans.py", "original_string": "def _validate_center_shape(X, n_centers, centers):\n    \"\"\"Check if centers is compatible with X and n_centers\"\"\"\n    if len(centers) != n_centers:\n        raise ValueError('The shape of the initial centers (%s) '\n                         'does not match the number of clusters %i'\n                         % (centers.shape, n_centers))\n    if centers.shape[1] != X.shape[1]:\n        raise ValueError(\n            \"The number of features of the initial centers %s \"\n            \"does not match the number of features of the data %s.\"\n            % (centers.shape[1], X.shape[1]))\n", "docstring": "Check if centers is compatible with X and n_centers\n"}
{"repo": "mars-master/mars/learn/cluster/_kmeans.py", "original_string": "def _check_normalize_sample_weight(sample_weight, X):\n    \"\"\"Set sample_weight if None, and check for correct dtype\"\"\"\n    sample_weight_was_none = sample_weight is None\n    sample_weight = _check_sample_weight(sample_weight, X, dtype=X.dtype)\n    if not sample_weight_was_none:\n        # normalize the weights to sum up to n_samples\n        # an array of 1 (i.e. samples_weight is None) is already normalized\n        n_samples = len(sample_weight)\n        scale = n_samples / sample_weight.sum()\n        sample_weight *= scale\n    return sample_weight\n", "docstring": "Set sample_weight if None, and check for correct dtype\n"}
{"repo": "mars-master/mars/learn/cluster/_kmeans.py", "original_string": "    def fit_predict(self, X, y=None, sample_weight=None, session=None, run_kwargs=None):\n        \"\"\"Compute cluster centers and predict cluster index for each sample.\n        Convenience method; equivalent to calling fit(X) followed by\n        predict(X).\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            New data to transform.\n        y : Ignored\n            Not used, present here for API consistency by convention.\n        sample_weight : array-like of shape (n_samples,), default=None\n            The weights for each observation in X. If None, all observations\n            are assigned equal weight.\n        Returns\n        -------\n        labels : ndarray of shape (n_samples,)\n            Index of the cluster each sample belongs to.\n        \"\"\"\n        return self.fit(X, sample_weight=sample_weight,\n                        session=session, run_kwargs=run_kwargs).labels_\n", "docstring": "Compute cluster centers and predict cluster index for each sample."}
{"repo": "mars-master/mars/learn/cluster/_kmeans.py", "original_string": "    def transform(self, X, session=None, run_kwargs=None):\n        \"\"\"Transform X to a cluster-distance space.\n        In the new space, each dimension is the distance to the cluster\n        centers.  Note that even if X is sparse, the array returned by\n        `transform` will typically be dense.\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            New data to transform.\n        Returns\n        -------\n        X_new : tensor of shape (n_samples, n_clusters)\n            X transformed in the new space.\n        \"\"\"\n        check_is_fitted(self)\n        X = self._check_test_data(X)\n        return self._transform(X, session=session, run_kwargs=run_kwargs)\n", "docstring": "Transform X to a cluster-distance space."}
